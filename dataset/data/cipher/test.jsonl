{"project": "cipher", "commit_id": "Snippet23795194_6100.java", "target": 1, "func": "package com.infovale.cripto;\n\nimport java.io.UnsupportedEncodingException;\nimport java.math.BigInteger;\nimport java.security.InvalidKeyException;\nimport java.security.KeyFactory;\nimport java.security.KeyPair;\nimport java.security.KeyPairGenerator;\nimport java.security.NoSuchAlgorithmException;\nimport java.security.PrivateKey;\nimport java.security.PublicKey;\nimport java.security.spec.InvalidKeySpecException;\nimport java.security.spec.PKCS8EncodedKeySpec;\nimport java.util.Arrays;\n\nimport javax.crypto.BadPaddingException;\nimport javax.crypto.Cipher;\nimport javax.crypto.IllegalBlockSizeException;\nimport javax.crypto.NoSuchPaddingException;\n\npublic class RSA {\n\n\nstatic String kPublic = \"\";\nstatic String kPrivate = \"\";\n\npublic RSA()\n{\n\n}\n\n\npublic String Encrypt(String plain) throws NoSuchAlgorithmException,\n        NoSuchPaddingException, InvalidKeyException,\n        IllegalBlockSizeException, BadPaddingException {\n\n    String encrypted;\n    byte[] encryptedBytes;      \n\n    KeyPairGenerator kpg = KeyPairGenerator.getInstance(\"RSA\");\n    kpg.initialize(1024);\n    KeyPair kp = kpg.genKeyPair();\n\n    PublicKey publicKey = kp.getPublic();\n    PrivateKey privateKey = kp.getPrivate();\n\n    byte[] publicKeyBytes = publicKey.getEncoded();\n    byte[] privateKeyBytes = privateKey.getEncoded();\n\n    kPublic = bytesToString(publicKeyBytes);\n    kPrivate = bytesToString(privateKeyBytes);\n\n    Cipher cipher = Cipher.getInstance(\"RSA\");\n    cipher.init(Cipher.ENCRYPT_MODE, publicKey);\n    encryptedBytes = cipher.doFinal(plain.getBytes());\n\n    encrypted = bytesToString(encryptedBytes);\n    return encrypted;\n\n}\n\npublic String Decrypt(String result) throws NoSuchAlgorithmException,\n        NoSuchPaddingException, InvalidKeyException,\n        IllegalBlockSizeException, BadPaddingException {\n\n    byte[] decryptedBytes;\n\n    byte[] byteKeyPrivate = stringToBytes(kPrivate);\n\n    KeyFactory kf = KeyFactory.getInstance(\"RSA\");\n\n    PrivateKey privateKey = null;\n    try {\n\n        privateKey = kf.generatePrivate(new PKCS8EncodedKeySpec(byteKeyPrivate));\n\n    } catch (InvalidKeySpecException e) {\n        e.printStackTrace();\n    }\n\n    String decrypted;\n\n    Cipher cipher = Cipher.getInstance(\"RSA\");\n    cipher.init(Cipher.DECRYPT_MODE, privateKey);\n    decryptedBytes = cipher.doFinal(stringToBytes(result));\n    decrypted = new String(decryptedBytes);\n    return decrypted;\n\n}\n\npublic String bytesToString(byte[] b) {\n    byte[] b2 = new byte[b.length + 1];\n    b2[0] = 1;\n    System.arraycopy(b, 0, b2, 1, b.length);\n    return new BigInteger(b2).toString(36);\n}\n\npublic byte[] stringToBytes(String s) {\n    byte[] b2 = new BigInteger(s, 36).toByteArray();\n    return Arrays.copyOfRange(b2, 1, b2.length);\n}\n}\n", "idx": 2495}
{"project": "cipher", "commit_id": "Snippet15807423_38811.java", "target": 0, "func": "public class Storage \n{\n    private final byte[] salt = {\n            ( byte )0xf5, ( byte )0x33, ( byte )0x01, ( byte )0x2a,\n            ( byte )0xb2, ( byte )0xcc, ( byte )0xe4, ( byte )0x7f\n            };\n        private int iterationCount = 100;\n\n        public void encryptAndWriteToFile(String host,String user,String pw,boolean flag)\n        {\n            String usr=host+\",\"+user+\",\"+pw+\",\"+Boolean.toString(flag);\n            Cipher cipher = null;\n            try \n            {\n                PBEKeySpec keySpec =new PBEKeySpec(usr.toCharArray());\n                SecretKeyFactory keyFactory =SecretKeyFactory.getInstance( \"PBEWithMD5AndDES\" );\n                SecretKey secretKey = keyFactory.generateSecret( keySpec );\n                PBEParameterSpec parameterSpec =new PBEParameterSpec( salt, iterationCount );\n                cipher = Cipher.getInstance( \"PBEWithMD5AndDES\" );\n                cipher.init( Cipher.ENCRYPT_MODE, secretKey,parameterSpec );\n            }catch ( NoSuchAlgorithmException exception )\n            {\n                exception.printStackTrace();\n                System.exit( 1 );\n            }catch ( InvalidKeySpecException exception )\n            {\n                exception.printStackTrace();\n                System.exit( 1 );\n            }catch ( InvalidKeyException exception )\n            {\n                exception.printStackTrace();\n                System.exit( 1 );\n            }catch ( NoSuchPaddingException exception )\n            {\n                exception.printStackTrace();\n                System.exit( 1 );\n            }catch ( InvalidAlgorithmParameterException exception )\n            {\n                exception.printStackTrace();\n                System.exit( 1 );\n            }\n            byte[] outputArray = null;\n            try \n            {\n                outputArray = usr.getBytes( \"ISO-8859-1\" );\n            }catch (UnsupportedEncodingException ex) \n            {\n                        Logger.getLogger(Storage.class.getName()).log(Level.SEVERE, null, ex);\n            }\n            File sdCard=Environment.getExternalStorageDirectory();//+\"/userData.txt\";\n            String user_credentails=sdCard.getName()+\"/userData.txt\";\n            File file = new File(user_credentails);\n            Log.d(user_credentails, \"is input file \");\n            FileOutputStream fileOutputStream = null;\n            try\n            {\n                fileOutputStream = new FileOutputStream( file );\n            }catch ( IOException exception )\n            {\n                exception.printStackTrace();\n                System.exit( 1 );\n            }\n            CipherOutputStream out =new CipherOutputStream( fileOutputStream, cipher );\n            try\n            {\n                out.write( outputArray );\n                out.flush();\n                out.close();\n            }catch ( IOException exception )\n            {\n                exception.printStackTrace();\n                System.exit( 1 );\n            }\n            Vector fileBytes = new Vector();\n            try \n            {\n                FileInputStream in = new FileInputStream( file );\n                byte contents;\n                while ( in.available() > 0 ) {\n                contents = ( byte )in.read();\n                fileBytes.add( new Byte( contents ) );\n                }\n                in.close();\n            }catch ( IOException exception )\n            {\n                exception.printStackTrace();\n                System.exit( 1 );\n            }\n            byte[] encryptedText = new byte[ fileBytes.size() ];\n            for ( int i = 0; i < fileBytes.size(); i++ ) \n            {\n                encryptedText[ i ] =\n                ( ( Byte ) fileBytes.elementAt( i ) ).byteValue();\n            }\n        }\n        public String[] readFromFileAndDecrypt(boolean state)\n        {\n            Vector fileBytes = new Vector();\n            String pw = \"123\";\n            String fileName = \"security.txt\";\n            String usr=\"10.0.2.2\"+\",\"+\"haider\"+\",\"+pw+\",\"+Boolean.toString(state);\n            Cipher cipher = null;\n            try \n            {\n                PBEKeySpec keySpec =new PBEKeySpec(usr.toCharArray());\n                SecretKeyFactory keyFactory =SecretKeyFactory.getInstance( \"PBEWithMD5AndDES\" );\n                SecretKey secretKey = keyFactory.generateSecret( keySpec );\n                PBEParameterSpec parameterSpec =new PBEParameterSpec( salt, iterationCount );\n                cipher = Cipher.getInstance( \"PBEWithMD5AndDES\" );\n\n                cipher.init( Cipher.DECRYPT_MODE, secretKey,parameterSpec );\n            }catch ( NoSuchAlgorithmException exception ) \n            {\n                exception.printStackTrace();\n                System.exit( 1 );\n            }catch ( InvalidKeySpecException exception ) \n            {\n                exception.printStackTrace();\n                System.exit( 1 );\n            }catch ( InvalidKeyException exception )\n            {\n                exception.printStackTrace();\n                System.exit( 1 );\n            }catch ( NoSuchPaddingException exception )\n            {\n                exception.printStackTrace();\n                System.exit( 1 );\n            }catch ( InvalidAlgorithmParameterException exception )\n            {\n                exception.printStackTrace();\n                System.exit( 1 );\n            }\n            try \n            {\n                File sdCard=Environment.getExternalStorageDirectory();\n                String user_credentails=sdCard.getAbsolutePath()+\"/userData.txt\";\n                Log.d(user_credentails, \" is file name and path\");\n                File file = new File(user_credentails);\n                FileInputStream fileInputStream =new FileInputStream( file );\n                CipherInputStream in =new CipherInputStream( fileInputStream, cipher );\n                byte contents = ( byte ) in.read();\n                Log.d(Byte.toString(contents),\"  is line\");//.out.println(\"\\n\"+contents+\"\\n\");\n                while ( contents != -1 ) \n                {\n                    fileBytes.add( new Byte( contents ) );\n                    contents = ( byte ) in.read();\n                }\n                in.close();\n            }catch ( IOException exception ) \n            {\n                exception.printStackTrace();\n                System.exit( 1 );\n            }\n            byte[] decryptedText = new byte[ fileBytes.size() ];\n            for( int i = 0; i < fileBytes.size(); i++ ) \n            {\n                 decryptedText[ i ] =( ( Byte )fileBytes.elementAt( i ) ).byteValue();\n            }\n            Log.d(new String(decryptedText),\" is data\");\n            String uUser=new String( decryptedText );\n            String[] delims=uUser.split(\",\");\n            return delims;\n        }\n\n}\n", "idx": 2245}
{"project": "cipher", "commit_id": "Snippet35661789_17555.java", "target": 1, "func": "if(dflag == 1) {\n     //AES-128 bit key initialization.\n     System.out.println(\"File completely received\");\n     byte[] keyvalue = \"AES128PeerBuLLet\".getBytes();\n     Key key = new SecretKeySpec(keyvalue, \"AES\");\n\n     //Initialization Vector initialized\n     IvParameterSpec ivParameterSpec = null;\n\n     //Cipher Initialization.\n     Cipher decCipher = Cipher.getInstance(\"AES/CBC/PKCS5Padding\");\n      try {\n           decCipher.init(Cipher.DECRYPT_MODE, key, new IvParameterSpec(iv));\n     } catch (InvalidAlgorithmParameterException ex) {\n                        Logger.getLogger(PeersController.class.getName()).log(Level.SEVERE, null, ex);\n      }\n      System.out.println(decCipher.getProvider().getInfo());\n\n      //Decryption Mechanism.\n      try (FileOutputStream stream = new FileOutputStream(decrypted)) {\n             try (FileInputStream fis = new FileInputStream(encrypted)) {\n                    try (CipherInputStream cis = new CipherInputStream(fis, decCipher)) {\n                           int read, i = 0;\n                           byte[] buffer = new byte[(1024 * 1024) + 16];\n                           while ((read = cis.read(buffer)) != -1) {\n                                    stream.write(buffer, 0, read);\n                                    i = i + read;\n                                    double d = (double) i / len;\n                                    double progress = new BigDecimal(d).setScale(3, BigDecimal.ROUND_HALF_UP).doubleValue();\n                                    Platform.runLater(() -> {\n                                        pBar.setProgress(progress);\n                                        progressText.setText(\"Decrypting..\");\n                                    });\n                                }\n                            } catch (Exception e) {\n                                System.out.println(e.getMessage());\n                            }\n                        }\n                    } catch (Exception e) {\n                        System.out.println(e.getMessage());\n                    }\n        }\n", "idx": 2663}
{"project": "cipher", "commit_id": "Snippet18326911_1369.java", "target": 1, "func": "String message = textField.getText();\n// generate a key\nKeyGenerator keygen = KeyGenerator.getInstance(\"AES\");\nkeygen.init(128);  // To use 256 bit keys, you need the \"unlimited strength\" encryption policy files from Sun.\nbyte[] key = keygen.generateKey().getEncoded();\nSecretKeySpec skeySpec = new SecretKeySpec(key, \"AES\");\n\n// build the initialization vector.  This example is all zeros, but it \n// could be any value or generated using a random number generator.\nbyte[] iv = {0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0};\nIvParameterSpec ivspec = new IvParameterSpec(iv);\n\n// initialize the cipher for encrypt mode\nCipher cipher = Cipher.getInstance(\"AES/CBC/PKCS5Padding\");\ncipher.init(Cipher.ENCRYPT_MODE, skeySpec, ivspec);\n\n// encrypt the message\nbyte[] encrypted = cipher.doFinal(message.getBytes());\nSystem.out.println(\"Ciphertext: \" + encrypted + \"\\n\");\nSystem.out.println(encrypted);\nout.println(encrypted);\ntextField.setText(\"\"); \n", "idx": 2453}
{"project": "cipher", "commit_id": "Snippet42774977_24826.java", "target": 0, "func": "   Cipher desCipher;\nSecretKey myDesKey = null;\n// Create the cipher\n\ndesCipher = Cipher.getInstance(\"DES/ECB/PKCS5Padding\");\n\npacketIn = new DatagramPacket(dataOut, dataOut.length);\nsocket.receive(packetIn);\nByteArrayInputStream bais = new ByteArrayInputStream(packetIn.getData());\nObjectInputStream oos = new ObjectInputStream(bais);\nmyDesKey = (SecretKey) oos.readObject();\nSystem.out.println(\"the key is \" + myDesKey.toString());\ndesCipher.init(Cipher.DECRYPT_MODE, myDesKey); \n", "idx": 2045}
{"project": "cipher", "commit_id": "Snippet29613940_11689.java", "target": 1, "func": "public static String encrypt(String value, String key) {\n    SecretKey secretKey;\n    String ex;\n    try {\n        byte[] encodedKey = Base64.decode(key, Base64.DEFAULT);\n\n        secretKey = new SecretKeySpec(encodedKey,\n                \"AES\");\n        Cipher encrypt = Cipher.getInstance(\"AES/CBC/PKCS5Padding\");\n        encrypt.init(Cipher.ENCRYPT_MODE, secretKey,ivSpec);\n        byte[] valueDecode = value.getBytes(\"UTF-16\");\n        byte[] valueInput = Base64.decode(value, Base64.DEFAULT);\n        byte[] valueOutput = encrypt.doFinal(valueInput);\n\n\n        return \n                 Base64.encodeToString( valueOutput, Base64.DEFAULT );\n    } catch (Exception e) {\n        e.printStackTrace();\n        ex = e.toString();\n    }\n//  Log.d(TAG, ex);\n    return null;\n}\n\nprivate static String decrypt(String value, String key) {\n    SecretKey secretKey;\n    String ex;\n\n    byte[] encodedKey;\n    try {\n        encodedKey = Base64.decode(key, Base64.DEFAULT);\n\n        secretKey = new SecretKeySpec(encodedKey, \n                \"AES\");\n        Cipher decrypt = Cipher.getInstance(\"AES/CBC/PKCS5Padding\");\n        decrypt.init(Cipher.DECRYPT_MODE, secretKey, ivSpec);\n        byte[] valueInput = Base64.decode(value,Base64.DEFAULT);\n        byte[] valueOutput = decrypt.doFinal(valueInput);\n\n        return Base64.encodeToString(valueOutput, Base64.DEFAULT);\n    } catch ( Exception e) {\n        e.printStackTrace();\n    }\n    return null;\n}\n", "idx": 2624}
{"project": "cipher", "commit_id": "Snippet19676675_2413.java", "target": 0, "func": "cipher = Cipher.getInstance(\"AES/ECB/ZeroBytePadding\");\n", "idx": 2097}
{"project": "cipher", "commit_id": "Snippet9759283_34190.java", "target": 0, "func": "import javax.crypto.spec.DESedeKeySpec\nimport javax.crypto.spec.IvParameterSpec\nimport javax.crypto.Cipher\nimport javax.crypto.SecretKeyFactory\n\n\n...\nDESedeKeySpec k;\nCipher c;\n\n...\nk = new DESedeKeySpec(\"abcdefghabcdefgh\".getBytes());\nc = Cipher.getInstance(\"DESede/CBC/PKCS5Padding\");\nc.init(Cipher.DECRYPT_MODE, k);\ndecrypted = c.doFinal(\"jEUQrH58Ulk=\\n\".getBytes());\n", "idx": 2069}
{"project": "cipher", "commit_id": "Snippet36895793_18876.java", "target": 0, "func": "public class EncryptDecryptStringWithDES {\n\n    public static Cipher ecipher;\n    public static Cipher dcipher;\n\n    public static SecretKey key;\n\n\n    public static String getEncryptedText(String sty) throws Exception {\n\n        // generate secret key using DES algorithm\n        key = KeyGenerator.getInstance(\"DES\").generateKey();\n        ecipher = Cipher.getInstance(\"DES\");\n\n\n        // initialize the ciphers with the given key\n\n        ecipher.init(Cipher.ENCRYPT_MODE, key);\n\n\n\n\n        sty = encrypt(sty);\n\n        return sty;\n    }\n\n    public static String getDecryptedText(String sty) throws Exception {\n   key = KeyGenerator.getInstance(\"DES\").generateKey();\n\n        dcipher = Cipher.getInstance(\"DES\");\n        dcipher.init(Cipher.DECRYPT_MODE, key);\n        sty = decrypt(sty);\n\n        return sty;\n\n    }\n\n\n    public static String encrypt(String str) {\n\n        try {\n\n            // encode the string into a sequence of bytes using the named charset\n\n            // storing the result into a new byte array.\n\n            byte[] utf8 = str.getBytes(\"UTF8\");\n\n            byte[] enc = ecipher.doFinal(utf8);\n\n// encode to base64\n\n            enc = BASE64EncoderStream.encode(enc);\n\n            return new String(enc);\n\n        } catch (Exception e) {\n\n            e.printStackTrace();\n\n        }\n\n        return null;\n\n    }\n\n    public static String decrypt(String str) {\n\n        try {\n\n            // decode with base64 to get bytes\n\n            byte[] dec = BASE64DecoderStream.decode(str.getBytes());\n\n            byte[] utf8 = dcipher.doFinal(dec);\n\n// create new string based on the specified charset\n\n            return new String(utf8, \"UTF8\");\n\n        } catch (Exception e) {\n\n            e.printStackTrace();\n\n        }\n\n        return null;\n\n    }\n", "idx": 2005}
{"project": "cipher", "commit_id": "Snippet15948662_38931.java", "target": 0, "func": "String encryptedString = \u2026 ;\nString decryptedString = null;\nSecretKeySpec key = new SecretKeySpec(myKey.getBytes(), \"Blowfish\");\nCipher cipher;\ntry {\n    cipher = Cipher.getInstance(\"Blowfish\");\n    cipher.init(Cipher.DECRYPT_MODE, key);\n    byte[] decrypted = cipher.doFinal(encryptedString.getBytes());\n    decryptedString = new String(decrypted, Charset.forName(\"UTF-8\"));\n} [ catch Exceptions \u2026 ]\n", "idx": 2236}
{"project": "cipher", "commit_id": "Snippet24839323_7160.java", "target": 0, "func": "public static byte[] encryptLB(byte[] key, byte[] iv, byte[] unencrypted)\n               throws NoSuchAlgorithmException, ... {\n            MessageDigest digest = MessageDigest.getInstance(\"MD5\");\n            digest.update(key);\n            byte[] hash = digest.digest(); //build the hash (128 bit)\n\n              Cipher cipher = Cipher.getInstance(\"RC2/CBC/PKCS5Padding\");\n              cipher.init(Cipher.ENCRYPT_MODE, new SecretKeySpec(hash, \"RC2\"));\n              byte[] unByte = unencrypted;\n              byte[] encrypted = cipher.doFinal(unencrypted);\n              return encrypted;\n             }\n", "idx": 1984}
{"project": "cipher", "commit_id": "Snippet6285221_32028.java", "target": 1, "func": "Android Code:\npublic static final int SALT_LENGTH = 20;\npublic static final int PBE_ITERATION_COUNT = 1000;\n\nprivate static final String RANDOM_ALGORITHM = \"SHA1PRNG\";\nprivate static final String PBE_ALGORITHM = \"PBEWithSHA256And256BitAES-CBC-BC\";\nprivate static final String CIPHER_ALGORITHM = \"AES/CBC/PKCS5Padding\";\n\nprivate static final String TAG = Act.class.getSimpleName();\n\n@Override\npublic void onCreate(Bundle savedInstanceState) {\n\n    super.onCreate(savedInstanceState);\n    setContentView(R.layout.main);\n\n    try {\n\n        String password = \"password\";\n        String plainText = \"plaintext message to be encrypted\";\n\n        // byte[] salt = generateSalt();\n        byte[] salt = \"dfghjklpoiuytgftgyhj\".getBytes();\n        Log.i(TAG, \"Salt: \" + salt.length + \" \" + HexEncoder.toHex(salt));\n        PBEKeySpec pbeKeySpec = new PBEKeySpec(password.toCharArray(), salt, PBE_ITERATION_COUNT, 256);\n        SecretKeyFactory factory = SecretKeyFactory.getInstance(PBE_ALGORITHM);\n        SecretKey tmp = factory.generateSecret(pbeKeySpec);\n        SecretKey secret = new SecretKeySpec(tmp.getEncoded(), \"AES\");\n        byte[] key = secret.getEncoded();\n        Log.i(TAG, \"Key: \" + HexEncoder.toHex(key));\n\n        // PBEParameterSpec pbeParamSpec = new PBEParameterSpec(salt, ITERATION_COUNT);\n\n        Cipher encryptionCipher = Cipher.getInstance(CIPHER_ALGORITHM);\n\n        // byte[] encryptionSalt = generateSalt();\n        // Log.i(TAG, \"Encrypted Salt: \" + encryptionSalt.length + \" \" + HexEncoder.toHex(encryptionSalt));\n        // PBEParameterSpec pbeParamSpec = new PBEParameterSpec(encryptionSalt, 1000);\n        // byte[] iv = params.getParameterSpec(IvParameterSpec.class).getIV();\n        Log.i(TAG, encryptionCipher.getParameters() + \" \");\n        byte[] iv = generateIv();\n        IvParameterSpec ivspec = new IvParameterSpec(iv);\n\n        encryptionCipher.init(Cipher.ENCRYPT_MODE, secret, ivspec);\n        byte[] encryptedText = encryptionCipher.doFinal(plainText.getBytes());\n        Log.i(TAG, \"Encrypted: \" + HexEncoder.toHex(encryptedText));\n\n        Cipher decryptionCipher = Cipher.getInstance(CIPHER_ALGORITHM);\n        decryptionCipher.init(Cipher.DECRYPT_MODE, secret, ivspec);\n        byte[] decryptedText = decryptionCipher.doFinal(encryptedText);\n        Log.i(TAG, \"Decrypted: \" + new String(decryptedText));\n\n    } catch (Exception e) {\n        e.printStackTrace();\n    }\n\n}\n\nprivate byte[] generateSalt() throws NoSuchAlgorithmException {\n    SecureRandom random = SecureRandom.getInstance(RANDOM_ALGORITHM);\n    byte[] salt = new byte[SALT_LENGTH];\n    random.nextBytes(salt);\n    return salt;\n}\n\nprivate byte[] generateIv() throws NoSuchAlgorithmException {\n    SecureRandom random = SecureRandom.getInstance(RANDOM_ALGORITHM);\n    byte[] iv = new byte[16];\n    random.nextBytes(iv);\n    return iv;\n}\n", "idx": 2614}
{"project": "cipher", "commit_id": "Snippet30853043_12984.java", "target": 1, "func": "Cipher.getInstance(\"AES/CBC/PKCS5Padding\")", "idx": 2741}
{"project": "cipher", "commit_id": "Snippet21823120_4232.java", "target": 1, "func": "// Encryption code\nprotected byte[] encryptMessageWithPrivateKey(String aMessage) throws Exception {\n    ByteArrayOutputStream inputStream = new ByteArrayOutputStream();\n    ByteArrayOutputStream resultStream = new ByteArrayOutputStream();\n    byte[] vEncoded = null;\n\n    DataOutputStream outStream = new DataOutputStream(inputStream);\n    outStream.writeBytes(Integer.toString(this.randomGen.nextInt()));\n    outStream.writeBytes(\":\");\n\n    outStream.writeBytes(this.mTimestampFormat.format(Long.valueOf(System.currentTimeMillis())));\n    outStream.writeBytes(\":\");\n\n    outStream.writeBytes(\",\");\n\n    outStream.writeBytes(aMessage);\n\n    DataOutputStream resultWriter = new DataOutputStream(resultStream);\n    if (this.mEncryptCipher == null) {\n        KeyStore privateKs = KeyStore.getInstance(KeyStore.getDefaultType());\n        privateKs.load(new FileInputStream(new File(mPrivateCertFile)), null);\n        KeyStore.PrivateKeyEntry privateKeyEntry = (KeyStore.PrivateKeyEntry) privateKs\n                .getEntry(mPrivateCertKey, new KeyStore.PasswordProtection(\n                        mPrivateCertPassword.toCharArray()));\n        PrivateKey privateKey = privateKeyEntry.getPrivateKey();\n\n        System.out.println(\"encrypt private key : \" + privateKey.getFormat());\n        this.mEncryptCipher = Cipher.getInstance(\"RSA/ECB/PKCS1Padding\");\n        this.mEncryptCipher.init(1, privateKey);\n        System.out.println(\"mEncryptCipher = \" + this.mEncryptCipher);\n    }\n\n    byte[] vMyUnincryptedString = inputStream.toByteArray();\n\n    resultWriter.write(this.mEncryptCipher.doFinal(vMyUnincryptedString));\n\n    vEncoded = resultStream.toByteArray();\n\n    System.out.println(\"Encrypt length : \" + vEncoded.length);\n    return vEncoded;\n}\n\n// Decyption code\nprotected byte[] decryptMessageWithPrivateKey(String aSecretMessage) throws Exception {\n    System.out.println(\"aSecretMessage : \" + aSecretMessage);\n    byte[] vNoSecret = null;\n    if (this.mDecryptCipher == null) {\n        KeyStore privateKs = KeyStore.getInstance(KeyStore.getDefaultType());\n        privateKs.load(new FileInputStream(new File(mPrivateCertFile)), null);\n        KeyStore.PrivateKeyEntry privateKeyEntry = (KeyStore.PrivateKeyEntry) privateKs\n                .getEntry(mPrivateCertKey, new KeyStore.PasswordProtection(\n                        mPrivateCertPassword.toCharArray()));\n\n        PrivateKey privateKey = privateKeyEntry.getPrivateKey();\n        /*\n         * KeyPair keyPair =\n         * KeyPairGenerator.getInstance(\"RSA\").generateKeyPair(); PublicKey\n         * publicKey=keyPair.getPublic(); System.out.println(\"public key : \"\n         * +publicKey.toString());\n         */\n\n        System.out.println(\"privateKey = \" + privateKey.getAlgorithm());\n\n        this.mDecryptCipher = Cipher.getInstance(\"RSA/ECB/PKCS1Padding\");\n        /* .getInstance(\"RSA/ECB/PKCS1Padding\"); */\n\n        System.out.println(\"List of provider : \");\n        Provider[] prov = Security.getProviders();\n        for (Provider provider : prov) {\n            System.out.println(\" : \" + provider.getName() + \" ,Info : \" + provider.getInfo());\n\n        }\n\n        this.mDecryptCipher.init(2, privateKey);\n        System.out.println(\"mDecryptCipher = \" + this.mDecryptCipher);\n    }\n\n    /* byte[]encryptText = HexToByte.hexStringToByteArray(aSecretMessage); */\n    byte[] encryptText = TestConverter.afromHex(aSecretMessage);\n    System.out.println(\"Encrypt lenght : \" + encryptText);\n    vNoSecret = this.mDecryptCipher.doFinal(encryptText);\n\n    System.out.println(\"vNoSecret msg : \" + vNoSecret.length);\n    return vNoSecret;\n}\n", "idx": 2513}
{"project": "cipher", "commit_id": "Snippet24189285_6471.java", "target": 0, "func": "@Override\nprotected void onCreate(Bundle savedInstanceState) {\n    // TODO Auto-generated method stub\n    super.onCreate(savedInstanceState);\n    setContentView(R.layout.amain);\n\n    try {\n        viewKey();\n    } catch (Exception e) {\n        // TODO Auto-generated catch block\n        e.printStackTrace();\n        Log.d(\"checkingthevalue\",e.toString());\n    }\n}\n\n private void viewKey() {\n        // TODO Auto-generated method stub\n         String pass = \"password\";\n         String testStr = \"TheSecretString\";\n         final byte[] SALT = {\n                (byte) 0xaa, (byte) 0xaa, (byte) 0xce, (byte) 0xce,\n                (byte) 0xaa, (byte) 0xaa, (byte) 0xce, (byte) 0xce,\n            };\n         try{\n             SecretKeyFactory keyFactory = SecretKeyFactory.getInstance(\"PBEWithMD5AndDES\");\n             SecretKey key = keyFactory.generateSecret(new PBEKeySpec(pass.toCharArray()));\n             Cipher pbeCipher = Cipher.getInstance(\"PBEWithMD5AndDES\");\n             pbeCipher.init(Cipher.ENCRYPT_MODE, key, new PBEParameterSpec(SALT, 20));\n             String strEnc = base64Encode(pbeCipher.doFinal(testStr.getBytes(\"UTF-8\")));\n             Log.d(\"ViewKey\", \"strEnc :: \" + strEnc);\n         }catch (Exception e)\n         {\n             Log.d(\"ViewKey\",\"ERROR\");\n         }\n    }\n private static String base64Encode(byte[] bytes) {\nfinal int asd = Base64.URL_SAFE | Base64.NO_PADDING | Base64.NO_WRAP ;\n            return Base64.encodeToString(bytes,asd);\n        }\n", "idx": 2033}
{"project": "cipher", "commit_id": "Snippet16390526_39349.java", "target": 0, "func": "// Create a new key to encrypt and decrypt the file\nbyte[] key = \"password\".getBytes();\n\n// Get a cipher object in encrypt mode \nCipher cipher = null;\ntry {\n    DESKeySpec dks = new DESKeySpec(key);\n    SecretKeyFactory skf = SecretKeyFactory.getInstance(\"DES\");\n    SecretKey desKey = skf.generateSecret(dks);\n    cipher = Cipher.getInstance(\"DES\");\n    cipher.init(Cipher.ENCRYPT_MODE, desKey);\n} catch (InvalidKeyException | NoSuchAlgorithmException | InvalidKeySpecException | NoSuchPaddingException ex) {\n    System.err.println(\"[CRITICAL] Incryption chiper error\");\n}\n\n// Encrypt the file\ntry {\n    new ObjectOutputStream(new CipherOutputStream(new FileOutputStream(\"test\"), cipher)).writeObject(\"test text\");\n} catch (IOException e) {\n    System.err.println(\"[CRITICAL] Error encrypting data: \" + e.getMessage());\n    e.printStackTrace();\n}\n\n// Get a cipher object in decrypt mode\ntry {\n    DESKeySpec dks = new DESKeySpec(key);\n    SecretKeyFactory skf = SecretKeyFactory.getInstance(\"DES\");\n    SecretKey desKey = skf.generateSecret(dks);\n    cipher = Cipher.getInstance(\"DES\");\n    cipher.init(Cipher.DECRYPT_MODE, desKey);\n} catch (InvalidKeyException | NoSuchAlgorithmException | InvalidKeySpecException | NoSuchPaddingException ex) {\n    System.err.println(\"[CRITICAL] Incryption chiper error\");\n}\n\n// Decrypt the file\ntry {\n    // This is the line that throws the exception\n    System.out.println((String) new ObjectInputStream(new CipherInputStream(new FileInputStream(\"test\"), cipher)).readObject()); \n} catch (IOException | ClassNotFoundException e) {\n    System.err.println(\"[CRITICAL] Error decrypting data: \" + e.getMessage());\n    e.printStackTrace();\n}\n", "idx": 2009}
{"project": "cipher", "commit_id": "Snippet40845294_22722.java", "target": 0, "func": "public static String decodeParam(String content,String key){\n    String decodeParams = \"\";\n    byte[] decodeByte =  parseHexStr2Byte(content);\n    try {\n        decodeParams = deCrypt(decodeByte,key);\n    } catch (Exception e) {\n        e.printStackTrace();\n    }\n    return decodeParams;\n}\n\npublic static byte[] parseHexStr2Byte(String hexStr) {\n        if (hexStr.length() < 1)\n                return null;\n        byte[] result = new byte[hexStr.length()/2];\n        for (int i = 0;i< hexStr.length()/2; i++) {\n                int high = Integer.parseInt(hexStr.substring(i*2, i*2+1), 16);\n                int low = Integer.parseInt(hexStr.substring(i*2+1, i*2+2), 16);\n                result[i] = (byte) (high * 16 + low);\n        }\n        return result;\n}\n\npublic static String deCrypt (byte[] src,String strKey) throws Exception{\n    KeyGenerator keygen;\n    SecretKey desKey;\n    Cipher c;\n    byte[] cByte;\n\n    keygen = KeyGenerator.getInstance(\"AES\");\n    SecureRandom secureRandom = SecureRandom.getInstance(\"SHA1PRNG\");\n    secureRandom.setSeed(strKey.getBytes());\n    keygen.init(128, secureRandom);\n\n    SecretKeySpec securekey = new SecretKeySpec(strKey.getBytes(), \"AES\");\n\n    desKey = keygen.generateKey();\n    c = Cipher.getInstance(\"AES\");\n\n    c.init(Cipher.DECRYPT_MODE, desKey);\n\n\n    cByte = c.doFinal(src);\n\n    return new String(cByte,\"UTF-8\");\n}\n", "idx": 2240}
{"project": "cipher", "commit_id": "Snippet10451068_34809.java", "target": 0, "func": "// Java - Encrypt\nprivate String EncryptAES(String text,String key) throws Exception\n    {\n      SecretKeySpec skeySpec = new SecretKeySpec(key.getBytes(), \"AES\");\n\n      // Instantiate the cipher\n      Cipher cipher = Cipher.getInstance(\"AES\");\n\n      cipher.init(Cipher.ENCRYPT_MODE, skeySpec);\n      byte[] encrypted = cipher.doFinal(text.getBytes());\n\n      String encrypttext = new BASE64Encoder().encode(encrypted);\n\n      return encrypttext;\n    }\n\nRESULT: TeUZAFxoFoQy/roPm5tXyPzJP/TLAwR1aIGn2xHbZpsbY1qrKwXfO+F/DAqmeTwB0b8e6dsSM+Yy0zrQt22E2Q== \n", "idx": 1925}
{"project": "cipher", "commit_id": "Snippet44294039_26356.java", "target": 0, "func": "import javafx.application.Application;\nimport javafx.application.Platform;\nimport javafx.stage.*;\nimport javafx.scene.*;\nimport javafx.scene.control.*;\nimport javafx.scene.layout.*;\nimport javafx.geometry.*;\nimport javafx.scene.image.*;\nimport java.io.UnsupportedEncodingException;\nimport java.security.MessageDigest;\nimport java.security.NoSuchAlgorithmException;\nimport java.util.Arrays;\nimport sun.misc.BASE64Encoder;\nimport sun.misc.BASE64Decoder;\nimport java.security.Key;\nimport javax.crypto.Cipher;\nimport javax.crypto.Cipher;\nimport javax.crypto.spec.SecretKeySpec;\n\npublic class AESGui extends Application{\n\n    TextArea inputArea = new TextArea();\n    TextArea outputArea = new TextArea();\n    Main object1 = new Main();\n\n    public static void main(String [] args){\n        launch (args);\n    }\n\n\n    @Override\n    public void start(Stage stage){\n\n        HBox hbox1 = new HBox(50);\n        hbox1.setAlignment(Pos.CENTER);\n        hbox1.getChildren().addAll(inputArea, outputArea);\n\n        Button encrypt = new Button(\"Encrypt\");\n        encrypt.setOnAction (event -> {\n            object1.aesEncryption();\n        });\n\n        Button decrypt = new Button(\"Decrypt\");\n\n        HBox hbox2 = new HBox(50);\n        hbox2.setAlignment(Pos.CENTER);\n        hbox2.getChildren().addAll(encrypt, decrypt);\n\n        VBox vbox = new VBox();\n        vbox.setAlignment(Pos.CENTER);\n        vbox.getChildren().addAll(hbox1, hbox2);\n\n        Scene scene = new Scene(vbox, 900, 700);\n\n        stage.setScene(scene);\n        stage.setTitle(\"aes gui\");\n        stage.show();\n    }\n\n    public class AESAlgorithm{\n        public String algo = \"AES\";\n        public byte[] keyValue;\n\n        public AESAlgorithm(String key){\n            keyValue = key.getBytes();\n        }\n\n        public Key generateKey() throws Exception{\n            Key key = new SecretKeySpec(keyValue, algo);\n            return key;\n        }\n\n        public String encrypt(String msg) throws Exception{\n\n            Key key = generateKey();\n            Cipher c = Cipher.getInstance(algo);\n            c.init(Cipher.ENCRYPT_MODE, key);\n            byte[] encVal = c.doFinal(msg.getBytes());\n            String encryptedValue = new BASE64Encoder().encode(encVal);\n            return encryptedValue;\n\n        }\n\n        public String decrypt(String msg) throws Exception{\n\n            Key key = generateKey();\n            Cipher c = Cipher.getInstance(algo);\n            c.init(Cipher.DECRYPT_MODE, key);\n            byte[] decordedValue = new BASE64Decoder().decodeBuffer(msg);\n            byte[] decValue = c.doFinal(decordedValue);\n            String decryptedValue = new String(decValue);\n            return decryptedValue;\n        }\n    }\n\n    public class Main {\n        AESAlgorithm aesAlgo;\n        private byte[] keyValue = new byte[]{'t','h','e','b','e','s','t','s','e','c','r','e','t','k','e','y'};\n        public Main(){\n            //initComponents();\n            //here we passed key to constructor\n            aesAlgo = new AESAlgorithm(\"MySecretKey\");\n        }\n\n        private void aesEncryption(){\n            try{\n\n                String plainText = inputArea.getText();\n                String encryptedText = aesAlgo.encrypt(plainText);\n                outputArea.setText(encryptedText);\n\n            }\n            catch(Exception e){\n                e.printStackTrace();\n            }\n        }\n\n    }\n}\n", "idx": 2212}
{"project": "cipher", "commit_id": "Snippet22285670_4682.java", "target": 0, "func": "import java.security.spec.*;\nimport javax.crypto.*;\nimport javax.crypto.SecretKey;\nimport javax.crypto.SecretKeyFactory;\nimport javax.crypto.spec.DESedeKeySpec;\nimport sun.misc.BASE64Decoder;\nimport sun.misc.BASE64Encoder;\n\npublic class DESedeEncryption {\npublic static void main(String[] args) {\n\nSecretKey k1 = generateDESkey();\nSecretKey k2 = generateDESkey();\nSecretKey k3 = generateDESkey();\n\nString firstEncryption = desEncryption(\"plaintext\", k1);\nString decryption = desDecryption(firstEncryption, k2);\nString secondEncryption = desEncryption(decryption, k3);\nSystem.out.println(\"secondEncryption: \"+secondEncryption);\nSystem.out.println(\"firstEncryption: \"+firstEncryption);\nSystem.out.println(\"decryption: \"+decryption);\n\n}\n\npublic static SecretKey generateDESkey() {\nKeyGenerator keyGen = null;\ntry {\n    keyGen = KeyGenerator.getInstance(\"DESede\");\n} catch (Exception ex) {\n  ex.printStackTrace();\n}\nkeyGen.init(168); // key length 112 for two keys, 168 for three keys\nSecretKey secretKey = keyGen.generateKey();\nreturn secretKey;\n}\n\npublic static String desEncryption(String strToEncrypt, SecretKey desKey) {\ntry {\n    Cipher cipher = Cipher.getInstance(\"DESede/ECB/PKCS5Padding\");\n    cipher.init(Cipher.ENCRYPT_MODE, desKey);\n    String encryptedString = new      BASE64Encoder().encode(cipher.doFinal(strToEncrypt.getBytes()));\n    return encryptedString;\n\n\n} catch (Exception ex) {\n  ex.printStackTrace();\n}\nreturn null;\n}\n\npublic static String desDecryption(String strToDecrypt, SecretKey desKey) {\ntry {\n    Cipher cipher = Cipher.getInstance(\"DESede/ECB/PKCS5Padding\");\n    cipher.init(Cipher.DECRYPT_MODE, desKey);\n    String decryptedString = new String(cipher.doFinal(new     BASE64Decoder().decodeBuffer(strToDecrypt)));\n    return decryptedString;\n\n\n} \ncatch (Exception ex) {\n  ex.printStackTrace();\n}\nreturn null;\n}\n}\n", "idx": 2246}
{"project": "cipher", "commit_id": "Snippet35580510_17488.java", "target": 0, "func": "byte[] passwd = Base64Util.decode(pwd);\nbais = new ByteArrayInputStream(passwd);\nbaos = new ByteArrayOutputStream();\nCipher cipher = Cipher.getInstance(\"DESede\");\ncipher.init(Cipher.DECRYPT_MODE, key);\n// Read bytes, decrypt, and write them out.\nbyte[] buffer = new byte[2048];\nint bytesRead;\nwhile ((bytesRead = bais.read(buffer)) != -1) {\n    out.write(cipher.update(buffer, 0, bytesRead));\n}\n// Write out the final bunch of decrypted bytes\nout.write(cipher.doFinal());\nout.flush();\n", "idx": 2178}
{"project": "cipher", "commit_id": "Snippet19698721_2425.java", "target": 0, "func": "protected static String encrypt(String plaintext) {\n    final byte[] KEY = {\n            0x6d, 0x79, 0x56, 0x65, 0x72, 0x79, 0x54, 0x6f, 0x70,\n            0x53, 0x65, 0x63, 0x72, 0x65, 0x74, 0x4b\n    };\n\n    try {\n        Cipher cipher = Cipher.getInstance(\"AES/ECB/PKCS5Padding\");\n        final SecretKeySpec secretKey = new SecretKeySpec(KEY, \"AES\");\n        cipher.init(Cipher.ENCRYPT_MODE, secretKey);\n        final String encryptedString = Base64.encodeToString(\n            cipher.doFinal(plaintext.getBytes()), Base64.DEFAULT);\n\n        return encryptedString;\n    } catch (Exception e) {\n        return null;\n    }\n}\n", "idx": 2213}
{"project": "cipher", "commit_id": "Snippet45745017_27789.java", "target": 1, "func": "import com.google.common.io.ByteStreams;\n\nimport javax.crypto.Cipher;\nimport java.io.ByteArrayOutputStream;\nimport java.io.DataOutputStream;\nimport java.net.ServerSocket;\nimport java.net.Socket;\nimport java.security.KeyPair;\nimport java.security.KeyPairGenerator;\n\npublic class Main {\n\n    public static void main(String[] args) throws Exception {\n        KeyPairGenerator kpg = KeyPairGenerator.getInstance(\"RSA\");\n        kpg.initialize(1024);\n        KeyPair rsaKeyPair = kpg.generateKeyPair();\n        ServerSocket serverSocket = new ServerSocket(9000);\n        Socket socket = serverSocket.accept();\n        DataOutputStream dos = new DataOutputStream(socket.getOutputStream());\n        byte[] encodedPubKey = rsaKeyPair.getPublic().getEncoded();\n        dos.writeShort(encodedPubKey.length);\n        dos.write(encodedPubKey);\n        byte[] cipher = ByteStreams.toByteArray(socket.getInputStream());\n        socket.close();\n        Cipher c = Cipher.getInstance(\"RSA/ECB/OAEPWithSHA-1AndMGF1Padding\");\n        c.init(Cipher.DECRYPT_MODE, rsaKeyPair.getPrivate());\n        byte[] plain = c.doFinal(cipher);\n        System.out.println(new String(plain, StandardCharsets.UTF_8));\n    }\n}\n", "idx": 2461}
{"project": "cipher", "commit_id": "Snippet10197249_34516.java", "target": 0, "func": "DESKeySpec dks = new DESKeySpec(\"keyword\".getBytes()); \nSecretKeyFactory keyFactory = SecretKeyFactory.getInstance(\"DES\");\nSecretKey key = keyFactory.generateSecret(dks);\n\nCipher cipher = Cipher.getInstance(\"DES/ECB/PKCS5Padding\");\nSecureRandom sr = new SecureRandom();  \ncipher.init( Cipher.DECRYPT_MODE, key ,sr); \n\nbyte b[] = response.toByteArray();      \nbyte decryptedData[] = cipher.doFinal( b );\n", "idx": 2022}
{"project": "cipher", "commit_id": "Snippet20929131_3519.java", "target": 1, "func": "import java.security.NoSuchAlgorithmException;\n\nimport javax.crypto.Cipher;\nimport javax.crypto.NoSuchPaddingException;\nimport javax.crypto.spec.IvParameterSpec;\nimport javax.crypto.spec.SecretKeySpec;\n\npublic class MCrypt {\n\n    private String iv = \"fedcba9876543210\";//Dummy iv (CHANGE IT!)\n    private IvParameterSpec ivspec;\n    private SecretKeySpec keyspec;\n    private Cipher cipher;\n\n    private String SecretKey = \"0123456789abcdef\";//Dummy secretKey (CHANGE IT!)\n\n    public MCrypt()\n    {\n        ivspec = new IvParameterSpec(iv.getBytes());\n\n        keyspec = new SecretKeySpec(SecretKey.getBytes(), \"AES\");\n\n        try {\n            cipher = Cipher.getInstance(\"AES/CBC/NoPadding\");\n        } catch (NoSuchAlgorithmException e) {\n            // TODO Auto-generated catch block\n            e.printStackTrace();\n        } catch (NoSuchPaddingException e) {\n            // TODO Auto-generated catch block\n            e.printStackTrace();\n        }\n    }\n\n    public byte[] encrypt(String text) throws Exception\n    {\n        if(text == null || text.length() == 0)\n            throw new Exception(\"Empty string\");\n\n        byte[] encrypted = null;\n\n        try {\n            cipher.init(Cipher.ENCRYPT_MODE, keyspec, ivspec);\n\n            encrypted = cipher.doFinal(padString(text).getBytes());\n        } catch (Exception e)\n        {           \n            throw new Exception(\"[encrypt] \" + e.getMessage());\n        }\n\n        return encrypted;\n    }\n\n    public byte[] decrypt(String code) throws Exception\n    {\n        if(code == null || code.length() == 0)\n            throw new Exception(\"Empty string\");\n\n        byte[] decrypted = null;\n\n        try {\n            cipher.init(Cipher.DECRYPT_MODE, keyspec, ivspec);\n\n            decrypted = cipher.doFinal(hexToBytes(code));\n        } catch (Exception e)\n        {\n            throw new Exception(\"[decrypt] \" + e.getMessage());\n        }\n        return decrypted;\n    }\n\n\n\n    public static String bytesToHex(byte[] data)\n    {\n        if (data==null)\n        {\n            return null;\n        }\n\n        int len = data.length;\n        String str = \"\";\n        for (int i=0; i<len; i++) {\n            if ((data[i]&0xFF)<16)\n                str = str + \"0\" + java.lang.Integer.toHexString(data[i]&0xFF);\n            else\n                str = str + java.lang.Integer.toHexString(data[i]&0xFF);\n        }\n        return str;\n    }\n\n\n    public static byte[] hexToBytes(String str) {\n        if (str==null) {\n            return null;\n        } else if (str.length() < 2) {\n            return null;\n        } else {\n            int len = str.length() / 2;\n            byte[] buffer = new byte[len];\n            for (int i=0; i<len; i++) {\n                buffer[i] = (byte) Integer.parseInt(str.substring(i*2,i*2+2),16);\n            }\n            return buffer;\n        }\n    }\n\n\n\n    private static String padString(String source)\n    {\n      char paddingChar = ' ';\n      int size = 16;\n      int x = source.length() % size;\n      int padLength = size - x;\n\n      for (int i = 0; i < padLength; i++)\n      {\n          source += paddingChar;\n      }\n\n      return source;\n    }\n}\n", "idx": 2562}
{"project": "cipher", "commit_id": "Snippet21075369_3668.java", "target": 0, "func": "Cipher.getInstance(\"AES\")", "idx": 2116}
{"project": "cipher", "commit_id": "Snippet46981519_28971.java", "target": 0, "func": "public class Encryption {\n\n    public static SecretKey generateKey() throws NoSuchAlgorithmException {\n        Security.addProvider(new com.sun.crypto.provider.SunJCE());\n        KeyGenerator keygen = KeyGenerator.getInstance(\"DESede\");\n        keygen.init(168);\n        SecretKey klucz = keygen.generateKey();\n\n        return klucz;\n    }\n\n    static byte[] encrypt(byte[] plainTextByte, SecretKey klucz)\n        throws Exception {\n        Cipher cipher = Cipher.getInstance(\"DESede/ECB/PKCS5Padding\");\n        cipher.init(Cipher.ENCRYPT_MODE, klucz);\n        byte[] encryptedBytes = cipher.doFinal(plainTextByte);\n        return encryptedBytes;\n    }\n\n    static byte[] decrypt(byte[] encryptedBytes, SecretKey klucz)\n        throws Exception {\n        Cipher cipher = Cipher.getInstance(\"DESede/ECB/PKCS5Padding\");\n        cipher.init(Cipher.DECRYPT_MODE, klucz);\n        byte[] decryptedBytes = cipher.doFinal(encryptedBytes);\n        return decryptedBytes;\n    }\n}\n", "idx": 2156}
{"project": "cipher", "commit_id": "Snippet36202917_18061.java", "target": 0, "func": " public static byte[] encrypt(byte[] plainText, byte[] key)  {\ntry {\n  byte[] passwordKey128 = Arrays.copyOfRange(key, 0, 16);\n  SecretKeySpec secretKey = new SecretKeySpec(passwordKey128, \"AES\");\n  Cipher cipher = Cipher.getInstance(\"AES\");\n  cipher.init(Cipher.ENCRYPT_MODE, secretKey);\n  byte[] cipherText = cipher.doFinal(plainText);\n  // String encryptedString = Base64.getEncoder().encodeToString(cipherText);\n  return cipherText;\n", "idx": 2168}
{"project": "cipher", "commit_id": "Snippet14398287_37704.java", "target": 0, "func": "import java.io.UnsupportedEncodingException;\nimport java.security.InvalidKeyException;\nimport java.security.NoSuchAlgorithmException;\n\nimport javax.crypto.*;\nimport javax.crypto.spec.*;\n\n\npublic class Encryption \n{\n    private static final String ALGORITHME = \"Blowfish\";\n    private static final String TRANSFORMATION = \"Blowfish/ECB/PKCS5Padding\";\n    private static final String SECRET = \"kjkdfjslm\";\n    private static final String CHARSET = \"ISO-8859-1\";\n\n\n    public static void main(String[] argv) throws InvalidKeyException, NoSuchAlgorithmException, NoSuchPaddingException, UnsupportedEncodingException, IllegalBlockSizeException, BadPaddingException\n    {\n        Encryption main = new Encryption();\n\n        String plain = \"trallalla\";\n        System.out.println(\"initial : \" + plain);\n\n        String encrypted = main.encrypt(plain);\n        System.out.println(\"after encryption : \" + encrypted);\n\n        String decrypted = main.decrypt(encrypted);\n        System.out.println(\"after decryption : \" + decrypted);\n    }\n\n    public String encrypt(String plaintext) \n    throws NoSuchAlgorithmException, \n    NoSuchPaddingException, \n    InvalidKeyException, \n    UnsupportedEncodingException, \n    IllegalBlockSizeException, \n    BadPaddingException\n    {\n\n            Cipher cipher = Cipher.getInstance(TRANSFORMATION);\n            cipher.init(Cipher.ENCRYPT_MODE, new SecretKeySpec(SECRET.getBytes(CHARSET), ALGORITHME));\n            return new String(cipher.doFinal(plaintext.getBytes()), CHARSET);    \n    }\n\n    public String decrypt(String ciphertext) \n    throws NoSuchAlgorithmException, \n    NoSuchPaddingException, \n    InvalidKeyException, \n    UnsupportedEncodingException, \n    IllegalBlockSizeException, \n    BadPaddingException \n    {\n      Cipher cipher = Cipher.getInstance(TRANSFORMATION);\n      cipher.init(Cipher.DECRYPT_MODE, new SecretKeySpec(SECRET.getBytes(), ALGORITHME));\n      return new String(cipher.doFinal(ciphertext.getBytes(CHARSET)), CHARSET);\n    }\n}\n", "idx": 2103}
{"project": "cipher", "commit_id": "Snippet38487481_20452.java", "target": 0, "func": "public class EncryptActivity extends AppCompatActivity {\n\nEditText ed1;\nButton b1;\n\nprivate ClipboardManager myClipboard;\nprivate ClipData myClip;\nKeyGenerator keygenerator;\nstatic SecretKey secretkey;\n\nCipher cipher;\nbyte[] encrypted;\nString encryptedText = null;\n\n@Override\nprotected void onCreate(Bundle savedInstanceState) {\n    super.onCreate(savedInstanceState);\n    setContentView(R.layout.encrypt_activity);\n    ed1 = (EditText) findViewById(R.id.editText);\n    b1 = (Button) findViewById(R.id.button);\n    myClipboard = (ClipboardManager) getSystemService(CLIPBOARD_SERVICE);\n    b1.setOnClickListener(new View.OnClickListener() {\n        @Override\n        public void onClick(View v) {\n            String text = ed1.getText().toString();//now encrypt the message\n            try {\n                keygenerator = KeyGenerator.getInstance(\"Blowfish\");\n                secretkey = keygenerator.generateKey();\n                Log.d(\"asd\", secretkey.toString());\n                cipher = Cipher.getInstance(\"Blowfish\");\n                cipher.init(Cipher.ENCRYPT_MODE, secretkey);\n                encrypted = cipher.doFinal(text.getBytes());\n                encryptedText = encrypted.toString();\n                myClip = ClipData.newPlainText(\"text\", encryptedText);\n                myClipboard.setPrimaryClip(myClip);\n\n                Toast.makeText(getApplicationContext(), \"Text Copied\", Toast.LENGTH_SHORT).show();\n            } catch (Exception e) {\n            }\n        }\n    });\n}\n", "idx": 2089}
{"project": "cipher", "commit_id": "Snippet5307536_31586.java", "target": 1, "func": "Cipher.getInstance(\"AES/CBC/PKCS5Padding\")", "idx": 2696}
{"project": "cipher", "commit_id": "Snippet13175598_36767.java", "target": 0, "func": "public class Main {\n    public static void main(String[] args) throws GeneralSecurityException {\n        Cipher cipher = Cipher.getInstance(\"DES/ECB/NoPadding\");\n        byte[] keyByte = new byte[8];\n        byte[] data = new byte[8];\n        Key key = new SecretKeySpec(keyByte, \"DES\");\n        cipher.init(Cipher.ENCRYPT_MODE, key);\n        byte[] result = cipher.doFinal(data);\n        StringBuilder str = new StringBuilder();\n        for (byte b : result) {\n             str.append(Integer.toHexString(0xff & b)).append(' ');\n        }\n        System.out.println(str);\n    }\n}\n", "idx": 1932}
{"project": "cipher", "commit_id": "Snippet15153395_38248.java", "target": 0, "func": "public class AESKeyGenerator {\n\n    private Cipher mCipher;\n\n    public AESKeyGenerator()\n    {\n        // default constructor\n    }\n\n\n    public byte[] generate_k(String dhkey, String toEncrypt)\n    {\n        byte[] retVal;\n\n        try { // Set up the Cipher class of Android to use AES to generate keys\n            byte[] iv = new byte[16];\n            for (int i = 0; i < iv.length; i++)\n                iv[i] = new Byte(\"0\").byteValue();\n            IvParameterSpec ivspec = new IvParameterSpec(iv);\n            mCipher = Cipher.getInstance(\"AES\");\n            // Set up key to use in algorithm\n            MessageDigest hasher = MessageDigest.getInstance(\"SHA-256\"); // Initialize object that will hash my key.\n            byte[] key256 = hasher.digest(dhkey.getBytes()); // Hash the key to 256 bits using SHA\n            SecretKeySpec K = new SecretKeySpec(key256, \"AES\");\n            System.out.println(\"SecretKeySpec : \"+K  + \"  key256 \"+key256);\n            mCipher.init(Cipher.ENCRYPT_MODE, K, ivspec);\n            // Encrypt the parameter toEncrypt\n            retVal = mCipher.doFinal(toEncrypt.getBytes());\n            return retVal;\n        }\n        catch (Exception e) {\n                        e.printStackTrace();\n            System.err.println(\"Could not create and initialize object Cipher.\");\n        }\n\n        return null;\n\n    }\n\n    public byte[] generate_r(byte[] sharedKey, String toEncrypt)\n    {\n        byte[] retVal;\n        try {\n            /*byte[] iv = new byte[16];\n            for (int i = 0; i < iv.length; i++)\n                iv[i] = new Byte(\"0\").byteValue();\n            IvParameterSpec ivspec = new IvParameterSpec(iv);*/\n\n            // Set up the Cipher class of Android to use AES to generate keys\n            mCipher = Cipher.getInstance(\"AES/ECB/PKCS5Padding\");\n            // Set up key to use in algorithm\n            MessageDigest hasher = MessageDigest.getInstance(\"SHA-256\"); // Initialize object that will hash my key.\n            byte[] key256 = hasher.digest(sharedKey); // Hash the key to 256 bits using SHA 256\n            SecretKeySpec K = new SecretKeySpec(key256, \"AES\");\n            mCipher.init(Cipher.ENCRYPT_MODE, K);\n            // Encrypt the parameter toEncrypt\n            System.out.println(\"toEncrypt AES: \"+ toEncrypt);\n            retVal = mCipher.doFinal(toEncrypt.getBytes());\n            return retVal;\n        }\n        catch (Exception e) {\n                        e.printStackTrace();\n            System.err.println(\"exception: \"+ e.toString());\n            System.err.println(\"Could not create and initialize object Cipher.\");\n        }\n\n        return null;\n\n    }\n}\n", "idx": 2028}
{"project": "cipher", "commit_id": "Snippet19267766_2089.java", "target": 1, "func": "public String Encrypt(String text, String pubkey) {\n        String encryptedText;\n        PublicKey publicKey = null;\n        Cipher cipher;\n        try {\n            publicKey = getPublicKeyFromString(pubkey);\n            if (publicKey!=null) {\n                if(text != null){\n                    byte[] plainText = text.getBytes();\n                    cipher = Cipher.getInstance(\"RSA/ECB/PKCS1Padding\");\n                    cipher.init(Cipher.ENCRYPT_MODE, publicKey);\n                    encryptedText = bASE64Encoder.encode(cipher.doFinal(plainText));\n                }\n                else{\n                    encryptedText =  \"Error@Encrypt: Null data received\";\n                }\n            }\n            else{\n                encryptedText =  \"Error@Encrypt: Public Key not found\";\n            }\n        } \n        catch (Exception e) {\n            encryptedText =  \"Error@Encrypt: \"+ e.getMessage();\n        }\n        return encryptedText;\n\n    }\n", "idx": 2530}
{"project": "cipher", "commit_id": "Snippet27198370_9344.java", "target": 1, "func": "//Grab IV from message\nbyte[] iv = new byte[ivLength];\nSystem.arraycopy(encryptedMessage, nonSecretPayloadLength, iv, 0, iv.length);\n\nCipher aes = Cipher.getInstance(\"AES/CBC/PKCS7Padding\");\n// MISSING: create IvParameterSpec\nIvParameterSpec ivSpec = new IvParameterSpec(iv);\niv = ivSpec.getIV();\n\naes.init(Cipher.DECRYPT_MODE, secretKeySpecy, ivSpec);\n\n//byte[] decoded = aes.doFinal(Base64.decodeBase64(encryptedMessage));\n\nByteArrayOutputStream decrypterStream = new ByteArrayOutputStream();\nDataOutputStream binaryWriter = new DataOutputStream(decrypterStream);\n\n        binaryWriter.write(\n                encryptedMessage,\n                nonSecretPayloadLength + iv.length,\n                encryptedMessage.length - nonSecretPayloadLength - iv.length - sentTag.length\n        );\n", "idx": 2494}
{"project": "cipher", "commit_id": "Snippet24988787_7323.java", "target": 1, "func": "public String RSAEncrypt(final String plain, PublicKey publicKey ) throws NoSuchAlgorithmException, NoSuchPaddingException,\n    InvalidKeyException, IllegalBlockSizeException, BadPaddingException {\n\n    Cipher cipher = Cipher.getInstance(\"RSA\");\n    cipher.init(Cipher.ENCRYPT_MODE, publicKey);\n    byte [] encryptedBytes = cipher.doFinal(plain.getBytes());\n    String encrypted = bytesToString(encryptedBytes);\n    System.out.println(\"EEncrypted?????\" + encrypted );\n    return encrypted;\n}\n\npublic String RSADecrypt(String encryptedBytes,PrivateKey privateKey ) throws NoSuchAlgorithmException, NoSuchPaddingException,\n    InvalidKeyException, IllegalBlockSizeException, BadPaddingException, NoSuchProviderException {\n    Cipher cipher1 = Cipher.getInstance(\"RSA/ECB/PKCS1Padding\");\n    cipher1.init(Cipher.DECRYPT_MODE, privateKey);\n    byte [] decryptedBytes = cipher1.doFinal(stringToBytes(encryptedBytes));\n\n    String decrypted = new String(decryptedBytes);\n    System.out.println(\"DDecrypted?????\" + decrypted);\n    return decrypted;\n    }\n\npublic  String bytesToString(byte[] b) {\n    byte[] b2 = new byte[b.length + 1];\n    b2[0] = 1;\n    System.arraycopy(b, 0, b2, 1, b.length);\n    return new BigInteger(b2).toString(36);\n}\n\npublic  byte[] stringToBytes(String s) {\n    byte[] b2 = new BigInteger(s, 36).toByteArray();\n    return Arrays.copyOfRange(b2, 1, b2.length);\n}\n", "idx": 2363}
{"project": "cipher", "commit_id": "Snippet42266168_24254.java", "target": 0, "func": "import javax.crypto.Cipher;\nimport javax.crypto.SecretKey;\nimport javax.crypto.SecretKeyFactory;\nimport javax.crypto.spec.DESKeySpec;\n\nimport sun.misc.BASE64Decoder;\nimport sun.misc.BASE64Encoder;\n\n\npublic class DoDecode {\n    private static final String DES_TYPE = \"DES\";\n//    private static final String DES_TYPE = \"DES/CBC/NoPadding\";\n//    private static final String DES_TYPE = \"DES/CBC/PKCS5Padding\";\n//    private static final String DES_TYPE = \"DES/ECB/NoPadding\";\n//    private static final String DES_TYPE = \"DES/ECB/PKCS5Padding\"; //Use this\n//    private static final String DES_TYPE = \"DESede/CBC/NoPadding\";\n//    private static final String DES_TYPE = \"DESede/CBC/PKCS5Padding\";\n//    private static final String DES_TYPE = \"DESede/ECB/NoPadding\";\n//    private static final String DES_TYPE = \"DESede/ECB/PKCS5Padding\";\n\n    public synchronized static String encode(String unencodedString, String key) {\n        String ret = null;\n\n        try {\n            DESKeySpec keySpec = new DESKeySpec(key.getBytes(\"UTF8\"));\n            SecretKeyFactory keyFactory = SecretKeyFactory.getInstance(\"DES\");\n            SecretKey skey = keyFactory.generateSecret(keySpec);\n            sun.misc.BASE64Encoder base64encoder = new BASE64Encoder();\n\n            byte[] cleartext = unencodedString.getBytes(\"UTF8\");\n\n            Cipher cipher = Cipher.getInstance(DES_TYPE);\n            cipher.init(Cipher.ENCRYPT_MODE, skey);\n\n            ret = base64encoder.encode(cipher.doFinal(cleartext));\n        } catch (Exception ex) {\n            System.err.println(\"Encode exception: \"+ex.getMessage());\n        }\n\n        return ret;\n    }\n\n    public static String decode(String encodedString, String key) {\n        String ret = null;\n\n        try {\n            DESKeySpec keySpec = new DESKeySpec(key.getBytes(\"UTF8\"));\n            SecretKeyFactory keyFactory = SecretKeyFactory.getInstance(\"DES\");\n            SecretKey skey = keyFactory.generateSecret(keySpec);\n            sun.misc.BASE64Decoder base64decoder = new BASE64Decoder();\n\n            byte[] encrypedPwdBytes = base64decoder.decodeBuffer(encodedString);\n\n            Cipher cipher = Cipher.getInstance(DES_TYPE);\n            cipher.init(Cipher.DECRYPT_MODE, skey);\n            byte[] plainTextPwdBytes = (cipher.doFinal(encrypedPwdBytes));\n\n            ret = new String(plainTextPwdBytes);\n        } catch (Exception ex) {\n            System.err.println(\"Decode exception: \" + ex.getMessage());\n        }\n\n        return ret;\n    }\n\n    private static final String wasValidStr = \"h1JTFcRjW6vveQUrQqPUgnjGXo3NEZKDnBThZQN7uLfzPEpeFFONV4mvL71cT/xQb1mz5Xa/XZ/aW2GawZNumgO0reUZSDh30F7NfK0S/rMWM8FxcjBCkfFWAbLZHcyDJ5wW3F1yl5g=\";\n\n    public static void main(String[] args) {\n        System.out.println(DoDecode.decode(wasValidStr, \"invpwd~~\"));\n\n        String encoded = DoDecode.encode(\"This has worked in the past!\", \"invpwd~~\");\n        System.out.println(encoded);\n        System.out.println(DoDecode.decode(encoded, \"invpwd~~\"));\n    }\n}\n", "idx": 1948}
{"project": "cipher", "commit_id": "Snippet16231224_39187.java", "target": 0, "func": "public class DecryptFinal {\nprivate static Cipher dcipher;\n\nprivate static byte[] iv = {\n    (byte)0xB2, (byte)0x12, (byte)0xD5, (byte)0xB2,\n    (byte)0x44, (byte)0x21, (byte)0xC3, (byte)0xC3\n    };\n\n\npublic static void main(String[] args){\n\n    try {\n        String s = \"123456789123456789111234\";\n        AlgorithmParameterSpec paramSpec = new IvParameterSpec(iv);\n\n        SecretKeyFactory keyfactory=SecretKeyFactory.getInstance(\"DESede\");\n        byte[] encodedkey=s.getBytes();\n        System.out.println();\n         SecretKey key = keyfactory.generateSecret(new DESedeKeySpec(encodedkey));\n         System.out.println(new DESedeKeySpec(encodedkey));\n        SecretKeySpec(encodedKey,0,encodedKey.length,\"DESede\" );\n\n        dcipher = Cipher.getInstance(\"DESede/CBC/PKCS5Padding\");\n        dcipher.init(Cipher.DECRYPT_MODE, key, paramSpec);\n        FileInputStream fs =new FileInputStream(\"E:\\\\Test1\\\\Test1\\\\Encrypted Files\\\\Wedding bells.akr\");\n        FileOutputStream os= new FileOutputStream(\"E:\\\\Test1\\\\Test1\\\\Encrypted Files\\\\Encrypted Files\\\\E-pub Totorials\");\n        byte[] buf = new byte[1024];// bytes read from stream will be decrypted\n        CipherInputStream cis = new CipherInputStream(fs, dcipher);// read in the decrypted bytes and write the clear text to out\n        int numRead = 0;\n        while ((numRead = cis.read(buf)) >= 0) {\n            os.write(buf, 0, numRead);\n        }\n        cis.close();// close all streams\n        fs.close();\n        os.close();\n\n    }\n    catch(FileNotFoundException e) {\n        System.out.println(\"File Not Found:\" + e.getMessage());\n        return;\n    } catch (NoSuchAlgorithmException e) {\n        // TODO Auto-generated catch block\n        e.printStackTrace();\n    } catch (NoSuchPaddingException e) {\n        // TODO Auto-generated catch block\n        e.printStackTrace();\n\n    } catch (InvalidKeyException e) {\n        // TODO Auto-generated catch block\n        e.printStackTrace();\n    } catch (InvalidAlgorithmParameterException e) {\n        // TODO Auto-generated catch block\n        e.printStackTrace();\n    }\n    catch (IOException e) {\n        System.out.println(\"I/O Error:\" + e.getMessage());\n    }\n    catch (InvalidKeySpecException e) {\n        // TODO: handle exception\n        e.printStackTrace();\n    }\n", "idx": 2078}
{"project": "cipher", "commit_id": "Snippet15903096_38892.java", "target": 0, "func": "public class Test {\n        private static File file;\n        private static final byte[] STAT_KEY = { -1, -2, 3, 4, -5, -6, -7, 8 };\n        static {\n            file = new File(\"MyFile.txt\");\n        }\n\n        private static Cipher getCipher(int mode) throws InvalidKeyException, NoSuchAlgorithmException,\n                InvalidKeySpecException, NoSuchPaddingException {\n            DESKeySpec dks = new DESKeySpec(STAT_KEY);\n            SecretKeyFactory skf = SecretKeyFactory.getInstance(\"DES\");\n            SecretKey desKey = skf.generateSecret(dks);\n            Cipher cipher = Cipher.getInstance(\"DES\");\n            cipher.init(mode, desKey);\n            return cipher;\n        }\n\n        private static void appendToFile(String item) throws Exception {\n            CipherOutputStream cos = null;\n            try {\n                cos = new CipherOutputStream(new FileOutputStream(file, true), getCipher(Cipher.ENCRYPT_MODE));\n                cos.write((item + String.format(\"%n\")).getBytes());\n            } finally {\n                cos.close();\n            }\n        }\n\n        private static void readFromFile() throws Exception {\n            CipherInputStream cis = null;\n            try {\n                cis = new CipherInputStream(new FileInputStream(file), getCipher(Cipher.DECRYPT_MODE));\n                int content;\n                while ((content = cis.read()) != -1) {\n                    System.out.print((char) content);\n                }\n            } finally {\n                cis.close();\n            }\n        }\n\n        public static void main(String[] args) throws Exception {\n            String[] items = { \"Hello\", \"dear\", \"world\" };\n            for (String item : items) {\n                appendToFile(item);\n            }\n            readFromFile();\n        }\n    }\n", "idx": 2126}
{"project": "cipher", "commit_id": "Snippet30358788_12511.java", "target": 0, "func": "public class AESUtils {\n\n    public static byte[] encrypt(SecretKeySpec skeySpec, byte[] clear) throws Exception {\n        Cipher cipher = Cipher.getInstance(\"AES\");\n        cipher.init(Cipher.ENCRYPT_MODE, skeySpec);\n        byte[] encrypted = cipher.doFinal(clear);\n        return encrypted;\n    }\n\n    public static byte[] decrypt(SecretKeySpec skeySpec, byte[] encrypted) throws Exception {\n        Cipher cipher = Cipher.getInstance(\"AES\");\n        cipher.init(Cipher.DECRYPT_MODE, skeySpec);\n        byte[] decrypted = cipher.doFinal(encrypted);\n        return decrypted;\n    }\n\n    public static SecretKeySpec getKey(String key) throws NoSuchAlgorithmException {\n        SecureRandom sr = SecureRandom.getInstance(\"SHA1PRNG\");\n        sr.setSeed(key.getBytes());\n        KeyGenerator kg = KeyGenerator.getInstance(\"AES\");\n        kg.init(128, sr);\n        return new SecretKeySpec((kg.generateKey()).getEncoded(), \"AES\");\n    }\n}\n", "idx": 2077}
{"project": "cipher", "commit_id": "Snippet42696859_24735.java", "target": 0, "func": "            try {\n                        Cipher desCipher;\n                        byte[] decodedKey = pass.getText().getBytes();\n                        SecretKey originalKey = new SecretKeySpec(decodedKey, 0, decodedKey.length, \"DES\");\n                        desCipher = Cipher.getInstance(\"DES/ECB/PKCS5Padding\");\n                        byte[] text = input.getText().getBytes();\n                        desCipher.init(Cipher.DECRYPT_MODE, originalKey);\n                        byte[] textDecrypted = desCipher.doFinal(input.getText().getBytes());\n                        output.setText(Arrays.toString(textDecrypted));\n                    } catch (NoSuchAlgorithmException | InvalidKeyException | NoSuchPaddingException | IllegalBlockSizeException | BadPaddingException ex) {\n                        Error(ex.getMessage());\n                        Logger(ex.getMessage());\n                    }\n", "idx": 2206}
{"project": "cipher", "commit_id": "Snippet45922643_27990.java", "target": 1, "func": "public static String decrypt2(final String EncryptedMessageBase64,\n                              final String symKeyHex,\n                              final String sIvHex) {\n\n    final byte[] symKeyData = Base64.decode((symKeyHex),Base64.DEFAULT);\n    final byte[] byIvData = Base64.decode((sIvHex), Base64.DEFAULT);\n    final byte[] EncryptedMessage = Base64.decode(EncryptedMessageBase64, Base64.DEFAULT);\n\n    try\n    {\n\n        final Cipher cipher = Cipher.getInstance(\"AES/CBC/PKCS5Padding\");\n        final int blockSize = cipher.getBlockSize();\n\n        final SecretKeySpec symKey = new SecretKeySpec(symKeyData, \"AES\");\n        Log.i(\"### iv size -------->\", String.valueOf(blockSize));\n        Log.i(\"### symKeyHex -------->\", symKeyHex);\n        Log.i(\"### sIvHex -------->\", sIvHex);\n        Log.i(\"### blockSize -------->\", String.valueOf(blockSize));\n\n        final IvParameterSpec iv = new IvParameterSpec(byIvData);\n\n        final byte[] encryptedMessage = new byte[EncryptedMessage.length];\n\n        cipher.init(Cipher.DECRYPT_MODE, symKey, iv);\n", "idx": 2623}
{"project": "cipher", "commit_id": "Snippet24226554_6507.java", "target": 0, "func": "package Encrypt;\n\nimport org.apache.hadoop.hive.ql.exec.UDF;\nimport org.apache.hadoop.io.Text;\nimport java.security.*;\nimport org.apache.commons.codec.binary.Base64;\nimport java.io.*;\nimport java.security.InvalidAlgorithmParameterException;\nimport java.security.InvalidKeyException;\nimport javax.swing.JOptionPane;\nimport java.security.MessageDigest;\nimport java.security.NoSuchAlgorithmException;\nimport javax.crypto.BadPaddingException;\nimport javax.crypto.Cipher;\nimport javax.crypto.IllegalBlockSizeException;\nimport javax.crypto.NoSuchPaddingException;\nimport javax.crypto.spec.IvParameterSpec;\nimport javax.crypto.spec.SecretKeySpec;\n\npublic final class En1 extends UDF {\n\npublic Text evaluate(final Text s) throws Exception {\nif (s == null) {\n return null;\n}\nbyte[] sharedvector = {\n0x01, 0x02, 0x03, 0x05, 0x07, 0x0B, 0x0D, 0x11\n};\n\nString EncText = \"\";\nbyte[] keyArray = new byte[24];\nbyte[] temporaryKey;\nString key = \"developersnotedotcom\";\nbyte[] toEncryptArray = null;\n\n//try\n   // {\n\n    toEncryptArray =  s.toString().getBytes(\"UTF-8\");        \n    MessageDigest m = MessageDigest.getInstance(\"MD5\");\n    temporaryKey = m.digest(key.getBytes(\"UTF-8\"));\n\n    if(temporaryKey.length < 24) // DESede require 24 byte length key\n    {\n        int index = 0;\n        for(int i=temporaryKey.length;i< 24;i++)\n        {                   \n            keyArray[i] =  temporaryKey[index];\n        }\n    }        \n\n    Cipher c = Cipher.getInstance(\"DESede/CBC/PKCS5Padding\");            \n    c.init(Cipher.ENCRYPT_MODE, new SecretKeySpec(keyArray, \"DESede\"), new IvParameterSpec(sharedvector));            \n    byte[] encrypted = c.doFinal(toEncryptArray);            \n    EncText = Base64.encodeBase64String(encrypted);\n\n\n//  }\n   /* catch(NoSuchAlgorithmException | UnsupportedEncodingException | NoSuchPaddingException | InvalidKeyException | InvalidAlgorithmParameterException | IllegalBlockSizeException | BadPaddingException NoEx)\n{\n    //JOptionPane.showMessageDialog(null, NoEx);\n     System.out.println(NoEx);\n     System.exit(1);\n}*/\n\nreturn new Text(EncText.toString());        \n}\n\n}\n", "idx": 2223}
{"project": "cipher", "commit_id": "Snippet12523819_36308.java", "target": 0, "func": "import javax.crypto.Cipher;\nimport javax.crypto.spec.SecretKeySpec;\nimport javax.xml.bind.DatatypeConverter;\n\npublic class MyArcFour\n{\n   public static void main(String [] args) throws Exception\n   {\n      byte [] key = \"MYVERYINSECUREKEY\".getBytes(\"ASCII\");\n\n      String clearText = \"123456789012\";\n\n      Cipher rc4 = Cipher.getInstance(\"RC4\");\n      SecretKeySpec rc4Key = new SecretKeySpec(key, \"RC4\");\n      rc4.init(Cipher.ENCRYPT_MODE, rc4Key);\n\n      byte [] cipherText = rc4.update(clearText.getBytes(\"ASCII\"));\n\n      System.out.println(\"clear (ascii)        \" + clearText);\n      System.out.println(\"clear (hex)          \" + DatatypeConverter.printHexBinary(clearText.getBytes(\"ASCII\")));\n      System.out.println(\"cipher (hex) is      \" + DatatypeConverter.printHexBinary(cipherText));\n\n      Cipher rc4Decrypt = Cipher.getInstance(\"RC4\");\n      rc4Decrypt.init(Cipher.DECRYPT_MODE, rc4Key);\n      byte [] clearText2 = rc4Decrypt.update(cipherText);\n\n      System.out.println(\"decrypted (clear) is \" + new String(clearText2, \"ASCII\"));\n   }\n}\n", "idx": 2061}
{"project": "cipher", "commit_id": "Snippet5309137_31587.java", "target": 1, "func": "String text = \"hello\";\n        KeyPairGenerator kpg = KeyPairGenerator.getInstance(\"RSA\");\n        kpg.initialize(2048);\n        KeyPair kp = kpg.genKeyPair();\n        Key publicKey = kp.getPublic();\n        Key privateKey = kp.getPrivate();\n\n        Cipher cipher = Cipher.getInstance(\"RSA/ECB/NoPadding\");\n        cipher.init(Cipher.ENCRYPT_MODE, publicKey);\n        byte[] cipherData = cipher.doFinal(text.getBytes());\n\n        cipher = Cipher.getInstance(\"RSA/ECB/NoPadding\");\n        cipher.init(Cipher.DECRYPT_MODE, privateKey);\n        byte[] textData = cipher.doFinal(text.getBytes());\n\n        String decrypted = new String(textData);\n        System.out.println(decrypted);\n", "idx": 2499}
{"project": "cipher", "commit_id": "Snippet8362262_33178.java", "target": 0, "func": "protected static byte[] encrypt(byte[] data, String base64encodedKey) throws InvalidKeyException, IllegalBlockSizeException, BadPaddingException {\n    Cipher cipher;\n    try {\n        cipher = Cipher.getInstance(\"AES\");\n    } catch (NoSuchAlgorithmException ex) {\n        //log error\n    } catch (NoSuchPaddingException ex) {\n        //log error\n    }\n    SecretKey key = b64EncodedStringToSecretKey(base64encodedKey);\n    cipher.init(Cipher.ENCRYPT_MODE, key); //THIS IS WHERE IT FAILS\n    data = cipher.doFinal(data);\n    return data;\n}\nprivate static SecretKey b64EncodedStringToSecretKey(String base64encodedKey) {\n    SecretKey key = null;\n\n    try {\n        byte[] temp = Base64.decodeBase64(base64encodedKey.getBytes());\n        key = new SecretKeySpec(temp, SYMMETRIC_ALGORITHM);\n    } catch (Exception e) {\n        // Do nothing\n    }\n\n    return key;\n}\n", "idx": 2123}
{"project": "cipher", "commit_id": "Snippet17854366_946.java", "target": 1, "func": "    public  String Encrypt(String text, String key)\n        throws Exception {\n\n        Cipher cipher = Cipher.getInstance(\"AES/CBC/PKCS5Padding\");\n        byte[] keyBytes= new byte[16];\n        byte[] b= key.getBytes(\"UTF-8\");\n        int len= b.length;\n        if (len > keyBytes.length) len = keyBytes.length;\n        System.arraycopy(b, 0, keyBytes, 0, len);\n        SecretKeySpec keySpec = new SecretKeySpec(keyBytes,0,keyBytes.length, \"AES\");\n\n        cipher.init(Cipher.ENCRYPT_MODE,keySpec, ivspec);\n\n            byte[] outputBytes = new byte[100];\n            byte[] inputBytes;\n            inputBytes=text.getBytes(\"UTF-8\");\n        int results = cipher.doFinal(inputBytes,0,inputBytes.length,outputBytes,0);\n\n            String str = new String(outputBytes, 0, results);\n\n        String strMobile_No = Base64.encode(str.getBytes());\n            String strresult=strMobile_No.toString();\n          textField.setString(strMobile_No);\n          return strresult;\n\n        }\n", "idx": 2539}
{"project": "cipher", "commit_id": "Snippet44251884_26307.java", "target": 1, "func": "package ciphers;\n\nimport javax.crypto.Cipher;\nimport javax.crypto.spec.IvParameterSpec;\nimport javax.crypto.spec.SecretKeySpec;\n\nimport java.util.Base64;\n\npublic class Java_AES_Cipher {\n\n    private static String CIPHER_NAME = \"AES/CBC/PKCS5PADDING\";\n    private static int CIPHER_KEY_LEN = 16; //128 bits\n\n    /**\n     * Encrypt data using AES Cipher (CBC) with 128 bit key\n     * \n     * \n     * @param key  - key to use should be 16 bytes long (128 bits)\n     * @param iv - initialization vector\n     * @param data - data to encrypt\n     * @return encryptedData data in base64 encoding with iv attached at end after a :\n     */\n    public static String encrypt(String key, String iv, String data) {\n        try {\n            if (key.length() < Java_AES_Cipher.CIPHER_KEY_LEN) {\n                int numPad = Java_AES_Cipher.CIPHER_KEY_LEN - key.length();\n\n                for(int i = 0; i < numPad; i++){\n                    key += \"0\"; //0 pad to len 16 bytes\n                }\n\n            } else if (key.length() > Java_AES_Cipher.CIPHER_KEY_LEN) {\n                key = key.substring(0, CIPHER_KEY_LEN); //truncate to 16 bytes\n            }\n\n\n            IvParameterSpec initVector = new IvParameterSpec(iv.getBytes(\"UTF-8\"));\n            SecretKeySpec skeySpec = new SecretKeySpec(key.getBytes(\"UTF-8\"), \"AES\");\n\n            Cipher cipher = Cipher.getInstance(Java_AES_Cipher.CIPHER_NAME);\n            cipher.init(Cipher.ENCRYPT_MODE, skeySpec, initVector);\n\n            byte[] encryptedData = cipher.doFinal((data.getBytes()));\n\n            String base64_EncryptedData = Base64.getEncoder().encodeToString(encryptedData);\n            String base64_IV = Base64.getEncoder().encodeToString(iv.getBytes(\"UTF-8\"));\n\n            return base64_EncryptedData + \":\" + base64_IV;\n\n        } catch (Exception ex) {\n            ex.printStackTrace();\n        }\n\n        return null;\n    }\n\n    /**\n     * Decrypt data using AES Cipher (CBC) with 128 bit key\n     * \n     * @param key - key to use should be 16 bytes long (128 bits)\n     * @param data - encrypted data with iv at the end separate by :\n     * @return decrypted data string\n     */\n\n    public static String decrypt(String key, String data) {\n        try {\n\n            String[] parts = data.split(\":\");\n\n            IvParameterSpec iv = new IvParameterSpec(Base64.getDecoder().decode(parts[1]));\n            SecretKeySpec skeySpec = new SecretKeySpec(key.getBytes(\"UTF-8\"), \"AES\");\n\n            Cipher cipher = Cipher.getInstance(Java_AES_Cipher.CIPHER_NAME);\n            cipher.init(Cipher.DECRYPT_MODE, skeySpec, iv);\n\n            byte[] decodedEncryptedData = Base64.getDecoder().decode(parts[0]);\n\n            byte[] original = cipher.doFinal(decodedEncryptedData);\n\n            return new String(original);\n        } catch (Exception ex) {\n            ex.printStackTrace();\n        }\n\n        return null;\n    }\n\n}\n", "idx": 2472}
{"project": "cipher", "commit_id": "Snippet20906264_3510.java", "target": 0, "func": "public class Cryptooo {\n\nSecretKeySpec key = null;\nbyte[] ciphertext;\n\n public void generateKey()  {\n\n String passphrase = \"3xtr3meDiFficUltp@ss\";\n\n MessageDigest digest = null;\n try {\n     digest = MessageDigest.getInstance(\"SHA\");\n } catch (NoSuchAlgorithmException e) {\n     e.printStackTrace();\n }\n\n digest.update(passphrase.getBytes());\n key = new SecretKeySpec(digest.digest(), 0, 16, \"AES\");\n\n byte[] keyBytes = key.getEncoded();\n\n\n\n }\n\n\npublic byte[] encrypt(String string)    {\n    Cipher aes = null;\n    try {\n        aes = Cipher.getInstance(\"AES/ECB/PKCS5Padding\");\n\n    aes.init(Cipher.ENCRYPT_MODE, key);\n    ciphertext = aes.doFinal(string.getBytes());\n\n\n    } catch (NoSuchAlgorithmException e) {\n        e.printStackTrace();\n    } catch (NoSuchPaddingException e) {\n        e.printStackTrace();\n    } catch (IllegalBlockSizeException e) {\n        e.printStackTrace();\n    } catch (BadPaddingException e) {\n        e.printStackTrace();\n    } catch (InvalidKeyException e) {\n        e.printStackTrace();\n    }\n\n    return ciphertext;\n}\n\npublic String decrypt(byte[] ciphertext)    {\n\n    Cipher aes = null;\n    String cleartext =null;\n\n\n    try {\n        aes = Cipher.getInstance(\"AES/ECB/PKCS5Padding\");\n        aes.init(Cipher.DECRYPT_MODE, key);\n        cleartext = new String(aes.doFinal(ciphertext));\n\n    } catch (NoSuchAlgorithmException e) {\n        e.printStackTrace();\n    } catch (NoSuchPaddingException e) {\n        e.printStackTrace();\n    } catch (IllegalBlockSizeException e) {\n        e.printStackTrace();\n    } catch (BadPaddingException e) {\n        e.printStackTrace();\n    } catch (InvalidKeyException e) {\n        e.printStackTrace();\n    }\n\n    return cleartext;\n}\n\n}\n", "idx": 1962}
{"project": "cipher", "commit_id": "Snippet7181532_32631.java", "target": 1, "func": "public class DesEncrypter {\n\n    public static final int SALT_LENGTH = 20;\n    public static final int PBE_ITERATION_COUNT = 1024;\n\n    private static final String RANDOM_ALGORITHM = \"SHA1PRNG\";\n    private static final String PBE_ALGORITHM = \"PBEWithSHA256And256BitAES-CBC-BC\";\n    private static final String CIPHER_ALGORITHM = \"AES/CBC/PKCS5Padding\";\n\n\n    public byte[] encrypt(String password, String cleartext) {\n\n        byte[] encryptedText = null;\n\n        try {\n            byte[] salt = \"dfghjklpoiuytgftgyhj\".getBytes();\n\n            PBEKeySpec pbeKeySpec = new PBEKeySpec(password.toCharArray(), salt, PBE_ITERATION_COUNT, 256);\n\n            SecretKeyFactory factory = SecretKeyFactory.getInstance(\"PBEWITHSHAAND256BITAES-CBC-BC\");\n\n            SecretKey tmp = factory.generateSecret(pbeKeySpec);\n\n            SecretKey secret = new SecretKeySpec(tmp.getEncoded(), \"AES\");\n\n            byte[] key = secret.getEncoded();\n\n            Cipher encryptionCipher = Cipher.getInstance(CIPHER_ALGORITHM);   \n\n            byte[] iv = generateIv();\n\n            IvParameterSpec ivspec = new IvParameterSpec(iv);\n\n            encryptionCipher.init(Cipher.ENCRYPT_MODE, secret, ivspec);\n\n            encryptedText = encryptionCipher.doFinal(cleartext.getBytes());\n\n        } catch (Exception e) {\n            e.printStackTrace();\n        }\n\n        return encryptedText;\n    }\n\n    public String decrypt(String password, byte[] encryptedText) {\n\n        String cleartext = \"\";\n\n        try {\n            byte[] salt = \"dfghjklpoiuytgftgyhj\".getBytes();\n\n            PBEKeySpec pbeKeySpec = new PBEKeySpec(password.toCharArray(), salt, PBE_ITERATION_COUNT, 256);\n\n            SecretKeyFactory factory = SecretKeyFactory.getInstance(\"PBEWITHSHAAND256BITAES-CBC-BC\");\n\n            SecretKey tmp = factory.generateSecret(pbeKeySpec);\n\n            SecretKey secret = new SecretKeySpec(tmp.getEncoded(), \"AES\");\n\n            byte[] key = secret.getEncoded();\n\n            Cipher decryptionCipher = Cipher.getInstance(CIPHER_ALGORITHM);\n\n            byte[] iv = generateIv();\n\n            IvParameterSpec ivspec = new IvParameterSpec(iv);\n\n            decryptionCipher.init(Cipher.DECRYPT_MODE, secret, ivspec);\n\n            byte[] decryptedText = decryptionCipher.doFinal(encryptedText);\n\n            cleartext =  new String(decryptedText); \n\n        } catch (Exception e) {\n            e.printStackTrace();\n        }\n\n        return cleartext;\n    }   \n\n    private byte[] generateIv() throws NoSuchAlgorithmException {\n\n        SecureRandom random = SecureRandom.getInstance(RANDOM_ALGORITHM);\n\n        byte[] iv = new byte[16];\n\n        random.nextBytes(iv);\n\n        return iv;\n    }\n\n}\n", "idx": 2644}
{"project": "cipher", "commit_id": "Snippet32446396_14506.java", "target": 1, "func": "    loggedUser = null;\n    sharedPreferences = getSharedPreferences(AppConstants.PREFERENCES_FILE_NAME, MODE_PRIVATE);\n    if (sharedPreferences.getAll().isEmpty()) {\n        Intent loginActivityIntent = new Intent(MainActivity.this, LoginActivity.class);\n        startActivity(loginActivityIntent);\n        finishAffinity();\n    }\n\n    String loggedUserUsername = sharedPreferences.getString(AppConstants.LOGIN_CREDENTIAL_USERNAME_KEY, \"\");\n    if (loggedUserUsername.isEmpty()) {\n        Intent loginActivityIntent = new Intent(MainActivity.this, LoginActivity.class);\n        loginActivityIntent.setFlags(Intent.FLAG_ACTIVITY_CLEAR_TOP);\n        startActivity(loginActivityIntent);\n        finishAffinity();\n    } else {\n        File filesDirectory = new File(getFilesDir().getPath());\n        for (File file: filesDirectory.listFiles()) {\n            if (file.getName().contains(loggedUserUsername) && file.getName().contains(AppConstants.USER_INFO_FILE_SUFFIX)) {\n                String deviceId;\n                String deviceKey;\n                byte[] secretBytes;\n                byte[] ivBytes;\n                FileInputStream fileInputStream = null;\n                CipherInputStream cipherInputStream = null;\n                ObjectInputStream objectInputStream = null;\n\n                try {\n                    deviceId = sharedPreferences.getString(AppConstants.LOGIN_CREDENTIAL_DEVICE_ID_KEY, \"\").replace(\"-\", \"\");\n                    deviceKey = sharedPreferences.getString(AppConstants.LOGIN_CREDENTIAL_DEVICE_KEY_KEY, \"\").replace(\"-\", \"\");\n                    secretBytes = deviceKey.substring(0, 16).getBytes();\n                    ivBytes = deviceId.substring(deviceId.length() - 16, deviceId.length()).getBytes();\n\n                    fileInputStream = openFileInput(file.getName());\n                    final SecretKey secretKey = new SecretKeySpec(secretBytes, \"AES\");\n                    final IvParameterSpec ivParameterSpec = new IvParameterSpec(ivBytes);\n                    final Cipher cipher = Cipher.getInstance(\"AES/CBC/PKCS5Padding\");\n                    cipher.init(Cipher.DECRYPT_MODE, secretKey, ivParameterSpec);\n                    cipherInputStream = new CipherInputStream(fileInputStream, cipher);\n                    objectInputStream = new ObjectInputStream(cipherInputStream);\n                    loggedUser = new User((String)objectInputStream.readObject());\n                } catch (ClassNotFoundException | NoSuchAlgorithmException | NoSuchPaddingException | InvalidKeyException | InvalidAlgorithmParameterException | IOException | JSONException e) {\n                    if (AppConstants.DEBUG) Log.e(TAG, AppConstants.EXCEPTION_CAUGHT_MESSAGE + e.getMessage(), e);\n                    loggedUser = null;\n                } finally {\n                    if (objectInputStream != null) {\n                        try {\n                            objectInputStream.close();\n                        } catch (IOException e) {\n                            if (AppConstants.DEBUG) Log.e(TAG, AppConstants.EXCEPTION_CAUGHT_MESSAGE + e.getMessage(), e);\n                        }\n                    } else {\n                        if (AppConstants.DEBUG) Log.e(TAG, \"objectOutputStream:null\");\n                    }\n\n                    if (cipherInputStream != null) {\n                        try {\n                            cipherInputStream.close();\n                        } catch (IOException e) {\n                            if (AppConstants.DEBUG) Log.e(TAG, AppConstants.EXCEPTION_CAUGHT_MESSAGE + e.getMessage(), e);\n                        }\n                    } else {\n                        if (AppConstants.DEBUG) Log.e(TAG, \"cipherOutputStream:null\");\n                    }\n\n                    if (fileInputStream != null) {\n                        try {\n                            fileInputStream.close();\n                        } catch (IOException e) {\n                            if (AppConstants.DEBUG) Log.e(TAG, AppConstants.EXCEPTION_CAUGHT_MESSAGE + e.getMessage(), e);\n                        }\n                    } else {\n                        if (AppConstants.DEBUG) Log.e(TAG, \"fileOutputStream:null\");\n                    }\n                }\n                break;\n            }\n        }\n    }\n", "idx": 2685}
{"project": "cipher", "commit_id": "Snippet28171353_10349.java", "target": 1, "func": " public class Crypt {\n\nprivate static final String tag = Crypt.class.getSimpleName();\n\nprivate static final String characterEncoding = \"UTF-8\";\nprivate static final String cipherTransformation = \"AES/CBC/PKCS5Padding\";\nprivate static final String aesEncryptionAlgorithm = \"AES\";\nprivate static final String key = \"e8ffc7e56311679f12b6fc91aa77a5eb\";\nprivate static byte[] ivBytes = { 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00 };\nprivate static byte[] keyBytes;\n\nprivate static Crypt instance = null;\n\n\nprivate Crypt(){}\n\n\n\npublic static Crypt getInstance() {\n    if(instance == null){\n        instance = new Crypt();\n    }\n\n    return instance;\n}\n\n\n\npublic   byte[] encrypt(   byte[] mes)\n        throws NoSuchAlgorithmException,\n        NoSuchPaddingException,\n        InvalidKeyException,\n        InvalidAlgorithmParameterException,\n        IllegalBlockSizeException,\n        BadPaddingException, IOException {\n\n    keyBytes = key.getBytes(\"UTF-8\");\n    Log.d(tag,\"Long KEY: \"+keyBytes.length);\n    MessageDigest md = MessageDigest.getInstance(\"SHA-256\");\n    md.update(keyBytes);\n    keyBytes = md.digest();\n\n    Log.d(tag,\"Long KEY: \"+keyBytes.length);\n\n    AlgorithmParameterSpec ivSpec = new IvParameterSpec(ivBytes);\n    SecretKeySpec newKey = new SecretKeySpec(keyBytes, \"AES\");\n    Cipher cipher = null;\n    cipher = Cipher.getInstance(\"AES/CBC/PKCS5Padding\");\n    cipher.init(Cipher.ENCRYPT_MODE, newKey, ivSpec);\n\n    byte[] destination = new byte[ivBytes.length + mes.length];\n    System.arraycopy(ivBytes, 0, destination, 0, ivBytes.length);\n    System.arraycopy(mes, 0, destination, ivBytes.length, mes.length);\n    return  cipher.doFinal(destination);\n\n}\n\npublic   byte[] decrypt(   byte[] bytes)\n        throws NoSuchAlgorithmException,\n        NoSuchPaddingException,\n        InvalidKeyException,\n        InvalidAlgorithmParameterException,\n        IllegalBlockSizeException,\n        BadPaddingException, IOException, ClassNotFoundException {\n\n    keyBytes = key.getBytes(\"UTF-8\");\n    Log.d(tag,\"Long KEY: \"+keyBytes.length);\n    MessageDigest md = MessageDigest.getInstance(\"SHA-256\");\n    md.update(keyBytes);\n    keyBytes = md.digest();\n    Log.d(tag,\"Long KEY: \"+keyBytes.length);\n\n    byte[] ivB = Arrays.copyOfRange(bytes,0,16);\n    Log.d(tag, \"IV: \"+new String(ivB));\n    byte[] codB = Arrays.copyOfRange(bytes,16,bytes.length);\n\n\n    AlgorithmParameterSpec ivSpec = new IvParameterSpec(ivB);\n    SecretKeySpec newKey = new SecretKeySpec(keyBytes, \"AES\");\n    Cipher cipher = Cipher.getInstance(\"AES/CBC/PKCS5Padding\");\n    cipher.init(Cipher.DECRYPT_MODE, newKey, ivSpec);\n    return  cipher.doFinal(codB);\n\n}\n\n}\n", "idx": 2578}
{"project": "cipher", "commit_id": "Snippet16547808_39471.java", "target": 0, "func": "  FileInputStream fis = new FileInputStream(file);\n  FileOutputStream fos = new FileOutputStream(tmp_file);\n  String seed = \"password\";\n  byte[] rawKey = Utils.getRawKey(seed.getBytes());\n  SecretKeySpec skeySpec = new SecretKeySpec(rawKey, \"AES\");\n  Cipher cipher = Cipher.getInstance(\"AES\");\n  cipher.init(Cipher.DECRYPT_MODE, skeySpec);\n  int b;\n  byte[] data = new byte[4096];\n  while((b = fis.read(data)) != -1) {\n       fos.write(cipher.doFinal(data), 0, b);\n  }\n fos.flush();\n fos.close();\n fis.close();\n", "idx": 2143}
{"project": "cipher", "commit_id": "Snippet30348046_12498.java", "target": 0, "func": "private static final String ALGORITHM = \"AES\"; \n\npublic String encrypt(final String valueEnc, final String secKey) { \n\n    String encryptedVal = null;\n\n    try {\n        final Key key = generateKeyFromString(secKey);\n        final Cipher c = Cipher.getInstance(ALGORITHM);\n        c.init(Cipher.ENCRYPT_MODE, key);\n        final byte[] encValue = c.doFinal(valueEnc.getBytes());\n        encryptedVal = new BASE64Encoder().encode(encValue);\n    } catch(Exception ex) {\n        System.out.println(\"The Exception is=\" + ex);\n    }\n\n    return encryptedVal;\n}\n", "idx": 2050}
{"project": "cipher", "commit_id": "Snippet40820396_22707.java", "target": 0, "func": "import java.security.Security;\nimport javax.crypto.Cipher;\nimport javax.crypto.spec.SecretKeySpec;\n\npublic class EncryptTests {\n  public static void main(String[] args) throws Exception {\n        byte[] input = \"www.java2s.com\".getBytes();\n        byte[] keyBytes = new byte[] { 0x00, 0x01, 0x02, 0x03, 0x04, 0x05, 0x06, 0x07, 0x08, 0x09,\n            0x0a, 0x0b, 0x0c, 0x0d, 0x0e, 0x0f, 0x10, 0x11, 0x12, 0x13, 0x14, 0x15, 0x16, 0x17 };\n\n        SecretKeySpec key = new SecretKeySpec(keyBytes, \"AES\");\n        Cipher cipher = Cipher.getInstance(\"AES/ECB/PKCS5Padding\");\n        System.out.println(new String(input));\n\n        // encryption pass\n        cipher.init(Cipher.ENCRYPT_MODE, key);\n\n        byte[] cipherText = new byte[cipher.getOutputSize(input.length)];\n        int ctLength = cipher.update(input, 0, input.length, cipherText, 0);\n        ctLength += cipher.doFinal(cipherText, ctLength);\n        System.out.println(new String(cipherText));\n        System.out.println(ctLength);\n\n        // decryption pass\n        cipher.init(Cipher.DECRYPT_MODE, key);\n        byte[] plainText = new byte[cipher.getOutputSize(ctLength)];\n        int ptLength = cipher.update(cipherText, 0, ctLength, plainText, 0);\n        ptLength += cipher.doFinal(plainText, ptLength);\n        System.out.println(new String(plainText));\n        System.out.println(ptLength);\n      }\n    }   \n", "idx": 1952}
{"project": "cipher", "commit_id": "Snippet42956231_25083.java", "target": 0, "func": "public static byte[] encryptWithAES(byte[] message, Key AESkey) throws Exception {\nbyte[] decryptedMessage = null;\ntry {\n    Cipher encrypt = Cipher.getInstance(\"AES/ECB/PKCS5Padding\"); // here is the change\n    encrypt.init(Cipher.ENCRYPT_MODE, AESkey);\n    decryptedMessage = encrypt.doFinal(message);\n} catch (Exception ex) {\n    System.err.println(ex.getMessage());\n    throw ex;\n}\nreturn decryptedMessage;\n}\n", "idx": 2226}
{"project": "cipher", "commit_id": "Snippet38633402_20560.java", "target": 0, "func": "import java.security.Key;\nimport javax.crypto.Cipher;\nimport javax.crypto.spec.SecretKeySpec;\nimport sun.misc.BASE64Decoder;\nimport sun.misc.BASE64Encoder;\n\npublic class EncryptDecryptAESAlgo {\n    private static final String ALGO = \"AES\";\n    private static final byte[] keyValue = new byte[] { 'A', 'b', 'c', 'd', 'e', 'f', 'g', 'h', 'i', 'j', 'k', 'l', 'm',\n            'n', 'o', 'p' };\n\n    public String encrypt(String Data) throws Exception {\n        String encryptedValue = \"\";\n        try {\n            Key key = generateKey();\n            Cipher c = Cipher.getInstance(ALGO);\n            c.init(Cipher.ENCRYPT_MODE, key);\n            byte[] encVal = c.doFinal(Data.getBytes());\n            encryptedValue = new BASE64Encoder().encode(encVal);\n            return encryptedValue;\n        } catch (Exception e) {\n        }\n        return encryptedValue;\n    }\n\n    public String decrypt(String encryptedData) throws Exception {\n        String decryptedValue = \"\";\n        try {\n            Key key = generateKey();\n            Cipher c = Cipher.getInstance(ALGO);\n            c.init(Cipher.DECRYPT_MODE, key);\n            byte[] decordedValue = new BASE64Decoder().decodeBuffer(encryptedData);\n            byte[] decValue = c.doFinal(decordedValue);\n            decryptedValue = new String(decValue);\n            return decryptedValue;\n        } catch (Exception e) {\n        }\n        return decryptedValue;\n    }\n\n    private Key generateKey() throws Exception {\n        Key key = new SecretKeySpec(keyValue, ALGO);\n        return key;\n    }\n}\n", "idx": 2067}
{"project": "cipher", "commit_id": "Snippet35873174_17746.java", "target": 1, "func": "static final String RSA_ALGO = \"RSA/ECB/PKCS1Padding\";\n//  static final String RSA_ALGO = \"RSA\";\n\nprivate void _testCrypto2() throws Exception {\n  KeyPairGenerator keyGen;\n  KeyPair          keys;\n  byte[]           encrypted;\n  byte[]           decrypted;\n  String           input;\n  String           output;\n\n  keyGen = KeyPairGenerator.getInstance(\"RSA\");\n  keyGen.initialize(2048);\n  keys = keyGen.generateKeyPair();\n\n  input = \"foobar\";\n\n  // Plain crypto.\n  encrypted = this.RSAEncrypt(input, keys.getPublic());\n  output    = this.RSADecrypt(encrypted, keys.getPrivate());\n\n  // Streaming crypto.\n  encrypted = this.RSAEncryptStream(input, keys.getPublic());\n  output    = this.RSADecryptStream(encrypted, keys.getPrivate());\n}\n\npublic byte[] RSAEncrypt(final String plain, PublicKey _publicKey) throws Exception {\n  byte[] encryptedBytes;\n  Cipher cipher;\n\n  cipher = Cipher.getInstance(RSA_ALGO);\n  cipher.init(Cipher.ENCRYPT_MODE, _publicKey);\n  encryptedBytes = cipher.doFinal(plain.getBytes());\n\n  return encryptedBytes;\n}\n\npublic String RSADecrypt(final byte[] encryptedBytes, PrivateKey _privateKey) throws Exception {\n  Cipher cipher;\n  byte[] decryptedBytes;\n  String decrypted;\n\n  cipher = Cipher.getInstance(RSA_ALGO);\n  cipher.init(Cipher.DECRYPT_MODE, _privateKey);\n\n  decryptedBytes = cipher.doFinal(encryptedBytes);\n  decrypted      = new String(decryptedBytes);\n\n  return decrypted;\n}\n\npublic byte[] RSAEncryptStream(final String _plain, PublicKey _publicKey) throws Exception {\n  Cipher                cipher;\n  InputStream           in;\n  ByteArrayOutputStream out;\n  int                   numBytes;\n  byte                  buffer[] = new byte[0xffff];\n\n  in     = new ByteArrayInputStream(_plain.getBytes());\n  out    = new ByteArrayOutputStream();\n  cipher = Cipher.getInstance(RSA_ALGO);\n  cipher.init(Cipher.ENCRYPT_MODE, _publicKey);\n\n  try {\n    in = new CipherInputStream(in, cipher);\n    while ((numBytes = in.read(buffer)) != -1) {\n      out.write(buffer, 0, numBytes);\n    }\n  }\n  finally {\n    in.close();\n  }\n\n  return out.toByteArray();\n}\n\npublic String RSADecryptStream(final byte[] _encryptedBytes, PrivateKey _privateKey) throws Exception {\n  Cipher                cipher;\n  InputStream           in;\n  ByteArrayOutputStream out;\n  int                   numBytes;\n  byte                  buffer[] = new byte[0xffff];\n\n  in     = new ByteArrayInputStream(_encryptedBytes);\n  out    = new ByteArrayOutputStream();  \n  cipher = Cipher.getInstance(RSA_ALGO);\n  cipher.init(Cipher.DECRYPT_MODE, _privateKey);\n\n  try {\n    in = new CipherInputStream(in, cipher);\n    while ((numBytes = in.read(buffer)) != -1) {\n      out.write(buffer, 0, numBytes);\n    }\n  }\n  finally {\n    in.close();\n  }\n\n  return new String(out.toByteArray());\n}\n", "idx": 2384}
{"project": "cipher", "commit_id": "Snippet20737376_3322.java", "target": 0, "func": "        FileInputStream  file = new FileInputStream(\"src/image/A.jpg\");\n        FileOutputStream output = new FileOutputStream(\"src/image/AA.jpg\");\n        byte j[]=\"12345678\".getBytes();\n        SecretKeySpec kye = new SecretKeySpec(j,\"DES\");\n        System.out.println(kye);\n        Cipher enc = Cipher.getInstance(\"DES\");\n        enc.init(Cipher.ENCRYPT_MODE,kye);\n        CipherOutputStream cos = new CipherOutputStream(output, enc);\n        byte[] buf = new byte[1024];\n        int read;\n        while((read=file.read(buf))!=-1){\n            cos.write(buf,0,read);\n        }\n        file.close();\n        output.flush();\n        cos.close();\n", "idx": 2047}
{"project": "cipher", "commit_id": "Snippet7977008_33011.java", "target": 0, "func": " public static String encrypt( String content, String password ) throws NoSuchAlgorithmException,\n    NoSuchPaddingException, UnsupportedEncodingException, InvalidKeyException, IllegalBlockSizeException,\n    BadPaddingException\n{\n    KeyGenerator kgen = KeyGenerator.getInstance( \"AES\" );\n    kgen.init( 128, new SecureRandom( password.getBytes() ) );\n    SecretKey secretKey = kgen.generateKey();\n    byte[] enCodeFormat = secretKey.getEncoded();\n    SecretKeySpec key = new SecretKeySpec( enCodeFormat, \"AES\" );\n    Cipher cipher = Cipher.getInstance( \"AES\" );\n    byte[] byteContent = content.getBytes( \"utf-8\" );\n    cipher.init( Cipher.ENCRYPT_MODE, key );\n    byte[] result = cipher.doFinal( byteContent );\n    return parseByte2HexStr( result );\n}\n\n\npublic static String decrypt( String contents, String password ) throws NoSuchAlgorithmException,\n    NoSuchPaddingException, InvalidKeyException, IllegalBlockSizeException, BadPaddingException\n{\n    byte[] content = parseHexStr2Byte( contents );\n    KeyGenerator kgen = KeyGenerator.getInstance( \"AES\" );\n    kgen.init( 128, new SecureRandom( password.getBytes() ) );\n    SecretKey secretKey = kgen.generateKey();\n    byte[] enCodeFormat = secretKey.getEncoded();\n    SecretKeySpec key = new SecretKeySpec( enCodeFormat, \"AES\" );\n    Cipher cipher = Cipher.getInstance( \"AES\" );  \n    cipher.init( Cipher.DECRYPT_MODE, key );\n    byte[] result = cipher.doFinal( content );\n    return new String( result ); \n}\n\n\npublic static String parseByte2HexStr( byte buf[] )\n{\n    StringBuffer sb = new StringBuffer();\n    for( int i = 0; i < buf.length; i++ )\n    {\n        String hex = Integer.toHexString( buf[i] & 0xFF );\n        if( hex.length() == 1 )\n        {\n            hex = '0' + hex;\n        }\n        sb.append( hex.toUpperCase() );\n    }\n    return sb.toString();\n}\n\n\npublic static byte[] parseHexStr2Byte( String hexStr )\n{\n    if( hexStr.length() < 1 )\n        return null;\n    byte[] result = new byte[ hexStr.length() / 2 ];\n    for( int i = 0; i < hexStr.length() / 2; i++ )\n    {\n        int high = Integer.parseInt( hexStr.substring( i * 2, i * 2 + 1 ), 16 );\n        int low = Integer.parseInt( hexStr.substring( i * 2 + 1, i * 2 + 2 ), 16 );\n        result[i] = ( byte ) ( high * 16 + low );\n    }\n    return result;\n}\n", "idx": 2244}
{"project": "cipher", "commit_id": "Snippet13973662_37402.java", "target": 0, "func": "SecretKeyFactory kf = SecretKeyFactory.getInstance(\"DES\");\nString key = \"abcdefg\";\nDESKeySpec keySpec = new DESKeySpec(key.getBytes());\nSecretKey _key = kf.generateSecret(keySpec);\nString xform = \"DES\";\nCipher cipher = Cipher.getInstance(xform);\nbyte[] IV = { 11, 22, 33, 44, 55, 66, 77, 88, 99, 18, 69, 17, 72, 94, 18, 30 };\nIvParameterSpec ips = new IvParameterSpec(IV);\ncipher.init(Cipher.ENCRYPT_MODE, _key, ips);\nString plainText = \"abcdeffdkflsdkf\";\nbyte[] cipherText = cipher.doFinal(plainText.getBytes());\n", "idx": 1959}
{"project": "cipher", "commit_id": "Snippet25225514_7590.java", "target": 1, "func": "import java.io.FileInputStream;\nimport java.io.FileOutputStream;\nimport java.io.InputStream;\nimport java.io.OutputStream;\nimport java.security.MessageDigest;\nimport java.security.SecureRandom;\nimport java.util.Arrays;\n\nimport javax.crypto.Cipher;\nimport javax.crypto.CipherInputStream;\nimport javax.crypto.CipherOutputStream;\nimport javax.crypto.spec.SecretKeySpec;\n\n\npublic class AES {\nprivate String algo;\n private String path;\n private String password;\n public AES(String algo,String path, String password) {\n     this.algo = algo; //setting algo\n     this.path = path;//setting file path\n     this.password = password;\n    }\n\n    public void encrypt() throws Exception{\n     SecureRandom padding = new SecureRandom();\n     byte[] salt = new byte[16];\n     padding.nextBytes(salt);\n         //generating key\n     byte k[] = (password+salt).getBytes(\"UTF-8\");  \n     MessageDigest sha = MessageDigest.getInstance(\"SHA-1\");\n     k = sha.digest(k);\n     k = Arrays.copyOf(k, 16);  \n     for(int i=0;i<k.length;i++) System.out.print(k[i]);\n         SecretKeySpec key = new SecretKeySpec(k,algo);  \n         //creating and initialising cipher and cipher streams\n         Cipher encrypt =  Cipher.getInstance(algo);  \n         encrypt.init(Cipher.ENCRYPT_MODE, key);\n         //opening streams\n         FileOutputStream fos =new FileOutputStream(path+\".enc\");\n         try(FileInputStream fis =new FileInputStream(path)){\n            try(CipherOutputStream cout=new CipherOutputStream(fos, encrypt)){\n                copy(fis,cout);\n            }\n         }\n     }\n\n     public void decrypt() throws Exception{\n     SecureRandom padding = new SecureRandom();\n     byte[] salt = new byte[16];\n     padding.nextBytes(salt);\n         //generating same key\n      byte k[] = (password+salt).getBytes(\"UTF-8\");  \n     MessageDigest sha = MessageDigest.getInstance(\"SHA-1\");\n     k = sha.digest(k);\n     k = Arrays.copyOf(k, 16); \n      for(int i=0;i<k.length;i++) System.out.print(k[i]);\n         SecretKeySpec key = new SecretKeySpec(k,algo);  \n         //creating and initialising cipher and cipher streams\n         Cipher decrypt =  Cipher.getInstance(algo);  \n         decrypt.init(Cipher.DECRYPT_MODE, key);\n         //opening streams\n         FileInputStream fis = new FileInputStream(path);\n         try(CipherInputStream cin=new CipherInputStream(fis, decrypt)){  \n            try(FileOutputStream fos =new FileOutputStream(path.substring(0,path.lastIndexOf(\".\")))){\n               copy(cin,fos);\n           }\n         }\n      }\n\n  private void copy(InputStream is,OutputStream os) throws Exception{\n     byte buf[] = new byte[4096];  //4K buffer set\n     int read = 0;\n     while((read = is.read(buf)) != -1)  //reading\n        os.write(buf,0,read);  //writing\n  }\n\n}\n", "idx": 2388}
{"project": "cipher", "commit_id": "Snippet24807123_7131.java", "target": 0, "func": " byte key_bytes[] = \"12345678\".getBytes();\n SecretKeySpec _keyspec = new SecretKeySpec(key_bytes, \"DES\");\n Cipher cipher = Cipher.getInstance(\"DES/ECB/PKCS5Padding\"); // Yes, I know I shouldn't use DES\n cipher.init(Cipher.ENCRYPT_MODE, _keyspec);\n\n byte[] utf8 = value.getBytes(\"UTF8\");\n byte[] enc = cipher.doFinal(utf8);   // Encrypt\n\n String encrypted = new String(new Base64().encode(enc));\n\n return URLEncoder.encode(encrypted, \"UTF-8\");\n", "idx": 2128}
{"project": "cipher", "commit_id": "Snippet26182593_8406.java", "target": 1, "func": "public static SecretKeySpec generateKey(char[] password, byte[] salt) throws Exception {\n        SecretKeyFactory factory = SecretKeyFactory.getInstance(\"PBKDF2WithHmacSHA1\");\n        KeySpec spec = new PBEKeySpec(password, salt, 1024, 128);\n        SecretKey tmp = factory.generateSecret(spec);\n        SecretKeySpec secret = new SecretKeySpec(tmp.getEncoded(), \"AES\");\n        return secret;\n    }\n\npublic static Map encrypt(String cleartext, byte[] iv, SecretKeySpec secret) throws Exception {\n    Cipher cipher = Cipher.getInstance(\"AES/CBC/PKCS5Padding\");\n    // If the IvParameterSpec argument is omitted (null), a new IV will be\n    // created\n    cipher.init(Cipher.ENCRYPT_MODE, secret, iv == null ? null : new IvParameterSpec(iv));\n    AlgorithmParameters params = cipher.getParameters();\n    byte[] usediv = params.getParameterSpec(IvParameterSpec.class).getIV();\n    byte[] ciphertext = cipher.doFinal(cleartext.getBytes(\"UTF-8\"));\n    Map result = new HashMap();\n    result.put(IV, usediv);\n    result.put(CIPHERTEXT, ciphertext);\n    return result;\n}\n\n\npublic static String decrypt(byte[] ciphertext, byte[] iv, SecretKeySpec secret) throws Exception {\n    Cipher cipher = Cipher.getInstance(\"AES/CBC/NoPadding\");\n    cipher.init(Cipher.DECRYPT_MODE, secret, new IvParameterSpec(iv));\n    String plaintext = new String(cipher.doFinal(ciphertext), \"UTF-8\");\n    return plaintext;\n}\n\npublic static void main(String arg) throws Exception {\n    byte[] salt = new byte[] { -11, 84, 126, 65, -87, -104, 120, 33, -89, 19, 57, -6, -27, -19, -101, 107 };\n\n\n\n    byte[] interop_iv = Base64.decode(\"xxxxxxxxxxxxxxx==\", Base64.DEFAULT);\n    byte[] iv = null;\n    byte[] ciphertext;\n    SecretKeySpec secret; \n    secret = generateKey(\"xxxxxxxxxxxxxxx\".toCharArray(), salt);\n    Map result = encrypt(arg, iv, secret);\n    ciphertext = (byte[]) result.get(CIPHERTEXT);\n    iv = (byte[]) result.get(IV);\n    System.out.println(\"Cipher text:\" + Base64.encode(ciphertext, Base64.DEFAULT));\n    System.out.println(\"IV:\" + Base64.encode(iv, Base64.DEFAULT) + \" (\" + iv.length + \"bytes)\");\n    System.out.println(\"Key:\" + Base64.encode(secret.getEncoded(), Base64.DEFAULT));\n    System.out.println(\"Deciphered: \" + decrypt(ciphertext, iv, secret));\n\n    // Interop demonstration. Using a fixed IV that is used in the C#\n    // example\n    result = encrypt(arg, interop_iv, secret);\n    ciphertext = (byte[]) result.get(CIPHERTEXT);\n    iv = (byte[]) result.get(IV);\n\n    String text = Base64.encodeToString(ciphertext, Base64.DEFAULT);\n\n    System.out.println();\n    System.out.println(\"--------------------------------\");\n    System.out.println(\"Interop test - using a static IV\");\n    System.out.println(\"The data below should be used to retrieve the secret message by the receiver\");\n    System.out.println(\"Cipher text:  \" + text);\n    System.out.println(\"IV:           \" + Base64.encodeToString(iv, Base64.DEFAULT));\n    decrypt(Base64.decode(text, Base64.DEFAULT), iv, secret);\n}\n", "idx": 2464}
{"project": "cipher", "commit_id": "Snippet46988906_28991.java", "target": 1, "func": "\n\n    import javax.crypto.BadPaddingException;\n    import javax.crypto.Cipher;\n    import javax.crypto.IllegalBlockSizeException;\n    import javax.crypto.NoSuchPaddingException;\n    import javax.crypto.spec.IvParameterSpec;\n    import javax.crypto.spec.SecretKeySpec;\n\n    import java.security.InvalidKeyException;\n    import java.security.NoSuchAlgorithmException;\n    import java.security.InvalidAlgorithmParameterException;\n    import java.security.spec.AlgorithmParameterSpec;\n\n    public class AES256Cipher {\n\n        public static byte[] encrypt(byte[] ivBytes, byte[] keyBytes, byte[] textBytes) \n                throws java.io.UnsupportedEncodingException, \n                    NoSuchAlgorithmException,\n                    NoSuchPaddingException,\n                    InvalidKeyException,\n                    InvalidAlgorithmParameterException,\n                    IllegalBlockSizeException,\n                    BadPaddingException {\n\n            AlgorithmParameterSpec ivSpec = new IvParameterSpec(ivBytes);\n            SecretKeySpec newKey = new SecretKeySpec(keyBytes, \"AES\");\n            Cipher cipher = null;\n            cipher = Cipher.getInstance(\"AES/CBC/PKCS5Padding\");\n            cipher.init(Cipher.ENCRYPT_MODE, newKey, ivSpec);\n            return cipher.doFinal(textBytes);\n        }\n\n        public static byte[] decrypt(byte[] ivBytes, byte[] keyBytes, byte[] textBytes) \n                throws java.io.UnsupportedEncodingException, \n                NoSuchAlgorithmException,\n                NoSuchPaddingException,\n                InvalidKeyException,\n                InvalidAlgorithmParameterException,\n                IllegalBlockSizeException,\n                BadPaddingException {\n\n            AlgorithmParameterSpec ivSpec = new IvParameterSpec(ivBytes);\n            SecretKeySpec newKey = new SecretKeySpec(keyBytes, \"AES\");\n            Cipher cipher = Cipher.getInstance(\"AES/CBC/PKCS5Padding\");\n            cipher.init(Cipher.DECRYPT_MODE, newKey, ivSpec);\n            return cipher.doFinal(textBytes);\n        }\n    }\n\n", "idx": 2577}
{"project": "cipher", "commit_id": "Snippet5113498_31467.java", "target": 1, "func": "Cipher cipher = Cipher.getInstance(\"RSA/NONE/OAEPWithSHA1AndMGF1Padding\", \"BC\");\ncipher.init(Cipher.DECRYPT_MODE, keyPair.getPrivate());\nbyte[] cipherText = ...;\nbyte[] plainText = cipher.doFinal(cipherText);\n", "idx": 2405}
{"project": "cipher", "commit_id": "Snippet14936809_38008.java", "target": 0, "func": "public static String encrypt(String toEncrypt, byte[ ] key) throws Exception {\n    SecretKeySpec skeySpec = new SecretKeySpec(key, \"AES\");\n    Cipher cipher = Cipher.getInstance(\"AES\");\n    cipher.init(Cipher.ENCRYPT_MODE, skeySpec);\n    byte[ ] encryptedBytes = cipher.doFinal(toEncrypt.getBytes());\n    String encrypted = Base64.encodeBytes(encryptedBytes);\n    return encrypted;\n}\n\npublic static String decrypt(String encryptedText, byte[ ] key) throws Exception {\n    SecretKeySpec skeySpec = new SecretKeySpec(key, \"AES\");\n    Cipher cipher = Cipher.getInstance(\"AES\");\n    cipher.init(Cipher.DECRYPT_MODE, skeySpec);\n    byte[] toDecrypt = Base64.decode(encryptedText);\n    byte[] encrypted = cipher.doFinal(toDecrypt);\n    return new String(encrypted);\n}\n", "idx": 2173}
{"project": "cipher", "commit_id": "Snippet31497147_13654.java", "target": 1, "func": "private static final String truc = \"f41a3ff27aab7d5c\";\n\n\npublic static String encryptPass(String pass,String key) throws NoSuchPaddingException, NoSuchAlgorithmException, InvalidKeyException, BadPaddingException, IllegalBlockSizeException, UnsupportedEncodingException, InvalidAlgorithmParameterException {\n        MessageDigest md = MessageDigest.getInstance(\"SHA-256\");\n        md.update(key.getBytes(\"UTF-8\"));\n        byte[] digest = md.digest();\n        BCrypt bcrypt = new BCrypt();\n        SecretKey keyL =  new SecretKeySpec(digest, \"AES\");\n\n        Cipher AesCipher = Cipher.getInstance(\"AES/CTR/NoPadding\");\n        AesCipher.init(Cipher.ENCRYPT_MODE, keyL, new IvParameterSpec(truc.getBytes()));\n        byte[] encVal = AesCipher.doFinal(pass.getBytes());\n        pass = Base64.encodeToString(encVal, Base64.DEFAULT);\n\n        Log.i(\"ADA\", \"encoded pass: \" + pass);\n\n        return pass;\n    }\n\n    public static String decryptPass(String encPass , String key) throws NoSuchAlgorithmException, UnsupportedEncodingException, NoSuchPaddingException, InvalidKeyException, BadPaddingException, IllegalBlockSizeException, InvalidAlgorithmParameterException {\n        MessageDigest md = MessageDigest.getInstance(\"SHA-256\");\n        md.update(key.getBytes(\"UTF-8\"));\n        byte[] digest = md.digest();\n\n        SecretKey keyL =  new SecretKeySpec(digest, \"AES\");\n        Cipher AesCipher = Cipher.getInstance(\"AES/CTR/NoPadding\");\n        AesCipher.init(Cipher.DECRYPT_MODE, keyL, new IvParameterSpec(truc.getBytes()));\n        byte[] decodedValue = Base64.decode(encPass, Base64.DEFAULT);\n        byte[] decValue = AesCipher.doFinal(decodedValue);\n        String decryptedValue = new String(decValue);\n        Log.i(\"ADA\", \"decrpyted pass: \" + decryptedValue);\n\n        return decryptedValue;\n    }\n", "idx": 2660}
{"project": "cipher", "commit_id": "Snippet17820910_681.java", "target": 1, "func": "Cipher.getInstance(\"RSA/ECB/PKCS1Padding\")", "idx": 2592}
{"project": "cipher", "commit_id": "Snippet43456590_25572.java", "target": 0, "func": "public class EncryptionDecrption {\n\n    private static final String ALGO = \"AES\";\n    private static final byte[] keyValue = new byte[]{'T', 'h', 'e', 'R', 'o', 'o', 'K', 'n', 'a', 't','E','n', 'i', 'r','i','n'};\n\n    public EncryptionDecrption(){\n\n    }\n\n    public static String setEncryptedString(String data) throws Exception {\n        Key key = getKey();\n        Cipher cipher = Cipher.getInstance(ALGO);\n        cipher.init(Cipher.ENCRYPT_MODE, key);\n        byte[] encryptedValue = cipher.doFinal(data.getBytes(\"UTF-8\"));\n\n        return Base64.encodeToString(encryptedValue, Base64.DEFAULT);\n    }\n\n    public static String getDecryptedValue(String data) throws Exception {\n\n        if(data != null) {\n            Key key = getKey();\n            Cipher cipher = Cipher.getInstance(ALGO);\n            cipher.init(Cipher.DECRYPT_MODE, key);\n            byte[] decodebyte = Base64.decode(data.getBytes(\"UTF-8\"), Base64.DEFAULT);\n            byte[] decValue = cipher.doFinal(decodebyte);\n\n            return new String(decValue);\n        }\n\n        return null;\n    }\n\n    private static Key getKey() throws Exception {\n        return new SecretKeySpec(keyValue, ALGO);\n    }\n}\n", "idx": 1918}
{"project": "cipher", "commit_id": "Snippet32077760_14140.java", "target": 0, "func": "Cipher.getInstance(\"AES\")", "idx": 2055}
{"project": "cipher", "commit_id": "Snippet46355308_28459.java", "target": 1, "func": "\n\npublic class EncryptionUtil {\n\n    private static final Log LOGGER = LogFactory.getLog(EncryptionUtil.class);\n    private static final String CIPHER_MODE = \"AES/CBC/PKCS5PADDING\";\n    private static final String CRYPTO_PROPERTIES_PATH = \"/crypto.properties\";\n    private static final SecretKeySpec sKey = keySpecFromProperties();\n\n    private EncryptionUtil() {}\n\n    public static byte[] encrypt(byte[] aBytes) {\n         try {\n            SecureRandom lSecureRandom = new SecureRandom();\n            byte[] ivBytes = new byte[16];\n            lSecureRandom.nextBytes(ivBytes);\n            IvParameterSpec lSpec = new IvParameterSpec(ivBytes);\n            Cipher cipher = Cipher.getInstance(CIPHER_MODE);\n            cipher.init(Cipher.ENCRYPT_MODE, sKey, lSpec);\n            byte[] encryptedBytes = cipher.doFinal(aBytes);\n            byte[] outBytes = new byte[encryptedBytes.length + 16];\n            System.arraycopy(ivBytes, 0, outBytes, 0, 16);\n            System.arraycopy(encryptedBytes, 0, outBytes, 16, encryptedBytes.length);\n\n            return outBytes;\n        } catch (Exception aEx) {\n            LOGGER.error(\"Failed to encrypt bytes\");\n            throw new RuntimeException(aEx);\n        }\n    }\n\n    public static byte[] decrypt(byte[] aBytes) {\n        try {\n            byte[] lIvBytes = Arrays.copyOfRange(aBytes, aBytes.length - 16, aBytes.length);\n            byte[] lEncryptedBytes = Arrays.copyOfRange(aBytes, 0, aBytes.length - 16);\n            IvParameterSpec lIvSpec = new IvParameterSpec(lIvBytes);\n            Cipher cipher = Cipher.getInstance(CIPHER_MODE);\n            cipher.init(Cipher.DECRYPT_MODE, sKey, lIvSpec);\n            return cipher.doFinal(lEncryptedBytes);\n        }catch (Exception aEx){\n            LOGGER.error(\"Failed to decrypt bytes. Returning input bytes\", aEx);\n            return aBytes;\n        }\n    }\n\n    private static SecretKeySpec keySpecFromProperties(){\n        try(InputStream lPropStream = EncryptionUtil.class.getResourceAsStream(CRYPTO_PROPERTIES_PATH)){\n            Properties cryptoProps = new Properties();\n            cryptoProps.load(lPropStream);\n            String lSecret = cryptoProps.getProperty(\"secret\");\n            MessageDigest digest = MessageDigest.getInstance(\"SHA-256\");\n            digest.update(lSecret.getBytes(\"UTF-8\"));\n            byte[] keyBytes = new byte[16];\n            System.arraycopy(digest.digest(),0, keyBytes, 0, keyBytes.length);\n            return new SecretKeySpec(keyBytes, \"AES\");\n        } catch (Exception e) {\n            throw new RuntimeException(e);\n        }\n    }\n}\n", "idx": 2567}
{"project": "cipher", "commit_id": "Snippet27746249_9918.java", "target": 0, "func": "import java.security.spec.KeySpec;\n\n\nimport javax.crypto.Cipher;\nimport javax.crypto.SecretKey;\nimport javax.crypto.SecretKeyFactory;\nimport javax.crypto.spec.DESKeySpec;\nimport sun.misc.BASE64Decoder;\nimport sun.misc.BASE64Encoder;\n\npublic class DESEncryption {\n\nprivate static final String UNICODE_FORMAT = \"UTF8\";\npublic static final String DES_ENCRYPTION_SCHEME = \"DES\";\nprivate KeySpec myKeySpec;\nprivate SecretKeyFactory mySecretKeyFactory;\nprivate Cipher cipher;\nbyte[] keyAsBytes;\nprivate String myEncryptionKey;\nprivate String myEncryptionScheme;\nSecretKey key;\n\npublic DESEncryption() throws Exception\n{\n    myEncryptionKey = \"ThisIsSecretEncryptionKey\";\n    myEncryptionScheme = DES_ENCRYPTION_SCHEME;\n    keyAsBytes = myEncryptionKey.getBytes(UNICODE_FORMAT);\n    myKeySpec = new DESKeySpec(keyAsBytes);\n    mySecretKeyFactory = SecretKeyFactory.getInstance(myEncryptionScheme);\n    cipher = Cipher.getInstance(myEncryptionScheme);\n    key = mySecretKeyFactory.generateSecret(myKeySpec);\n}\n\n/**\n * <span class=\"IL_AD\" id=\"IL_AD2\">Method</span> To Encrypt The String\n */\npublic String encrypt(String unencryptedString) {\n    String encryptedString = null;\n    try {\n        cipher.init(Cipher.ENCRYPT_MODE, key);\n        byte[] plainText = unencryptedString.getBytes(UNICODE_FORMAT);\n        byte[] encryptedText = cipher.doFinal(plainText);\n        BASE64Encoder base64encoder = new BASE64Encoder();\n        encryptedString = base64encoder.encode(encryptedText);\n    } catch (Exception e) {\n        e.printStackTrace();\n    }\n    return encryptedString;\n}\n/**\n * Method To Decrypt An Ecrypted String\n */\npublic String decrypt(String encryptedString) {\n    String decryptedText=null;\n    try {\n        cipher.init(Cipher.DECRYPT_MODE, key);\n        BASE64Decoder base64decoder = new BASE64Decoder();\n        byte[] encryptedText = base64decoder.decodeBuffer(encryptedString);\n        byte[] plainText = cipher.doFinal(encryptedText);\n        decryptedText= bytes2String(plainText);\n    } catch (Exception e) {\n        e.printStackTrace();\n    }\n    return decryptedText;\n}\n/**\n * Returns String From An Array Of Bytes\n */\nprivate static String bytes2String(byte[] bytes) {\n    StringBuffer stringBuffer = new StringBuffer();\n    for (int i = 0; i < bytes.length; i++) {\n        stringBuffer.append((char) bytes[i]);\n    }\n    return stringBuffer.toString();\n}\n\n/**\n * Testing the DES Encryption And Decryption Technique\n */\npublic static void main(String args []) throws Exception\n{\n    DESEncryption myEncryptor= new DESEncryption();\n\n    String stringToEncrypt=\"Sanjaal.com\";\n    String encrypted=myEncryptor.encrypt(stringToEncrypt);\n    String decrypted=myEncryptor.decrypt(encrypted);\n\n    System.out.println(\"String To Encrypt: \"+stringToEncrypt);\n    System.out.println(\"Encrypted Value : \" + encrypted);\n    System.out.println(\"Decrypted Value : \"+decrypted);\n\n}   \n\n}\n", "idx": 2210}
{"project": "cipher", "commit_id": "Snippet6669812_32279.java", "target": 1, "func": "    public class KeyHandler {\n\n    Scanner scan = new Scanner(System.in);\n\n    public KeyHandler() {\n        try {\n            startMenu();\n        } catch (Exception e) {\n            System.out.println(\"fel n\u00e5gonstanns :)\");\n        }\n    }\n\n    public void startMenu() throws Exception {\n\n        System.out.println(\"Hej. Med detta program kan du generera en hemlig nyckel\" + \"\\n\" + \"Vill du:\" + \"\\n\" + \"1. Generera en nyckel\" + \"\\n\" + \"2. Avsluta\");\n        int val = Integer.parseInt(scan.nextLine());\n        do {\n            switch (val) {\n                case 1:\n                    generateKey();\n                    break;\n                case 2:\n                    System.exit(1);\n\n                default:\n                    System.out.println(\"Du m\u00e5ste v\u00e4lja val 1 eller 2\");\n            }\n        } while (val != 3);\n    }\n\n    public void generateKey() throws Exception {\n        try {\n            KeyGenerator gen = KeyGenerator.getInstance(\"AES\");\n            gen.init(128);\n\n            SecretKey key = gen.generateKey();\n            byte[] keyBytes = key.getEncoded();\n            System.out.print(\"Ge nyckeln ett filnamn: \");\n            String filename = scan.next();\n            System.out.println(\"Genererar nyckeln...\");\n            FileOutputStream fileOut = new FileOutputStream(filename);\n            fileOut.write(keyBytes);\n            fileOut.close();\n            System.out.println(\"Nyckeln \u00e4r genererad med filnamnet: \" + filename + \"...\");\n            System.exit(1);\n        } catch (NoSuchAlgorithmException e) {\n        }\n\n    }\n\n    public static void main(String[] args) {\n        new KeyHandler();\n    }\n}\n\npublic class EncryptHandler {\n\n    private String encryptedDataString;\n    private Cipher ecipher;\n    AlgorithmParameterSpec paramSpec;\n    byte[] iv;\n\n    public EncryptHandler(String dataString, String secretKey, String encryptedDataString) {\n        this.encryptedDataString = encryptedDataString;\n        try {\n            encryptFile(dataString, secretKey);\n        } catch (Exception e) {\n        }\n    }\n\n    public void encryptFile(String dataString, String secretKey) throws Exception {\n\n        FileInputStream fis = new FileInputStream(secretKey);\n        ByteArrayOutputStream baos = new ByteArrayOutputStream();\n\n        int theByte = 0;\n        while ((theByte = fis.read()) != -1) {\n            baos.write(theByte);\n        }\n        fis.close();\n\n        byte[] keyBytes = baos.toByteArray();\n        baos.close();\n        SecretKeySpec keySpec = new SecretKeySpec(keyBytes, \"AES\");\n\n        // build the initialization vector.  This example is all zeros, but it \n        // could be any value or generated using a random number generator.\n        byte[] iv = { 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0 };\n        IvParameterSpec ivspec = new IvParameterSpec(iv);\n\n        try {\n            ecipher = Cipher.getInstance(\"AES/CBC/PKCS5Padding\");\n            ecipher.init(Cipher.ENCRYPT_MODE, keySpec, ivspec);\n\n        } catch (Exception e) {\n            e.printStackTrace();\n        }\n\n        System.out.println(\"Encrypting file...\");\n        try {\n\n            encryptStream(new FileInputStream(dataString), new FileOutputStream(encryptedDataString));\n        } catch (Exception e) {\n            e.printStackTrace();\n        }\n\n    }\n\n    public void encryptStream(InputStream in, OutputStream out) {\n        ByteArrayOutputStream bOut = new ByteArrayOutputStream();\n        byte[] buf = new byte[1024];\n        try {\n            out = new CipherOutputStream(out, ecipher);\n\n            // read the cleartext and write it to out\n            int numRead = 0;\n            while ((numRead = in.read(buf)) >= 0) {\n                out.write(buf, 0, numRead);\n\n            }\n            bOut.writeTo(out);\n            out.close();\n            bOut.reset();\n\n        } catch (java.io.IOException e) {\n        }\n\n    }\n\n    public static void main(String[] args) {\n        String data = \"test.txt\";\n        String keyFileName = \"a\";\n        String encryptedFile = \"krypterad.txt\";\n        //String encryptedFile =args[2];\n        new EncryptHandler(data, keyFileName, encryptedFile);\n    }\n}\n\npublic class DecryptHandler {\n\n    public DecryptHandler() {\n\n        try {\n            decryptFile();\n        } catch (Exception e) {\n            e.printStackTrace();\n            System.out.println(\"n\u00e5got gick fel :) \");\n        }\n    }\n\n    public void decryptFile() throws Exception {\n        byte[] buf = new byte[1024];\n        String keyFilename = \"hemlig\";\n        FileInputStream fis = new FileInputStream(keyFilename);\n        ByteArrayOutputStream baos = new ByteArrayOutputStream();\n\n        int theByte = 0;\n        while ((theByte = fis.read()) != -1) {\n            baos.write(theByte);\n        }\n        fis.close();\n\n        byte[] keyBytes = baos.toByteArray();\n        baos.close();\n        SecretKeySpec keySpec = new SecretKeySpec(keyBytes, \"AES\");\n\n        // build the initialization vector.  This example is all zeros, but it \n        // could be any value or generated using a random number generator.\n        byte[] iv = { 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0 };\n        IvParameterSpec ivspec = new IvParameterSpec(iv);\n\n        Cipher c = Cipher.getInstance(\"AES/CBC/PKCS5Padding\");\n        System.out.println(\"h\u00e4r\");\n        c.init(Cipher.DECRYPT_MODE, keySpec, ivspec);\n\n        System.out.println(\"Decrypting file...\");\n        try {\n            decryptStream(new FileInputStream(\"krypterad.txt\"), new FileOutputStream(\"Dekryperad.txt\"), c, buf);\n        } catch (java.io.IOException e) {\n        }\n        System.out.println(\"File decrypted!\");\n    }\n\n    public void decryptStream(InputStream in, OutputStream out, Cipher dcipher, byte[] buf) {\n        try {\n\n            in = new CipherInputStream(in, dcipher);\n\n            // Read in the decrypted bytes and write the cleartext to out \n            int numRead = 0;\n\n\n            while ((numRead = in.read(buf)) >= 0) {\n                out.write(buf, 0, numRead);\n\n            }\n            out.close();\n\n\n        } catch (java.io.IOException e) {\n        }\n    }\n\n    public static void main(String[] args) {\n        new DecryptHandler();\n    }\n}\n", "idx": 2508}
{"project": "cipher", "commit_id": "Snippet36505038_18339.java", "target": 0, "func": "test.java:43: error: unreported exception NoSuchAlgorithmException; must be caught or declared to be thrown\n        Cipher cip = Cipher.getInstance(\"AES/ECB/PKCS5PADDING\");\n", "idx": 2082}
{"project": "cipher", "commit_id": "Snippet18283081_1329.java", "target": 0, "func": "Cipher cipher = Cipher.getInstance(\"AES\");\n", "idx": 2036}
{"project": "cipher", "commit_id": "Snippet10993335_35234.java", "target": 0, "func": "public class CryptData {\nprivate KeySpec keySpec;\nprivate SecretKey key;\nprivate IvParameterSpec iv;\n\npublic CryptData(String keyString, String ivString) {\n    try {\n        final MessageDigest md = MessageDigest.getInstance(\"md5\");\n\n        final byte[] digestOfPassword = md.digest(Base64\n                .decodeBase64(keyString.getBytes(\"ISO-8859-1\")));\n\n        final byte[] keyBytes = Arrays.copyOf(digestOfPassword, 24);\n        for (int j = 0, k = 16; j < 8;) {\n            keyBytes[k++] = keyBytes[j++];\n        }\n\n        //keySpec = new DESedeKeySpec(keyBytes);\n        keySpec = new DESedeKeySpec(keyString.getBytes());\n\n        key = SecretKeyFactory.getInstance(\"DESede\")\n                .generateSecret(keySpec);\n\n        iv = new IvParameterSpec(ivString.getBytes());\n    } catch (Exception e) {\n        e.printStackTrace();\n    }\n}\n\npublic String encrypt(String value) {\n    try {\n        Cipher ecipher = Cipher.getInstance(\"DESede/CFB/NoPadding\");\n\n                //\"SunJCE\");\n        ecipher.init(Cipher.ENCRYPT_MODE, key, iv);\n\n        if (value == null)\n            return null;\n\n        // Encode the string into bytes using utf-8\n        byte[] valeur = value.getBytes(\"ISO-8859-1\");\n        //byte[] utf8 = value.getBytes();\n\n        // Encrypt\n        byte[] enc = ecipher.doFinal(valeur);\n\n        // Encode bytes to base64 to get a string\n        return new String(Base64.encodeBase64(enc), \"ISO-8859-1\");\n    } catch (Exception e) {\n        e.printStackTrace();\n    }\n    return null;\n}\n", "idx": 2195}
{"project": "cipher", "commit_id": "Snippet4573447_31191.java", "target": 1, "func": "package com.citc.testencryption;\n\nimport java.security.NoSuchAlgorithmException;\nimport java.security.SecureRandom;\n\nimport javax.crypto.Cipher;\nimport javax.crypto.SecretKey;\nimport javax.crypto.SecretKeyFactory;\nimport javax.crypto.spec.IvParameterSpec;\nimport javax.crypto.spec.PBEKeySpec;\nimport javax.crypto.spec.SecretKeySpec;\n\nimport android.app.Activity;\nimport android.os.Bundle;\nimport android.util.Log;\n\npublic class Main extends Activity {\n\n    public static final int SALT_LENGTH = 20;\n    public static final int PBE_ITERATION_COUNT = 1000;\n\n    private static final String RANDOM_ALGORITHM = \"SHA1PRNG\";\n    private static final String PBE_ALGORITHM = \"PBEWithSHA256And256BitAES-CBC-BC\";\n    private static final String CIPHER_ALGORITHM = \"AES/CBC/PKCS5Padding\";\n\n    private static final String TAG = Main.class.getSimpleName();\n\n    @Override\n    public void onCreate(Bundle savedInstanceState) {\n\n        super.onCreate(savedInstanceState);\n        setContentView(R.layout.main);\n\n        try {\n\n            String password = \"password\";\n            String plainText = \"plaintext message to be encrypted\";\n\n            // byte[] salt = generateSalt();\n            byte[] salt = \"dfghjklpoiuytgftgyhj\".getBytes();\n            Log.i(TAG, \"Salt: \" + salt.length + \" \" + HexEncoder.toHex(salt));\n            PBEKeySpec pbeKeySpec = new PBEKeySpec(password.toCharArray(), salt, PBE_ITERATION_COUNT, 256);\n            SecretKeyFactory factory = SecretKeyFactory.getInstance(PBE_ALGORITHM);\n            SecretKey tmp = factory.generateSecret(pbeKeySpec);\n            SecretKey secret = new SecretKeySpec(tmp.getEncoded(), \"AES\");\n            byte[] key = secret.getEncoded();\n            Log.i(TAG, \"Key: \" + HexEncoder.toHex(key));\n\n            // PBEParameterSpec pbeParamSpec = new PBEParameterSpec(salt, ITERATION_COUNT);\n\n            Cipher encryptionCipher = Cipher.getInstance(CIPHER_ALGORITHM);\n\n            // byte[] encryptionSalt = generateSalt();\n            // Log.i(TAG, \"Encrypted Salt: \" + encryptionSalt.length + \" \" + HexEncoder.toHex(encryptionSalt));\n            // PBEParameterSpec pbeParamSpec = new PBEParameterSpec(encryptionSalt, 1000);\n            // byte[] iv = params.getParameterSpec(IvParameterSpec.class).getIV();\n            Log.i(TAG, encryptionCipher.getParameters() + \" \");\n            byte[] iv = generateIv();\n            IvParameterSpec ivspec = new IvParameterSpec(iv);\n\n            encryptionCipher.init(Cipher.ENCRYPT_MODE, secret, ivspec);\n            byte[] encryptedText = encryptionCipher.doFinal(plainText.getBytes());\n            Log.i(TAG, \"Encrypted: \" + HexEncoder.toHex(encryptedText));\n\n            Cipher decryptionCipher = Cipher.getInstance(CIPHER_ALGORITHM);\n            decryptionCipher.init(Cipher.DECRYPT_MODE, secret, ivspec);\n            byte[] decryptedText = decryptionCipher.doFinal(encryptedText);\n            Log.i(TAG, \"Decrypted: \" + new String(decryptedText));\n\n        } catch (Exception e) {\n            e.printStackTrace();\n        }\n\n    }\n\n    private byte[] generateSalt() throws NoSuchAlgorithmException {\n        SecureRandom random = SecureRandom.getInstance(RANDOM_ALGORITHM);\n        byte[] salt = new byte[SALT_LENGTH];\n        random.nextBytes(salt);\n        return salt;\n    }\n\n    private byte[] generateIv() throws NoSuchAlgorithmException {\n        SecureRandom random = SecureRandom.getInstance(RANDOM_ALGORITHM);\n        byte[] iv = new byte[16];\n        random.nextBytes(iv);\n        return iv;\n    }\n\n}\n", "idx": 2380}
{"project": "cipher", "commit_id": "Snippet6752963_32325.java", "target": 0, "func": "byte[] keyBytes = ...\nbyte[] volumeKeyFileContents = ...\n\nSecretKeyFactory factory = SecretKeyFactory.getInstance(\"AES\");\nSecretKey aesKey = factory.generateSecret(new SecretKeySpec(keyBytes, \"AES\"));\n\nCipher cipher = Cipher.getInstance(\"AES/ECB/PKCS5Padding\"); // for example\ncipher.init(Cipher.DECRYPT_MODE, aesKey);\nbyte[] plaintext = cipher.doFinal(volumeKeyFileContents);\n\n// (written from memory so may not compile without tweaks)\n", "idx": 2031}
{"project": "cipher", "commit_id": "Snippet18803008_1154.java", "target": 1, "func": "Key rootKey = new SecretKeySpec(keyBytes, \"AES\");\nKeyGenerator generator = KeyGenerator.getInstance(\"AES\");\ngenerator.init(128);\nKey keyToWrap = generator.generateKey();\n\nCipher cipher = Cipher.getInstance(\"AESWRAP\");\ncipher.init(Cipher.WRAP_MODE, rootKey);\nbyte[] wrappedKey = cipher.wrap(keyToWrap);\n\nCipher uncipher = Cipher.getInstance(\"AESWRAP\");\nuncipher.init(Cipher.UNWRAP_MODE, rootKey);\nKey unwrappedKey = uncipher.unwrap(wrappedKey, \"AES\", Cipher.SECRET_KEY);\n", "idx": 2761}
{"project": "cipher", "commit_id": "Snippet27868840_10020.java", "target": 1, "func": "Cipher c = Cipher.getInstance(\"RSA/None/PKCS1Padding\");\n", "idx": 2708}
{"project": "cipher", "commit_id": "Snippet28347341_10533.java", "target": 0, "func": "private static final String KEY = \"a2[..]\";\nprivate static final String SALT = \"t[..]\";\nprivate static final String IV = \"u[..]\";\nprivate static final String DES_EDE_PKCS5 = \"DESede/CBC/PKCS5Padding\"\n\npublic static String encrypt(String password) {\n    byte[] byteSalt = Base64.decode(SALT, Base64.DEFAULT);\n    byte[] bytesIv = Base64.decode(IV, Base64.DEFAULT);\n    String mdp = \"\";        \n    try {           \n        SecretKeyFactory factory = SecretKeyFactory.getInstance(\"PBKDF2WithHmacSHA1\");          \n        KeySpec spec = new PBEKeySpec(KEY.toCharArray(), byteSalt, NB_ITER_RFC, SIZE_KEY);          \n        SecretKey secretKey = factory.generateSecret(spec);             \n        Cipher c = Cipher.getInstance(DES_EDE_PKCS5);           \n        IvParameterSpec ivParam = new IvParameterSpec(bytesIv);         \n        c.init(Cipher.ENCRYPT_MODE, secretKey, ivParam);                \n        byte[] encrypted = c.doFinal(password.getBytes(\"UTF-8\"));\n        mdp = Base64.encodeToString(encrypted, Base64.DEFAULT);                 \n    }\n    catch [..]\n    return mdp;\n}\n", "idx": 2243}
{"project": "cipher", "commit_id": "Snippet25715001_8032.java", "target": 0, "func": " private static Cipher ecipher;\nprivate static Cipher dcipher;\n\npublic static String[] encrypt(String str) throws NoSuchAlgorithmException, NoSuchPaddingException, InvalidKeyException, UnsupportedEncodingException, IllegalBlockSizeException, BadPaddingException {\n    String Key, res;\n    SecretKey key;\n    String[] Return = new String[2];\n\n    key = KeyGenerator.getInstance(\"DES\").generateKey();\n    ecipher = Cipher.getInstance(\"DES\");\n    ecipher.init(Cipher.ENCRYPT_MODE, key);\n    byte[] utf8 = str.getBytes(\"UTF8\");\n    byte[] enc = ecipher.doFinal(utf8);\n\n    enc = BASE64EncoderStream.encode(enc);\n    res = new String(enc);\n\n    //Returning values 0 = Encrypted String 1 = Key For Storage in XML\n    Return[0] = res;\n    byte[] keyBytes = key.getEncoded(); \n    Key = new String(keyBytes,\"UTF8\");\n    Return[1] = Key;\n\n    return Return;\n}\n\npublic static String decrypt(String str, String Key) throws NoSuchAlgorithmException, NoSuchPaddingException, InvalidKeyException, IllegalBlockSizeException, UnsupportedEncodingException, BadPaddingException {\n    SecretKey key = new SecretKeySpec(Key.getBytes(\"UTF8\"), \"DES\");\n    dcipher = Cipher.getInstance(\"DES\");\n    dcipher.init(Cipher.DECRYPT_MODE, key);\n    byte[] dec = BASE64DecoderStream.decode(str.getBytes());\n    byte[] utf8 = dcipher.doFinal(dec);\n    return new String(utf8, \"UTF8\");\n}\n", "idx": 2052}
{"project": "cipher", "commit_id": "Snippet26935310_9058.java", "target": 1, "func": "package com.company.encrypt.tests;\n\nimport java.security.InvalidKeyException;\nimport java.security.NoSuchAlgorithmException;\nimport java.util.Arrays;\n\nimport javax.crypto.BadPaddingException;\nimport javax.crypto.Cipher;\nimport javax.crypto.IllegalBlockSizeException;\nimport javax.crypto.NoSuchPaddingException;\nimport javax.crypto.spec.IvParameterSpec;\nimport javax.crypto.spec.SecretKeySpec;\n\nimport org.apache.commons.codec.binary.Base64;\n\npublic class TestEncryptDecrypt {\n\n    private static final String characterEncoding = \"UTF-8\";\n    private static final String cipherTransformation = \"AES/CBC/PKCS5Padding\";\n    private static final String aesEncryptionAlgorithm = \"AES\";\n\n    public static void main(String[] args) throws Exception {\n        String key1 = \"1234567812345678\";\n        String text = \"01234567891234565\";\n        System.out.println(\"Original Text: \" + text);\n        String encrypted = encrypt(text, key1);\n        System.out.println(\"Encrypted: \" + encrypted);\n        String decrypted = decrypt(encrypted, key1);\n        System.out.println(\"Decrypted: \" + decrypted);\n\n    }\n\n    public static String decrypt(String encryptedText, String key) throws Exception {\n        String plainText = null;\n\n        int keyLength = key.length();\n        System.out.println(\"Key length: \" + String.valueOf(keyLength));\n        byte[] encryptedTextBytes = Base64.decodeBase64(encryptedText.getBytes());\n        byte[] keyBytes = key.getBytes();\n\n        byte[] initialVector = Arrays.copyOfRange(encryptedTextBytes, 0, keyLength);\n        byte[] trimmedCipherText = Arrays.copyOfRange(encryptedTextBytes, keyLength, encryptedTextBytes.length);\n\n        try {\n            Cipher cipher = Cipher.getInstance(cipherTransformation);\n            SecretKeySpec secretKeySpec = new SecretKeySpec(keyBytes, aesEncryptionAlgorithm);\n            IvParameterSpec ivParameterSpec = new IvParameterSpec(initialVector);\n            cipher.init(Cipher.DECRYPT_MODE, secretKeySpec, ivParameterSpec);\n\n            byte[] clearText;\n            clearText = cipher.doFinal(trimmedCipherText);\n\n            plainText = new String(clearText, characterEncoding);\n        } catch(NoSuchAlgorithmException | NoSuchPaddingException | IllegalBlockSizeException | BadPaddingException\n                | InvalidKeyException e) {\n            // TODO Auto-generated catch block\n            e.printStackTrace();\n        }\n        return plainText;\n\n    }\n\n    public static String encrypt(String plainText, String encryptionKey) throws Exception {\n\n        SecretKeySpec key = new SecretKeySpec(encryptionKey.getBytes(\"UTF-8\"), aesEncryptionAlgorithm);\n        Cipher cipher = Cipher.getInstance(cipherTransformation);\n        cipher.init(Cipher.ENCRYPT_MODE, key);\n\n        byte[] plainTextBytes = plainText.getBytes(\"UTF-8\");\n\n        byte[] encrypted = cipher.doFinal(plainTextBytes);\n\n        return new String(Base64.encodeBase64(encrypted));\n    }\n\n}\n", "idx": 2350}
{"project": "cipher", "commit_id": "Snippet46861817_28906.java", "target": 0, "func": "private String _encrypt2(String clearText,String key )\n{\n    try\n    {\n        /**\n         * create md5\n         */\n        MessageDigest md = MessageDigest.getInstance(\"md5\");\n        byte[] digestOfPassword = md.digest(key.getBytes(\"UTF-16LE\"));\n        byte[] keyBytes = Arrays.copyOf(digestOfPassword, 24);\n        for (int j = 0, k = 16; j < 8; )\n        {\n            keyBytes[k++] = keyBytes[j++];\n        }\n\n\n        SecretKey secretKey = new SecretKeySpec(keyBytes, 0, 24, \"DESede\");\n        IvParameterSpec iv = new IvParameterSpec(new byte[8]);\n        Cipher cipher = Cipher.getInstance(\"DESede/CBC/PKCS5Padding\");\n        cipher.init(Cipher.ENCRYPT_MODE, secretKey, iv);\n\n        byte[] plainTextBytes = clearText.getBytes(\"UTF-16LE\");\n        byte[] cipherText = cipher.doFinal(plainTextBytes);\n\n        String output = Base64.encodeToString(cipherText,Base64.DEFAULT);\n        return output;\n    }\n    catch (Exception ex) {}\n    return \"\";\n}\n", "idx": 2079}
{"project": "cipher", "commit_id": "Snippet32583766_14711.java", "target": 0, "func": "import java.security.Key;\nimport javax.crypto.Cipher;\nimport javax.crypto.spec.SecretKeySpec;\npublic class StrongAES \n{\n    public void run() \n    {\n        try \n        {\n            String text = \"Hello World\";\n            String key = \"Bar12345Bar12345\"; // 128 bit key\n            // Create key and cipher\n            Key aesKey = new SecretKeySpec(key.getBytes(), \"AES\");\n            Cipher cipher = Cipher.getInstance(\"AES\");\n            // encrypt the text\n            cipher.init(Cipher.ENCRYPT_MODE, aesKey);\n            byte[] encrypted = cipher.doFinal(text.getBytes());\n\n            StringBuilder sb = new StringBuilder();\n            for (byte b: encrypted) {\n                sb.append((char)b);\n            }\n\n            // the encrypted String\n            String enc = sb.toString();\n            System.out.println(\"encrypted:\" + enc);\n\n            // now convert the string to byte array\n            // for decryption\n            byte[] bb = new byte[enc.length()];\n            for (int i=0; i<enc.length(); i++) {\n                bb[i] = (byte) enc.charAt(i);\n            }\n\n            // decrypt the text\n            cipher.init(Cipher.DECRYPT_MODE, aesKey);\n            String decrypted = new String(cipher.doFinal(bb));\n            System.err.println(\"decrypted:\" + decrypted);\n\n        }\n        catch(Exception e) \n        {\n            e.printStackTrace();\n        }\n    }\n    public static void main(String[] args) \n    {\n        StrongAES app = new StrongAES();\n        app.run();\n    }\n}\n", "idx": 2074}
{"project": "cipher", "commit_id": "Snippet21170551_3727.java", "target": 1, "func": "public class MySecurity\n{\n    private static Cipher ecipher;\n    private Cipher dcipher;\n    private static String Password = \"$emP0sTM@rkT0P$3cu!ty12345678912\";\n    private static String InitialVector = \"OFRna73m*aze01xY\";\n\n    // ENCRYPTION ******************************************************\n    public String encryptText(String plainText)\n    {\n        String errorText = \"Error\";\n\n        try {\n            SecretKeySpec secretKey = new SecretKeySpec(Password.getBytes(\"ASCII\"), \"AES\");\n            ecipher = Cipher.getInstance(\"AES/CBC/PKCS5Padding\");\n            ecipher.init(Cipher.ENCRYPT_MODE, secretKey, new IvParameterSpec(InitialVector.getBytes(\"ASCII\")));\n             // Encode the string into bytes using utf-8\n            byte[] utf8 = plainText.getBytes(\"UTF8\");\n\n            // Encrypt\n            byte[] enc = ecipher.doFinal(utf8);\n             // Encode bytes to base64 to get a string\n            return Base64.encodeToString(enc, Base64.DEFAULT);  \n\n        } catch (InvalidKeyException e) {\n            e.printStackTrace();\n            errorText = e.getMessage();\n        } catch (InvalidAlgorithmParameterException e) {\n            e.printStackTrace();\n            errorText = e.getMessage();\n        }catch (NoSuchAlgorithmException e) {\n            e.printStackTrace();\n            errorText = e.getMessage();\n        } catch (NoSuchPaddingException e) {\n            e.printStackTrace();\n            errorText = e.getMessage();\n        }catch (UnsupportedEncodingException e) {\n            e.printStackTrace();\n            errorText = e.getMessage();\n        } catch (IllegalBlockSizeException e) {\n            e.printStackTrace();\n            errorText = e.getMessage();\n        } catch (BadPaddingException e) {\n            e.printStackTrace();\n            errorText = e.getMessage();\n        }\n\n\n        return errorText;\n    }\n\n    public static boolean encryptFile(String filePath)\n    {\n\n        try {\n            SecretKeySpec secretKey = new SecretKeySpec(Password.getBytes(\"ASCII\"), \"AES\");\n            ecipher = Cipher.getInstance(\"AES/CBC/PKCS5Padding\");\n            ecipher.init(Cipher.ENCRYPT_MODE, secretKey, new IvParameterSpec(InitialVector.getBytes(\"ASCII\")));\n\n            //create input stream to read in file that needs to be encrypted\n            FileInputStream inputStream = new FileInputStream(filePath);\n            //create output stream to write out the encrypted results, append .vault to out encrypted files\n            FileOutputStream outputStream = new FileOutputStream(filePath + \".vault\");\n            //wrap the output stream\n            CipherOutputStream encryptedOutputStream = new CipherOutputStream(outputStream, ecipher);\n\n            // Encrypt the file\n            int bytes;\n            byte[] data = new byte[8];\n            while((bytes = inputStream.read(data)) != -1)\n            {\n                encryptedOutputStream.write(data, 0, bytes);\n            }\n\n            // Flush and close streams.\n            encryptedOutputStream.flush();\n            encryptedOutputStream.close();\n            inputStream.close();\n            outputStream.flush();\n            outputStream.close();\n\n        } catch (FileNotFoundException e) {\n            e.printStackTrace();\n            return false;\n        } catch (InvalidKeyException e) {\n            e.printStackTrace();\n            return false;\n        } catch (InvalidAlgorithmParameterException e) {\n            e.printStackTrace();\n            return false;\n        }catch (NoSuchAlgorithmException e) {\n            e.printStackTrace();\n            return false;\n        } catch (NoSuchPaddingException e) {\n            e.printStackTrace();\n            return false;\n        }catch (UnsupportedEncodingException e) {\n            e.printStackTrace();\n            return false;\n        } catch (IOException e) {\n            e.printStackTrace();\n            return false;\n        } \n        return true;\n    }\n\n    public String decryptText(String cryptoText)\n    {\n        String errorText = \"Error\";\n\n        try {\n            SecretKeySpec secretKey = new SecretKeySpec(Password.getBytes(\"ASCII\"), \"AES\");\n            dcipher = Cipher.getInstance(\"AES/CBC/PKCS5Padding\");\n            dcipher.init(Cipher.DECRYPT_MODE, secretKey, new IvParameterSpec(InitialVector.getBytes(\"ASCII\")));\n\n        // Decode base64 to get bytes\n            byte[] dec = Base64.decode(cryptoText, Base64.DEFAULT);        \n         // Decrypt\n            byte[] utf8 = dcipher.doFinal(dec);        \n         // Decode using utf-8\n            return new String(utf8, \"UTF8\");    \n\n        } catch (InvalidKeyException e) {\n            e.printStackTrace();\n            errorText = e.getMessage();\n        } catch (InvalidAlgorithmParameterException e) {\n            e.printStackTrace();\n            errorText = e.getMessage();\n        }catch (NoSuchAlgorithmException e) {\n            e.printStackTrace();\n            errorText = e.getMessage();\n        } catch (NoSuchPaddingException e) {\n            e.printStackTrace();\n            errorText = e.getMessage();\n        }catch (UnsupportedEncodingException e) {\n            e.printStackTrace();\n            errorText = e.getMessage();\n        } catch (IllegalBlockSizeException e) {\n            e.printStackTrace();\n            errorText = e.getMessage();\n        } catch (BadPaddingException e) {\n            e.printStackTrace();\n            errorText = e.getMessage();\n        }  \n        return errorText;\n    } \n\n    public boolean decryptFile(String filePath)\n    {\n\n        try {\n            SecretKeySpec secretKey = new SecretKeySpec(Password.getBytes(\"ASCII\"), \"AES\");\n            dcipher = Cipher.getInstance(\"AES/CBC/PKCS5Padding\");\n            dcipher.init(Cipher.DECRYPT_MODE, secretKey, new IvParameterSpec(InitialVector.getBytes(\"ASCII\")));\n\n            //create input stream to read in file that needs to be decrypted\n            FileInputStream inputStream = new FileInputStream(filePath);\n            //create output stream to write out the decrypted results, remove .vault to from file\n            FileOutputStream outputStream = new FileOutputStream(filePath.replace(\".vault\", filePath));\n            //wrap the output stream\n            CipherInputStream encryptedInputStream = new CipherInputStream(inputStream, dcipher);\n\n            //Decrypt the file\n            int bytes;\n            byte[] data = new byte[8];\n            while((bytes = encryptedInputStream.read(data)) != -1)\n            {\n                outputStream.write(data, 0, bytes);\n            }\n\n            // Flush and close streams.\n            outputStream.flush();\n            outputStream.close();\n            inputStream.close();\n            encryptedInputStream.close();\n\n        } catch (FileNotFoundException e) {\n            e.printStackTrace();\n            return false;\n        } catch (InvalidKeyException e) {\n            e.printStackTrace();\n            return false;\n        } catch (InvalidAlgorithmParameterException e) {\n            e.printStackTrace();\n            return false;\n        }catch (NoSuchAlgorithmException e) {\n            e.printStackTrace();\n            return false;\n        } catch (NoSuchPaddingException e) {\n            e.printStackTrace();\n            return false;\n        }catch (UnsupportedEncodingException e) {\n            e.printStackTrace();\n            return false;\n        } catch (IOException e) {\n            e.printStackTrace();\n            return false;\n        } \n        return true;\n    }\n}\n", "idx": 2427}
{"project": "cipher", "commit_id": "Snippet2367697_30147.java", "target": 1, "func": "AlgorithmParameterSpec paramSpec = new IvParameterSpec(initv);\nencipher = Cipher.getInstance(\"AES/CBC/PKCS5Padding\");\nmac = Mac.getInstance(\"HmacSHA512\");\nencipher.init(Cipher.ENCRYPT_MODE, key, paramSpec);\nmac.init(key);\nbuf = new byte[encipher.getOutputSize(blockSize)];\n", "idx": 2516}
{"project": "cipher", "commit_id": "Snippet4894882_31367.java", "target": 1, "func": "    public static byte[] encrypt(byte[] text, PublicKey key) throws Exception\n{\n    byte[] cipherText = null;\n    try\n    {\n\n        Cipher cipher = Cipher.getInstance(\"ElGamal/None/NoPadding\", \"BC\"\");\n        if (_log.isDebugEnabled())\n        {\n            _log.debug(\"\\nProvider is: \" + cipher.getProvider().getInfo());\n            _log.debug(\"\\nStart encryption with public key\");\n        }\n\n        // encrypt the plaintext using the public key\n        cipher.init(Cipher.ENCRYPT_MODE, key);\n        cipherText = cipher.doFinal(text);\n    }\n    catch (Exception e)\n    {\n        _log.error(e, e);\n        throw e;\n    }\n    return cipherText;\n}\n", "idx": 2730}
{"project": "cipher", "commit_id": "Snippet10836902_35087.java", "target": 0, "func": " import java.security.Key;\n import javax.crypto.Cipher;\n import javax.crypto.spec.SecretKeySpec;\n import sun.misc.BASE64Decoder;\n import sun.misc.BASE64Encoder;\n\n public class AESEncryptionDecryptionTest {\n\n   private static final String ALGORITHM       = \"AES\";\n   private static final String myEncryptionKey = \"ThisIsFoundation\";\n   private static final String UNICODE_FORMAT  = \"UTF8\";\n\n   public static String encrypt(String valueToEnc) throws Exception {\n Key key = generateKey();\n Cipher c = Cipher.getInstance(ALGORITHM);\n c.init(Cipher.ENCRYPT_MODE, key);  \n byte[] encValue = c.doFinal(valueToEnc.getBytes());\n String encryptedValue = new BASE64Encoder().encode(encValue);\n return encryptedValue;\n   }\n\n\nprivate static Key generateKey() throws Exception {\nbyte[] keyAsBytes;\nkeyAsBytes = myEncryptionKey.getBytes(UNICODE_FORMAT);\nKey key = new SecretKeySpec(keyAsBytes, ALGORITHM);\nreturn key;\n}\n\n\n}\n", "idx": 2032}
{"project": "cipher", "commit_id": "Snippet20751030_3348.java", "target": 0, "func": "private static final String ALGORITHM = \"AES\";\n\n protected static String encrypt(String valueToEnc, byte[] keyValue) throws Exception {\n    Key key = generateKey(keyValue);\n    Cipher c = Cipher.getInstance(ALGORITHM);\n    c.init(Cipher.ENCRYPT_MODE, key);\n    byte[] encValue = c.doFinal(valueToEnc.getBytes());\n    String encryptedValue = new BASE64Encoder().encode(encValue);\n    return encryptedValue;\n}\n\nprotected static String decrypt(String encryptedValue, byte[] keyValue) throws Exception {\n    try\n    {\n        Key key = generateKey(keyValue);\n        Cipher c = Cipher.getInstance(ALGORITHM);\n        c.init(Cipher.DECRYPT_MODE, key);\n        byte[] decordedValue = new BASE64Decoder().decodeBuffer(encryptedValue);\n        byte[] decValue = c.doFinal(decordedValue);\n        String decryptedValue = new String(decValue);\n        return decryptedValue;\n    }\n    catch(Exception ex)\n    {\n        return \"\";\n    }\n}\n\nprivate static Key generateKey(byte[] keyValue) throws Exception {          \n    Key key = new SecretKeySpec(keyValue, ALGORITHM);\n    return key;\n}\n", "idx": 2109}
{"project": "cipher", "commit_id": "Snippet23570655_5914.java", "target": 0, "func": "String key = \"abcd\";\nSecretKeySpec keySpec = new SecretKeySpec(key.getBytes(), \"Blowfish\");\nCipher cipher = Cipher.getInstance(\"Blowfish\");\ncipher.init(cipher.ENCRYPT_MODE, keySpec);\nreturn DatatypeConverter.printBase64Binary(cipher.doFinal(key.getBytes()));\n", "idx": 2190}
{"project": "cipher", "commit_id": "Snippet11477175_35585.java", "target": 0, "func": "                    // Encrypt\n                    byte[] input = jo.toString().getBytes(\"UTF-8\");\n\n                    MessageDigest md = MessageDigest.getInstance(\"MD5\");\n                    byte[] thedigest = md.digest(ENCRYPTION_KEY.getBytes(\"UTF-8\"));\n                    SecretKeySpec skc = new SecretKeySpec(thedigest, \"AES/ECB/PKCS5Padding\");\n                    Cipher cipher = Cipher.getInstance(\"AES/ECB/PKCS5Padding\");\n                    cipher.init(Cipher.ENCRYPT_MODE, skc);\n\n                    byte[] cipherText = new byte[cipher.getOutputSize(input.length)];\n                    int ctLength = cipher.update(input, 0, input.length, cipherText, 0);\n                    ctLength += cipher.doFinal(cipherText, ctLength);\n                    String query = Base64.encodeToString(cipherText, Base64.DEFAULT);\n", "idx": 2247}
{"project": "cipher", "commit_id": "Snippet33082516_15123.java", "target": 1, "func": "Cipher cipher = Cipher.getInstance(\"AES/CBC/ZeroPadding\", \"BC\");\n", "idx": 2706}
{"project": "cipher", "commit_id": "Snippet39805168_21692.java", "target": 0, "func": "public static String decrypt(String input, String key) {\n        byte[] output = null;\n        try {\n            SecretKeySpec skey = new SecretKeySpec(key.getBytes(), \"AES\");\n            Cipher cipher = Cipher.getInstance(\"AES/ECB/PKCS5Padding\");\n            cipher.init(Cipher.DECRYPT_MODE, skey);\n            output = cipher.doFinal(Base64.decode(input,Base64.NO_WRAP));\n        } catch (Exception e) {\n            System.out.println(e.toString());\n        }\n        return new String(output);\n}\n", "idx": 1958}
{"project": "cipher", "commit_id": "Snippet45693335_27704.java", "target": 0, "func": "private static final String UNICODE_FORMAT = \"UTF8\";\npublic static final String DESEDE_ENCRYPTION_SCHEME = \"DESede\";\nprivate KeySpec myKeySpec;\nprivate SecretKeyFactory mySecretKeyFactory;\nprivate Cipher cipher;\nbyte[] keyAsBytes;\nprivate String myEncryptionKey;\nprivate String myEncryptionScheme;\nSecretKey key;\n\npublic DESedeEncryption() throws Exception\n{\n    myEncryptionKey = \"YOURPRIVATEKEY\";\n    myEncryptionScheme = DESEDE_ENCRYPTION_SCHEME;\n    keyAsBytes = myEncryptionKey.getBytes(UNICODE_FORMAT);\n    myKeySpec = new DESedeKeySpec(keyAsBytes);\n    mySecretKeyFactory = SecretKeyFactory.getInstance(myEncryptionScheme);\n    cipher = Cipher.getInstance(myEncryptionScheme);\n    key = mySecretKeyFactory.generateSecret(myKeySpec);\n}\n\n/**\n * Method To Encrypt The String\n */\npublic String encrypt(String unencryptedString) {\n    String encryptedString = null;\n    try {\n        cipher.init(Cipher.ENCRYPT_MODE, key);\n        byte[] plainText = unencryptedString.getBytes(UNICODE_FORMAT);\n        byte[] encryptedText = cipher.doFinal(plainText);\n        encryptedString = Base64.encodeToString(encryptedText, Base64.DEFAULT);\n    } catch (Exception e) {\n        e.printStackTrace();\n    }\n    return encryptedString.endsWith(\"\\n\") ? encryptedString.replace(\"\\n\",\"\") : encryptedString;\n}\n/**\n * Method To Decrypt An Ecrypted String\n */\npublic String decrypt(String encryptedString) {\n    String decryptedText=null;\n    try {\n        cipher.init(Cipher.DECRYPT_MODE, key);\n        byte[] encryptedText = Base64.decode(encryptedString, Base64.DEFAULT);\n        byte[] plainText = cipher.doFinal(encryptedText);\n        decryptedText= bytes2String(plainText);\n    } catch (Exception e) {\n        e.printStackTrace();\n    }\n    return decryptedText;\n}\n/**\n * Returns String From An Array Of Bytes\n */\nprivate static String bytes2String(byte[] bytes) {\n    StringBuffer stringBuffer = new StringBuffer();\n    for (int i = 0; i > bytes.length; i++) {\n        stringBuffer.append((char) bytes[i]);\n    }\n    return stringBuffer.toString();\n}\n", "idx": 1993}
{"project": "cipher", "commit_id": "Snippet11543268_35608.java", "target": 1, "func": "import javax.crypto.Cipher;\n\necipher = Cipher.getInstance(\"AES/CBC/PKCS5Padding\"); \n", "idx": 2589}
{"project": "cipher", "commit_id": "Snippet19223599_2060.java", "target": 0, "func": "SecretKeySpec keySpec = new SecretKeySpec(keyBytes, \"AES\");\nCipher cipher = Cipher.getInstance(\"AES\");\ncipher.init(Cipher.ENCRYPT_MODE, keySpec);\nbyte[] encrypted = cipher.doFinal(clearTextBytes);\n", "idx": 1974}
{"project": "cipher", "commit_id": "Snippet20803436_3408.java", "target": 0, "func": "    int k=i;\n\n    String questionImage[]={\"\",\"B001\",\"B002\",\"B003\"};\n\n    String questionDecryptImageName=questionImage[k];\n\n    String afterDrcryptName[]={\"A.jpg\",\"B.jpg\",\"C.jpg\",\"D.jpg\"};\n\n    try{\n\n        FileInputStream file = new FileInputStream(\"src/learning/dvd/Temp2/\"+questionDecryptImageName+\".jpg\");\n\n    FileOutputStream output = new FileOutputStream(\"src/learning/dvd/Temp2/\"+afterDrcryptName[k]);\n\n        byte j[]=\"NiTh5252\".getBytes();\n\n        SecretKeySpec kye = new SecretKeySpec(j,\"DES\");\n\n        System.out.println(kye);\n\n        Cipher enc = Cipher.getInstance(\"DES\");\n\n        enc.init(Cipher.DECRYPT_MODE,kye);\n\n        CipherOutputStream cos = new CipherOutputStream(output, enc);\n\n        byte[] buf = new byte[1024];\n\n        int read;\n\n        while((read=file.read(buf))!=-1){\n\n            cos.write(buf,0,read);\n\n        }\n\n        file.close();\n\n        cos.close();\n\n        output.flush();  \n\n    }catch(Exception e){\n\n        JOptionPane.showMessageDialog(null, e);\n\n    }\n\n}  \n", "idx": 1939}
{"project": "cipher", "commit_id": "Snippet42547298_24573.java", "target": 0, "func": "    String content = \"some content\";\n    String privateKey = \"secret key\";\n    Key key = new SecretKeySpec(privateKey.getBytes(), \"AES/ECB/PKCS7Padding\");\n    try {\n        Cipher localCipher = Cipher.getInstance(\"AES/ECB/PKCS7Padding\", \"BC\");\n        localCipher.init(2, key);\n        Log.e(\"error\", new String(localCipher.doFinal(Base64.decode(content, 0))));\n    } catch (NoSuchAlgorithmException | NoSuchProviderException | NoSuchPaddingException | BadPaddingException | IllegalBlockSizeException | InvalidKeyException e) {\n        e.printStackTrace();\n    }\n", "idx": 1946}
{"project": "cipher", "commit_id": "Snippet13108567_36719.java", "target": 0, "func": "final Key k = new SecretKeySpec(keyString.getBytes(), \"AES\");\nCipher c = Cipher.getInstance(\"AES\");\nc.init(Cipher.DECRYPT_MODE, k);\n\nfinal InputStream in = new BufferedInputStream(new FileInputStream(fileNameToDecrypt));\nfinal CipherInputStream instream = new CipherInputStream(in, c);\n\nif (instream.read() != 'B') {\n    System.out.println(\"Error\");\n}\n\nif (instream.read() != 'Z') {\n    System.out.println(\"Error\");\n}\n\nfinal CBZip2InputStream zip = new CBZip2InputStream(instream);\n", "idx": 2023}
{"project": "cipher", "commit_id": "Snippet45925986_27983.java", "target": 1, "func": "public static String decrypt2(final String sEncryptedMessageBase64,\n                              final String sSymKeyHex,\n                              final String sIvHex)\n{\n    final byte[] byteEncryptedMessage = Base64.decode(sEncryptedMessageBase64, Base64.DEFAULT);\n\n    try\n    {\n        final Cipher cipher = Cipher.getInstance(\"AES/CBC/PKCS5Padding\");\n        final SecretKeySpec symKey = new SecretKeySpec(byteSymKeyData, \"AES\");\n        final IvParameterSpec iv = new IvParameterSpec(byteIvData);\n\n        cipher.init(Cipher.DECRYPT_MODE, symKey, iv);\n        final byte[] encodedMessage = cipher.doFinal(byteEncryptedMessage);\n        final String message = new String(encodedMessage, Charset.forName(\"UTF-8\"));\n\n        return message;\n    }\n    catch (GeneralSecurityException e) {\n\n        Log.e(\"%%%%%\", e.getMessage());\n\n        throw new IllegalStateException(\n                \"Unexpected exception during decryption\", e);\n    }\n}\n", "idx": 2659}
{"project": "cipher", "commit_id": "Snippet16596992_39556.java", "target": 1, "func": "Cipher c = Cipher.getInstance(\"AESWrap\", \"SunJCE\");\nc.init(Cipher.WRAP_MODE, secretKey);\nbyte[] result = c.wrap(someKey);\n", "idx": 2399}
{"project": "cipher", "commit_id": "Snippet47243228_29229.java", "target": 1, "func": "package test;\n\nimport java.security.AlgorithmParameters;\nimport java.security.spec.KeySpec;\nimport java.util.Formatter;\nimport javax.crypto.Cipher;\nimport javax.crypto.SecretKey;\nimport javax.crypto.SecretKeyFactory;\nimport javax.crypto.spec.IvParameterSpec;\nimport javax.crypto.spec.PBEKeySpec;\nimport javax.crypto.spec.SecretKeySpec;\n\n/*\n * Issue: Using \"AES/CBC/PKCS5Padding\" encryption, the Initialization Vector\n *        appears to only affect the first block?!? \n * \n * Example Output\n *    iv 1e6376d5d1180cf9fcf7c78d7f1f1b96\n *    bv 00000000000000000000000000000000\n *    I: 222222222222222222222222222222222222222222222222222222222222222222222222222222222222222222222222222222222222222222222222222222222222222222222222222222222222222222222222222222222222222222222222222222222222222222222222222222222222222222222222222222222222222222222222222222222222222222222222222222222222222222222222222222222222222222222222222222222222222222222222222222222222222222222222222222222222222222222222222222222222222222222222222222222222222222222222222222222222222222222222222222222222222222222222222222222222222222222222222222222222222222222222222222222222222222222222222222222222222222222222\n *    E: b35b3945cdcd08e2f8a65b353ff754c32a48d9624e16b616d432ee5f78a26aa295d83625634d1048bf2dbb51fc657b7f796b60066129da5e1e7d3c7b51a30c1d962db75ac6666d4b32513c154b47f18eb66f62d7417cfd77f07f81f27f08d7d818e6910ca5849da3e6cff852bc06317e2d51907879598c8d3ae74074f4c27f7b8e2f74ca04d3ed6ac839b819a0f4cb462d0a4d9497cd917b8bd0aafb590ddd593b5b652cf8f642d3b2cd9dc0981dc1c913d52d065a844ea65e72cd7738eee3b488c4304e884109320dc54668ac4659d6014de9cf19422f7f68157d4330478589533571434d07b1939e56259fb8828823361bc912b84dc6ccdd5878b1d05801e0a6ce099bc86f1356fd145338163d59a07f2efdb1a6f91f4a35e6304f2d15d9972b0dda3c2275b5942a7f032ab6f90138\n *    D: 3c4154f7f33a2edbded5e5af5d3d39b42222222222222222222222222222222222222222222222222222222222222222222222222222222222222222222222222222222222222222222222222222222222222222222222222222222222222222222222222222222222222222222222222222222222222222222222222222222222222222222222222222222222222222222222222222222222222222222222222222222222222222222222222222222222222222222222222222222222222222222222222222222222222222222222222222222222222222222222222222222222222222222222222222222222222222222222222222222222222222222222222222222222222222222222222222222222222222222222222222222222222222222222222222222222222222\n */\npublic class IvBug {\n\n    public static void main(String[] args) throws Exception {\n        // Initialize.\n        final char[] password = \"foo\".toCharArray();\n        final byte[] salt = \"bar\".getBytes();\n\n        byte[] iData = new byte[300];\n        java.util.Arrays.fill(iData, (byte)0x22);               // Make the issue easy to see.\n//      for (int i=0; i<msg.length; i++) msg[i] = (byte) i;     // Alternate fill.\n\n        // Perform the test.\n        SecretKey sKey = generateKey(password,salt);\n        byte[] iv = generateIv(sKey);\n        byte[] eData = encrypt(sKey, iData, iv);\n        byte[] badIv = new byte[iv.length];             // Discard initialization vector.\n        byte[] dData = decrypt(sKey, eData, badIv);\n\n        // Display the results.\n        System.out.println(\"iv \" + hexStr(iv));\n        System.out.println(\"bv \" + hexStr(badIv));\n        System.out.println(\"I: \" + hexStr(iData));      // Initial\n        System.out.println(\"E: \" + hexStr(eData));      // Encrypted\n        System.out.println(\"D: \" + hexStr(dData));      // Decrypted\n    }\n\n    static SecretKey generateKey(char[] password, byte[] salt) throws Exception {\n        SecretKeyFactory factory = SecretKeyFactory.getInstance(\"PBKDF2WithHmacSHA256\");\n        KeySpec spec = new PBEKeySpec(password, salt, 65536, 128);\n        SecretKey tmp = factory.generateSecret(spec);\n        return new SecretKeySpec(tmp.getEncoded(), \"AES\");\n    }\n\n    static byte[] generateIv(SecretKey key) throws Exception {\n        Cipher cipher = Cipher.getInstance(\"AES/CBC/PKCS5Padding\");\n        AlgorithmParameters params = cipher.getParameters();\n        return params.getParameterSpec(IvParameterSpec.class).getIV();\n    }\n\n    static byte[] encrypt(SecretKey key, byte[] data, byte[] iv) throws Exception {\n        Cipher cipher = Cipher.getInstance(\"AES/CBC/PKCS5Padding\");\n        cipher.init(Cipher.ENCRYPT_MODE, key, new IvParameterSpec(iv));\n        return cipher.doFinal(data);\n    }\n\n    static byte[] decrypt(SecretKey key, byte[] data, byte[] iv) throws Exception {\n        Cipher cipher = Cipher.getInstance(\"AES/CBC/PKCS5Padding\");\n        cipher.init(Cipher.DECRYPT_MODE, key, new IvParameterSpec(iv));\n        return cipher.doFinal(data);\n    }\n\n    static String hexStr(byte[] bytes) {\n        try (Formatter formatter = new Formatter()) {\n            for (byte b : bytes) formatter.format(\"%02x\", b);\n            return formatter.toString();\n        }\n    }\n}\n", "idx": 2421}
{"project": "cipher", "commit_id": "Snippet35599799_17497.java", "target": 0, "func": "public class DES {\n\nprivate static final int POLYNOMIAL   = 0x8408;\nprivate static final int PRESET_VALUE = 0x6363;\n\npublic static byte[] gen_sessionKey(byte[] b) {\n\n    byte[] key = new byte[] { (byte) 0x0, (byte) 0x0, (byte) 0x0, (byte) 0x0, (byte) 0x0, (byte) 0x0, (byte) 0x0,\n            (byte) 0x0, (byte) 0x0, (byte) 0x0, (byte) 0x0, (byte) 0x0, (byte) 0x0, (byte) 0x0, (byte) 0x0,\n            (byte) 0x0 };\n    byte[] response = decrypt(key, b);\n    byte[] rndB = response;\n    byte[] rndA = new byte[] { 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00 };\n    byte[] rndAB = new byte[16];\n    System.arraycopy(rndA, 0, rndAB, 0, 8);\n    rndB = leftShift(rndB);\n    rndB = xorBytes(rndA, rndB);\n    rndB = decrypt(key, rndB);\n    System.arraycopy(rndB, 0, rndAB, 8, 8);\n    return rndAB;\n}\npublic static byte[] gen_piccKey(byte[] key) {\n\n    byte[] rndA = new byte[] { 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00 };\n    byte[] rndB = new byte[] { 0x11, 0x22, 0x33, 0x44, 0x55, 0x66, 0x77, (byte) 0x88, (byte) 0x99, (byte) 0xAA, (byte) 0xBB, (byte) 0xCC, (byte) 0xDD, (byte) 0xEE, (byte) 0xFF, (byte) 0xFF };\n    byte[] rndAB = new byte[24];\n    rndA = xorBytes(rndA, rndB);\n    Log.v(\"xor length\", String.valueOf(rndB.length));\n    byte[] rndABC = iso14443a_crc(rndA);\n    byte[] rndABB = iso14443a_crc(rndB);\n    Log.v(\"rnd length\", ByteArrayToHexString(rndABC)+\"\\n\"+ByteArrayToHexString(rndABB));\n    System.arraycopy(rndA, 0, rndAB, 0, 16);\n    System.arraycopy(rndABC, 0, rndAB, 16, 2);\n    System.arraycopy(rndABB, 0, rndAB, 18, 2);\n    byte[] rndABCD = new byte[] { 0x00, 0x00, 0x00, 0x00}; \n    System.arraycopy(rndABCD, 0, rndAB, 20, 4);\n    Log.v(\"final\", ByteArrayToHexString(rndAB));\n    rndAB = decrypt(key , rndAB);\n    return rndAB;\n}\n\nprivate static byte[] xorBytes(byte[] rndA, byte[] rndB) {\n    // TODO Auto-generated method stub\n    byte[] b = new byte[rndB.length];\n    for (int i = 0; i < rndB.length; i++) {\n        b[i] = (byte) (rndA[i] ^ rndB[i]);\n    }\n    return b;\n}\n\n\npublic static byte[] leftShift(byte[] data) {\n    // TODO Auto-generated method stub\n    byte[] temp = new byte[data.length];\n    temp[data.length - 1] = data[0];\n    for (int i = 1; i < data.length; i++) {\n        temp[i - 1] = data[i];\n    }\n    return temp;\n}\n\npublic static byte[] decrypt(byte[] key, byte[] enciphered_data) {\n\n    try {\n        byte[] iv = new byte[] { 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00 };\n        IvParameterSpec ivParameterSpec = new IvParameterSpec(iv);\n        SecretKey s = new SecretKeySpec(key, \"DESede\");\n        Cipher cipher;\n        cipher = Cipher.getInstance(\"DESede/CBC/NoPadding\", \"BC\");\n        cipher.init(Cipher.DECRYPT_MODE, s, ivParameterSpec);\n        byte[] deciphered_data = cipher.doFinal(enciphered_data);\n        return deciphered_data;\n    } catch (NoSuchAlgorithmException e) {\n        // TODO Auto-generated catch block\n        e.printStackTrace();\n    } catch (NoSuchProviderException e) {\n        // TODO Auto-generated catch block\n        e.printStackTrace();\n    } catch (NoSuchPaddingException e) {\n        // TODO Auto-generated catch block\n        e.printStackTrace();\n    } catch (InvalidKeyException e) {\n        // TODO Auto-generated catch block\n        e.printStackTrace();\n    } catch (InvalidAlgorithmParameterException e) {\n        // TODO Auto-generated catch block\n        e.printStackTrace();\n    } catch (IllegalBlockSizeException e) {\n        // TODO Auto-generated catch block\n        e.printStackTrace();\n    } catch (BadPaddingException e) {\n        // TODO Auto-generated catch block\n        e.printStackTrace();\n    }\n    return null;\n}\n\n static byte[] iso14443a_crc(byte[] Data)   // DESFireSAM crc16 do not invert the result\n    {\n        int  bt;\n        int wCrc = 0x6363;\n        int j = 0;\n        int t8 = 0;\n        int t9 = 0;\n        int tA = 0;\n        int Len = Data.length;\n        final int maskB = 0x0000000000000000FF;\n        final int maskW = 0x00000000000000FFFF;\n\n\n        do\n        {\n            bt = Data[j++]              & maskB;\n            bt =  (bt^(wCrc & 0x00FF))  & maskB;\n            bt =  (bt^(bt<<4))          & maskB;\n\n\n            t8 = (bt << 8)          & maskW;\n            t9 = (bt<<3)            & maskW;\n            tA = (bt>>4)            & maskW;\n            wCrc = (wCrc >> 8)^(t8^t9^tA)  & maskW;\n        }\n        while (j < Len);\n\n\n        byte[] bb = new byte[2];\n        bb[0] = (byte) (wCrc          & maskB);\n        bb[1] = (byte) ((wCrc >>8)    & maskB);\n        return bb;\n}\n private static String ByteArrayToHexString(byte[] inarray) {\n        int i, j, in;\n        String[] hex = { \"0\", \"1\", \"2\", \"3\", \"4\", \"5\", \"6\", \"7\", \"8\", \"9\", \"A\", \"B\", \"C\", \"D\", \"E\", \"F\" };\n        String out = \"\";\n\n        for (j = 0; j < inarray.length; ++j) {\n            in = (int) inarray[j] & 0xff;\n            i = (in >> 4) & 0x0f;\n            out += hex[i];\n            i = in & 0x0f;\n            out += hex[i];\n        }\n        return out;\n    }\n", "idx": 2025}
{"project": "cipher", "commit_id": "Snippet41414233_23378.java", "target": 0, "func": "public class CipherStreams {\n    public static void main(String[] args) {\n        try {\n            KeyGenerator keygen = KeyGenerator.getInstance(\"AES\");\n            Key k = keygen.generateKey();\n\n            Cipher aes = Cipher.getInstance(\"AES/ECB/PKCS5Padding\");\n            aes.init(Cipher.ENCRYPT_MODE, k);\n            String fileName = \"Encrypted.txt\";\n            FileOutputStream fs = new FileOutputStream(fileName);\n            CipherOutputStream out = new CipherOutputStream(fs, aes);\n            out.write(\"[Hello:Okay]\\nOkay\".getBytes());\n            out.flush();\n            out.close();\n\n            Cipher aes2 = Cipher.getInstance(\"AES/ECB/PKCS5Padding\");\n            aes2.init(Cipher.DECRYPT_MODE, k);\n\n            FileInputStream fis = new FileInputStream(fileName);\n            CipherInputStream in = new CipherInputStream(fis, aes2);\n            ByteArrayOutputStream baos = new ByteArrayOutputStream();\n\n            byte[] b = new byte[1024];\n            int numberOfBytedRead;\n            while ((numberOfBytedRead = in.read(b)) >= 0) {\n                baos.write(b, 0, numberOfBytedRead);\n            }\n            System.out.println(new String(baos.toByteArray()));\n        }\n        catch (NoSuchAlgorithmException | NoSuchPaddingException | InvalidKeyException | IOException ex) {\n            ex.printStackTrace();\n            ;\n        }\n    }\n}\n", "idx": 2098}
{"project": "cipher", "commit_id": "Snippet34860527_16825.java", "target": 1, "func": "public class EncryptionManager {\n    private static final byte[] keyBytes = new byte[] { 0x00, 0x01, 0x02, 0x03, 0x04, 0x05, 0x06, 0x07, 0x08, 0x09, 0x0a, 0x0b, 0x0c, 0x0d, 0x0e, 0x0f, 0x10, 0x11, 0x12, 0x13, 0x14, 0x15, 0x16, 0x17 };\n    private static final byte[] ivBytes = new byte[] { 0x00, 0x01, 0x02, 0x03, 0x04, 0x05, 0x06, 0x07, 0x08, 0x09, 0x0a, 0x0b, 0x0c, 0x0d, 0x0e, 0x0f };\n\n    public byte[] encrypt(byte[] plaintext) throws Exception {\n        Cipher cipher = getCipher(true);\n        return cipher.doFinal(plaintext);\n    }\n\n    public byte[] decrypt(byte [] ciphertext) throws Exception {\n        Cipher cipher = getCipher(false);\n        return cipher.doFinal(ciphertext);\n    }\n\n    private static Cipher getCipher(boolean encrypt) throws Exception {\n        Cipher cipher = Cipher.getInstance(\"AES/CBC/PKCS5Padding\");\n        SecretKeySpec secretKeySpec = new SecretKeySpec(keyBytes, \"AES\");\n        IvParameterSpec ivParameterSpec = new IvParameterSpec(ivBytes);\n        cipher.init(encrypt ? Cipher.ENCRYPT_MODE : Cipher.DECRYPT_MODE,  \n                    secretKeySpec, ivParameterSpec);\n        return cipher;\n    }\n}\n", "idx": 2375}
{"project": "cipher", "commit_id": "Snippet23317236_5660.java", "target": 1, "func": "public static void GenarationKEY(byte[] data) {\n\n        try {\n            File fileEndSignatuer = new File(\"EndSignatuer.txt\");\n            FileOutputStream fopEndSignatuer = new FileOutputStream(\n                    fileEndSignatuer);\n            // /Read private key from file\n            FileInputStream keyfis = new FileInputStream(\"PiveteKey.txt\");\n            byte[] PrivateKeyB = new byte[keyfis.available()];\n            keyfis.read(PrivateKeyB);\n            keyfis.close();\n            byte[] decodePrivetekey = Base64.decodeBase64(PrivateKeyB);\n            // /get private key\n            PKCS8EncodedKeySpec pubKeySpec = new PKCS8EncodedKeySpec(\n                    decodePrivetekey);\n            KeyFactory keyFactory = KeyFactory.getInstance(\"RSA\");\n            PrivateKey privKey = keyFactory.generatePrivate(pubKeySpec);\n            // / make hash\n            Cipher cipher = Cipher.getInstance(\"RSA\");\n            cipher.init(Cipher.ENCRYPT_MODE, privKey);\n            // /make encoding\n            MessageDigest md5_digest = MessageDigest.getInstance(\"MD5\");\n            byte[] digest = md5_digest.digest(data);\n            byte[] cipherText = cipher.doFinal(digest);\n            byte[] degnatureencode = Base64.encodeBase64(cipherText);\n            fopEndSignatuer.write(degnatureencode);\n            fopEndSignatuer.flush();\n            fopEndSignatuer.close();\n} \n", "idx": 2598}
{"project": "cipher", "commit_id": "Snippet27831154_9988.java", "target": 0, "func": "    public NewJFrame() {try{\n                String key = \"squirrel123\";\n                FileInputStream fis2 = newFileInputStream(\"encrypted.mui\");\n                FileOutputStream fos2 = new FileOutputStream(\"decrypt.rar\");\n\n                decrypt(key, fis2, fos2);\n                Desktop dk=Desktop.getDesktop();\n                File f = new File(\"decrypt.rar\");\n                dk.open(f);\n            }\n                catch (Throwable e) {\n         JOptionPane.showMessageDialog(null, e);\n    }}  \n    public static void decrypt(String key, InputStream is, OutputStream os) throws Throwable {\n    encryptOrDecrypt(key, Cipher.DECRYPT_MODE, is, os);\n}\n\npublic static void encryptOrDecrypt(String key, int mode, InputStream is, OutputStream os) throws Throwable {\n\n    DESKeySpec dks = new DESKeySpec(key.getBytes());\n    SecretKeyFactory skf = SecretKeyFactory.getInstance(\"DES\");\n    SecretKey desKey = skf.generateSecret(dks);\n    Cipher cipher = Cipher.getInstance(\"DES\"); // DES/ECB/PKCS5Padding for SunJCE\n\n    if (mode == Cipher.ENCRYPT_MODE) {\n        cipher.init(Cipher.ENCRYPT_MODE, desKey);\n        CipherInputStream cis = new CipherInputStream(is, cipher);\n        doCopy(cis, os);\n    } else if (mode == Cipher.DECRYPT_MODE) {\n        cipher.init(Cipher.DECRYPT_MODE, desKey);\n        CipherOutputStream cos = new CipherOutputStream(os, cipher);\n        doCopy(is, cos);\n    }\n}\n\npublic static void doCopy(InputStream is, OutputStream os) throws IOException {\n    byte[] bytes = new byte[64];\n    int numBytes;\n    while ((numBytes = is.read(bytes)) != -1) {\n        os.write(bytes, 0, numBytes);\n    }\n    os.flush();\n    os.close();\n    is.close();\n}\n", "idx": 2219}
{"project": "cipher", "commit_id": "Snippet34339600_16312.java", "target": 1, "func": "public static void main(String... args) throws Exception {\n    String masterPassword = \"password\";\n    String base64EncodedKey = \"U2FsdGVkX18QAut2uv9ElKWb2T8QycYS4k0PgjwUtWW2NaBlEmolBwNhPkYDvg986QOYqDs/LVC7mnUUQbrRkbn0sLBbLQ/+oMjvzBpcBRIPqBnQ7bKZjPXZIBDt+15KSRWGSFAnrXVL6Udcecu7t8WNrcUoXy9bgjRpwCzqaMuVRik3sBQNmNbb/4rbf9+NM6tNEZ4KsoHBkcXj4DofzISOBQhmpjfqagjb057vb/8+Pi5cpRl4sO3GPX0Xu8XVTQsLffm3oTTywG9V+2XwXMfvb34SXrJPOkxlHBqjw2GqNx4bhz9buCoLzUFrFfTEeB+gg2yEwFONWhPtV7D/MYAOrZB8P0RaL7oQh1mAnx9ESlFJ5V6VzwbFZGxj7QeaEWG47HFBdSfSuAdibs7N+GtAFv2lQQnEK+li0+rwEYZ+AKeohqe3A6yZDGYpkGvGFr4EDsWEHnYtWl8yL6guLELJxbLXZ8HLLE+W4Sut9l69OS5QeqgLJcuvtw0l1psmrsx8SA/NyFfGNfQE4xi7RPg8qhR3ardEiG6O+IhMMD80PBHFqKZy0jLPRbZA42oApF7isbm4OUQBBrObOpuLMwTCrsMD6DrUUUy1wwd3Ij35mvF7xcJwiYGuE/B3Eqk2UDfDlMXeiWurPJ+px1ie9ZhdfXCTYJOUuRFB25fw0aXFVKO40yrlHoi69B0P2HffO2uH2bzhWQ7KOAqjRyo6mtPn5Xsd+T4rZKWNoWt+fjmLbx+evdDCiF1E/2k8oHAlrvp65DVFhbK69BKFTuMdqr+3sSX9Jl1KPuvJP9fWIk85ncF/K5BbiZ9d47pBt8DFEf+lDhCBSemM0Tjn8fSG6oDlqpdIl7ZXWc/5NhdE6idMQm9bOPbtZWIBM5kJqLpOHLt37vslZFwNv5sq0c2ULwGaBeP1WHfpE0PcaBTTweP3T56ufzo1Larsgw/X3VIXfKM7ZULgbPMQU0SxxBj//jDZJrm+8e782LJJTIMGkcs6B/AOuZCtZVe5gYz1Wlk3JGg+sinBslLyVSP7hFaKHji9KUoBhmyVJajiBYrEVdGLKdyWE7FbGQOZ5rSVNE5kLJ3TBhaejjpHvlJMuGa1WtBmVZTaq2E5ax0wShJixfm+QZMTEhq1ryM3pdsxg0ul1GMLs9x+WRps/F8YHBilwYKEAbqVJxnTRjl8vmqDUS+VrNRYkRHP982DwikzOpTtdlN6+PMta53bw3Q6Qxiiaxhl4SuPYwsV9XcAuDNYu7NcFY+2/IiMJl/ZhLQUXLsbnDT9jUbSi5HVO3W1m65mXX+O/0mFeWmIcf2Ch5aBRhxAtup74V/vKGNVUNY8vU43KrEKFpbD5vc54UY6itQZef3VM+VNqJzQrI9Ka3wKIaY7IWN87KZ/1Odw1ZjdmNQX\";\n    String base64EncodedPassword = \"U2FsdGVkX1+H71VA6yn6cA/A/ojEP2lwCUcorrz8CqkffRHSghm/Q0pDsf/p/FTw\"; //value is 'password'\n    int iterations = 100000;\n\n    Base64.Decoder base64Decoder = Base64.getDecoder();\n\n    byte[] decodedKey = base64Decoder.decode(base64EncodedKey);\n    byte[] salt = Arrays.copyOfRange(decodedKey, 8, 16);\n    byte[] keyData = Arrays.copyOfRange(decodedKey, 16, decodedKey.length);\n\n\n    KeySpec spec = new PBEKeySpec(masterPassword.toCharArray(), salt, iterations, 32 * 8);\n    SecretKeyFactory f = SecretKeyFactory.getInstance(\"PBKDF2WithHmacSHA1\");\n    SecretKey secretKey = f.generateSecret(spec);\n\n    byte[] rawKey = secretKey.getEncoded();\n    byte[] aesRaw = Arrays.copyOfRange(rawKey, 0, 16);\n    byte[] aesIv = Arrays.copyOfRange(rawKey, 16, 32);\n\n    SecretKeySpec aesKey = new SecretKeySpec(aesRaw, \"AES\");\n    Cipher cipher = Cipher.getInstance(\"AES/CBC/NoPadding\");\n    cipher.init(Cipher.DECRYPT_MODE, aesKey, new IvParameterSpec(aesIv));\n\n    byte[] decryptedKey = cipher.doFinal(keyData);\n\n    byte[] decodedPassword = base64Decoder.decode(base64EncodedPassword);\n    byte[] passwordSalt = Arrays.copyOfRange(decodedPassword, 8, 16);\n    byte[] passwordData = Arrays.copyOfRange(decodedPassword, 16,decodedPassword.length);\n    // hmm...\n}\n", "idx": 2456}
{"project": "cipher", "commit_id": "Snippet11311247_35460.java", "target": 0, "func": "Security.addProvider(new BouncyCastleProvider())\nbyte[] bKey = Hex.decode(\"C67DDB0CE47D27FAF6F32ECA5C99E8AF\")\nbyte[] bMsg = Hex.decode(\"ff00\")\n\nbyte[] keyBytes = Arrays.copyOf(sKey.bytes, 24)\nint j = 0, k = 16\nwhile (j < 8) {\n    keyBytes[k++] = keyBytes[j++]\n}\n\nSecretKey key3 = new SecretKeySpec(keyBytes, \"DESede\")\nIvParameterSpec iv3 = new IvParameterSpec(new byte[8])\nCipher cipher3 = Cipher.getInstance(\"DESede/CBC/ZeroBytePadding\")\ncipher3.init(Cipher.ENCRYPT_MODE, key3, iv3)\n\nbyte[] bMac = cipher3.doFinal(bMsg)\nprintln new String(Hex.encode(bMac))\n", "idx": 2162}
{"project": "cipher", "commit_id": "Snippet10782267_35046.java", "target": 0, "func": "static void decrypt() throws IOException, NoSuchAlgorithmException, NoSuchPaddingException, InvalidKeyException {\n    FileInputStream fis = new FileInputStream(\"data/encrypted\");\n\n    FileOutputStream fos = new FileOutputStream(\"data/decrypted\");\n    SecretKeySpec sks = new SecretKeySpec(\"MyDifficultPassw\".getBytes(), \"AES\");\n    Cipher cipher = Cipher.getInstance(\"AES\");\n    cipher.init(Cipher.DECRYPT_MODE, sks);\n    CipherInputStream cis = new CipherInputStream(fis, cipher);\n    int b;\n    byte[] d = new byte[8];\n    while((b = cis.read(d)) != -1) {\n        fos.write(d, 0, b);\n    }\n    fos.flush();\n    fos.close();\n    cis.close();\n}\n", "idx": 1989}
{"project": "cipher", "commit_id": "Snippet29129256_11191.java", "target": 0, "func": "import java.security.*;\nimport java.util.Scanner;\n\nimport javax.crypto.*;\nimport javax.crypto.spec.IvParameterSpec;\n\npublic class MainApp\n{\n    static Scanner sc = new Scanner(System.in);\n    public KeyGenerator keygen;\n    public SecretKey secKey;\n    Cipher c;\n\n    static SecureRandom rnd = new SecureRandom();\n    static IvParameterSpec iv = new IvParameterSpec(rnd.generateSeed(8));\n\n    public static void main(String[] args) throws Exception\n    {\n        MainApp theApp = new MainApp();\n        theApp.start();\n    }\n\n    public void start() throws Exception\n    {\n        keygen = KeyGenerator.getInstance(\"DES\");\n        secKey = keygen.generateKey();\n\n        System.out.println(secKey);\n\n        boolean success = false;\n        boolean success2 = false;\n        boolean exit = false;\n        int type = 0;\n\n        do\n        {\n            do \n            {\n                System.out.println(\"Weclome to the DES Encryption/Decription zone!\");\n                System.out.println(\"What form of mode do you wish to use? [E]CB or [C]BC? Type [Q]uit to exit\");\n                String input = sc.nextLine();\n\n                    if(input.equalsIgnoreCase(\"e\")){\n\n                        type = 1;\n\n                        do{\n                            System.out.println(\"Do you wish to use padding? [Y]es or [N]o?\");\n                            input = sc.nextLine();\n\n                            if(input.equalsIgnoreCase(\"y\")){\n                                c = Cipher.getInstance(\"DES/ECB/PKCS5Padding\");\n                                success = true;\n                                success2 = true;\n                            }\n                            else if(input.equalsIgnoreCase(\"n\")){\n                                c = Cipher.getInstance(\"DES/ECB/NoPadding\");\n                                success = true;\n                                success2 = true;\n                            }\n                            else{\n                                System.out.println(\"Error - please enter a valid input\");\n                                success = false;\n                                success2 = false;\n                            }\n                        }while(!success2);\n\n                    }\n                    else if(input.equalsIgnoreCase(\"c\")){\n\n                        type = 2;\n\n                        do{\n                            System.out.println(\"Do you wish to use padding? [Y]es or [N]o?\");\n                            input = sc.nextLine();\n\n                            if(input.equalsIgnoreCase(\"y\")){\n                                c = Cipher.getInstance(\"DES/CBC/PKCS5Padding\");\n                                success = true;\n                                success2 = true;\n                            }\n                            else if(input.equalsIgnoreCase(\"n\")){\n                                c = Cipher.getInstance(\"DES/CBC/NoPadding\");\n                                success = true;\n                                success2 = true;\n                            }\n                            else{\n                                System.out.println(\"Error - please enter a valid input\");\n                                success = false;\n                                success2 = false;\n                            }\n                        }while(!success2);\n                    }\n\n                    else if(input.equalsIgnoreCase(\"q\")){\n                        System.out.println(\"Thanks for using me!\");\n                        System.exit(0);\n                        success = true;\n                        exit = true;\n                    }\n                    else{\n                        System.out.println(\"Error - please enter a valid input\");\n                        success = false;\n                    }\n            }while(!success);\n\n\n            System.out.println(\"Input what you wish to encrypt\");\n            String input = sc.nextLine();\n\n            byte[] text = input.getBytes();\n\n            System.out.println(type);\n\n            System.out.println(\"--------------------------------------------\");\n\n            System.out.println(\"Text : \" + new String(text));\n\n            byte[] textEncrypted = encrypt(text, c, type);\n\n            System.out.println(\"Text Encrypted : \" + textEncrypted);\n\n            byte[] textDecrypted = decrypt(textEncrypted, c, type);\n\n            System.out.println(\"Text Decrypted : \" + new String(textDecrypted));\n\n            System.out.println(\"--------------------------------------------\");\n\n        }while(!exit);\n    }\n\n    public byte[] encrypt(byte[] b, Cipher c, int type) throws Exception\n    {\n        if(type == 1)\n        {\n        c.init(Cipher.ENCRYPT_MODE, secKey);\n        }\n        else if(type == 2)\n        {   \n            c.init(Cipher.ENCRYPT_MODE, secKey, iv);\n        }\n        byte[] encryptedText = null;\n        try {\n            encryptedText = c.doFinal(b);\n        } catch (IllegalBlockSizeException e) {\n            System.out.println(\"ERROR - If you have selected to not automatically pad your plaintext it must be a mutiple of eight bytes to be accepted. Exiting program\");\n            System.exit(0);\n        } \n\n        return encryptedText;\n    }\n\n    public byte[] decrypt(byte[] b, Cipher c, int type) throws Exception\n    {\n        if(type == 1)\n        {\n        c.init(Cipher.DECRYPT_MODE, secKey);\n        }\n        else if(type == 2)\n        {   \n            c.init(Cipher.DECRYPT_MODE, secKey, iv);\n        }\n\n        byte[] decryptedText = c.doFinal(b);\n\n        return decryptedText;\n\n    }\n\n\n}\n", "idx": 2164}
{"project": "cipher", "commit_id": "Snippet31613311_13733.java", "target": 1, "func": "public class TwofishInStreams {\n\n    public static void main(String[] args) throws Exception {\n        Security.addProvider(new BouncyCastleProvider());\n        Cipher twofish = Cipher.getInstance(\"twofish/cbc/pkcs5padding\");\n        SecretKey twoFishKey = new SecretKeySpec(new byte[16], \"twofish\");\n        IvParameterSpec iv = new IvParameterSpec(new byte[16]);\n        twofish.init(Cipher.ENCRYPT_MODE, twoFishKey, iv);\n        ByteArrayOutputStream baos = new ByteArrayOutputStream();\n        try (CipherOutputStream cos = new CipherOutputStream(baos, twofish)) {\n            cos.write(\"owlstead\".getBytes(StandardCharsets.UTF_8));\n        }\n        System.out.println(Hex.toHexString(baos.toByteArray()));\n    }\n}\n", "idx": 2410}
{"project": "cipher", "commit_id": "Snippet20422593_3068.java", "target": 0, "func": "public class EncodeDecodeAES {\n    private final static String HEX = \"0123456789ABCDEF\";\n\n    private final static int JELLY_BEAN_4_2 = 17;\n\n    private final static byte[] key = { 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,\n            0, 0, 0 };\n\n\n\n    public static String encrypt(String seed, String cleartext)\n            throws Exception {\n\n        byte[] rawKey = getRawKey(seed.getBytes());\n\n        byte[] result = encrypt(rawKey, cleartext.getBytes());\n\n        String fromHex = toHex(result);\n\n        String base64 = new String(Base64.encodeToString(fromHex.getBytes(), 0));\n\n        return base64;\n\n    }\n\n    public static String decrypt(String seed, String encrypted)\n            throws Exception {\n\n        byte[] seedByte = seed.getBytes();\n\n        System.arraycopy(seedByte, 0, key, 0,\n                ((seedByte.length < 16) ? seedByte.length : 16));\n\n        String base64 = new String(Base64.decode(encrypted, 0));\n\n        byte[] rawKey = getRawKey(seedByte);\n\n        byte[] enc = toByte(base64);\n\n        byte[] result = decrypt(rawKey, enc);\n\n        return new String(result);\n\n    }\n\n    public static byte[] encryptBytes(String seed, byte[] cleartext)\n            throws Exception {\n\n        byte[] rawKey = getRawKey(seed.getBytes());\n\n        byte[] result = encrypt(rawKey, cleartext);\n\n        return result;\n\n    }\n\n    public static byte[] decryptBytes(String seed, byte[] encrypted)\n            throws Exception {\n\n        byte[] rawKey = getRawKey(seed.getBytes());\n\n        byte[] result = decrypt(rawKey, encrypted);\n\n        return result;\n\n    }\n\n    private static byte[] getRawKey(byte[] seed) throws Exception {\n\n        KeyGenerator kgen = KeyGenerator.getInstance(\"AES\"); // , \"SC\");\n\n        SecureRandom sr = null;\n\n        if (android.os.Build.VERSION.SDK_INT >= JELLY_BEAN_4_2) {\n\n            sr = SecureRandom.getInstance(\"SHA1PRNG\", \"Crypto\");\n\n        } else {\n            sr = SecureRandom.getInstance(\"SHA1PRNG\");\n\n        }\n\n        sr.setSeed(seed);\n\n        try {\n\n            kgen.init(256, sr);\n\n            // kgen.init(128, sr);\n\n        } catch (Exception e) {\n\n            // Log.w(LOG,\n            // \"This device doesn't suppor 256bits, trying 192bits.\");\n\n            try {\n\n                kgen.init(192, sr);\n\n            } catch (Exception e1) {\n\n                // Log.w(LOG,\n                // \"This device doesn't suppor 192bits, trying 128bits.\");\n\n                kgen.init(128, sr);\n\n            }\n\n        }\n\n        SecretKey skey = kgen.generateKey();\n\n        byte[] raw = skey.getEncoded();\n\n        return raw;\n\n    }\n\n    private static byte[] encrypt(byte[] raw, byte[] clear) throws Exception {\n\n        SecretKeySpec skeySpec = new SecretKeySpec(raw, \"AES\");\n\n        Cipher cipher = Cipher.getInstance(\"AES\"); // /ECB/PKCS7Padding\", \"SC\");\n\n        cipher.init(Cipher.ENCRYPT_MODE, skeySpec);\n\n        byte[] encrypted = cipher.doFinal(clear);\n\n        return encrypted;\n\n    }\n\n    private static byte[] decrypt(byte[] raw, byte[] encrypted)\n            throws Exception {\n\n        SecretKeySpec skeySpec = new SecretKeySpec(raw, \"AES\");\n\n        Cipher cipher = Cipher.getInstance(\"AES\"); // /ECB/PKCS7Padding\", \"SC\");\n\n        cipher.init(Cipher.DECRYPT_MODE, skeySpec);\n\n        byte[] decrypted = cipher.doFinal(encrypted);\n\n        return decrypted;\n\n    }\n\n    public static String toHex(String txt) {\n\n        return toHex(txt.getBytes());\n\n    }\n\n    public static String fromHex(String hex) {\n\n        return new String(toByte(hex));\n\n    }\n\n    public static byte[] toByte(String hexString) {\n\n        int len = hexString.length() / 2;\n\n        byte[] result = new byte[len];\n\n        for (int i = 0; i < len; i++)\n\n            result[i] = Integer.valueOf(hexString.substring(2 * i, 2 * i + 2),\n                    16).byteValue();\n\n        return result;\n\n    }\n\n    public static String toHex(byte[] buf) {\n\n        if (buf == null)\n\n            return \"\";\n\n        StringBuffer result = new StringBuffer(2 * buf.length);\n\n        for (int i = 0; i < buf.length; i++) {\n\n            appendHex(result, buf[i]);\n\n        }\n\n        return result.toString();\n\n    }\n\n private static void appendHex(StringBuffer sb, byte b) {\n\n        sb.append(HEX.charAt((b >> 4) & 0x0f)).append(HEX.charAt(b & 0x0f));\n\n    }\n\n}\n", "idx": 2056}
{"project": "cipher", "commit_id": "Snippet27129435_9295.java", "target": 0, "func": "String key = enc_key;\n\n// Create key and cipher\nKey aesKey = new SecretKeySpec(key.getBytes(), \"AES\");\nCipher cipher = Cipher.getInstance(\"AES\");\n\n// decrypt the text\ncipher.init(Cipher.DECRYPT_MODE, aesKey);\nstrDecrypted = new String(cipher.doFinal(Base64.decodeBase64(encrypted.getBytes())));\n", "idx": 2144}
{"project": "cipher", "commit_id": "Snippet12053299_35990.java", "target": 1, "func": "        KeyGenerator keyGenerator = KeyGenerator.getInstance(\"AES\");\n    keyGenerator.init(128); // 192 and 256 bits may not be available\n\n    SecretKey secretKey = keyGenerator.generateKey();\n\n    Cipher cipher = Cipher.getInstance(\"AES/CBC/PKCS5Padding\");\n\n\n    // By initializing the cipher in CBC mode, an \"initialization vector\" has been randomly\n    // generated. This initialization vector will be necessary to decrypt the encrypted data.\n    // It is safe to store the initialization vector in plain text for later use. You can obtain\n    // it's bytes by calling iv.getIV().\n    cipher.init(Cipher.ENCRYPT_MODE, secretKey);\n    IvParameterSpec iv = cipher.getParameters().getParameterSpec(IvParameterSpec.class);\n        //      IvParameterSpec iv = new IvParameterSpec(IV); //used for the hardcoded one\n\n        byte[] encryptedData = cipher.doFinal(data);\n", "idx": 2746}
{"project": "cipher", "commit_id": "Snippet22585025_4969.java", "target": 1, "func": "public static String encryptWithPublicKey(byte[] message, PublicKey publicKey) throws Exception {\n    PublicKey apiPublicKey = publicKey;\n    Cipher rsaCipher = Cipher.getInstance(\"RSA/ECB/PKCS1Padding\");\n    rsaCipher.init(Cipher.ENCRYPT_MODE, apiPublicKey);\n    byte[] encVal = rsaCipher.doFinal(message);\n    String encryptedValue = new BASE64Encoder().encode(encVal);\n    return encryptedValue;\n}\n\npublic static String decryptWithPrivateKey(byte[] message, PrivateKey privateKey) throws Exception {\n    PrivateKey pKey = privateKey;\n    Cipher rsaCipher = Cipher.getInstance(\"RSA/ECB/PKCS1Padding\");\n    rsaCipher.init(Cipher.DECRYPT_MODE, pKey);\n    byte[] decVal = rsaCipher.doFinal(message);\n    String decryptedValue = new String(decVal);\n    return decryptedValue;\n}\n", "idx": 2360}
{"project": "cipher", "commit_id": "Snippet6252392_32019.java", "target": 1, "func": "public String decrypt(byte[] text) {\n    byte[] crypt = null;\n    String plainText = null;\n    try {\n        final Cipher cipher = Cipher.getInstance(\"AES/CFB/NoPadding\", \"SunJCE\");\n        final SecretKey skeySpec = KeyGenerator.getInstance(\"AES\").generateKey();\n        cipher.init(Cipher.DECRYPT_MODE, skeySpec);\n\n        crypt = cipher.doFinal(text);\n        plainText = new String(crypt);\n\n\n\n    } catch (Exception ex) {\n          throw new RuntimeException(ex);\n    }\n        return plainText;\n}\n", "idx": 2473}
{"project": "cipher", "commit_id": "Snippet39615507_21543.java", "target": 1, "func": "import java.security.KeyFactory;\nimport java.security.KeyPair;\nimport java.security.KeyPairGenerator;\nimport java.security.NoSuchAlgorithmException;\nimport java.security.NoSuchProviderException;\nimport java.security.PrivateKey;\nimport java.security.PublicKey;\nimport java.security.SecureRandom;\nimport java.security.spec.PKCS8EncodedKeySpec;\nimport java.security.spec.X509EncodedKeySpec;\n\nimport javax.crypto.Cipher;\n\n/**\n * @author visruthcv\n *\n */\npublic class CryptographyUtil {\n\n    private static final String ALGORITHM = \"RSA\";\n\n    public static byte[] encrypt(byte[] publicKey, byte[] inputData)\n            throws Exception {\n\n        PublicKey key = KeyFactory.getInstance(ALGORITHM)\n                .generatePublic(new X509EncodedKeySpec(publicKey));\n\n        Cipher cipher = Cipher.getInstance(ALGORITHM);\n        cipher.init(Cipher.PUBLIC_KEY, key);\n\n        byte[] encryptedBytes = cipher.doFinal(inputData);\n\n        return encryptedBytes;\n    }\n\n    public static byte[] decrypt(byte[] privateKey, byte[] inputData)\n            throws Exception {\n\n        PrivateKey key = KeyFactory.getInstance(ALGORITHM)\n                .generatePrivate(new PKCS8EncodedKeySpec(privateKey));\n\n        Cipher cipher = Cipher.getInstance(ALGORITHM);\n        cipher.init(Cipher.PRIVATE_KEY, key);\n\n        byte[] decryptedBytes = cipher.doFinal(inputData);\n\n        return decryptedBytes;\n    }\n\n    public static KeyPair generateKeyPair()\n            throws NoSuchAlgorithmException, NoSuchProviderException {\n\n        KeyPairGenerator keyGen = KeyPairGenerator.getInstance(ALGORITHM);\n\n        SecureRandom random = SecureRandom.getInstance(\"SHA1PRNG\", \"SUN\");\n\n        // 512 is keysize\n        keyGen.initialize(512, random);\n\n        KeyPair generateKeyPair = keyGen.generateKeyPair();\n        return generateKeyPair;\n    }\n\n    public static void main(String[] args) throws Exception {\n\n        KeyPair generateKeyPair = generateKeyPair();\n\n        byte[] publicKey = generateKeyPair.getPublic().getEncoded();\n        byte[] privateKey = generateKeyPair.getPrivate().getEncoded();\n\n        byte[] encryptedData = encrypt(publicKey,\n                \"hi this is Visruth here\".getBytes());\n\n        byte[] decryptedData = decrypt(privateKey, encryptedData);\n\n        System.out.println(new String(decryptedData));\n\n    }\n\n}\n", "idx": 2432}
{"project": "cipher", "commit_id": "Snippet37683385_19645.java", "target": 1, "func": "package szyfrator;\n\nimport java.io.BufferedInputStream;\nimport java.io.File;\nimport java.io.FileInputStream;\nimport java.io.FileOutputStream;\nimport java.io.IOException;\nimport java.security.KeyFactory;\nimport java.security.NoSuchAlgorithmException;\nimport java.security.PrivateKey;\nimport java.security.PublicKey;\nimport java.security.spec.PKCS8EncodedKeySpec;\nimport java.security.spec.X509EncodedKeySpec;\n\nimport javax.crypto.Cipher;\nimport javax.crypto.KeyGenerator;\nimport javax.crypto.SecretKey;\n\nimport org.apache.commons.compress.compressors.bzip2.BZip2CompressorInputStream;\nimport org.apache.commons.compress.utils.IOUtils;\nimport org.apache.tools.bzip2.CBZip2OutputStream;\n\nimport com.google.common.hash.HashCode;\nimport com.google.common.hash.Hashing;\nimport com.google.common.io.Files;\nimport com.sun.org.apache.xml.internal.security.utils.Base64;\n\npublic class Cryptography {\n\n    private static byte[] aesKey;\n    private static String base64AESKey;\n    private static byte[] encryptedAESKey;\n    private static String base64AESEncryptedKey;\n    private static byte[] aesKeyTransformed;\n\n    public static void main(String args[]){\n\n        Cryptography.generateAESkey();\n        Cryptography.encryptAESKey(new File(\"G:\\\\HASHBABYHASH\\\\public.txt\"));\n        Cryptography.decryptAESKey(new File(\"G:\\\\HASHBABYHASH\\\\private.txt\"));\n\n        System.out.println(\"String: \" + Base64.encode(Cryptography.getAesKey()) + \"\\r\\n\");\n        System.out.println(\"Encrypted string: \" + Cryptography.getBase64EncryptedKey() + \"\\r\\n\");\n        System.out.println(\"Decrypted String: \" + Base64.encode(Cryptography.getAesKeyTransformed()) + \"\\r\\n\");\n\n    }\n\n    public static void generateAESkey(){\n\n        try {\n            KeyGenerator    keyGen = KeyGenerator.getInstance(\"AES\");\n\n            keyGen.init(256); \n            SecretKey secretKey = keyGen.generateKey();\n\n            byte[] keyBytes = secretKey.getEncoded(); \n            base64AESKey = Base64.encode(keyBytes); \n\n            aesKey = keyBytes;\n        } catch (NoSuchAlgorithmException e) {\n            e.printStackTrace();\n        }\n    }\n\n    public static void encryptAESKey(File publicKeyFile){\n\n        try {       \n            FileInputStream input = new FileInputStream(publicKeyFile);\n\n            byte[] decoded = Base64.decode(IOUtils.toByteArray(input));     \n\n            X509EncodedKeySpec publicSpec = new X509EncodedKeySpec(decoded);\n            KeyFactory keyFactory = KeyFactory.getInstance(\"RSA\");\n            PublicKey publicKey = keyFactory.generatePublic(publicSpec);   \n\n            Cipher cipher = Cipher.getInstance(\"RSA/ECB/NoPadding\");\n            cipher.init(Cipher.ENCRYPT_MODE, publicKey);  \n\n            encryptedAESKey = cipher.doFinal(aesKey);\n            base64AESEncryptedKey = Base64.encode(encryptedAESKey);\n\n            input.close();\n        }catch (Exception e) {\n            e.printStackTrace();\n        }\n    }\n\n    public static void decryptAESKey(File privateKeyFile){\n\n        try {\n            FileInputStream input = new FileInputStream(privateKeyFile);\n\n            byte[] decoded = Base64.decode(IOUtils.toByteArray(input));\n\n            PKCS8EncodedKeySpec keySpec = new PKCS8EncodedKeySpec(decoded);\n            KeyFactory keyFactory = KeyFactory.getInstance(\"RSA\");\n            PrivateKey privateKey = keyFactory.generatePrivate(keySpec);\n\n            Cipher cipher = Cipher.getInstance(\"RSA/ECB/NoPadding\");\n            cipher.init(Cipher.DECRYPT_MODE, privateKey);  \n\n            aesKeyTransformed = cipher.doFinal(encryptedAESKey);\n            input.close();  \n        }catch (Exception e) {\n            e.printStackTrace();\n        }\n    }\n}\n", "idx": 2743}
{"project": "cipher", "commit_id": "Snippet23148072_5504.java", "target": 1, "func": " public static final String PUBLIC = \"q/9CujExqL6rsMMO22WWIotoXDCw5KEmGQJqL9UJEfoErwZ9ZCm3OwMTSlAMSfoXEMA04Y1rhfYC3MtU/7dYEoREfsvOPGDBWanTKyMzv2otCfiURyQoghEdkhv3ipQQaaErT7lfBKobJsdqJlvxo4PCOUas2Z6YpoMYgthzTiM=\";\n    public static final String EXPONENT = \"AQAB\";\n\n    public static PublicKey getPublicKey() throws Exception{\n        byte[] modulusBytes = Base64.decode(PUBLIC, 0);\n        byte[] exponentBytes = Base64.decode(EXPONENT,    0);\n\n        BigInteger modulus = new BigInteger(1, (modulusBytes) );\n        BigInteger exponent = new BigInteger(1, (exponentBytes));\n\n        RSAPublicKeySpec spec = new RSAPublicKeySpec(modulus, exponent);\n        KeyFactory kf = KeyFactory.getInstance(\"RSA\");\n        return kf.generatePublic(spec);\n    }\n\n    public static byte[] encrypt(Key publicKey, String s) throws Exception{\n        byte[] byteData = s.getBytes(\"UTF-8\");\n        Cipher cipher = Cipher.getInstance(\"RSA/ECB/PKCS1Padding\"); \n        cipher.init(Cipher.ENCRYPT_MODE, publicKey); \n        byte[] encryptedData = cipher.doFinal(byteData);\n        return encryptedData;\n    }\n\n    public static String arrayAsString (byte [] array){\n        String p = \"\";\n        for (int i = 0; i < array.length; i++) {\n            p +=  unsignedToBytes(array[i]);\n            if (i < array.length - 1)\n                p+= \",\";\n        }\n        return p;\n    }\n\n    public static int unsignedToBytes(byte b) {\n        return b & 0xFF;\n    }\n\n   public static void main(String[] args){\n        PublicKey publicKey = getPublicKey();\n        byte [] encrypted = encode(publicKey, \"passwordHere\");\n        String pass = arrayAsString(encrypted);\n        webservice.AuthenticateUser(\"testAdmin\", pass); \n   }\n", "idx": 2563}
{"project": "cipher", "commit_id": "Snippet14095115_37457.java", "target": 0, "func": "import java.security.SecureRandom;\n\nimport javax.crypto.Cipher;\nimport javax.crypto.KeyGenerator;\nimport javax.crypto.SecretKey;\nimport javax.crypto.spec.SecretKeySpec;\n\n/**\n * Usage:\n * <pre>\n * String crypto = AESEncrypt.encrypt(masterpassword, cleartext)\n * ...\n * String cleartext = AESEncrypt.decrypt(masterpassword, crypto)\n * &lt;/pre&gt;\n * @author ferenc.hechler\n */\npublic class AESEncrypt {\n\n    public static String encrypt(String seed, String cleartext) throws Exception {\n        byte[] rawKey = getRawKey(seed.getBytes());\n        byte[] result = encrypt(rawKey, cleartext.getBytes());\n        return toHex(result);\n    }\n\n    public static String decrypt(String seed, String encrypted) throws Exception {\n        byte[] rawKey = getRawKey(seed.getBytes());\n        byte[] enc = toByte(encrypted);\n        byte[] result = decrypt(rawKey, enc);\n        return new String(result);\n    }\n\n    private static byte[] getRawKey(byte[] seed) throws Exception {\n        KeyGenerator kgen = KeyGenerator.getInstance(\"AES\");\n        SecureRandom sr = SecureRandom.getInstance(\"SHA1PRNG\");\n        sr.setSeed(seed);\n        kgen.init(128, sr); // 192 and 256 bits may not be available\n        SecretKey skey = kgen.generateKey();\n        byte[] raw = skey.getEncoded();\n        return raw;\n    }\n\n\n    private static byte[] encrypt(byte[] raw, byte[] clear) throws Exception {\n        SecretKeySpec skeySpec = new SecretKeySpec(raw, \"AES\");\n        Cipher cipher = Cipher.getInstance(\"AES\");\n        cipher.init(Cipher.ENCRYPT_MODE, skeySpec);\n        byte[] encrypted = cipher.doFinal(clear);\n        return encrypted;\n    }\n\n    private static byte[] decrypt(byte[] raw, byte[] encrypted) throws Exception {\n        SecretKeySpec skeySpec = new SecretKeySpec(raw, \"AES\");\n        Cipher cipher = Cipher.getInstance(\"AES\");\n        cipher.init(Cipher.DECRYPT_MODE, skeySpec);\n        byte[] decrypted = cipher.doFinal(encrypted);\n        return decrypted;\n    }\n\n    public static String toHex(String txt) {\n        return toHex(txt.getBytes());\n    }\n    public static String fromHex(String hex) {\n        return new String(toByte(hex));\n    }\n\n    public static byte[] toByte(String hexString) {\n        int len = hexString.length()/2;\n        byte[] result = new byte[len];\n        for (int i = 0; i < len; i++)\n            result[i] = Integer.valueOf(hexString.substring(2*i, 2*i+2), 16).byteValue();\n        return result;\n    }\n\n    public static String toHex(byte[] buf) {\n        if (buf == null)\n            return \"\";\n        StringBuffer result = new StringBuffer(2*buf.length);\n        for (int i = 0; i < buf.length; i++) {\n            appendHex(result, buf[i]);\n        }\n        return result.toString();\n    }\n    private final static String HEX = \"0123456789ABCDEF\";\n    private static void appendHex(StringBuffer sb, byte b) {\n        sb.append(HEX.charAt((b>>4)&0x0f)).append(HEX.charAt(b&0x0f));\n    }\n\n}\n", "idx": 2108}
{"project": "cipher", "commit_id": "Snippet44081175_26174.java", "target": 1, "func": "import javax.crypto.Cipher;\nimport javax.crypto.SecretKey;\nimport javax.crypto.spec.IvParameterSpec;\nimport javax.crypto.spec.SecretKeySpec;\nimport javax.xml.bind.DatatypeConverter;\nimport java.security.SecureRandom;\n\npublic class MainNew {\n\n    public static void main(String[] args) throws Exception{\n        String iv = getEncryptionIV();\n        System.out.println(\" iv = \"+iv);\n\n        String encryptedData= encryptWithIVandKey(iv,encryptionKey,\"hello world! golang is awesome!\");\n        System.out.println(encryptedData);\n        String decryptedData = decrypt (iv,encryptionKey,encryptedData);\n        System.out.println(decryptedData);\n    }\n\n\n    static final String encryptionKey = \"rakesh1@n1111112\";\n\n\n    static byte[] doFinal(int encryptMode, SecretKey key, String iv, byte[] bytes) {\n\n        try {\n            Cipher cipher = Cipher.getInstance(\"AES/CBC/PKCS5Padding\");\n            cipher.init(encryptMode, key, new IvParameterSpec(DatatypeConverter.parseBase64Binary(iv)));\n            byte[] data = cipher.doFinal(bytes);\n\n            return data;\n\n        } catch (Exception e) {\n            e.printStackTrace();\n            System.out.println(e);\n        }\n        return null;\n\n    }\n\n\n\n    static SecretKey generateKey(String passphrase) {\n\n        SecretKey key = null;\n\n        try {\n\n            key = new SecretKeySpec(passphrase.getBytes(\"UTF-8\"), \"AES\");\n\n\n        } catch (Exception e) {\n            e.printStackTrace();\n            System.out.println(e);\n        }\n\n        return key;\n    }\n\n\n\n\n    static String getEncryptionIV() {\n        SecureRandom random = new SecureRandom();\n        byte[] ivBytes = new byte[16];\n        random.nextBytes(ivBytes);\n        return DatatypeConverter.printBase64Binary(ivBytes);\n    }\n\n    static String encryptWithIVandKey( String iv, String passphrase, final String strToEncrypt) {\n        String encryptedStr = \"\";\n\n        try {\n            Cipher cipher = Cipher.getInstance(\"AES/CBC/PKCS5Padding\");\n            SecretKey key = generateKey(passphrase);\n            cipher.init(Cipher.ENCRYPT_MODE, key, new IvParameterSpec(DatatypeConverter.parseBase64Binary(iv)));\n\n            encryptedStr = DatatypeConverter.printBase64Binary(cipher.doFinal(strToEncrypt.getBytes(\"UTF-8\")));\n\n        } catch (Exception e) {\n            e.printStackTrace();\n            System.out.println(e);\n        }\n\n\n        return encryptedStr;\n    }\n\n    static String decrypt(String iv, String passphrase, String ciphertext) {\n        try {\n            SecretKey key = generateKey(passphrase);\n            byte[] decrypted = doFinal(Cipher.DECRYPT_MODE, key, iv, DatatypeConverter.parseBase64Binary(ciphertext));\n            return new String(decrypted, \"UTF-8\");\n        } catch (Exception e) {\n            e.printStackTrace();\n            System.out.println(e);\n        }\n        return \"\";\n    }\n\n}\n", "idx": 2579}
{"project": "cipher", "commit_id": "Snippet40107024_22042.java", "target": 1, "func": "public class Main {\n    private String randomized = \"21232d0960a7b522d3e25141e54ecee6\";\n    private String keySuffix = \"1dad418a\";\n    private String cryptogram = \"00110001 01111000 01111101 01111100 01100001 11011110 10010010 01011011\";\n    private byte[] cryptogramBytes;\n    private String pattern = \"[a-zA-Z1-9\\\\s]*\";\n    private IvParameterSpec ivSpec = null;\n    private Cipher cipher = null;\n\n    public static void main(String... args){\n        char[] elements = { 'a', 'b', 'c', 'd', 'e', 'f', '1', '2', '3', '4', '5', '6', '7', '8', '9', '0' };\n        char[] buff = new char[8];\n        Main main = new Main ();\n        byte[] convertedRandomized = DatatypeConverter.parseHexBinary(main.randomized);\n        main.ivSpec = new IvParameterSpec(convertedRandomized);\n        main.cryptogram = main.cryptogram.replaceAll(\"\\\\s\", \"\");\n        BigInteger bigint = new BigInteger(main.cryptogram, 2);\n        main.cryptogramBytes = bigint.toByteArray();\n        main.cipher = Cipher.getInstance(\"AES/CBC/NoPadding\");\n        main.permGen(elements, 0, 8, buff);\n    }\n\n    public void permGen(char[] s, int i, int k, char[] buff){\n        if (i < k) {\n            for (int j = 0; j < s.length; j++) {\n                buff[i] = s[j];\n                permGen(s, i + 1, k, buff);\n            }\n        } else {\n            String result = decrypt(String.valueOf(buff) + keySuffix);\n            if (result.matches(pattern))\n                System.out.println(\"Key is: \" + String.valueOf(buff) + keySuffix);\n        }\n    }\n\n    public String decrypt(String key){\n        SecretKeySpec skeySpec = new SecretKeySpec(key.getBytes(), \"AES\");\n        cipher.init(Cipher.DECRYPT_MODE, skeySpec, ivSpec);\n        return new String(cipher.doFinal(cryptogramBytes));\n    }\n}\n", "idx": 2675}
{"project": "cipher", "commit_id": "Snippet29603246_11658.java", "target": 1, "func": "public static String decryptWithIV(byte[] key, String encrypted)\n        throws GeneralSecurityException {\n    if (key.length != 16) {\n        throw new IllegalArgumentException(\"Invalid key size.\");\n    }\n\n    byte[] ciphertextBytes = Base64.decodeBase64(encrypted.getBytes());\n    IvParameterSpec iv = new IvParameterSpec(ciphertextBytes, 0, 16);\n    ciphertextBytes = Arrays.copyOfRange(ciphertextBytes, 16,\n            ciphertextBytes.length);\n\n    SecretKeySpec skeySpec = new SecretKeySpec(key, \"AES\");\n\n    Cipher cipher = Cipher.getInstance(\"AES/CBC/NoPadding\");\n    cipher.init(Cipher.DECRYPT_MODE, skeySpec, iv);\n    byte[] original = cipher.doFinal(ciphertextBytes);\n\n    // remove zero bytes at the end\n    int lastLength = original.length;\n    for (int i = original.length - 1; i > original.length - 16; i--) {\n        if (original[i] == (byte) 0) {\n            lastLength--;\n        } else {\n            break;\n        }\n    }\n\n    return new String(original, 0, lastLength);\n}\n", "idx": 2505}
{"project": "cipher", "commit_id": "Snippet21240950_3651.java", "target": 1, "func": "Cipher cipher = Cipher.getInstance(\"AES/CBC/PKCS5Padding\");\nbyte[] keyBytes = new byte[16];\nbyte[] b = passphare.getBytes(\"UTF-8\");\nint len = b.length;\nif (len > keyBytes.length) {\n    len = keyBytes.length;\n}\n\nSystem.arraycopy(b, 0, keyBytes, 0, len);\nSecretKeySpec keySpec = new SecretKeySpec(keyBytes, \"AES\");\nIvParameterSpec ivSpec = new IvParameterSpec(keyBytes);\ncipher.init(opmode, keySpec, ivSpec);\n\ncipher.doFinal(textToEncrypt.getBytes(\"UTF-8\"));\n", "idx": 2415}
{"project": "cipher", "commit_id": "Snippet28308775_10513.java", "target": 1, "func": "    public static String RSAPublicEncryptuion(String text){\n    DataInputStream dis = null;\n    try {\n        File pubKeyFile = new File(\"public_key.der\");\n        dis = new DataInputStream(new FileInputStream(pubKeyFile));\n        byte[] keyBytes = new byte[(int) pubKeyFile.length()];\n        dis.readFully(keyBytes);\n        dis.close();\n        X509EncodedKeySpec keySpec = new X509EncodedKeySpec(keyBytes);\n        KeyFactory keyFactory = KeyFactory.getInstance(\"RSA\");\n        RSAPublicKey publicKey = (RSAPublicKey)keyFactory.generatePublic(keySpec);\n        Cipher cipher = Cipher.getInstance(\"RSA/ECB/PKCS1PADDING\");\n        cipher.init(Cipher.ENCRYPT_MODE, publicKey);\n        String textoEncryptado = new String(cipher.doFinal(text.getBytes()), \"UTF-8\");\n        return textoEncryptado;\n    } catch (FileNotFoundException ex) {\n        Logger.getLogger(RSAEncrypt.class.getName()).log(Level.SEVERE, null, ex);\n    } catch (IOException | NoSuchAlgorithmException | InvalidKeySpecException | NoSuchPaddingException | InvalidKeyException ex) {\n        Logger.getLogger(RSAEncrypt.class.getName()).log(Level.SEVERE, null, ex);\n    } catch (IllegalBlockSizeException | BadPaddingException ex) {\n        Logger.getLogger(RSAEncrypt.class.getName()).log(Level.SEVERE, null, ex);\n    }\n   return \"Error\";\n}\n", "idx": 2656}
{"project": "cipher", "commit_id": "Snippet18589000_1615.java", "target": 0, "func": "public class SymmetricCipherTest {\n    private static final String DEFAULT_ENCRYPTION_ALGORITHM = \"PBEWithMD5AndTripleDES\";\n    public final String ENCODE_INDICATOR_START = \"ENC(\";\n    public final String ENCODE_INDICATOR_END = \")\";\n    public final String APP_ENCRYPTION_KEY_FILE = \"application/.encryption.key\";\n    public static final int INTERATION = 15;\n    private static final byte[] SALT = { (byte) 0xd7, (byte) 0x73, (byte) 0x21, (byte) 0x8c, (byte) 0x7e, (byte) 0xc8, (byte) 0xee,\n            (byte) 0x99 };\n\n//  private static SymmetricCipherTest instance = initApplicaitonKey();\n    private static Base64 base64 = new Base64();\n    private static Cipher encrypter;\n    private static Cipher decrypter;\n//  private final Base64 base64 = new Base64();\n\n    private static final int KEYLENGTH = 256;\n    public final String ERROR_KEY_GENERATION = \"Encryption key generation failed. Please verify the logs.\";\n    public static void main(String[] args) throws InvalidKeySpecException, NoSuchPaddingException, InvalidKeyException, InvalidAlgorithmParameterException, IllegalBlockSizeException, BadPaddingException {\n        String applicationKey=\"abcdefghijklmnopqrstu\";\n        String password=\"HellowWorld\";\n        try{\n            SecretKeyFactory kf = SecretKeyFactory.getInstance(DEFAULT_ENCRYPTION_ALGORITHM);\n            PBEKeySpec keySpec = new PBEKeySpec(applicationKey.toCharArray());\n            SecretKey key = kf.generateSecret(keySpec);\n            Cipher ciph = Cipher.getInstance(DEFAULT_ENCRYPTION_ALGORITHM);\n\n            PBEParameterSpec params = new PBEParameterSpec(SALT, INTERATION);\n            ciph.init(Cipher.ENCRYPT_MODE, key, params);\n            encrypter=ciph;\n            String encriptedString=new String(base64.encode(encrypter.doFinal(password.getBytes())));\n            System.out.println(encriptedString);\n\n            Cipher ciph1 = Cipher.getInstance(DEFAULT_ENCRYPTION_ALGORITHM);\n            ciph1.init(Cipher.DECRYPT_MODE, key, params);\n            decrypter=ciph;\n            String decryiptedString=new String(base64.decode(decrypter.doFinal(encriptedString.getBytes())));\n            System.out.println(decryiptedString);\n\n        }catch(NoSuchAlgorithmException e){\n            System.out.println(\"No such algorithm\");\n        }\n\n    }\n}\n", "idx": 2141}
{"project": "cipher", "commit_id": "Snippet45837757_27906.java", "target": 0, "func": "private String encryptDES(String sessionKey) throws Exception {\n    KeyGenerator keygenerator = KeyGenerator.getInstance(\"DESede\");\n    SecretKey myKey = keygenerator.generateKey();\n    SecureRandom sr = new SecureRandom(); \n    byte [] iv = new byte[8]; \n    sr.nextBytes(iv); \n    IvParameterSpec IV = new IvParameterSpec(iv);\n    Cipher cipher = Cipher.getInstance(\"DESede/CBC/PKCS5Padding\");\n    cipher.init(Cipher.ENCRYPT_MODE, myKey, IV);\n    String encrypted = Base64.encode(cipher.doFinal(sessionKey.getBytes()));\n    return encrypted;\n}\n", "idx": 2230}
{"project": "cipher", "commit_id": "Snippet9907052_34315.java", "target": 0, "func": "Cipher aesCipher = Cipher.getInstance(\"RC4\");\n", "idx": 2071}
{"project": "cipher", "commit_id": "Snippet27783382_9948.java", "target": 1, "func": "    import java.security.MessageDigest;\n    import javax.crypto.spec.SecretKeySpec;\n    import javax.crypto.spec.IvParameterSpec;\n    import javax.crypto.Cipher;\n    import java.util.Base64;\n    import javax.xml.bind.DatatypeConverter;\n\n    public class AESExample {\n        private static byte[] iv = \"0000000000000000\".getBytes();\n        private static String decrypt(String encrypted, String seed)\n                throws Exception {\n            byte[] keyb = seed.getBytes(\"utf-8\");\n            MessageDigest md = MessageDigest.getInstance(\"SHA-256\");\n            byte[] thedigest = md.digest(keyb);\n            SecretKeySpec skey = new SecretKeySpec(thedigest, \"AES\");\n            Cipher dcipher = Cipher.getInstance(\"AES/CBC/PKCS5Padding\");\n            dcipher.init(Cipher.DECRYPT_MODE, new SecretKeySpec(seed.getBytes(\"UTF-8\"), \"AES\"), new IvParameterSpec(iv));\n            byte[] clearbyte = dcipher.doFinal(DatatypeConverter\n                    .parseHexBinary(encrypted));\n            return new String(clearbyte);\n        }\n        public static String encrypt(String content, String key) throws Exception {\n            byte[] input = content.getBytes(\"utf-8\");\n            MessageDigest md = MessageDigest.getInstance(\"SHA-256\");\n            byte[] thedigest = md.digest(key.getBytes(\"utf-8\"));\n            SecretKeySpec skc = new SecretKeySpec(thedigest, \"AES\");\n            Cipher cipher = Cipher.getInstance(\"AES/CBC/PKCS5Padding\");\n            cipher.init(Cipher.ENCRYPT_MODE, new SecretKeySpec(key.getBytes(\"UTF-8\"), \"AES\"), new IvParameterSpec(iv));\n            byte[] cipherText = new byte[cipher.getOutputSize(input.length)];\n            int ctLength = cipher.update(input, 0, input.length, cipherText, 0);\n            ctLength += cipher.doFinal(cipherText, ctLength);\n            return DatatypeConverter.printHexBinary(cipherText);\n        }\n\npublic static String encrypt128(String content, String key) throws Exception {\n        byte[] input = content.getBytes(\"utf-8\");\n        Cipher cipher = Cipher.getInstance(\"AES/CBC/PKCS5Padding\");\n        cipher.init(Cipher.ENCRYPT_MODE, new SecretKeySpec(DatatypeConverter.parseHexBinary(key), \"AES\"), new IvParameterSpec(iv));\n         byte[] encrypted = cipher.doFinal(content.getBytes(\"UTF-8\"));\n        return DatatypeConverter.printHexBinary(encrypted);\n    }\n\n        public static void main(String[] args) throws Exception {\n            String data = \"Here is my string\";\n            String key = \"1234567891123456\";\n            String cipher = AESExample.encrypt(data, key);\n            String decipher = AESExample.decrypt(cipher, key);\n            System.out.println(cipher);\n            System.out.println(decipher);\n            System.out.println(AESExample.encrypt(data, \"1234567891123456\"));\n            System.out.println(AESExample.encrypt128(data, \"d7900701209d3fbac4e214dfeb5f230f\"));\n        }\n    }\n", "idx": 2528}
{"project": "cipher", "commit_id": "Snippet32544436_14659.java", "target": 0, "func": "package experiment;\n\npublic class Experiment implements Serializable {\n    public static void main(String[] args) throws Exception {\n        File data = new File(\"C:\\\\Users\\\\Furze\\\\Desktop\\\\experiment.dat\");   \n        // I only execute the following to encrypt the file, which works fine:\n        Test test = new Test(new VariableMap<String, String>() {{\n            put(\"Name\", \"Furze\");\n        }});   \n        Cipher cipher = Cipher.getInstance(\"Blowfish\");\n        cipher.init(Cipher.ENCRYPT_MODE, new SecretKeySpec(new byte[] {0x00,0x01,0x02,0x03,0x04,0x05,0x06,0x07}, \"Blowfish\"));\n        SealedObject sealedObject = new SealedObject(test, cipher);\n        CipherOutputStream outputStream = new CipherOutputStream(new BufferedOutputStream(new FileOutputStream(data.getPath())), cipher);\n        ObjectOutputStream objectOutput = new ObjectOutputStream(outputStream);\n        objectOutput.writeObject(sealedObject);     \n        objectOutput.close();\n        // I then comment out the above code to test the file, which fails.\n        Cipher cipher = Cipher.getInstance(\"Blowfish\");\n        cipher.init(Cipher.DECRYPT_MODE, new SecretKeySpec(new byte[] {0x00,0x01,0x02,0x03,0x04,0x05,0x06,0x07}, \"Blowfish\"));\n        CipherInputStream inputStream = new CipherInputStream(new BufferedInputStream(new FileInputStream(data.getPath())), cipher);\n        ObjectInputStream objectInput = new ObjectInputStream(inputStream);\n        SealedObject sealedObject = (SealedObject) objectInput.readObject();\n        Test test = (Test) sealedObject.getObject(cipher);\n        System.out.println(test.variables.get(\"Name\"));\n    }\n}\n", "idx": 2068}
{"project": "cipher", "commit_id": "Snippet46637945_28748.java", "target": 0, "func": "public static void main(String args[]) throws NoSuchAlgorithmException, IOException{\n\n    Scanner sc = new Scanner(System.in);  \n    System.out.println(\"Nome fo ficheiro:\");\n    String fileName = sc.nextLine();\n    byte [] byteMsg = getByteMsg(fileName);\n\n\n    //* Declare Encriptor--> Cipher//\n    Cipher cifrador = null;\n    try {\n         cifrador = Cipher.getInstance(\"DES\");\n    } catch (NoSuchPaddingException ex) {\n        System.out.println(\"Problema na mensagem\");\n    }\n\n\n    //* Generate key -->  KeyGenerator*//\n    KeyGenerator kgen = null;\n    try{\n        kgen = KeyGenerator.getInstance(\"DES\");\n    }\n    catch(NoSuchAlgorithmException e){\n        System.out.println(\"Algoritmo de encripta\u00e7\u00e3o n\u00e3o encontrado\");\n    }\n    SecretKey key = kgen.generateKey();\n\n\n    //* Inicialize Encritptor and encrypt message* --> Cipher//\n    try {\n        cifrador.init(1, key);   //1 = Cipher.ENCRYPT_MODE\n\n    } catch (InvalidKeyException ex) {\n        System.out.println(\"Chave de cifragem inv\u00e1lida\");\n    }\n    byte[]byteMsgCod = null;\n    try {\n        byteMsgCod = cifrador.doFinal(byteMsg);\n    } catch (IllegalBlockSizeException ex) {\n        System.out.println(\"Tamanho de Bloco Ilegal\");\n    } catch (BadPaddingException ex) {\n        System.out.println(\"Bad Padding\");\n    }  \n\n\n\n    //* Write encrypted message in the file*//\n    PrintWriter pw = new PrintWriter(fileName);\n    String msgCod = new String(byteMsgCod);\n    System.out.println(msgCod);\n    pw.println(msgCod);\n    pw.close();\n\n\n\n    /* Read text from file */   \n}\nprivate static byte[] getByteMsg(String fileName) throws IOException{\n    //Ler msg do ficheiro\n    Scanner sc = new Scanner(System.in);\n    FileInputStream fis = null;\n\n    try {\n        fis = new FileInputStream(fileName);\n    } catch (FileNotFoundException ex) {\n        System.out.println(\"Ficheiro n\u00e3o encontrado\");\n    }\n\n    byte[] byteMsg = new byte[fis.available()];\n\n    fis.close();\n\n    return byteMsg;\n}\n", "idx": 1994}
{"project": "cipher", "commit_id": "Snippet42501609_24523.java", "target": 0, "func": "    private static void startCrypting(int cipherMode, String key, File inputFile,\n                             File outputFile) throws MediaCodec.CryptoException {\n    try {\n        Key secretKey = new SecretKeySpec(key.getBytes(), \"AES\");\n        Cipher cipher = Cipher.getInstance(\"AES\");\n        cipher.init(cipherMode, secretKey);\n\n        FileInputStream inputStream = new FileInputStream(inputFile);\n        FileOutputStream outputStream = new FileOutputStream(outputFile);\n\n        CipherOutputStream out = new CipherOutputStream(outputStream, cipher);\n        byte[] buffer = new byte[8192];\n        int count;\n        while ((count = inputStream.read(buffer)) > 0) {\n            out.write(buffer, 0, count);\n        }\n\n        out.flush();\n        out.close();\n        outputStream.close();\n        inputStream.close();\n\n    } catch (NoSuchPaddingException | NoSuchAlgorithmException | InvalidKeyException | IOException ex) {\n        ex.printStackTrace();\n    }\n}\n", "idx": 2254}
{"project": "cipher", "commit_id": "Snippet43186915_25321.java", "target": 0, "func": "  public class Java {\n\n       private static SecretKey key = null;         \n       private static Cipher cipher = null;\n\n       public static void main(String[] args) throws Exception\n       {\n          String filename = RESOURCES_DIR + \"toto.enc\";\n\n          byte[] key = Base64.decode(\"2AxIw+/AzDBj83OILV9GDpOs+izDFJEhD6pve/IPsN9=\");\n          SecretKeySpec secretKey = new SecretKeySpec(key, \"AES\");\n          cipher = Cipher.getInstance(\"AES\");\n\n          cipher.init(Cipher.DECRYPT_MODE, secretKey);\n          byte[] test = Base64.decode(readFile(filename));\n          byte[] decryptedBytes = cipher.doFinal(test);\n          String decryptedText = new String(decryptedBytes, \"UTF8\");\n\n          System.out.println(\"After decryption: \" + decryptedText);\n       }\n\n        public final static String RESOURCES_DIR = \"C:/Users/toto/Desktop/\";\n\n        static String readFile(String filename) throws FileNotFoundException, IOException {\n            FileReader fr;\n            BufferedReader br;\n\n            fr = new FileReader(new File(filename));\n            br = new BufferedReader(fr);\n            String str;\n            String res = \"\";\n            while ((str = br.readLine()) != null) {\n                res += str;\n            }\n            return res;\n        }\n    }\n", "idx": 2185}
{"project": "cipher", "commit_id": "Snippet5124438_31469.java", "target": 0, "func": "Cipher c = Cipher.getInstance(\"RC5/CBC/PKCS5Padding\");", "idx": 2073}
{"project": "cipher", "commit_id": "Snippet40443876_22309.java", "target": 1, "func": "KeyGenerator keyGen = KeyGenerator.getInstance(\"AES\");\nkeyGen.init(128);\nSecretKey mSecretKey = keyGen.generateKey();\n\npublic byte[] encrypt(byte[] data) {\n    try {\n        Cipher c = Cipher.getInstance(\"AES/CBC/PKCS5PADDING\");\n        SecretKeySpec k = new SecretKeySpec(mSecretKey.getEncoded(), \"AES\");\n        c.init(Cipher.ENCRYPT_MODE, k);\n        byte[] encryptedData = c.doFinal(data);\n        return Bytes.concat(c.getIV(), encryptedData);\n    } catch (Exception e) {\n        e.printStackTrace();\n    }\n    return null;\n}\n\npublic byte[] decrypt(byte[] encryptedData) {\n    try {\n        byte[] iv = Arrays.copyOfRange(encryptedData, 0, 16);\n        SecretKeySpec k = new SecretKeySpec(mSecretKey.getEncoded(), \"AES\");\n        Cipher c = Cipher.getInstance(\"AES/CBC/PKCS5PADDING\");\n        c.init(Cipher.DECRYPT_MODE, k, new IvParameterSpec(iv));\n        byte[] decrypted = c.doFinal(Arrays.copyOfRange(encryptedData, 16, encryptedData.length));\n        return decrypted;\n    } catch (Exception e) {\n        e.printStackTrace();\n    }\n    return null;\n}\n", "idx": 2439}
{"project": "cipher", "commit_id": "Snippet31238639_13354.java", "target": 0, "func": "Cipher cipher = Cipher.getInstance(\"AES/ECB/PKCS7Padding\", \"BC\");\n", "idx": 2038}
{"project": "cipher", "commit_id": "Snippet36062003_17964.java", "target": 1, "func": "import javax.crypto.*;\nimport java.io.ByteArrayInputStream;\nimport java.io.ByteArrayOutputStream;\nimport java.security.Key;\nimport java.security.Provider;\nimport java.security.Security;\nimport org.bouncycastle.jce.provider.BouncyCastleProvider;\nimport org.bouncycastle.util.encoders.Hex;\n\npublic class Main {\n\npublic static BouncyCastleProvider bc = new BouncyCastleProvider();\n\nstatic {\n    Security.addProvider(bc);\n}\n\npublic static void main(String[] args) {\n    byte[] data = \"This is message, length=32 bytes\".getBytes();\n\n    Key key;\n    CipherInputStream       cIn;\n    CipherOutputStream      cOut;\n    ByteArrayInputStream    bIn;\n    ByteArrayOutputStream   bOut;\n    byte[]                  bytes;\n\n    byte[] keyData = Hex.decode(\"8182838485868788898a8b8c8d8e8f80d1d2d3d4d5d6d7d8d9dadbdcdddedfd0\");\n\n    key = new SecretKeySpec(keyData,\"GOST28147\");\n\n    Cipher cipher = Cipher.getInstance(\"GOST28147/ECB/NoPadding\", bc);\n\n    cipher.init(Cipher.ENCRYPT_MODE, key); //Exception in thread \"main\" java.security.InvalidKeyException: Illegal key size or default parameters\n\n    bOut = new ByteArrayOutputStream();\n\n    cOut = new CipherOutputStream(bOut, cipher);\n\n    for (int i = 0; i != data.length / 2; i++)\n    {\n        cOut.write(data[i]);\n    }\n    cOut.write(data, data.length / 2, data.length - data.length / 2);\n    cOut.close();\n\n    bytes = bOut.toByteArray();\n\n    System.out.print(key.toString() + System.lineSeparator());\n    System.out.print(byteArrayToString(bytes) + System.lineSeparator());\n}\n}\n", "idx": 2351}
{"project": "cipher", "commit_id": "Snippet27051499_9201.java", "target": 1, "func": "public AESCipher(Key key) {\n        this(key.getEncoded());\n    }\n\n    /**\n     * Create AESCipher based on existing {@link Key} and Initial Vector (iv) in bytes\n     *\n     * @param key Key\n     */\n    public AESCipher(Key key, byte[] iv) {\n        this(key.getEncoded(), iv);\n    }\n\n    /**\n     * <p>Create AESCipher using a byte[] array as a key</p>\n     * <p/>\n     * <p><strong>NOTE:</strong> Uses an Initial Vector of 16 0x0 bytes. This should not be used to create strong security.</p>\n     *\n     * @param key Key\n     */\n    public AESCipher(byte[] key) {\n        this(key, INITIAL_IV);\n    }\n\n    private AESCipher(byte[] key, byte[] iv) {\n        try {\n            this.secretKeySpec = new SecretKeySpec(key, \"AES\");\n            this.iv = new IvParameterSpec(iv);\n            this.cipher = Cipher.getInstance(ALGORITHM_AES256);\n        } catch (NoSuchAlgorithmException | NoSuchPaddingException e) {\n            throw Throwables.propagate(e);\n        }\n    }\n", "idx": 2438}
{"project": "cipher", "commit_id": "Snippet22745803_5148.java", "target": 1, "func": "Cipher cipher = Cipher.getInstance(\"RSA\");\n", "idx": 2636}
{"project": "cipher", "commit_id": "Snippet45911218_27986.java", "target": 1, "func": "private static byte[] encrypt(byte[] data, byte[] key) throws Exception {\n    Cipher cipher = Cipher.getInstance(\"AES/CBC/PKCS5Padding\");\n    byte[] iv = new byte[cipher.getBlockSize()];\n    IvParameterSpec ivParams = new IvParameterSpec(iv);\n    cipher.init(Cipher.ENCRYPT_MODE, new SecretKeySpec(key, \"AES\"), ivParams);\n    return cipher.doFinal(data);\n}\n\nprivate static byte[] decrypt(byte[] encrypted, byte[] key) throws Exception {\n    Cipher cipher = Cipher.getInstance(\"AES/CBC/PKCS5Padding\");\n    byte[] ivByte = new byte[cipher.getBlockSize()];\n    IvParameterSpec ivParamsSpec = new IvParameterSpec(ivByte);\n    cipher.init(Cipher.DECRYPT_MODE, new SecretKeySpec(key, \"AES\"), ivParamsSpec);\n    return cipher.doFinal(encrypted);\n}\n", "idx": 2724}
{"project": "cipher", "commit_id": "Snippet16212408_39172.java", "target": 1, "func": " private void mDecrypt_File(FileInputStream fin, String outFile) throws Exception {\n    FileOutputStream fout = new FileOutputStream(outFile);\n\n    byte[] iv = new byte[16];\n    byte[] salt = new byte[16];\n    byte[] len = new byte[8];\n    byte[] FC_TAGBuffer = new byte[8];\n\n    Cipher cipher = Cipher.getInstance(CIPHER_INSTANCE);\n\n    DataInputStream dis = new DataInputStream(fin);\n\n    dis.read(iv, 0, 16);\n    dis.read(salt, 0, 16);\n\n    Rfc2898DeriveBytes rfc = new Rfc2898DeriveBytes(DEFAULT_PASSWORD, salt, F_ITERATIONS);\n    SecretKey key = new SecretKeySpec(rfc.getBytes(32), \"AES\");\n\n    //decryption code\n    cipher.init(Cipher.DECRYPT_MODE, key, new IvParameterSpec(iv));\n    CipherInputStream cIn = new CipherInputStream(dis, cipher);\n\n    cIn.read(len, 0, 8);\n    long lSize = getLong(len, 0);\n\n    cIn.read(FC_TAGBuffer, 0, 8);\n\n    byte[] tempFC_TAGBuffer = changeByteArray(FC_TAGBuffer, 0);//new byte[8];                           \n\n    BigInteger ulong = new BigInteger(1, tempFC_TAGBuffer);\n\n    if (!ulong.equals(FC_TAG)) {\n        Exception ex = new Exception(\"Tags are not equal\");\n        throw ex;\n    }\n\n    byte[] bytes = new byte[BUFFER_SIZE];\n    //determine number of reads to process on the file                          \n    long numReads = lSize / BUFFER_SIZE;\n    // determine what is left of the file, after numReads                   \n    long slack = (long) lSize % BUFFER_SIZE;\n\n    int read = -1;\n    int value = 0;\n    int outValue = 0;\n\n    MessageDigest md = MessageDigest.getInstance(\"SHA-256\");\n    md.reset();\n    // read the buffer_sized chunks         \n    for (int i = 0; i < numReads; ++i) {\n        read = cIn.read(bytes, 0, bytes.length);\n        fout.write(bytes, 0, read);\n        md.update(bytes, 0, read);\n        value += read;\n        outValue += read;\n    }\n    // now read the slack                   \n    if (slack > 0) {\n        read = cIn.read(bytes, 0, (int) slack);\n        fout.write(bytes, 0, read);\n        md.update(bytes, 0, read);\n        value += read;\n        outValue += read;\n    }\n    fout.flush();\n    fout.close();\n    byte[] curHash = md.digest();\n\n    byte[] oldHash = new byte[md.getDigestLength()];\n    read = cIn.read(oldHash, 0, oldHash.length);\n    if (oldHash.length != read || (!CheckByteArrays(oldHash, curHash))) {\n        Exception ex = new Exception(\"File Corrupted!\");\n        throw ex;\n    }\n    if (outValue != lSize) {\n        Exception ex = new Exception(\"File Sizes don't match!\");\n        throw ex;\n    }\n}\n", "idx": 2584}
{"project": "cipher", "commit_id": "Snippet47351743_29341.java", "target": 1, "func": "public static String decryptionWithFile(String encrypted,String privateFile2)throws Exception  {\n    PrivateKey privateKey = getPrivateKey(privateFile2);\n\n    Cipher cipher = Cipher.getInstance(\"RSA/ECB/PKCS1Padding\");\n    cipher.init(Cipher.DECRYPT_MODE, privateKey);\n    byte[] bts = Hex.decodeHex(encrypted.toCharArray());\n    bts = cipher.doFinal(bts);\n\n\n    bts = getFinalBytesOfDycryptedString(bts);\n    String decryptedMessage = new String(cipher.doFinal(encrypted.getBytes()));\n    return new String(bts,\"UTF-8\");\n}\n", "idx": 2515}
{"project": "cipher", "commit_id": "Snippet39718278_21623.java", "target": 0, "func": "public class EncUtil {\n    //String enc_key = \"ea3401cec22dec24e9756a71904b8515\";\n        public String  encmsg(String msg,String enc_key)\n            {\n                try {\n                    SecretKeySpec skeySpec = new SecretKeySpec(HexfromString(enc_key), \"AES\");\n                    Cipher cipher = Cipher.getInstance(\"AES\");\n                    cipher.init(1, skeySpec);\n\n                    byte encstr[] = cipher.doFinal(msg.getBytes());\n\n                    String decmsg=\"\"+HextoString(encstr);\n//                    System.out.println(decmsg);\n\n                    return \"\"+decmsg;\n\n                } catch (InvalidKeyException e) {\n                    // TODO Auto-generated catch block\n                    e.printStackTrace();\n                } catch (NoSuchAlgorithmException e) {\n                    // TODO Auto-generated catch block\n                    e.printStackTrace();\n                } catch (NoSuchPaddingException e) {\n                    // TODO Auto-generated catch block\n                    e.printStackTrace();\n                } catch (IllegalBlockSizeException e) {\n                    // TODO Auto-generated catch block\n                    e.printStackTrace();\n                } catch (BadPaddingException e) {\n                    // TODO Auto-generated catch block\n                    e.printStackTrace();\n                }catch (NullPointerException e){\n                    e.printStackTrace();\n                }\n                return \"0\";\n\n        }\n", "idx": 2004}
{"project": "cipher", "commit_id": "Snippet11924988_35903.java", "target": 0, "func": " byte[] keyBytes = \"vikoAmrPass12345\".getBytes(); \n SecretKeySpec key = new SecretKeySpec(keyBytes, \"AES\"); \n Cipher cipher = Cipher.getInstance(\"AES/ECB/NoPadding\"); \n cipher.init(Cipher.DECRYPT_MODE, key); \n byte [] out = cipher.doFinal(inv); \n System.out.println(\"Decrypted: \" +new String(out));\n", "idx": 1928}
{"project": "cipher", "commit_id": "Snippet28190858_10360.java", "target": 1, "func": "private byte[] decryptSecretKeyData(byte[] encryptedSecretKey, byte[] iv, PrivateKey privateKey) throws Exception \n{\n    try {\n\n        Provider provider= new sun.security.pkcs11.SunPKCS11(keyStoreFile1);\n        Security.addProvider(provider);\n\n        LOG.info(\"**************Inside decryptSecretKeyData***********************\");\n        Cipher rsaCipher = Cipher.getInstance(\"RSA/ECB/OAEPWITHSHA-256ANDMGF1PADDING\", provider);\n\n        // decrypting the session key with rsa no padding.\n        rsaCipher.init(Cipher.DECRYPT_MODE, privateKey); \n\n        /* The reason is RSA OAEP SHA256 is not supported in HSM. */\n        byte[] decKey = rsaCipher.doFinal(encryptedSecretKey);\n\n        OAEPEncoding encode = new OAEPEncoding(new RSAEngine(), new SHA256Digest(), iv);\n        LOG.info(\"******************RSAPublicKey rsaPublickey = (*****************************\");\n\n        java.security.interfaces.RSAPublicKey rsaPublickey = (java.security.interfaces.RSAPublicKey) publicKeyFile;\n        RSAKeyParameters keyParams = new RSAKeyParameters(false, rsaPublickey.getModulus(), EXPONENT);\n        encode.init(false, keyParams);\n\n        LOG.info(\"******************encode.processBlock(decKey, 0, decKey.length);************************\");\n        byte decryptedSecKey[] = encode.processBlock(decKey, 0, decKey.length);\n\n        return decryptedSecKey;\n    } catch (InvalidCipherTextException e) {\n        LOG.info(\"*******************Failed to decrypt AES secret key using RSA :**********************\");\n        throw new Exception(\"Failed to decrypt AES secret key using RSA :\" + e.toString());\n    }\n\n}\n", "idx": 2517}
{"project": "cipher", "commit_id": "Snippet7914231_32996.java", "target": 0, "func": "package Algorithms;\n\nimport java.io.UnsupportedEncodingException;\nimport java.security.InvalidKeyException;\nimport java.security.MessageDigest;\nimport java.security.NoSuchAlgorithmException;\nimport java.util.Arrays;\n\nimport javax.crypto.BadPaddingException;\nimport javax.crypto.Cipher;\nimport javax.crypto.IllegalBlockSizeException;\nimport javax.crypto.NoSuchPaddingException;\nimport javax.crypto.spec.SecretKeySpec;\n\npublic class MyDES {\n    public static String encrypt(String pass,String plainText) throws NoSuchAlgorithmException, UnsupportedEncodingException, NoSuchPaddingException, InvalidKeyException, IllegalBlockSizeException, BadPaddingException{\n        byte[] key = pass.getBytes(\"UTF-8\"); //get byte arrays of the given password\n        MessageDigest sha = MessageDigest.getInstance(\"SHA-1\"); //get SHA-1 hashing instance\n        key=sha.digest(key); //has the given password\n        key=Arrays.copyOf(key,24);//take the first 16 bytes as the key for DES encryption\n\n        SecretKeySpec sks = new SecretKeySpec(key, \"DESede\");//key spec for 3-DES\n        Cipher c = Cipher.getInstance(\"DESede\");//get an instance of 3DES\n        c.init(Cipher.ENCRYPT_MODE,sks); //initialize 3DES to encrypt mode with given parameters\n        byte[] cipherTextBytes = c.doFinal(plainText.getBytes()); //encrypt\n\n        System.out.println(\"key used: \"+new String(key)+\" cipher generated \"+new String(cipherTextBytes));\n        StringBuffer cipherText= new StringBuffer();\n        for(int i=0;i<cipherTextBytes.length;i++)\n        {\n            cipherText.append(Integer.toHexString(cipherTextBytes[i]));\n        }\n\n        System.out.println(\"Final Cipher returned: \"+cipherText.toString());\n        return cipherText.toString();\n    }\n\n    public static String decrypt(String pass,String cipherText) throws UnsupportedEncodingException, NoSuchAlgorithmException, NoSuchPaddingException, InvalidKeyException, IllegalBlockSizeException, BadPaddingException{\n        System.out.println(\"Initially in decryption-> pass:\"+pass+\" cipher: \"+cipherText);\n        byte[] byteArray = new byte[cipherText.length() / 2];\n        int j=0;\n        for(int k=0;k<cipherText.length()-1;k+=2)\n        {\n            String o= cipherText.substring(k,k+2);\n            int dec = Integer.parseInt(o,16);\n            byteArray[j++] = (byte)dec;\n        }\n\n        String plainText=\"\";\n        byte[] key = pass.getBytes(\"UTF-8\");\n        MessageDigest sha = MessageDigest.getInstance(\"SHA-1\");\n        key=sha.digest(key);\n        key=Arrays.copyOf(key,24);\n        System.out.println(\"\\nkey obtained: \"+new String(key)+\"\\n Later cipher text:-> \"+new String(byteArray));\n\n        SecretKeySpec sks = new SecretKeySpec(key, \"DESede\");\n        Cipher c = Cipher.getInstance(\"DESede\");\n        c.init(Cipher.DECRYPT_MODE,sks);\n        plainText = new String(c.doFinal(byteArray));\n        return plainText;\n    }\n\n}\n", "idx": 2016}
{"project": "cipher", "commit_id": "Snippet28389807_10556.java", "target": 1, "func": "package com.test;\n\nimport java.io.UnsupportedEncodingException;\nimport java.security.AlgorithmParameters;\nimport java.security.InvalidAlgorithmParameterException;\nimport java.security.InvalidKeyException;\nimport java.security.NoSuchAlgorithmException;\nimport java.security.SecureRandom;\nimport java.security.spec.InvalidParameterSpecException;\nimport java.util.Random;\nimport java.util.logging.Level;\nimport java.util.logging.Logger;\nimport java.util.prefs.Preferences;\nimport javax.crypto.BadPaddingException;\nimport javax.crypto.Cipher;\nimport javax.crypto.IllegalBlockSizeException;\nimport javax.crypto.KeyGenerator;\nimport javax.crypto.SecretKey;\nimport javax.crypto.spec.IvParameterSpec;\nimport org.apache.commons.codec.binary.Base64;\n\npublic class Settings {\n    private Preferences prefs = null;\n    private byte[] iv = null;\n    private SecretKey secret = null;\n    Cipher cipher = null;\n\n    public static void main(String[] args){\n       Settings t = new Settings();\n       String encText = t.encryptText(\"HELLO\");//Encrypt a value\n       String output = t.decryptText(encText);//Decrypt the value\n       System.out.println(output); //Display the decrypted value.\n    }\n\n    public Settings(){\n        try {\n            String parentClass = new Exception().getStackTrace()[1].getClassName();//Really only controls where the prefs go, shouldn't matter.\n            this.prefs = Preferences.userNodeForPackage(Class.forName(parentClass));\n            Random r = new SecureRandom();\n            KeyGenerator keyGen = KeyGenerator.getInstance(\"AES\");\n            keyGen.init(128); // 128 bit key\n            this.secret = keyGen.generateKey();\n\n            cipher = Cipher.getInstance(\"AES/CBC/PKCS5Padding\");\n        } catch (NoSuchAlgorithmException ex) {\n            Logger.getLogger(this.getClass().getName()).log(Level.SEVERE, null, ex);\n        } catch (Exception ex) {\n            Logger.getLogger(this.getClass().getName()).log(Level.SEVERE, null, ex);\n        }\n    }\n        private String encryptText(String plainText){\n        try {\n            cipher.init(Cipher.ENCRYPT_MODE, this.secret);\n            AlgorithmParameters params = cipher.getParameters();\n\n            this.iv = prefs.getByteArray(\"IV\", null);\n            if(this.iv == null){\n                this.iv = params.getParameterSpec(IvParameterSpec.class).getIV();\n                prefs.putByteArray(\"IV\", this.iv);\n            }\n            byte[] ciphertext = cipher.doFinal(plainText.getBytes(\"UTF-8\"));\n            String ret = new String(Base64.encodeBase64(ciphertext));\n            return ret;\n        } catch (InvalidParameterSpecException | IllegalBlockSizeException | BadPaddingException | UnsupportedEncodingException | InvalidKeyException ex) {\n            Logger.getLogger(this.getClass().getName()).log(Level.SEVERE, null, ex);\n        }\n        return \"\";\n   }\n    private String decryptText(String cipherText){\n        try {\n            this.iv = prefs.getByteArray(\"IV\", null);\n            byte[] cText = Base64.decodeBase64(cipherText); \n            cipher.init(Cipher.DECRYPT_MODE, this.secret, new IvParameterSpec(this.iv));\n            String ret = new String(cipher.doFinal(cText), \"UTF-8\");\n            return ret;\n        } catch (IllegalBlockSizeException | BadPaddingException | UnsupportedEncodingException | InvalidKeyException | InvalidAlgorithmParameterException ex) {\n            Logger.getLogger(this.getClass().getName()).log(Level.SEVERE, null, ex);\n        }\n        return \"\";\n   }\n}\n", "idx": 2355}
{"project": "cipher", "commit_id": "Snippet40274794_22173.java", "target": 1, "func": "public class MysteryHandler {\n\n    private static SecretKey secretKey;\n    private static Cipher cipher;\n    private static byte[] utf8Bytes;\n\n    /**Verschluesseln*/\n    public static byte[] encrypt(String plainText){\n        try {\n            secretKey = KeyGenerator.getInstance(\"AES\").generateKey();\n            cipher = Cipher.getInstance(\"AES/CBC/PKCS7PADDING\");\n            cipher.init(Cipher.ENCRYPT_MODE, secretKey);\n            utf8Bytes = plainText.getBytes(\"UTF8\");\n            return cipher.doFinal(utf8Bytes);\n        } catch (Exception e) {\n            e.printStackTrace();\n            return null;\n        }\n    }\n\n    /**Entschluesseln*/\n    public static String decrypt(byte[] secret){\n        try {\n            cipher = Cipher.getInstance(\"AES/CBC/PKCS7PADDING\");\n            cipher.init(Cipher.DECRYPT_MODE, secretKey, new IvParameterSpec(secret, secret.length - 16, 16));\n            utf8Bytes = cipher.doFinal(secret);\n            return new String(utf8Bytes, \"UTF8\");\n        } catch (Exception e) {\n            e.printStackTrace();\n            return null;\n        }\n\n    }\n\n}\n", "idx": 2683}
{"project": "cipher", "commit_id": "Snippet33419530_15468.java", "target": 1, "func": "import javax.crypto.Cipher;\nimport javax.crypto.spec.IvParameterSpec;\nimport javax.crypto.spec.SecretKeySpec;\n\n\npublic class AESEncr {\n\n    static String IV = \"AAAAAAAAAAAAAAAA\";\n    static String encryptionKey = \"0123456789abcdef\";\n\n    public static byte[] encrypt(byte[] data) throws Exception {\n        Cipher cipher = Cipher.getInstance(\"AES/CBC/PKCS5Padding\");\n        SecretKeySpec key = new SecretKeySpec(encryptionKey.getBytes(\"UTF-8\"), \"AES\");\n        cipher.init(Cipher.ENCRYPT_MODE, key,new IvParameterSpec(IV.getBytes(\"UTF-8\")));\n        return cipher.doFinal(data);\n    }\n\n    public static byte[] decrypt(byte[] cipherText) throws Exception{\n        Cipher cipher = Cipher.getInstance(\"AES/CBC/PKCS5Padding\");\n        SecretKeySpec key = new SecretKeySpec(encryptionKey.getBytes(\"UTF-8\"), \"AES\");\n        cipher.init(Cipher.DECRYPT_MODE, key,new IvParameterSpec(IV.getBytes(\"UTF-8\")));\n        return cipher.doFinal(cipherText);\n    }\n}\n", "idx": 2407}
{"project": "cipher", "commit_id": "Snippet3181250_30614.java", "target": 0, "func": "Cipher c1 = Cipher.getInstance(\"DES\");\n", "idx": 2015}
{"project": "cipher", "commit_id": "Snippet40402357_22265.java", "target": 0, "func": "public static String decrypt(String encryptedText) {\n    try {\n        byte[] keyData = secret_key.getBytes();\n        SecretKeySpec secretKey = new SecretKeySpec(keyData, \"AES/ECB/PKCS7Padding\");\n        Cipher cipher = Cipher.getInstance(\"AES/ECB/PKCS7Padding\");\n        cipher.init(Cipher.DECRYPT_MODE, secretKey);\n\n        byte[] cipherText = Base64.decode(encryptedText,Base64.NO_WRAP);\n        String decryptedString = new String(cipher.doFinal(cipherText),\"UTF-8\");\n\n        return decryptedString;\n    } catch (Exception e) {\n        e.printStackTrace();\n    }\n    return null;\n}\n", "idx": 2149}
{"project": "cipher", "commit_id": "Snippet47495440_29473.java", "target": 1, "func": "public class PasswordEncryption {\n    private final static int DerivationIterations = 1000;\n     private final int Keysize = 256;\n\n    private static byte[] getSalt() throws NoSuchAlgorithmException {\n        SecureRandom sr = new SecureRandom();\n        byte[] salt = new byte[32];\n        sr.nextBytes(salt);\n        return salt;\n    }\n\n    public static String Encrypt(String plainText, String passPhrase)\n             {\n        Security.addProvider(new org.bouncycastle.jce.provider.BouncyCastleProvider());\n        byte[] saltStringBytes = getSalt();\n        byte[] IvStringBytes=getSalt();\n        byte[] pwd = plainText.getBytes(\"UTF-8\");\n        char[] chars = passPhrase.toCharArray();\n        SecretKeyFactory factory = SecretKeyFactory.getInstance(\"PBKDF2WithHmacSHA1\");\n        KeySpec pbeKeySpec = new PBEKeySpec(chars, saltStringBytes, DerivationIterations, 256);\n        SecretKey secretKey = factory.generateSecret(pbeKeySpec);\n        System.out.println(secretKey.toString());\n        SecretKey secret = new SecretKeySpec(secretKey.getEncoded(), \"AES\");\n        Cipher cipher = Cipher.getInstance(\"AES/CBC/PKCS7Padding\",\"BC\");\n        cipher.init(Cipher.ENCRYPT_MODE, secret);\n        byte[] result = cipher.doFinal(pwd);\n        ByteArrayOutputStream outputStream = new ByteArrayOutputStream();\n        outputStream.write(saltStringBytes);\n        outputStream.write(IvStringBytes);\n        outputStream.write(result);\n\n        byte end[] = outputStream.toByteArray();\n\n        String base64Encoded = Base64.getEncoder().encodeToString(end);\n        System.out.println(base64Encoded);\n\n        return base64Encoded;\n\n    }\n\n    public static void main(String[] args) {\n        Encrypt(\"passwordhere\", \"ABC\");\n    }\n\n}\n", "idx": 2591}
{"project": "cipher", "commit_id": "Snippet39669917_21566.java", "target": 1, "func": "package com.company;\nimport com.hazelcast.util.Base64;\nimport javax.crypto.*;\nimport javax.crypto.spec.*;\n\nclass Encryption {\n\n    public static String encrypt (String strKey, String strIv, String str) {\n        String secret = \"\";\n        try{\n            byte[] key = Base64.decode(strKey.getBytes());\n            byte[] iv  = Base64.decode(strIv.getBytes());\n\n            SecretKeySpec keyspec = new SecretKeySpec(key, \"AES\");\n            IvParameterSpec ivspec = new IvParameterSpec(iv);\n            Cipher cipher = Cipher.getInstance(\"AES/CBC/PKCS5Padding\");\n\n            cipher.init(Cipher.ENCRYPT_MODE, keyspec, ivspec);\n            secret = new String(Base64.encode(cipher.doFinal(str.getBytes())));\n\n        }\n        catch(Exception e){\n            e.printStackTrace();\n        }\n        return secret;\n    }\n\n    public static String decrypt (String strKey, String strIv, String str) {\n        String secret = \"\";\n        try{\n\n            byte[] key = Base64.decode(strKey.getBytes());\n            byte[] iv  = Base64.decode(strIv.getBytes());\n\n\n            SecretKeySpec keyspec = new SecretKeySpec(key, \"AES\");\n            IvParameterSpec ivspec = new IvParameterSpec(iv);\n            Cipher cipher = Cipher.getInstance(\"AES/CBC/PKCS5Padding\");\n\n            cipher.init(Cipher.DECRYPT_MODE, keyspec,ivspec);\n            secret = new String(cipher.doFinal(new Base64().decode(str.getBytes())));\n\n        }\n        catch(Exception e){\n            e.printStackTrace();\n        }\n        return secret;\n    }\n\n    public static void main(String[] argv) {\n        String strIv = \"18A5Z/IsHs6g8/65sBxkCQ==\";\n        String strKey = \"\";\n        int keyStrength = 256;\n        try {\n            KeyGenerator kgen = KeyGenerator.getInstance(\"AES\");\n            kgen.init(keyStrength);\n\n            SecretKey skey = kgen.generateKey();\n            byte[] raw = skey.getEncoded();\n            strKey = new String(new Base64().encode(raw));\n            System.out.println(\"Secret key is: \" + strKey);\n        } catch (Exception ex) {\n            System.out.println(ex.toString());\n        }\n        String message = \"My, it's a lovely day today!!!\";\n        String encrypted = Encryption.encrypt(strKey, strIv, message);\n        System.out.println(\"Encrypted string is: \" + encrypted);\n        System.out.println(\"Decrypted string is: \" + Encryption.decrypt(strKey, strIv, encrypted));\n\n\n    }\n}\n", "idx": 2436}
{"project": "cipher", "commit_id": "Snippet21888201_4309.java", "target": 1, "func": "final MessageDigest md = MessageDigest.getInstance(\"SHA1\");\n\nbyte[] digest = md.digest(dataBuffer.array());\n\n// RSA decrypt\n\nCipher cipher = Cipher.getInstance(\"RSA/ECB/PKCS1Padding\");\n\ncipher.init(Cipher.DECRYPT_MODE, cert);\n\nbyte[] decrypted = cipher.doFinal(sigToCheck);    \n\n\n\nSystem.out.println(\"signature verifies: \" + Arrays.equals(digest, decrypted));\n", "idx": 2397}
{"project": "cipher", "commit_id": "Snippet5295110_31561.java", "target": 0, "func": "        final String key = \"=abcd!#Axd*G!pxP\";\n        final javax.crypto.spec.SecretKeySpec keySpec = new SecretKeySpec(key.getBytes(), \"AES\");\n        final javax.crypto.Cipher cipher = Cipher.getInstance(\"AES\");\n        cipher.init(Cipher.ENCRYPT_MODE, keySpec);\n        byte [] encryptedValue = cipher.doFinal(input.getBytes());\n        return new String(org.apache.commons.codec.binary.Hex.encodeHex(encryptedValue));\n", "idx": 2060}
{"project": "cipher", "commit_id": "Snippet9537017_33988.java", "target": 0, "func": "byte[] salt = {\n    (byte)0xc7, (byte)0x73, (byte)0x21, (byte)0x8c,\n    (byte)0x7e, (byte)0xc8, (byte)0xee, (byte)0x99\n};\n\nint count = 20;\n\nPBEParameterSpec pbeParamSpec = new PBEParameterSpec(salt, count);\nPBEKeySpec pbeKeySpec = new PBEKeySpec(password.toCharArray());\nSecretKeyFactory keyFac = SecretKeyFactory.getInstance(\"PBEWithMD5AndDES\");\nSecretKey pbeKey = keyFac.generateSecret(pbeKeySpec);\n\nCipher cipher = Cipher.getInstance(\"PBEWithMD5AndDES\");\ncipher.init(Cipher.ENCRYPT_MODE, pbeKey, pbeParamSpec);\n\nSealedObject sealed = new SealedObject(object, cipher);\n...\n", "idx": 2186}
{"project": "cipher", "commit_id": "Snippet31125672_13276.java", "target": 0, "func": "import java.security.InvalidAlgorithmParameterException;  \nimport java.security.InvalidKeyException;  \nimport java.security.NoSuchAlgorithmException;  \n\nimport javax.crypto.BadPaddingException;\nimport javax.crypto.Cipher;\nimport javax.crypto.IllegalBlockSizeException;\nimport javax.crypto.NoSuchPaddingException;\nimport javax.crypto.spec.*;\n\nimport org.apache.commons.codec.binary.*;\n\npublic class simple {\n\n public static void main(String[] args) {\n   String Key = \"1234567890\";\n   byte[] KeyData = Key.getBytes(); \n   String IV    = \"\\0\\0\\0\\0\\0\\0\\0\\0\";\n\n   try { \n     SecretKeySpec KS = new SecretKeySpec(KeyData, \"Blowfish\");\n     // modo CBC\n     Cipher cipher = Cipher.getInstance(\"Blowfish/CBC/PKCS5Padding\");\n     try {\n       try {    \n         IvParameterSpec IVparam = new javax.crypto.spec.IvParameterSpec(IV.getBytes());                     \n         cipher.init(Cipher.ENCRYPT_MODE, KS,IVparam);\n       } catch (InvalidAlgorithmParameterException e) {System.out.println(e);};  \n     } catch (InvalidKeyException e) {System.out.println(e);};  \n\n    // get the text to encrypt\n    String inputText = \"HELLOYOUHELLOYOUHELLOYOUHELLOYOUHELLOYOUHELLOYOUHELLOYOUHELLOYOUHELLOYOUHELLOYOU\";\n\n    // encrypt message\n    try {\n      byte[] encrypted = cipher.doFinal(inputText.getBytes());\n      Base64 b64 = new Base64();\n      System.out.println(\"Java Ciphertext\\n\" + b64.encodeAsString(encrypted));\n    } catch (IllegalBlockSizeException e) {System.out.println(e);}\n    catch (BadPaddingException e) {System.out.println(e);}  \n   }  \n   catch (NoSuchPaddingException e) {}\n   catch (NoSuchAlgorithmException e) {}\n }   \n\n}\n", "idx": 2029}
{"project": "cipher", "commit_id": "Snippet38869230_20773.java", "target": 0, "func": "public String encryptWithAES(String value, String key, String encoding) throws NoSuchAlgorithmException, NoSuchPaddingException, DecoderException, UnsupportedEncodingException, InvalidKeyException, IllegalBlockSizeException, BadPaddingException {\n    byte[] keyBytes = Hex.decodeHex(key.toLowerCase().toCharArray());\n    byte[] dataToSend = value.getBytes(encoding);\n    Cipher c = Cipher.getInstance(\"AES\");\n    SecretKeySpec k = new SecretKeySpec(keyBytes, \"AES\");\n    c.init(1, k);\n    byte[] encryptedData = c.doFinal(dataToSend);\n    return new String(Hex.encodeHex(encryptedData));\n}\n\npublic String decryptAES(String encrypted, String key, String encoding) throws NoSuchAlgorithmException, NoSuchPaddingException, DecoderException, UnsupportedEncodingException, InvalidKeyException, IllegalBlockSizeException, BadPaddingException {\n    byte[] keyBytes = Hex.decodeHex(key.toCharArray());\n    byte[] encryptedData = Hex.decodeHex(encrypted.toCharArray());\n    Cipher c = Cipher.getInstance(\"AES\");\n    SecretKeySpec k = new SecretKeySpec(keyBytes, \"AES\");\n    c.init(2, k);\n    byte[] dencryptedData = c.doFinal(encryptedData);\n    return new String(dencryptedData, encoding);\n}\n", "idx": 2121}
{"project": "cipher", "commit_id": "Snippet22388332_4766.java", "target": 1, "func": "public static void main(String[] args) throws NoSuchAlgorithmException, NoSuchPaddingException, \nInvalidKeyException, IllegalBlockSizeException, BadPaddingException  {\n\nKeyGenerator keyGenerator = KeyGenerator.getInstance(\"AES\");\nkeyGenerator.init(128);\nKey aesKey = keyGenerator.generateKey();\n\n\n\nKeyPairGenerator keyPairGenerator = KeyPairGenerator.getInstance(\"RSA\");\nkeyPairGenerator.initialize(1024);\nKeyPair keyPair = keyPairGenerator.genKeyPair();\n\nCipher cipher = Cipher.getInstance(\"RSA/ECB/PKCS1Padding\");\n\nbyte[] aesKeyBytes = aesKey.getEncoded();\nSystem.out.println(\"1. aesKeyBytes= \"+ bytesToHex(aesKeyBytes));\n\ncipher.init(Cipher.ENCRYPT_MODE, keyPair.getPublic());\nbyte[] cipherText = cipher.doFinal(aesKeyBytes);\nSystem.out.println(\"2. cipherText= \"+bytesToHex(cipherText));\n\ncipher.init(Cipher.DECRYPT_MODE, keyPair.getPrivate());\nbyte[] decryptedKeyBytes = cipher.doFinal(cipherText);\nSystem.out.println(\"3. decryptedKeyBytes= \"+bytesToHex(decryptedKeyBytes));\n\n\n//use symmetric with the decrypted key\nSecretKey newAesKey = new SecretKeySpec(decryptedKeyBytes, \"AES\");\n", "idx": 2463}
{"project": "cipher", "commit_id": "Snippet24130154_6114.java", "target": 1, "func": "Cipher cipher = Cipher.getInstance(\"AES/CBC/PKCS7Padding\");\n", "idx": 2368}
{"project": "cipher", "commit_id": "Snippet11318790_35467.java", "target": 0, "func": "// Create data array with size greater 256 bytes\nbyte[] SOURCE_DATA = new byte[257];     \nfor (int i=0;i<SOURCE_DATA.length; i++) {\n    SOURCE_DATA[i] = (byte)((i+1) & 0xff);\n}\n\n// Init ciphers\nCipher encC = Cipher.getInstance(\"AES/ECB/PKCS5Padding\");\nCipher decC = Cipher.getInstance(\"AES/ECB/PKCS5Padding\");\nencC.init(Cipher.ENCRYPT_MODE, new SecretKeySpec(new byte[] {0,1,2,3,4,5,6,7,8,9,1,2,3,4,5,6}, \"AES\"));                  \ndecC.init(Cipher.DECRYPT_MODE, new SecretKeySpec(new byte[] {0,1,2,3,4,5,6,7,8,9,1,2,3,4,5,6}, \"AES\"));          \n\n// Encrypt\nByteArrayOutputStream bos = new ByteArrayOutputStream();\nCipherOutputStream cos = new CipherOutputStream(bos, encC);\nDataOutputStream dos = new DataOutputStream(cos);\n\ndos.write(SOURCE_DATA, 0, SOURCE_DATA.length);\ndos.close();\n\nbyte[] ENCRYPTED_DATA = bos.toByteArray();\n\n// Decrypt\nByteArrayInputStream bis = new ByteArrayInputStream(ENCRYPTED_DATA);\nCipherInputStream cis = new CipherInputStream(bis, decC);\nDataInputStream dis = new DataInputStream(cis);\n\nbyte[] DECRYPTED_DATA = new byte[SOURCE_DATA.length];\ndis.read(DECRYPTED_DATA, 0, DECRYPTED_DATA.length);\ncis.close();\n\nSystem.out.println(\"Source Data:    \"+toHex(SOURCE_DATA));\nSystem.out.println(\"Decrypted Data: \"+toHex(DECRYPTED_DATA));            \n", "idx": 2046}
{"project": "cipher", "commit_id": "Snippet34533032_16517.java", "target": 1, "func": "package nl.owlstead.stackoverflow;\n\nimport static java.nio.charset.StandardCharsets.UTF_8;\n\nimport java.security.KeyFactory;\nimport java.security.NoSuchAlgorithmException;\nimport java.security.Security;\nimport java.security.Signature;\nimport java.security.interfaces.RSAPublicKey;\nimport java.security.spec.InvalidKeySpecException;\nimport java.security.spec.RSAPublicKeySpec;\nimport java.util.Base64;\nimport java.util.Base64.Decoder;\n\nimport javax.crypto.Cipher;\n\nimport org.bouncycastle.jce.provider.BouncyCastleProvider;\n\npublic class PKCS1PublicKey {\n\n    public static RSAPublicKey fromPKCS1Encoding(byte[] pkcs1EncodedPublicKey) {\n        // --- parse public key ---\n        org.bouncycastle.asn1.pkcs.RSAPublicKey pkcs1PublicKey;\n        try {\n            pkcs1PublicKey = org.bouncycastle.asn1.pkcs.RSAPublicKey\n                    .getInstance(pkcs1EncodedPublicKey);\n        } catch (Exception e) {\n            throw new IllegalArgumentException(\n                    \"Could not parse BER PKCS#1 public key structure\", e);\n        }\n\n        // --- convert to JCE RSAPublicKey\n        RSAPublicKeySpec spec = new RSAPublicKeySpec(\n                pkcs1PublicKey.getModulus(), pkcs1PublicKey.getPublicExponent());\n        KeyFactory rsaKeyFact;\n        try {\n            rsaKeyFact = KeyFactory.getInstance(\"RSA\");\n        } catch (NoSuchAlgorithmException e) {\n            throw new IllegalStateException(\"RSA KeyFactory should be available\", e);\n        }\n        try {\n            return (RSAPublicKey) rsaKeyFact.generatePublic(spec);\n        } catch (InvalidKeySpecException e) {\n            throw new IllegalArgumentException(\n                    \"Invalid RSA public key, modulus and/or exponent invalid\", e);\n        }\n    }\n\n    public static void main(String[] args) throws Exception {\n        Security.addProvider(new BouncyCastleProvider());\n\n        String pkey = \"MIIBCgKCAQEA2tF2g/muNw9xKTVcIkjUMvMhygtIW49yo1PgbwqDQ/w9MSfEARtYYF6Tenfz0twaR/eI14GXmlIffflORe4eaSuMBhwQFOIKU/1+v1BV3RLqGGblvHTVaMVm49AGiqxNnh1LBbcSrC5UhMqlL/HGiku0oYsbjLzwcLc5ac6aBQVD60wWGNm1g26lRQGRbCLqxVfcWKT3AMvEQK3cEx/En7/5Vg1V8xnJraNMrO8UGnaX8LLJFzYJiSCEShh7F+pMHbf4MaBekw7Aaf5hPJtczNsR137R92Be3OP4idI5NLmTV+Pi1DWlxhjEhswKH88SP+gsW31gS7B/ddECUqewQwIDAQAB\";\n        Decoder decoder = Base64.getDecoder();\n        byte[] dpkey = decoder.decode(pkey);\n        RSAPublicKey publicKey = fromPKCS1Encoding(dpkey);\n\n        String plainData = \"Hi I m here\";\n        String data = \"aP0nuYYA1hE5odsCkR/DcdRbBvO2Z8IOlqXf/bKZJiG8HELIop90Vno1dKC1qyHEAOXy0gtH7GtJamzoBjDZmHPT6eto9EZP/xE7xZ8L05kjp0z2thLqO7on4C6DrG++TK1j+E3T7V0UeU874WIB0AEVzu1XUKFW6aeuU67a/gdn8N2n7N/WXtlyNSVZXg8f4PeUhGvFJrhINZT7BuMMZj1gZs4wMJPAICwfvVeg02RPH0N3Ybf2iVgRuZlmtQXGTyBlCxe9ybdHzuQM6nXghpLNmaOzCypb+yVs3Da7E0b3/fKQ7JqPSquWex2ERZbIMSTC6oCzc1rOF6iKVAd92Q==\";\n        byte[] ciphertext = decoder.decode(data);\n\n        // this will fail of course if the \"signature\" was generated using OAEP - use PSS signatures instead (see comments below)\n        verifyBC(publicKey, plainData, ciphertext);\n        System.out.flush();\n        decryptBC(publicKey, plainData, ciphertext);\n        System.out.flush();\n        decryptSun(publicKey, plainData, ciphertext);\n        System.out.flush();\n    }\n\n    private static void decryptBC(RSAPublicKey publicKey, String plainData,\n            byte[] ciphertext) throws Exception {\n        Cipher oaep = Cipher.getInstance(\"RSA/ECB/OAEPWithSHA1AndMGF1Padding\", \"BC\");\n        // this *should* fail\n        oaep.init(Cipher.DECRYPT_MODE, publicKey);\n        byte[] plaintext = oaep.doFinal(ciphertext);\n        System.out.println(new String(plaintext, UTF_8));\n    }\n\n    private static void decryptSun(RSAPublicKey publicKey, String plainData,\n            byte[] ciphertext) throws Exception {\n        Cipher oaep = Cipher.getInstance(\"RSA/ECB/OAEPWithSHA1AndMGF1Padding\", \"SunJCE\");\n        // this fails beautifully\n        oaep.init(Cipher.DECRYPT_MODE, publicKey);\n        byte[] plaintext = oaep.doFinal(ciphertext);\n        System.out.println(new String(plaintext, UTF_8));\n    }\n\n    private static void verifyBC(RSAPublicKey publicKey, String plainData,\n            byte[] ciphertext) throws Exception {\n        // what should work (for PKCS#1 v1.5 signatures), requires Bouncy Castle provider\n        Signature sig = Signature.getInstance( \"SHA256withRSAandMGF1\");\n        sig.initVerify(publicKey);\n        sig.update(plainData.getBytes(UTF_8));\n        System.out.println(sig.verify(ciphertext));\n    }\n}\n", "idx": 2534}
{"project": "cipher", "commit_id": "Snippet15190770_38288.java", "target": 0, "func": "public static String encrypt(byte[] raw, byte[] clear) throws Exception {\n    SecretKeySpec skeySpec = new SecretKeySpec(raw, \"AES\");\n    Cipher cipher = Cipher.getInstance(\"AES/ECB/ZeroBytePadding\");\n    cipher.init(Cipher.ENCRYPT_MODE, skeySpec);\n\n    byte[] encrypted = cipher.doFinal(clear);\n    return android.util.Base64.encodeToString(encrypted, android.util.Base64.NO_WRAP);\n}\n\npublic static byte[] decrypt(byte[] raw, byte[] encrypted) throws Exception {\n    SecretKeySpec skeySpec = new SecretKeySpec(raw, \"AES\");\n    Cipher cipher = Cipher.getInstance(\"AES/ECB/ZeroBytePadding\");\n    cipher.init(Cipher.DECRYPT_MODE, skeySpec);\n\n    byte[] decrypted = cipher.doFinal(encrypted);\n    return decrypted;\n}\n", "idx": 2227}
{"project": "cipher", "commit_id": "Snippet27752419_9923.java", "target": 1, "func": "StringBuffer sbselect1=new StringBuffer();\nsbselect1.append(\"SELECT Keyforkey FROM \");\nsbselect1.append(UserConstants.USER_DETAILS_TABLE_NAME2);\nsbselect1.append(\" where ID=2\");\nps1=conn.prepareStatement(sbselect1.toString());\nResultSet rs =ps1.executeQuery();\n rs.next();\nString keyskey = rs.getString(\"KeyforKey\");\nSystem.out.println(\"Fetched Key from DB \"+keyskey);\nSecurity.addProvider(new FlexiCoreProvider());\nCipher cipher2 = Cipher.getInstance(\"AES128_CBC\", \"FlexiCore\");\n//  byte[] encodedKey =keyskey.getBytes();\nSecretKey key2 = new SecretKeySpec(keyskey.getBytes(), 0,  keyskey.length(), \"AES\");\nSystem.out.println(\"invalid Key  \"+ key2);\nrs.close(); \n", "idx": 2710}
{"project": "cipher", "commit_id": "Snippet10782187_35039.java", "target": 0, "func": "public static String encrypt(String seed, String cleartext) throws Exception  \n{\n    byte[] rawKey = getRawKey(seed.getBytes());\n    byte[] result = encrypt(rawKey, cleartext.getBytes()); \n    return toHex(result);\n}\n\nprivate static byte[] encrypt(byte[] raw, byte[] clear) throws Exception \n{\n    SecretKeySpec skeySpec = new SecretKeySpec(raw, \"AES\");\n    Cipher cipher = Cipher.getInstance(\"AES\");\n    cipher.init(Cipher.ENCRYPT_MODE, skeySpec);\n    byte[] encrypted = cipher.doFinal(clear);\n    return encrypted;\n}\n", "idx": 2091}
{"project": "cipher", "commit_id": "Snippet1755259_30062.java", "target": 0, "func": "package org.temp2.cod1;\nimport java.security.*;\nimport javax.crypto.*;\nimport javax.crypto.spec.*;\nimport java.io.*;\n\npublic class Code1 {\n\n    byte[] plaintext = new byte[32];   // <<<<<<<<<<<<<<<<<<<<<<<<<< syntax error\n    for (int i = 0; i < 32; i++) {\n      plaintext[i] = (byte) (i % 16);\n    }\n\n    byte[] key = new byte[16];\n    SecureRandom r = new SecureRandom();\n    r.nextBytes(key);\n\n    Cipher c = Cipher.getInstance(\"AES\");\n    SecretKeySpec k =  new SecretKeySpec(key, \"AES\");\n    c.init(Cipher.ENCRYPT_MODE, k);\n    byte[] encryptedData = c.doFinal(plaintext);\n}\n}\n", "idx": 2059}
{"project": "cipher", "commit_id": "Snippet30996440_13191.java", "target": 1, "func": "import java.io.BufferedInputStream;\nimport java.io.ByteArrayInputStream;\nimport java.io.ByteArrayOutputStream;\nimport java.io.DataInputStream;\nimport java.io.File;\nimport java.io.FileInputStream;\nimport java.io.IOException;\nimport java.io.UnsupportedEncodingException;\nimport java.nio.ByteBuffer;\nimport java.util.Arrays;\nimport java.lang.Thread;\n\nimport javax.crypto.Cipher;\nimport javax.crypto.spec.IvParameterSpec;\nimport javax.crypto.spec.SecretKeySpec;\n\n\n\nclass encryptThread extends Thread {\n   private Thread t;\n   private String threadName;\n   private long[] password_aes;\n   private String uh = \"\";\n   private static final char[] CA = \"ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/\".toCharArray();\n   private static final int[] IA = new int[256];\n   private int j = 0;\n\n\n    static {\n        Arrays.fill(IA, -1);\n        for (int i = 0, iS = CA.length; i < iS; i++)\n            IA[CA[i]] = i;\n        IA['='] = 0;\n    }\n\n   encryptThread( String name, int i){\n       threadName = name;   \n       j = i;\n   }\n\n   public void run() {\n    String finalString = \"\";\n    String[] parts = threadName.split(\":\");\n    password_aes = prepare_key_pw(parts[1]);\n    uh = stringhash(parts[0], password_aes);\n    finalString = (parts[0] + \":\" + parts[1] + \":\" + uh + \"\\n\");\n    //System.out.println(finalString);\n    PassArray.passwordArray[j] = finalString;\n\n    if (j == 176) {\n        for (int x = 0; x < 500; x++) {\n            System.out.println(PassArray.passwordArray[x]);\n        }\n    }\n   }\n\n   public void start ()\n   {\n      System.out.println(\"Starting \" +  threadName );\n      if (t == null)\n      {\n         t = new Thread (this, threadName);\n         t.start ();\n      }\n   }\n\n    public static long[] str_to_a32(String string) {\n        if (string.length() % 4 != 0) {\n            string += new String(new char[4 - string.length() % 4]);\n        }\n        long[] data = new long[string.length() / 4];\n\n        byte[] part = new byte[8];\n        for (int k = 0, i = 0; i < string.length(); i += 4, k++) {\n            String sequence = string.substring(i, i + 4);\n            ByteArrayOutputStream baos = new ByteArrayOutputStream();\n            try {\n                baos.write(sequence.getBytes(\"ISO-8859-1\"));\n                System.arraycopy(baos.toByteArray(), 0, part, 4, 4);\n                ByteBuffer bb = ByteBuffer.wrap(part);\n                data[k] = bb.getLong();\n            } catch (IOException e) {\n                data[k] = 0;\n            }\n        }\n        return data;\n    }\n\n    public static String a32_to_str(long[] data) {\n        byte[] part = null;\n        StringBuilder builder = new StringBuilder();\n        ByteBuffer bb = ByteBuffer.allocate(8);\n        for (int i = 0; i < data.length; i++) {\n            bb.putLong(data[i]);\n            part = Arrays.copyOfRange(bb.array(), 4, 8);\n            bb.clear();\n            ByteArrayInputStream bais = new ByteArrayInputStream(part);\n            while (bais.available() > 0) {\n                builder.append((char) bais.read());\n            }\n        }\n        return builder.toString();\n    }\n\n    public static byte[] aes_cbc_encrypt(byte[] data, byte[] key) {\n        String iv = \"\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\";\n        IvParameterSpec ivSpec = new IvParameterSpec(iv.getBytes());\n        byte[] output = null;\n        try {\n            SecretKeySpec keySpec = new SecretKeySpec(key, \"AES\");\n            Cipher cipher = Cipher.getInstance(\"AES/CBC/NOPADDING\");\n            cipher.init(Cipher.ENCRYPT_MODE, keySpec, ivSpec);\n            output = cipher.doFinal(data);\n\n        } catch (Exception e) {\n            e.printStackTrace();\n        }\n        return output;\n    }\n\n    public static long[] aes_cbc_encrypt_a32(long[] idata, long[] ikey) {\n        try {\n            byte[] data = a32_to_str(idata).getBytes(\"ISO-8859-1\");\n            byte[] key = a32_to_str(ikey).getBytes(\"ISO-8859-1\");\n            byte[] encrypt = aes_cbc_encrypt(data, key);\n\n            return str_to_a32(new String(encrypt, \"ISO-8859-1\"));\n\n        } catch (UnsupportedEncodingException e) {\n            e.printStackTrace();\n        }\n        return new long[0];\n    }\n\n    public static String base64_url_encode(String data) {\n\n        try {\n            data = new String(base64_url_encode_byte((data.getBytes(\"ISO-8859-1\")),true), \"ISO-8859-1\");\n        } catch (UnsupportedEncodingException e) {\n            e.printStackTrace();\n        }\n        data = data.replaceAll(\"\\\\+\", \"-\");\n        data = data.replaceAll(\"/\", \"_\");\n        data = data.replaceAll(\"=\", \"\");\n\n        return data;\n    }\n\n    public static String a32_to_base64(long[] a) {\n        return base64_url_encode(a32_to_str(a));\n    }\n\n    public static String stringhash(String email, long[] aeskey) {\n        long[] s32 = str_to_a32(email);\n        long[] h32 = {0, 0, 0, 0};\n        for (int i = 0; i < s32.length; i++) {\n            h32[i % 4] ^= s32[i];\n        }\n        for (int r = 0; r < 0x4000; r++) {\n            h32 = aes_cbc_encrypt_a32(h32, aeskey);\n        }\n        long[] h32Part = new long[2];\n        h32Part[0] = h32[0];\n        h32Part[1] = h32[2];\n        return a32_to_base64(h32Part);\n    }\n\n    public static long[] prepare_key(long[] password) {\n        long[] pkey = {0x93C467E3, 0x7DB0C7A4, 0xD1BE3F81, 0x0152CB56};\n        for (int r = 0; r < 0x10000; r++) {\n            for (int j = 0; j < password.length; j += 4) {\n                long[] key = {0, 0, 0, 0};\n                for (int i = 0; i < 4; i++) {\n                    if (i + j < password.length) {\n                        key[i] = password[i + j];\n                    }\n                }\n                pkey = aes_cbc_encrypt_a32(pkey, key);\n            }\n        }\n        return pkey;}\n\n    public static long[] prepare_key_pw(String password) {\n        return prepare_key(str_to_a32(password));\n    }\n\n       public final static byte[] base64_url_encode_byte(byte[] sArr, boolean lineSep){\n            // Check special case\n            int sLen = sArr != null ? sArr.length : 0;\n            if (sLen == 0)\n                return new byte[0];\n\n            int eLen = (sLen / 3) * 3;                              // Length of even 24-bits.\n            int cCnt = ((sLen - 1) / 3 + 1) << 2;                   // Returned character count\n            int dLen = cCnt + (lineSep ? (cCnt - 1) / 76 << 1 : 0); // Length of returned array\n            byte[] dArr = new byte[dLen];\n\n            // Encode even 24-bits\n            for (int s = 0, d = 0, cc = 0; s < eLen;) {\n                // Copy next three bytes into lower 24 bits of int, paying attension to sign.\n                int i = (sArr[s++] & 0xff) << 16 | (sArr[s++] & 0xff) << 8 | (sArr[s++] & 0xff);\n\n                // Encode the int into four chars\n                dArr[d++] = (byte) CA[(i >>> 18) & 0x3f];\n                dArr[d++] = (byte) CA[(i >>> 12) & 0x3f];\n                dArr[d++] = (byte) CA[(i >>> 6) & 0x3f];\n                dArr[d++] = (byte) CA[i & 0x3f];\n\n                // Add optional line separator\n                if (lineSep && ++cc == 19 && d < dLen - 2) {\n                    dArr[d++] = '\\r';\n                    dArr[d++] = '\\n';\n                    cc = 0;\n\n                }\n            }\n\n            // Pad and encode last bits if source isn't an even 24 bits.\n            int left = sLen - eLen; // 0 - 2.\n            if (left > 0) {\n                // Prepare the int\n                int i = ((sArr[eLen] & 0xff) << 10) | (left == 2 ? ((sArr[sLen - 1] & 0xff) << 2) : 0);\n\n                // Set last four chars\n                dArr[dLen - 4] = (byte) CA[i >> 12];\n                dArr[dLen - 3] = (byte) CA[(i >>> 6) & 0x3f];\n                dArr[dLen - 2] = left == 2 ? (byte) CA[i & 0x3f] : (byte) '=';\n                dArr[dLen - 1] = '=';\n            }\n            return dArr;\n        }\n\n\n    }\n\n\npublic class TestThread {\n\n\n   final static String OUTPUT_FILE_NAME = \"C:\\\\combo_encrypted.txt\";\n\n   public static void main(String args[]) throws IOException, Throwable {\n\n\n      for (int f = 0; f < 500; f++){\n          PassArray.passwordArray[f] = \"haddy ma'am\";\n      }\n\n\n      File file1 = new File(\"File1.txt\");\n      File file2 = new File(\"File2.txt\");\n      File file3 = new File(\"File3.txt\");\n      File file4 = new File(\"File4.txt\");\n\n      FileInputStream fis1 = null;\n      FileInputStream fis2 = null;\n      FileInputStream fis3 = null;\n      FileInputStream fis4 = null;\n\n      BufferedInputStream bis1 = null;\n      BufferedInputStream bis2 = null;\n      BufferedInputStream bis3 = null;\n      BufferedInputStream bis4 = null;\n\n      DataInputStream dis1 = null;\n      DataInputStream dis2 = null;\n      DataInputStream dis3 = null;\n      DataInputStream dis4 = null;\n\n      fis1 = new FileInputStream(file1);    \n      fis2 = new FileInputStream(file2);\n      fis3 = new FileInputStream(file3);\n      fis4 = new FileInputStream(file4);\n\n      bis1 = new BufferedInputStream(fis1);\n      bis2 = new BufferedInputStream(fis2);\n      bis3 = new BufferedInputStream(fis3);\n      bis4 = new BufferedInputStream(fis4);\n\n      dis1 = new DataInputStream(bis1);\n      dis2 = new DataInputStream(bis2);\n      dis3 = new DataInputStream(bis3);\n      dis4 = new DataInputStream(bis4);\n\n      int i = 0;\n\n      while ( (dis4.available() != 0) ) {\n          encryptThread[] threadList = new encryptThread[4];\n\n\n\n\n            String combo1 = dis1.readLine();\n            String combo2 = dis2.readLine();\n            String combo3 = dis3.readLine();\n            String combo4 = dis4.readLine();\n\n\n            threadList[0] = new encryptThread(combo1, i);\n            threadList[1] = new encryptThread(combo2, i);\n            threadList[2] = new encryptThread(combo3, i);\n            threadList[3] = new encryptThread(combo4, i);\n\n            threadList[0].start();\n            threadList[1].start();\n            threadList[2].start();\n            threadList[3].start();\n\n\n            /*\n            RunnableDemo R1 = new RunnableDemo(combo1, array1, i);\n            RunnableDemo R2 = new RunnableDemo(combo2, array2, i);\n            RunnableDemo R3 = new RunnableDemo(combo3, array3, i);\n            RunnableDemo R4 = new RunnableDemo(combo4, array4, i);\n\n            R1.start();\n            R2.start();\n            R3.start();\n            R4.start();\n            */\n            i++;\n      }\n\n      fis1.close();\n      fis2.close();\n      fis3.close();\n      fis4.close();\n\n      bis1.close();\n      bis2.close();\n      bis3.close();\n      bis4.close();\n\n      dis1.close();\n      dis2.close(); \n      dis3.close(); \n      dis4.close(); \n\n      System.out.println(PassArray.passwordArray[5]);\n   }   \n}\n\nclass PassArray {\n    public static String[] passwordArray = new String[500];\n\n}\n", "idx": 2450}
{"project": "cipher", "commit_id": "Snippet31720188_13813.java", "target": 0, "func": "IvParameterSpec localIvParameterSpec = new IvParameterSpec(new byte[] { 12, 34, 34, 11, 64, 23, 89, 27 });\n\nDESKeySpec localDESKeySpec = new DESKeySpec(paramString2.getBytes());\n\nSecretKey localSecretKey = SecretKeyFactory.getInstance(\"DES\").generateSecret(localDESKeySpec);\n\nCipher localCipher = Cipher.getInstance(\"DES/CBC/PKCS5Padding\");\n\nlocalCipher.init(1, localSecretKey, localIvParameterSpec);\n\nreturn new String(Base64.encode(localCipher.doFinal(paramString1.getBytes()), 0));\n", "idx": 1973}
{"project": "cipher", "commit_id": "Snippet34584743_16557.java", "target": 1, "func": "public static String encrypt(String src) {\n    try {\n        Cipher cipher = Cipher.getInstance(\"AES/CBC/PKCS5Padding\");\n\n        Key key = makeKey();\n        AlgorithmParameterSpec iv = makeIv();\n\n        cipher.init(Cipher.ENCRYPT_MODE, key, iv);\n        return Base64.encodeBytes(cipher.doFinal(src.getBytes()));\n    } catch (Exception e) {\n        throw new RuntimeException(e);\n    }\n}\n\n static AlgorithmParameterSpec makeIv() {\n        return new IvParameterSpec(ENCRYPTION_IV.getBytes(encoding));\n}\n\n\nstatic Key makeKey() {\n    try {\n        MessageDigest md = MessageDigest.getInstance(\"SHA-256\");\n        byte[] key = md.digest(ENCRYPTION_KEY.getBytes(encoding));\n        return new SecretKeySpec(key, \"AES\");\n    } catch (NoSuchAlgorithmException e) {\n        e.printStackTrace();\n    }\n    return null;\n}\n", "idx": 2374}
{"project": "cipher", "commit_id": "Snippet7414955_32719.java", "target": 1, "func": "public class KeyPairsGenerator {\n\n    public static void main(String args[]){\n        KeyPairsGenerator testClass = new KeyPairsGenerator();\n        testClass.GenerateKeyPair();\n        testClass.testEncryptDecrypt();\n    }\n\n    public void testEncryptDecrypt(){\n\n        ObjectInputStream oinPublic = null;\n        ObjectInputStream oinPrivate = null;\n        try {\n\n            //****************\n            //ENCRYPT\n            oinPublic = new ObjectInputStream\n            (new BufferedInputStream(new FileInputStream(\"public.key\")));\n            BigInteger m = (BigInteger) oinPublic.readObject();\n            BigInteger e = (BigInteger) oinPublic.readObject();\n            RSAPublicKeySpec keySpec = new RSAPublicKeySpec(m, e);\n            KeyFactory fact = KeyFactory.getInstance(\"RSA\");\n            PublicKey pubKey = fact.generatePublic(keySpec);\n\n            Cipher cipher = Cipher.getInstance(\"RSA/ECB/PKCS1Padding\");\n            cipher.init(Cipher.ENCRYPT_MODE, pubKey);\n            byte[] cipherData = cipher.doFinal(\"hello hello\".getBytes());\n\n            System.out.println(cipherData.toString());\n\n            //****************\n            //DECRYPT\n            oinPrivate = new ObjectInputStream\n            (new BufferedInputStream(new FileInputStream(\"private.key\")));\n            BigInteger m1 = (BigInteger) oinPrivate.readObject();\n            BigInteger e1 = (BigInteger) oinPrivate.readObject();\n            RSAPrivateKeySpec keySpecPrivate = new RSAPrivateKeySpec(m1, e1);\n            KeyFactory fact1 = KeyFactory.getInstance(\"RSA\");\n            PrivateKey privKey = fact1.generatePrivate(keySpecPrivate);\n\n            Cipher cipher1 = Cipher.getInstance(\"RSA/ECB/PKCS1Padding\");\n            cipher1.init(Cipher.DECRYPT_MODE, privKey);\n            byte[] cipherData1 = cipher1.doFinal(cipherData);\n\n            System.out.println(cipherData1.toString()); \n\n        } catch (Exception e) {\n            throw new RuntimeException(\"Spurious serialization error\", e);\n        } finally {\n            try {\n                oinPrivate.close();\n                oinPublic.close();\n            } catch (IOException e) {\n                // TODO Auto-generated catch block\n                e.printStackTrace();\n            }\n        }\n    }\n\n\n    public void GenerateKeyPair()\n    {       \n        try{\n            KeyPairGenerator kpg = KeyPairGenerator.getInstance(\"RSA\");\n            kpg.initialize(2048);\n            KeyPair kp = kpg.genKeyPair();\n\n            KeyFactory fact = KeyFactory.getInstance(\"RSA\");\n            RSAPublicKeySpec pub = fact.getKeySpec(\n                    kp.getPublic(),RSAPublicKeySpec.class);\n            RSAPrivateKeySpec priv = fact.getKeySpec\n            (kp.getPrivate(),RSAPrivateKeySpec.class);\n\n            saveToFile(\"public.key\", pub.getModulus(),pub.getPublicExponent());\n        saveToFile(\"private.key\", priv.getModulus(),priv.getPrivateExponent());\n        }catch(Exception e){\n            System.out.println(e.getMessage());\n        }\n    }\n\n    public void saveToFile(String fileName,BigInteger mod, \n            BigInteger exp) throws Exception {\n\n        ObjectOutputStream oout = new ObjectOutputStream\n        (new BufferedOutputStream(new FileOutputStream(fileName)));\n        try {\n            oout.writeObject(mod);\n            oout.writeObject(exp);\n        } catch (Exception e) {\n            throw new Exception(\"error\", e);\n        } finally {\n            oout.close();\n        }\n    }\n}\n", "idx": 2566}
{"project": "cipher", "commit_id": "Snippet21890769_4311.java", "target": 1, "func": "public static String encrypt(String text, String keyPhrase) throws Exception {\n        byte[] salt = { 0x49, 0x76, 0x61, 0x6e, 0x20, 0x4d, 0x65, 0x64, 0x76, 0x65, 0x64, 0x65, 0x76 };\n        byte[] data = text.getBytes(\"UTF-16LE\");\n        PBEKeySpec spec = new PBEKeySpec(keyPhrase.toCharArray(), salt, 1);\n\n        SecretKey secret = new SecretKeySpec(keyPhrase.getBytes(\"UTF-16LE\"), \"AES\");\n        Cipher cipher = Cipher.getInstance(\"AES/CBC/PKCS5Padding\");\n\n        cipher.init(Cipher.ENCRYPT_MODE, secret);\n        byte[] ciphertext = cipher.doFinal(data);\n        return Base64.encodeBase64String(ciphertext);\n    }\n", "idx": 2709}
{"project": "cipher", "commit_id": "Snippet27665096_9849.java", "target": 0, "func": "SecretKey deskey = new SecretKeySpec(keybyte, \"DESede/ECB/NOPADDING\");\nCipher c1 = Cipher.getInstance(\"DESede/ECB/NOPADDING\");\nc1.init(Cipher.ENCRYPT_MODE, deskey);\n", "idx": 1927}
{"project": "cipher", "commit_id": "Snippet20061563_2725.java", "target": 0, "func": "public class Test {\n\n    static ReadableByteChannel readChannel = null;\n    static WritableByteChannel writeChannel = null;\n    static SecretKey key = makeKeyFromPassword(\"abcdefghi\".getBytes()); \n    static byte b[];\n\n    public static SecretKey makeKeyFromPassword(byte[] password) {\n        try {\n            DESKeySpec dks = new DESKeySpec(password);\n            SecretKeyFactory skf = SecretKeyFactory.getInstance(\"DES\");\n            return skf.generateSecret(dks);\n        } catch (Exception e) {\n            e.printStackTrace();\n        }\n        return null;\n    }\n\n    public static void run(int mode) throws Exception {\n        ByteBuffer readBuffer = ByteBuffer.allocate(1024);\n        ByteBuffer writeBuffer = ByteBuffer.allocate(1024);\n\n        // initializing cipher...\n        Cipher cipher = Cipher.getInstance(\"DES\");\n        cipher.init(mode, key);\n\n        while (readChannel.read(readBuffer) != -1) {\n            readBuffer.flip();\n            cipher.doFinal(readBuffer, writeBuffer);\n            writeBuffer.flip();\n            writeChannel.write(writeBuffer);\n            readBuffer.clear();\n            writeBuffer.clear();\n        }\n    }\n\n    static void f(String inFileString, String fileString, int mode) {\n        FileOutputStream fos = null;\n        FileSystem fs = FileSystems.getDefault();\n        Path fp = fs.getPath(inFileString);\n\n        try {\n            readChannel = FileChannel.open(fp,\n                    EnumSet.of(StandardOpenOption.READ));\n            fos = new FileOutputStream(fileString);\n            writeChannel = Channels.newChannel(fos);\n            run(mode);\n        } catch (Exception e) {\n            e.printStackTrace();\n        }\n    }\n\n    public static void main(String[] args) {\n        f(\"C:\\\\test.txt\", \"C:\\\\des.txt\", Cipher.ENCRYPT_MODE);\n        System.out.println(\"Encrypted.\");\n        f(\"C:\\\\des.txt\", \"C:\\\\undes.txt\", Cipher.DECRYPT_MODE);\n        System.out.println(\"Decrypted.\");\n    }\n\n}\n", "idx": 2099}
{"project": "cipher", "commit_id": "Snippet45962578_28046.java", "target": 1, "func": "class GCMClient\n{\n    // AES-GCM parameters\n    public static final int AES_KEY_SIZE = 128; // in bits\n    public static final int GCM_NONCE_LENGTH = 12; // in bytes\n    public static final int GCM_TAG_LENGTH = 16; // in bytes\n    public static void main(String args[]) throws Exception{        \n        DatagramSocket clientSocket = new DatagramSocket();\n        InetAddress IPAddress = InetAddress.getByName(\"192.168.1.8\");\n        byte[] sendData = new byte[1024];\n        byte[] receiveData = new byte[1024];        \n        byte[] input = \"hi\".getBytes(); //2 bytes \n\n        byte[] keyBytes =\"qwertyuiopasdfgh\".getBytes();\n        SecretKey key = new SecretKeySpec(keyBytes, 0, keyBytes.length, \"AES\");       \n        Cipher cipher = Cipher.getInstance(\"AES/GCM/NoPadding\", \"SunJCE\");\n        byte[] nonce = new byte[GCM_NONCE_LENGTH];\n        nonce = \"poiuytrewqlk\".getBytes();;;        \n        GCMParameterSpec spec = new GCMParameterSpec(GCM_TAG_LENGTH * 8, nonce);\n        cipher.init(Cipher.ENCRYPT_MODE, key, spec);\n        byte[] aad =  \"Whatever I like\".getBytes();;\n        cipher.updateAAD(aad);\n        byte[] cipherText = cipher.doFinal(input); \n        System.out.println(cipherText.length+ \"data sent!!!!!!! \"); //18 bytes after encryption\n        DatagramPacket sendPacket = new DatagramPacket(cipherText, cipherText.length, IPAddress, 9999);\n        clientSocket.send(sendPacket);  \n        clientSocket.close();     \n   }\n}\n", "idx": 2646}
{"project": "cipher", "commit_id": "Snippet4259082_31061.java", "target": 0, "func": "  final byte[] rawKey = hexStringToByteArray(\"9c361fec3ac1ebe7b540487c9c25e24e\");\n  final SecretKeySpec skeySpec = new SecretKeySpec(rawKey, \"AES\");\n  // Instantiate the cipher\n  final Cipher cipher = Cipher.getInstance(\"AES\");\n  cipher.init(Cipher.ENCRYPT_MODE, skeySpec);\n\n  final byte[] encrypted = cipher.doFinal(plainText.getBytes());\n", "idx": 1980}
{"project": "cipher", "commit_id": "Snippet28676019_10819.java", "target": 0, "func": "package com.example.encryptiondecryption;\n\n    import java.security.SecureRandom;\n\n    import javax.crypto.Cipher;\n    import javax.crypto.KeyGenerator;\n    import javax.crypto.spec.SecretKeySpec;\n    import android.app.Activity;\n    import android.app.Dialog;\n    import android.content.Context;\n    import android.os.Bundle;\n    import android.util.Base64;\n    import android.util.Log;\n    import android.view.View;\n    import android.view.View.OnClickListener;\n    import android.widget.Button;\n    import android.widget.EditText;\n    import android.widget.TextView;\n\n    public class MainActivity extends Activity implements OnClickListener {\n\n        static final String TAG = \"SymmetricAlgorithmAES\";\n        static final String TAG1 = \"encccccccc\";\n        EditText getData_edt, key_edt;\n        Button genkey_btn, encrypt_btn, decrypt_btn;\n        static String key_str = null;\n        static String getData_str = null;\n\n        static SecretKeySpec sks = null;\n        static byte[] encodedBytes = null;\n\n        static byte[] decodedBytes = null;\n\n        @Override\n        protected void onCreate(Bundle savedInstanceState) {\n            super.onCreate(savedInstanceState);\n            setContentView(R.layout.activity_main);\n\n            getData_edt = (EditText) (findViewById(R.id.am_input_edt));\n            genkey_btn = (Button) (findViewById(R.id.am_key_btn));\n            encrypt_btn = (Button) (findViewById(R.id.am_encrypt_btn));\n            decrypt_btn = (Button) (findViewById(R.id.am_decrypt_btn));\n            getData_str = getData_edt.getText().toString();\n\n            genkey_btn.setOnClickListener(this);\n            encrypt_btn.setOnClickListener(this);\n            decrypt_btn.setOnClickListener(this);\n\n        }\n\n        @Override\n        public void onClick(View v) {\n            // TODO Auto-generated method stub\n            switch (v.getId()) {\n\n            case R.id.am_key_btn:\n                genKey(sks);\n\n                break;\n            case R.id.am_encrypt_btn:\n                encrypt(sks);\n\n                break;\n            case R.id.am_decrypt_btn:\n                decrypt();\n\n                break;\n\n            default:\n                break;\n            }\n\n        }\n\n        private void genKey(SecretKeySpec sks) {\n            // TODO Auto-generated method stub\n            Context context = this;\n            final Dialog myDialog = new Dialog(context);\n\n            myDialog.setContentView(R.layout.dialog);\n\n            myDialog.setTitle(\"enter key\");\n\n            key_edt = (EditText) myDialog.findViewById(R.id.dg_key_tv);\n            Button ok_btn = (Button) myDialog.findViewById(R.id.dg_ok_btn);\n            Button cancel_btn = (Button) myDialog.findViewById(R.id.dg_cancel_btn);\n\n            Log.d(TAG1, key_str);\n\n            ok_btn.setOnClickListener(new OnClickListener() {\n\n                @Override\n                public void onClick(View v) {\n                    // TODO Auto-generated method stub\n\n                    key_str = key_edt.getText().toString();\n\n                }\n            });\n            try {\n                SecureRandom sr = SecureRandom.getInstance(\"SHA1PRNG\");\n                sr.setSeed(key_str.getBytes());\n\n                KeyGenerator kg = KeyGenerator.getInstance(\"AES\");\n                kg.init(128, sr);\n                sks = new SecretKeySpec((kg.generateKey()).getEncoded(), \"AES\");\n                Log.i(\"encrypt\", sks.toString());\n\n            } catch (Exception e) {\n                Log.e(TAG, \"AES secret key spec error\");\n            }\n            cancel_btn.setOnClickListener(new OnClickListener() {\n\n                @Override\n                public void onClick(View v) {\n                    // TODO Auto-generated method stub\n                    myDialog.dismiss();\n                }\n            });\n            myDialog.show();\n\n        }\n\n        private void encrypt(SecretKeySpec sks) {\n            // TODO Auto-generated method stub\n\n            try {\n                Cipher c = Cipher.getInstance(\"AES\");\n                c.init(Cipher.ENCRYPT_MODE, sks);\n                encodedBytes = c.doFinal(getData_str.getBytes());\n                String encoded = Base64\n                        .encodeToString(encodedBytes, Base64.DEFAULT);\n                System.out.println(\" \" + encoded);\n            } catch (Exception e) {\n                Log.e(TAG, \"AES encryption error\");\n            }\n        }\n\n        private void decrypt() {\n            // TODO Auto-generated method stub\n\n            try {\n                Cipher c = Cipher.getInstance(\"AES\");\n                c.init(Cipher.DECRYPT_MODE, sks);\n                decodedBytes = c.doFinal(encodedBytes);\n                System.out.println(\" \" + new String(decodedBytes));\n\n            } catch (Exception e) {\n                Log.e(TAG, \"AES decryption error\");\n                TextView tvdecoded = (TextView) findViewById(R.id.am_show_tv);\n                tvdecoded.setText(\"DECOD\\n\" + new String(decodedBytes) + \"\\n\");\n            }\n        }\n    }\n", "idx": 2027}
{"project": "cipher", "commit_id": "Snippet12981410_36583.java", "target": 1, "func": "String passwordToEncrypt = ....//user entered\nbyte[] passwordToEncryptBytes = passwordToEncrypt.getBytes();\n\nKeyGenerator keyGen = KeyGenerator.getInstance(\"AES\");\nSecretKey mySecretKey = keyGen.generateKey();\n\nCipher cipher = Cipher.getInstance(\"AES/CBC/PKCS5Padding\");\ncipher.init(Cipher.ENCRYPT_MODE, mySecretKey);\nIvParameterSpec ivParameter = \n                    cipher.getParameters().getParameterSpec(IvParameterSpec.class);\nbyte[] encryptedPasswordData = cipher.doFinal(passwordToEncryptBytes);\n", "idx": 2525}
{"project": "cipher", "commit_id": "Snippet4951468_31413.java", "target": 1, "func": "Cipher cipher = Cipher.getInstance(\"AES/CTR/PKCS5Padding\", \"BC\");\n\ncipher.init(Cipher.ENCRYPT_MODE, key);\n\nbyte[] result = cipher.doFinal(\"Some plaintext\");\n", "idx": 2476}
{"project": "cipher", "commit_id": "Snippet22280721_4677.java", "target": 0, "func": "import java.security.spec.*;\nimport javax.crypto.*;\nimport sun.misc.BASE64Decoder;\nimport sun.misc.BASE64Encoder;\n\npublic class DESedeEncryption {\npublic static void main(String[] args) {\n\nSecretKey k1 = generateDESkey();\nSecretKey k2 = generateDESkey();\n\nString firstEncryption = desEncryption(\"plaintext\", k1);\nSystem.out.println(\"firstEncryption Value : \"+firstEncryption);\nString decryption = desDecryption(firstEncryption, k2);\nSystem.out.println(\"decryption Value : \"+decryption);\nString secondEncryption = desEncryption(decryption, k1);\nSystem.out.println(\"secondEncryption Value : \"+secondEncryption);\n\n}\n\npublic static SecretKey generateDESkey() {\nKeyGenerator keyGen = null;\ntry {\n    keyGen = KeyGenerator.getInstance(\"DESede\");\n} catch (Exception ex) {     \n}\nkeyGen.init(112); // key length 56\nSecretKey secretKey = keyGen.generateKey();\nreturn secretKey;\n}\n\npublic static String desEncryption(String strToEncrypt, SecretKey desKey) {\ntry {\n    Cipher cipher = Cipher.getInstance(\"DESede/ECB/PKCS5Padding\");\n    cipher.init(Cipher.ENCRYPT_MODE, desKey);\n    BASE64Encoder base64encoder = new BASE64Encoder();\n    byte[] encryptedText = cipher.doFinal(strToEncrypt.getBytes());\n    String encryptedString =base64encoder.encode(encryptedText);\n    return encryptedString;\n} catch (Exception ex) {\n}\nreturn null;\n}\n\npublic static String desDecryption(String strToDecrypt, SecretKey desKey) {\ntry {\n    Cipher cipher = Cipher.getInstance(\"DESede/ECB/PKCS5Padding\");\n    cipher.init(Cipher.DECRYPT_MODE, desKey);\n    BASE64Decoder base64decoder = new BASE64Decoder();\n    byte[] encryptedText = base64decoder.decodeBuffer(strToDecrypt);\n    byte[] plainText = cipher.doFinal(encryptedText);\n    String decryptedString= bytes2String(plainText);\n    return decryptedString;\n} catch (Exception ex) {\n}\nreturn null;\n}\n\n private static String bytes2String(byte[] bytes) {\n    StringBuffer stringBuffer = new StringBuffer();\n    for (int i = 0; i <bytes.length; i++) {\n        stringBuffer.append((char) bytes[i]);\n    }\n    return stringBuffer.toString();\n}\n}\n", "idx": 2198}
{"project": "cipher", "commit_id": "Snippet27561605_9666.java", "target": 1, "func": "public static void deriveKeyAndIV(String password)\n            throws Exception\n    {\n        SecureRandom random = new SecureRandom();\n        if (salt == null)\n        {\n            salt = new byte[HASH_BYTE_SIZE / 8]; // use salt size at least as long as hash\n            random.nextBytes(salt);\n        }\n        if (ivBytes == null)\n        {\n            ivBytes = new byte[HASH_BYTE_SIZE / 8];\n            random.nextBytes(ivBytes);\n        }\n\n        PBEKeySpec spec = new PBEKeySpec(password.toCharArray(), salt, PBKDF2_ITERATIONS, HASH_BYTE_SIZE);\n        SecretKeyFactory skf = SecretKeyFactory.getInstance(\"PBKDF2WithHmacSHA256\");\n        keyBytes = skf.generateSecret(spec).getEncoded();\n    }\npublic static byte[] encrypt(byte[] message) \n            throws Exception\n    {\n        // wrap key data in Key/IV specs to pass to cipher\n        SecretKeySpec key = new SecretKeySpec(keyBytes, \"AES\");\n        //IvParameterSpec ivSpec = new IvParameterSpec(ivBytes);\n        // create the cipher with the algorithm you choose\n        // see javadoc for Cipher class for more info, e.g.\n        Cipher cipher = Cipher.getInstance(\"AES/GCM/PKCS5Padding\");\n\n        GCMParameterSpec gps = new GCMParameterSpec(128, ivBytes);\n\n        cipher.init(Cipher.ENCRYPT_MODE, key, gps);\n        byte[] encrypted = new byte[cipher.getOutputSize(message.length)];\n        int enc_len = cipher.update(message, 0, message.length, encrypted, 0);\n        enc_len += cipher.doFinal(encrypted, enc_len);\n        return encrypted;\n    }\npublic static byte[] decrypt(byte[] cipher_text) \n            throws Exception\n    {\n        // wrap key data in Key/IV specs to pass to cipher\n        SecretKeySpec key = new SecretKeySpec(keyBytes, \"AES\");\n        // create the cipher with the algorithm you choose\n        // see javadoc for Cipher class for more info, e.g.\n        Cipher cipher = Cipher.getInstance(\"AES/GCM/PKCS5Padding\");\n\n        GCMParameterSpec gps = new GCMParameterSpec(128, ivBytes);\n\n        cipher.init(Cipher.DECRYPT_MODE, key, gps);\n        byte[] decrypted = new byte[cipher.getOutputSize(cipher_text.length)];\n        int dec_len = cipher.update(cipher_text, 0, cipher_text.length, decrypted, 0);\n        dec_len += cipher.doFinal(decrypted, dec_len);\n        return decrypted;\n    }\npublic static void main(String[] args) {\n        String pass = \"hello\";\n        try {\n            deriveKeyAndIV(pass);\n            byte[] tmp = encrypt(\"world!\".getBytes());\n            System.out.println(new String(Base64.getEncoder().encode(tmp)));\n            System.out.println(new String(tmp));\n            System.out.println(\"encrypted:\\t\" + bytesToHex(tmp));\n            System.out.println(\"key:\\t\" + bytesToHex(keyBytes));\n            System.out.println(\"iv:\\t\" + bytesToHex(ivBytes));\n            tmp = decrypt(tmp);\n\n            System.out.println(\"decrypted:\\t\" + bytesToHex(tmp));\n        } catch (Exception e) {\n            e.printStackTrace();\n        }\n\n    }\n", "idx": 2478}
{"project": "cipher", "commit_id": "Snippet10427205_34794.java", "target": 0, "func": "byte[] key = new byte[]{31, 30, 31, 36, 32, 11, 11, 11, 22, 26,\n               30, 30, 30, 30, 30, 30, 30, 30, 30, 30, 30, 30, 30, 30};\nmyKeySpec = new DESedeKeySpec(key);\nmySecretKeyFactory = SecretKeyFactory.getInstance(\"TripleDES\");\nde = mySecretKeyFactory.generateSecret(myKeySpec);\n\n    Cipher c = Cipher.getInstance(\"TripleDES\");\nc.init(Cipher.DECRYPT_MODE, key);\n\n    int l = completeHexStr.length();\n\n    if (l%8==1){\n        completeHexStr = completeHexStr + \"0000000\";\n    }else if (l%8==7){\n        completeHexStr = completeHexStr + \"0\";\n    }\nbyte decordedValue[] =completeHexString.getBytes();\nbyte[] decValue = c.doFinal(decordedValue);\nString decryptedValue = new String(decValue);\nSystem.out.println(\"decryptedValue= \" + decryptedValue);\n", "idx": 1917}
{"project": "cipher", "commit_id": "Snippet12995990_36625.java", "target": 0, "func": "// in java\nchiper = Cipher.getInstance(\"DES/CBC/PKCS5Padding\");\n", "idx": 2229}
{"project": "cipher", "commit_id": "Snippet18433119_1493.java", "target": 0, "func": "KeyGenerator keyGenerator = KeyGenerator.getInstance(\"Blowfish\");\nSecretKey secretKey = keyGenerator.generateKey();\nCipher cipher = Cipher.getInstance(\"Blowfish\"); \ncipher.init(Cipher.ENCRYPT_MODE, secretKey);\nString input = \"password\";\nbyte encrypted[] = cipher.doFinal(input.getBytes());\n\nStringBuilder str = new StringBuilder();\n\nfor(byte b:encrypted){\n     str.append(String.format(\"%02x\", b));\n}\n\nString encData = str.toString();\nSystem.out.println(encData);\n", "idx": 2083}
{"project": "cipher", "commit_id": "Snippet10222196_34563.java", "target": 1, "func": "import java.security.InvalidKeyException;\nimport java.security.KeyFactory;\nimport java.security.KeyPair;\nimport java.security.KeyPairGenerator;\nimport java.security.NoSuchAlgorithmException;\nimport java.security.PrivateKey;\nimport java.security.PublicKey;\nimport java.security.SecureRandom;\nimport java.security.spec.InvalidKeySpecException;\nimport java.security.spec.PKCS8EncodedKeySpec;\nimport java.security.spec.X509EncodedKeySpec;\n\nimport javax.crypto.BadPaddingException;\nimport javax.crypto.Cipher;\nimport javax.crypto.IllegalBlockSizeException;\nimport javax.crypto.NoSuchPaddingException;\nimport javax.xml.bind.DatatypeConverter;\n\npublic class RSAExample {\n    private static byte[] h2b(String hex){\n        return DatatypeConverter.parseHexBinary(hex);\n    }\n    private static String b2h(byte[] bytes){\n        return DatatypeConverter.printHexBinary(bytes);\n    }\n\n    private static SecureRandom sr = new SecureRandom();\n\n    public static KeyPair newKeyPair(int rsabits) throws NoSuchAlgorithmException {\n        KeyPairGenerator generator = KeyPairGenerator.getInstance(\"RSA\");\n        generator.initialize(rsabits, sr);\n        return generator.generateKeyPair();\n    }\n\n    public static byte[] pubKeyToBytes(PublicKey key){\n        return key.getEncoded(); // X509 for a public key\n    }\n    public static byte[] privKeyToBytes(PrivateKey key){\n        return key.getEncoded(); // PKCS8 for a private key\n    }\n\n    public static PublicKey bytesToPubKey(byte[] bytes) throws InvalidKeySpecException, NoSuchAlgorithmException{\n        return KeyFactory.getInstance(\"RSA\").generatePublic(new X509EncodedKeySpec(bytes));\n    }\n    public static PrivateKey bytesToPrivKey(byte[] bytes) throws InvalidKeySpecException, NoSuchAlgorithmException{\n        return KeyFactory.getInstance(\"RSA\").generatePrivate(new PKCS8EncodedKeySpec(bytes));\n    }\n\n    public static byte[] encryptWithPubKey(byte[] input, PublicKey key) throws IllegalBlockSizeException, BadPaddingException, InvalidKeyException, NoSuchAlgorithmException, NoSuchPaddingException {\n        Cipher cipher = Cipher.getInstance(\"RSA/ECB/PKCS1Padding\");\n        cipher.init(Cipher.ENCRYPT_MODE, key);\n        return cipher.doFinal(input);\n    }\n    public static byte[] decryptWithPrivKey(byte[] input, PrivateKey key) throws IllegalBlockSizeException, BadPaddingException, InvalidKeyException, NoSuchAlgorithmException, NoSuchPaddingException {\n        Cipher cipher = Cipher.getInstance(\"RSA/ECB/PKCS1Padding\");\n        cipher.init(Cipher.DECRYPT_MODE, key);\n        return cipher.doFinal(input);\n    }\n\n\n    public static void main(String[] args) throws Exception {\n        KeyPair kp = newKeyPair(1<<11); // 2048 bit RSA; might take a second to generate keys\n        PublicKey pubKey = kp.getPublic();\n        PrivateKey privKey = kp.getPrivate();\n        String plainText = \"Dear Bob,\\nWish you were here.\\n\\t--Alice\";\n        byte[] cipherText = encryptWithPubKey(plainText.getBytes(\"UTF-8\"),pubKey);\n        System.out.println(\"cipherText: \"+b2h(cipherText));\n        System.out.println(\"plainText:\");\n        System.out.println(new String(decryptWithPrivKey(cipherText,privKey),\"UTF-8\"));\n    }\n}\n", "idx": 2759}
{"project": "cipher", "commit_id": "Snippet22395403_4778.java", "target": 1, "func": "KeyStore primaryKeyStore = getKeyStore(keyStoreFile, password, keyType, provider);\njava.security.cert.Certificate certs = primaryKeyStore.getCertificate(aliasName);\ncipher = Cipher.getInstance(\"RSA\");\ncipher.init(Cipher.ENCRYPT_MODE, certs);\n", "idx": 2763}
{"project": "cipher", "commit_id": "Snippet24541112_6883.java", "target": 1, "func": "Cipher.getInstance(\"RSA/ECB/PKCS1Padding\");\n", "idx": 2640}
{"project": "cipher", "commit_id": "Snippet47103931_29114.java", "target": 1, "func": "        Cipher aesCBC = Cipher.getInstance(\"AES/CBC/Pkcs5Padding\");\n        MessageDigest md5 = MessageDigest.getInstance(\"MD5\");\n\n        // --- create key and IV  ---\n        // the IV is useless, OpenSSL might as well have use zero's\n        final byte[][] keyAndIV = EVP_BytesToKey(\n                KEY_SIZE_BITS / 8,\n                aesCBC.getBlockSize(),\n                md5,\n                salt,\n                PASSWORD_STRING.getBytes(\"UTF-8\"),\n                ITERATIONS);\n        SecretKeySpec key = new SecretKeySpec(keyAndIV[INDEX_KEY], \"AES\");\n        IvParameterSpec iv = new IvParameterSpec(keyAndIV[INDEX_IV]);\n\n        // --- initialize cipher instance and decrypt ---\n        aesCBC.init(Cipher.DECRYPT_MODE, key, iv);\n        byte[] decrypted = aesCBC.doFinal(encrypted);\n\n        System.out.println(new String(decrypted, \"UTF-8\"));\n", "idx": 2583}
{"project": "cipher", "commit_id": "Snippet40192264_22090.java", "target": 1, "func": "Cipher.getInstance(\"RSA/ECB/PKCS1Padding\")\n", "idx": 2666}
{"project": "cipher", "commit_id": "Snippet42252463_24226.java", "target": 1, "func": "public static String toHex(String arg) {\n    return String.format(\"%x\", new BigInteger(1, arg.getBytes()));\n}\npublic static String AesEncrypt(String encryptedMessage){\n    try {\n        IvParameterSpec initialVector = new IvParameterSpec(\"xxxxxxxxxxxxxxxx\".getBytes(\"UTF-8\"));\n        SecretKeySpec secretKeySpec = new SecretKeySpec(\"xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx\".getBytes(\"UTF-8\"), \"AES\");\n\n        Cipher cipher = Cipher.getInstance(\"AES/CBC/PKCS5Padding\");\n        cipher.init(Cipher.ENCRYPT_MODE, secretKeySpec, initialVector);\n\n        byte[] encrypted = cipher.doFinal(encryptedMessage.getBytes());\n        StringBuilder encryptedSb = new StringBuilder(encrypted.length);\n        for (byte i : encrypted){\n            encryptedSb.append(i);\n        }\n        return toHex(encryptedSb.toString());\n    } catch (Exception ex) {\n        ex.printStackTrace();\n        return null;\n    }\n}\n", "idx": 2367}
{"project": "cipher", "commit_id": "Snippet30160303_12309.java", "target": 0, "func": "import java.io.File;\nimport java.io.FileInputStream;\nimport java.io.FileOutputStream;\nimport java.io.IOException;\n\nimport javax.crypto.BadPaddingException;\nimport javax.crypto.Cipher;\nimport javax.crypto.CipherOutputStream;\nimport javax.crypto.IllegalBlockSizeException;\nimport javax.crypto.NoSuchPaddingException;\nimport javax.crypto.ShortBufferException;\nimport javax.crypto.spec.SecretKeySpec;\n\nimport java.security.InvalidKeyException;\nimport java.security.NoSuchAlgorithmException;\nimport java.security.NoSuchProviderException;\nimport java.util.Scanner;\n\npublic class EncryptDecrypt {\n    static Cipher cipher;\n    static byte[] cipherText;\n    static byte[] input;\n    static byte k[]=\"2305ty6345663ty0\".getBytes();\n    static SecretKeySpec key = new SecretKeySpec(k, \"AES\");\n    static int ctLength;\n    static String filePath = \"C:/inddexfolder/casie.jpg\";\n    static String encryptionPath = \"C:/indexfolder1/encrypt.jpg\";\n\n        public static void main(String[] args) {\n            EncryptDecrypt.encrypt();\n            EncryptDecrypt.decrypt();\n        }\n\n        public static void encrypt() {\n            try{\n                input = filePath.getBytes();\n                FileInputStream file = new FileInputStream(filePath);\n                FileOutputStream outStream = new FileOutputStream(encryptionPath);\n\n                cipher  = Cipher.getInstance(\"AES/ECB/PKCS5Padding\", \"SunJCE\");\n\n                cipher.init(Cipher.ENCRYPT_MODE, key);\n                cipherText = new byte[cipher.getOutputSize(input.length)];\n                ctLength = cipher.update(input, 0, input.length, cipherText, 0);\n                ctLength+= cipher.doFinal(cipherText, ctLength);\n                String encrypted = new String (cipherText);\n                CipherOutputStream cos = new CipherOutputStream(outStream, cipher);\n                byte[] buf = new byte[1024];\n                int read;\n                while((read=file.read(buf))!=-1){\n                    cos.write(buf,0,read);\n                }\n                file.close();\n                outStream.flush();\n                cos.close();\n            }\n            catch(IOException e) {  \n                e.printStackTrace();\n            } catch (NoSuchAlgorithmException e) {\n                e.printStackTrace();\n            } catch (NoSuchPaddingException e) {\n                e.printStackTrace();\n            } catch (InvalidKeyException e) {\n                e.printStackTrace();\n            } catch (NoSuchProviderException e) {\n                e.printStackTrace();\n            } catch (IllegalBlockSizeException e) {\n                e.printStackTrace();\n            } catch (ShortBufferException e) {\n                e.printStackTrace();\n            } catch (BadPaddingException e) {\n                e.printStackTrace();\n            }\n        }\n\n        public static void decrypt() {\n        try {\n            FileInputStream file = new FileInputStream(encryptionPath);\n            FileOutputStream outStream = new FileOutputStream(\"casenc1.jpg\");\n            byte k[]=\"2305ty6345663ty0\".getBytes();\n            SecretKeySpec key = new SecretKeySpec(k, \"AES\");\n            cipher  = Cipher.getInstance(\"AES\");\n            cipher.init(Cipher.DECRYPT_MODE, key);\n            CipherOutputStream cos = new CipherOutputStream(outStream, cipher);\n            byte[] buf = new byte[1024];\n            int read;\n            while((read=file.read(buf))!=-1) {\n                cos.write(buf,0,read);\n            }\n            file.close();\n            outStream.flush();\n            cos.close();\n\n         Runtime.getRuntime().exec(\"rundll32 url.dll, FiProtocolHandler \n          \"+\"casenc1.jpg\");\n\n        } catch(IOException e) {\n            System.out.println(\" not decrypted Successfully\");\n        } catch (InvalidKeyException e) {\n            e.printStackTrace();\n        } catch (NoSuchAlgorithmException e) {\n            e.printStackTrace();\n        } catch (NoSuchPaddingException e) {\n            e.printStackTrace();\n        }\n    }\n}\n", "idx": 2048}
{"project": "cipher", "commit_id": "Snippet12894722_36444.java", "target": 0, "func": "public String saltTxt = \"12345678\";\npublic String Encrypt(String str) {\n    try {\n        KeySpec myKey = new DESKeySpec(saltTxt.getBytes(\"UTF8\"));\n        SecretKey key = SecretKeyFactory.getInstance(\"DES\").generateSecret(myKey);\n        Cipher ecipher = Cipher.getInstance(\"DES\");\n        ecipher.init(Cipher.ENCRYPT_MODE, key);\n\n        byte[] data = str.getBytes(\"UTF8\");\n\n        byte[] crypt = ecipher.doFinal(data);\n\n        return new BASE64Encoder().encode(crypt);\n    } catch (Exception ex) {\n    }\n\n    return null;\n} \n", "idx": 1999}
{"project": "cipher", "commit_id": "Snippet21881829_4297.java", "target": 1, "func": "public boolean decryptFile(String filePath)\n    {\n\n        try {\n            SecretKeySpec secretKey = new SecretKeySpec(Password.getBytes(\"ASCII\"), \"AES\");\n            dcipher = Cipher.getInstance(\"AES/CBC/PKCS5Padding\");\n            dcipher.init(Cipher.DECRYPT_MODE, secretKey, new IvParameterSpec(InitialVector.getBytes(\"ASCII\")));\n\n            //Creating File object to into FileInputStream() constructor\n            String fileDirectory = Environment.getExternalStorageDirectory().getPath() + filePath;\n            String actualFilePath = fileDirectory + \"/\" + \"Text.txt\";\n            File actualFile = new File(actualFilePath);\n\n            //create input stream to read in file that needs to be decrypted\n            FileInputStream inputStream = new FileInputStream(actualFile);\n\n            //create output stream to write out the decrypted results, remove .vault to from file\n            FileOutputStream outputStream = new FileOutputStream(filePath.replace(\".vault\", filePath));\n            //wrap the output stream\n            CipherInputStream encryptedInputStream = new CipherInputStream(inputStream, dcipher);\n\n            //Decrypt the file\n            int bytes;\n            byte[] data = new byte[8];\n            while((bytes = encryptedInputStream.read(data)) != -1)\n            {\n                outputStream.write(data, 0, bytes);\n            }\n\n            // Flush and close streams.\n            outputStream.flush();\n            outputStream.close();\n            inputStream.close();\n            encryptedInputStream.close();\n\n        } catch (FileNotFoundException e) {\n            e.printStackTrace();\n            return false;\n        } catch (InvalidKeyException e) {\n            e.printStackTrace();\n            return false;\n        } catch (InvalidAlgorithmParameterException e) {\n            e.printStackTrace();\n            return false;\n        }catch (NoSuchAlgorithmException e) {\n            e.printStackTrace();\n            return false;\n        } catch (NoSuchPaddingException e) {\n            e.printStackTrace();\n            return false;\n        }catch (UnsupportedEncodingException e) {\n            e.printStackTrace();\n            return false;\n        } catch (IOException e) {\n            e.printStackTrace();\n            return false;\n        } \n        return true;\n    }\n", "idx": 2557}
{"project": "cipher", "commit_id": "Snippet27817741_9970.java", "target": 0, "func": "Cipher cipher = Cipher.getInstance(\"AES\", \"BC\");\n", "idx": 1996}
{"project": "cipher", "commit_id": "Snippet40421146_22286.java", "target": 1, "func": "    private static String TRANSFORMATION = \"AES/CBC/PKCS5Padding\";\n\n    private static String ALGORITHM = \"AES\";\n    private static String DIGEST = \"MD5\";\n\n    private static Cipher cipher;\n    private static SecretKey password;\n    private static IvParameterSpec IVParamSpec;\n    private final static String pvtkey=\"GDNBCGDRFSC$%#%=\";\n\n    //16-byte private key\n    private static byte[] IV = pvtkey.getBytes();\n\n    public PassWordEncryptor() {\n        try {\n\n            //Encode digest\n            MessageDigest digest;           \n            digest = MessageDigest.getInstance(DIGEST);            \n            password = new SecretKeySpec(digest.digest(pvtkey.getBytes()), ALGORITHM);\n\n            //Initialize objects\n            cipher = Cipher.getInstance(TRANSFORMATION);\n            IVParamSpec = new IvParameterSpec(IV);\n\n        } catch (NoSuchAlgorithmException e) {\n            Log.i(Lams4gApp.TAG, \"No such algorithm \" + ALGORITHM);\n        } catch (NoSuchPaddingException e) {\n            System.out.println( \"No such padding PKCS7\"+ e);\n        }\n    }\n    /**\n    Encryptor.\n\n    @text String to be encrypted\n    @return Base64 encrypted text\n\n    */\n    public String encrypt(byte[] text) {\n\n        byte[] encryptedData;\n\n        try {\n\n            cipher.init(Cipher.ENCRYPT_MODE, password, IVParamSpec);\n            encryptedData = cipher.doFinal(text);\n\n        } catch (InvalidKeyException e) {\n            System.out.println( \"Invalid key  (invalid encoding, wrong length, uninitialized, etc).\"+ e);\n            return null;\n        } catch (InvalidAlgorithmParameterException e) {\n            System.out.println( \"Invalid or inappropriate algorithm parameters for \" + ALGORITHM+ e);\n            return null;\n        } catch (IllegalBlockSizeException e) {\n            System.out.println( \"The length of data provided to a block cipher is incorrect\"+ e);\n            return null;\n        } catch (BadPaddingException e) {\n            System.out.println( \"The input data but the data is not padded properly.\"+ e);\n            return null;\n        }               \n        return Base64.encodeToString(encryptedData,Base64.DEFAULT);\n\n    }\n", "idx": 2354}
{"project": "cipher", "commit_id": "Snippet45597969_27677.java", "target": 1, "func": "public class KripAsim {\nString hasil;\n\npublic String encrypt(String text) {\n    try {\n\n        String PUBLIC_KEY=\"MIIBIjANBgkqhkiG9w0BAQEFAAOCAQ8AMIIBCgKCAQEAvCNqSslgCndo8vfNrkXFDLXmst024Oi8D7LEiJFjYBva4kBKKISe8rKp58kCLLHjv90RN+Dy2KWcf0eFkKaqc3zILBI99JhV1z8TFOzmt5dfgW6fD1ucBfsK6pWxK84DddyOqKldwHlReqjuDHT2jLue51vpXaCa12WV5bMnGsfy3vZKnp699YCguqRpTR1MijZ9pz8WqldrR0a/DCaq5YxZ7lvjwuWIodQy3S3XRHAaeaUrFHFFLumzXAGuP447oRYR0p+1qsy8+wOtrsGm8m8bMg+C1XGMblkODtOFHz3wtrRZ5OwzgEm7J7odmSX8mSYBZYLcnUVqIFRsQkZLiwIDAQAB\";\n\n        byte [] decoded = Base64.decode(PUBLIC_KEY,Base64.NO_WRAP);\n        KeyFactory keyFac = KeyFactory.getInstance(\"RSA\");\n        PKCS8EncodedKeySpec keySpec = new PKCS8EncodedKeySpec(decoded);\n\n        PublicKey pubkey = keyFac.generatePublic(keySpec);\n\n        Cipher rsa;\n        rsa = Cipher.getInstance(\"RSA\");\n        rsa.init(Cipher.ENCRYPT_MODE, pubkey);\n        hasil = Base64.encodeToString(rsa.doFinal(text.getBytes(\"UTF-8\")),Base64.NO_WRAP);\n        return hasil;\n    } catch (Exception e) {\n        e.printStackTrace();\n    }\n    return hasil;\n\n}\n}\n", "idx": 2491}
{"project": "cipher", "commit_id": "Snippet32411759_14498.java", "target": 0, "func": "        try {\n        String dataAlgorithm =  JCEMapper.translateURItoJCEID(tmp);\n        decryptor = Cipher.getInstance(dataAlgorithm);\n\n        //decryptor = Cipher.getInstance(\"DESede/CBC/ISO10126Padding\");\n\n        int ivLen = decryptor.getBlockSize();\n        byte[] ivBytes = null; // = new byte[ivLen];\n\n        if (dataAlgorithm.matches(\".*[gG][cC][mM].*$\")) { // TK 03/09/2015 - probably needs more places for decrypting body stuff\n          ivLen = 12; // 12 for GCM - also see wss4j-2.1.2/ws-security-common/src/main/java/org/apache/wss4j/common/util/AttachmentUtils.java\n          ivBytes = new byte[ivLen];\n          System.arraycopy(cipherInput, 0, ivBytes, 0, ivLen);\n          GCMParameterSpec iv = new GCMParameterSpec(16 * Byte.SIZE, ivBytes);\n          decryptor.init(Cipher.DECRYPT_MODE, symmetricKey, iv);\n        }\n        else {\n          ivBytes = new byte[ivLen];\n          System.arraycopy(cipherInput, 0, ivBytes, 0, ivLen);\n          IvParameterSpec iv = new IvParameterSpec(ivBytes);\n          decryptor.init(Cipher.DECRYPT_MODE, symmetricKey, iv);\n        }\n\n        cipherOutput = decryptor.doFinal(cipherInput, ivLen, cipherInput.length-ivLen);\n    } catch (Exception e) {\n        log.log(Level.SEVERE, \"WSS1232.failedto.decrypt.attachment\", e);\n        throw new XWSSecurityException(e);\n    }\n", "idx": 2169}
{"project": "cipher", "commit_id": "Snippet38407929_19350.java", "target": 0, "func": "Cipher cipher = Cipher.getInstance(\"Blowfish\")", "idx": 2148}
{"project": "cipher", "commit_id": "Snippet14696399_37885.java", "target": 1, "func": "Cipher cipher = Cipher.getInstance(\"AES/CBC/PKCS5Padding\");\n", "idx": 2575}
{"project": "cipher", "commit_id": "Snippet16369787_39315.java", "target": 0, "func": "Cipher dcipher = Cipher.getInstance(\"DESede/CBC/PKCS5Padding\",\"SunJCE\");\n", "idx": 2166}
{"project": "cipher", "commit_id": "Snippet15906041_38899.java", "target": 1, "func": "public class Cryptor {\n\n    private Cipher cipher;\n    private String secretKey = \"1234567890qwertz\";\n    private String iv = \"1234567890qwertz\";\n\n    private SecretKey keySpec;\n    private IvParameterSpec ivSpec;\n    private Charset CHARSET = Charset.forName(\"ISO-8859-1\"); // ISO-8859-1 vs. UTF-8\n\n    public Cryptor() throws CryptingException {\n\n        keySpec = new SecretKeySpec(secretKey.getBytes(CHARSET), \"AES\");\n        ivSpec = new IvParameterSpec(iv.getBytes(CHARSET));\n        try {\n            cipher = Cipher.getInstance(\"AES/CFB8/NoPadding\");\n        } catch (NoSuchAlgorithmException e) {\n            throw new SecurityException(e);\n        } catch (NoSuchPaddingException e) {\n            throw new SecurityException(e);\n        }\n    }\n\n    public String decrypt(String input) throws CryptingException {\n\n        try {\n            cipher.init(Cipher.DECRYPT_MODE, keySpec, ivSpec);\n            return new String(cipher.doFinal(input.getBytes(CHARSET)), CHARSET).trim();\n        } catch (IllegalBlockSizeException e) {\n            throw new SecurityException(e);\n        } catch (BadPaddingException e) {\n            throw new SecurityException(e);\n        } catch (InvalidKeyException e) {\n            throw new SecurityException(e);\n        } catch (InvalidAlgorithmParameterException e) {\n            throw new SecurityException(e);\n        }\n    }\n\n    public String encrypt(String input) throws CryptingException {\n        try {\n            cipher.init(Cipher.ENCRYPT_MODE, keySpec, ivSpec);\n            return new String(cipher.doFinal(input.getBytes(CHARSET)), CHARSET).trim();\n        } catch (InvalidKeyException e) {\n            throw new SecurityException(e);\n        } catch (InvalidAlgorithmParameterException e) {\n            throw new SecurityException(e);\n        } catch (IllegalBlockSizeException e) {\n            throw new SecurityException(e);\n        } catch (BadPaddingException e) {\n            throw new SecurityException(e);\n        }\n    }\n\n    public static void main(String Args[]) {\n\n        try {\n            Cryptor c = new Cryptor();\n            String original = \"MiiiM\u00fc\u00e4\u00f6Mee\u029e\";\n            System.out.println(\"Original: \" + original);\n            String encrypted = c.encrypt(\"MiiiM\u00fc\u00e4\u00f6Mee\u029e\");\n            System.out.println(\"Encoded: \" + encrypted);\n            System.out.println(\"Decoded: \" + c.decrypt(encrypted));\n\n        } catch (CryptingException e) {\n            e.printStackTrace();\n        }\n    }\n\n    class CryptingException extends RuntimeException {\n\n        private static final long serialVersionUID = 7123322995084333687L;\n\n        public CryptingException() {\n            super();\n        }\n\n        public CryptingException(String message) {\n            super(message);\n        }\n    }\n}\n", "idx": 2634}
{"project": "cipher", "commit_id": "Snippet15610329_38417.java", "target": 1, "func": "Cipher c = Cipher.getInstance(\"AES/CBC/NoPadding\");\nc.init(Cipher.ENCRYPT_MODE, secretKey, new IvParameterSpec(zeroBytes));\n\nbyte[] encrypted_response = transceive(c.doFinal(message));\n\n// TODO: cipher needs to be re-set to DECRYPT_MODE while retaining the IV\nc.init(Cipher.DECRYPT_MODE, ...?);\n\nbyte[] response = c.doFinal(encrypted_response);\n", "idx": 2576}
{"project": "cipher", "commit_id": "Snippet10341150_34701.java", "target": 1, "func": "    SecretKeySpec localSecretKeySpec = new SecretKeySpec(\"aaaaaaaaaaaaaaaa\".getBytes(), \"AES\");\n    Cipher localCipher = Cipher.getInstance(\"AES/CBC/PKCS5Padding\");\n    localCipher.init(Cipher.ENCRYPT_MODE, localSecretKeySpec);\n\n    CipherOutputStream cos = new CipherOutputStream(new FileOutputStream(\"abc\"), localCipher);\n    IOUtils.write(\"abc\", cos);\n    cos.flush();\n", "idx": 2621}
{"project": "cipher", "commit_id": "Snippet31474283_13631.java", "target": 1, "func": "public void decrypt(String inputFile){\n    FileInputStream fis = new FileInputStream(inputFile);\n    // Save file: filename.dec\n    FileOutputStream fos = new FileOutputStream(inputFile.substring(0,\n            inputFile.length() - 4) + \".dec\");\n\n    Cipher cipher = Cipher.getInstance(\"AES/CBC/PKCS5Padding\");\n    cipher.init(Cipher.DECRYPT_MODE, secret, new IvParameterSpec(iv));\n    // Read from file encrypted  ---> .dec \n    int readByte;\n    byte[] buffer = new byte[1024];\n    while ((readByte = fis.read(buffer)) != -1) {\n        fos.write(cipher.doFinal(buffer), 0, readByte);\n    }\n    fos.flush();\n    fos.close();\n    fis.close();\n}\n", "idx": 2394}
{"project": "cipher", "commit_id": "Snippet2556365_30325.java", "target": 1, "func": "import java.io.OutputStream;\nimport java.math.BigInteger;\nimport java.security.Key;\nimport java.security.KeyFactory;\nimport java.security.interfaces.RSAPrivateKey;\nimport java.security.interfaces.RSAPublicKey;\nimport java.security.spec.RSAPrivateKeySpec;\nimport java.security.spec.RSAPublicKeySpec;\n\nimport javax.crypto.Cipher;\n\npublic class AsyncronousKeyTest {\n\n    private final Cipher cipher;\n    private final KeyFactory keyFactory;\n    private final RSAPrivateKey privKey;\n\n    private AsyncronousKeyTest() throws Exception {\n cipher = Cipher.getInstance(\"AES/CBC/NoPaddin\", \"BC\");\n keyFactory = KeyFactory.getInstance(\"AES\", \"BC\");\n\n // create the keys\n\n RSAPrivateKeySpec privKeySpec = new RSAPrivateKeySpec(new BigInteger(\n  \"d46f473a2d746537de2056ae3092c451\", 16), new BigInteger(\"57791d5430d593164082036ad8b29fb1\",\n  16));\n privKey = (RSAPrivateKey) keyFactory.generatePrivate(privKeySpec);\n\n    }\n\n    public void generateAuthorizationAct(OutputStream outputStream) throws Exception {\n\n KeyFactory keyFactory = KeyFactory.getInstance(\"AES\", \"BC\");\n RSAPublicKeySpec pubKeySpec = new RSAPublicKeySpec(new BigInteger(\"d46f473a2d746537de2056ae3092c451\",\n  16), new BigInteger(\"11\", 16));\n RSAPublicKey pubKey = (RSAPublicKey) keyFactory.generatePublic(pubKeySpec);\n\n byte[] data = new byte[] {0x01};\n\n byte[] encrypted = encryptAO(pubKey, data);\n outputStream.write(encrypted);\n    }\n\n    /** Encrypt the AuthorizationObject. */\n    public byte[] encryptAO(Key pubKey, byte[] data) throws Exception {\n cipher.init(Cipher.ENCRYPT_MODE, pubKey);\n byte[] cipherText = cipher.doFinal(data);\n return cipherText;\n    }\n\n    public byte[] decrypt(byte[] cipherText) throws Exception {\n cipher.init(Cipher.DECRYPT_MODE, privKey);\n byte[] decyptedData = cipher.doFinal(cipherText);\n return decyptedData;\n\n    }\n\n    public static void main(String[] args) throws Exception {\n System.out.println(\"start\");\n\n AsyncronousKeyTest auth = new AsyncronousKeyTest();\n auth.generateAuthorizationAct(System.out);\n\n System.out.println(\"done\");\n    }\n\n}\n", "idx": 2527}
{"project": "cipher", "commit_id": "Snippet16192140_39058.java", "target": 0, "func": "Cipher aes = Cipher.getInstance(\"AES/ECB/PKCS5Padding\");//Gave padding during encryption too\naes.init(Cipher.ENCRYPT_MODE, generateKey());\nbyte[] ciphertext = aes.doFinal(rawPassword.getBytes());\n", "idx": 2251}
{"project": "cipher", "commit_id": "Snippet27621696_9737.java", "target": 1, "func": "package groovy;\n\nimport java.io.BufferedReader;\nimport java.io.FileReader;\nimport java.io.IOException;\nimport java.io.UnsupportedEncodingException;\nimport java.security.GeneralSecurityException;\nimport java.security.InvalidKeyException;\nimport java.security.KeyFactory;\nimport java.security.NoSuchAlgorithmException;\nimport java.security.PrivateKey;\nimport java.security.PublicKey;\nimport java.security.Signature;\nimport java.security.SignatureException;\nimport java.security.interfaces.RSAPrivateKey;\nimport java.security.interfaces.RSAPublicKey;\nimport java.security.spec.PKCS8EncodedKeySpec;\nimport java.security.spec.X509EncodedKeySpec;\n\nimport javax.crypto.Cipher;\n\nimport org.apache.commons.codec.binary.Base64;\n\npublic class RSA {\n\nprivate static String getKey(String filename) throws IOException {\n    // Read key from file\n    String strKeyPEM = \"\";\n    BufferedReader br = new BufferedReader(new FileReader(filename));\n    String line;\n    while ((line = br.readLine()) != null) {\n        strKeyPEM += line + \"\\n\";\n    }\n    br.close();\n    return strKeyPEM;\n}\npublic static RSAPrivateKey getPrivateKey(String filename) throws IOException, GeneralSecurityException {\n    String privateKeyPEM = getKey(filename);\n    return getPrivateKeyFromString(privateKeyPEM);\n}\n\npublic static RSAPrivateKey getPrivateKeyFromString(String key) throws IOException, GeneralSecurityException {\n    String privateKeyPEM = key;\n    privateKeyPEM = privateKeyPEM.replace(\"-----BEGIN PRIVATE KEY-----\\n\", \"\");\n    privateKeyPEM = privateKeyPEM.replace(\"-----END PRIVATE KEY-----\", \"\");\n    byte[] encoded = Base64.decodeBase64(privateKeyPEM);\n    KeyFactory kf = KeyFactory.getInstance(\"RSA\");\n    PKCS8EncodedKeySpec keySpec = new PKCS8EncodedKeySpec(encoded);\n    RSAPrivateKey privKey = (RSAPrivateKey) kf.generatePrivate(keySpec);\n    return privKey;\n}\n\n\npublic static RSAPublicKey getPublicKey(String filename) throws IOException, GeneralSecurityException {\n    String publicKeyPEM = getKey(filename);\n    return getPublicKeyFromString(publicKeyPEM);\n}\n\npublic static RSAPublicKey getPublicKeyFromString(String key) throws IOException, GeneralSecurityException {\n    String publicKeyPEM = key;\n    publicKeyPEM = publicKeyPEM.replace(\"-----BEGIN PUBLIC KEY-----\\n\", \"\");\n    publicKeyPEM = publicKeyPEM.replace(\"-----END PUBLIC KEY-----\", \"\");\n    byte[] encoded = Base64.decodeBase64(publicKeyPEM);\n    KeyFactory kf = KeyFactory.getInstance(\"RSA\");\n    RSAPublicKey pubKey = (RSAPublicKey) kf.generatePublic(new X509EncodedKeySpec(encoded));\n    return pubKey;\n}\n\npublic static String sign(PrivateKey privateKey, String message) throws NoSuchAlgorithmException, InvalidKeyException, SignatureException, UnsupportedEncodingException {\n    Signature sign = Signature.getInstance(\"SHA1withRSA\");\n    sign.initSign(privateKey);\n    sign.update(message.getBytes(\"UTF-8\"));\n    return new String(Base64.encodeBase64(sign.sign()), \"UTF-8\");\n}\n\n\npublic static boolean verify(PublicKey publicKey, String message, String signature) throws SignatureException, NoSuchAlgorithmException, UnsupportedEncodingException, InvalidKeyException {\n    Signature sign = Signature.getInstance(\"SHA1withRSA\");\n    sign.initVerify(publicKey);\n    sign.update(message.getBytes(\"UTF-8\"));\n    return sign.verify(Base64.decodeBase64(signature.getBytes(\"UTF-8\")));\n}\n\npublic static String encrypt(String rawText, PublicKey publicKey) throws IOException, GeneralSecurityException {\n    Cipher cipher = Cipher.getInstance(\"RSA\");\n    cipher.init(Cipher.ENCRYPT_MODE, publicKey);\n    return Base64.encodeBase64String(cipher.doFinal(rawText.getBytes(\"UTF-8\")));\n}\n\npublic static String decrypt(String cipherText, PrivateKey privateKey) throws IOException, GeneralSecurityException {\n    Cipher cipher = Cipher.getInstance(\"RSA\");\n    cipher.init(Cipher.DECRYPT_MODE, privateKey);\n    return new String(cipher.doFinal(Base64.decodeBase64(cipherText)), \"UTF-8\");\n}\n}\n\n\nRequired jar library \"common-codec-1.6\"\n", "idx": 2409}
{"project": "cipher", "commit_id": "Snippet18282593_1325.java", "target": 0, "func": "package Chat.Application;\n\nimport java.awt.event.ActionEvent;\nimport java.awt.event.ActionListener;\nimport java.io.BufferedReader;\nimport java.io.IOException;\nimport java.io.InputStreamReader;\nimport java.io.PrintWriter;\nimport java.net.Socket;\n\nimport javax.swing.JFrame;\nimport javax.swing.JOptionPane;\nimport javax.swing.JScrollPane;\nimport javax.swing.JTextArea;\nimport javax.swing.JTextField;\n\nimport java.security.GeneralSecurityException;\nimport java.security.InvalidKeyException;\nimport java.security.MessageDigest;\nimport java.security.NoSuchAlgorithmException;\nimport java.util.logging.Level;\nimport java.util.logging.Logger;\nimport javax.crypto.BadPaddingException;\nimport javax.crypto.Cipher;\nimport javax.crypto.IllegalBlockSizeException;\nimport javax.crypto.NoSuchPaddingException;\nimport javax.crypto.spec.SecretKeySpec;\nimport org.omg.PortableInterceptor.SYSTEM_EXCEPTION;\n/**\n * A simple Swing-based client for the chat server.  Graphically\n * it is a frame with a text field for entering messages and a\n * textarea to see the whole dialog.\n *\n * The client follows the Chat Protocol which is as follows.\n * When the server sends \"SUBMITNAME\" the client replies with the\n * desired screen name.  The server will keep sending \"SUBMITNAME\"\n * requests as long as the client submits screen names that are\n * already in use.  When the server sends a line beginning\n * with \"NAMEACCEPTED\" the client is now allowed to start\n * sending the server arbitrary strings to be broadcast to all\n * chatters connected to the server.  When the server sends a\n * line beginning with \"MESSAGE \" then all characters following\n * this string should be displayed in its message area.\n */\npublic class ChatClient {\n\n    BufferedReader in;\n    PrintWriter out;\n    JFrame frame = new JFrame(\"ELECTRON Chatroom\");\n    JTextField textField = new JTextField(40);\n    JTextArea messageArea = new JTextArea(8, 40);\n\n    /**\n     * Constructs the client by laying out the GUI and registering a\n     * listener with the textfield so that pressing Return in the\n     * listener sends the textfield contents to the server.  Note\n     * however that the textfield is initially NOT editable, and\n     * only becomes editable AFTER the client receives the NAMEACCEPTED\n     * message from the server.\n     */\n    public ChatClient() {\n\n        // Layout GUI\n        textField.setEditable(false);\n        messageArea.setEditable(false);\n        messageArea.setWrapStyleWord(true);\n        messageArea.setLineWrap(true);\n        frame.getContentPane().add(textField, \"North\");\n        frame.getContentPane().add(new JScrollPane(messageArea), \"Center\");\n        frame.pack();\n        // Add Listeners\n        textField.addActionListener(new ActionListener() {\n            /**\n             * Responds to pressing the enter key in the textfield by sending\n             * the contents of the text field to the server.    Then clear\n             * the text area in preparation for the next message.\n             */\n        @Override\n        public void actionPerformed(ActionEvent e) {\n            try {\n                String input = (textField.getText());\n                //ENCRYPTION\n                MessageDigest md5 = MessageDigest.getInstance(\"MD5\");\n                md5.update(\"So What's Up Doc?\".getBytes());\n\n                SecretKeySpec key = new SecretKeySpec(md5.digest(), \"AES\");\n\n                Cipher cipher = Cipher.getInstance(\"AES\");\n                cipher.init(Cipher.ENCRYPT_MODE, key);\n\n                byte encryptedMessage[] = cipher.doFinal(input.getBytes());\n                //Sends the encrypted version of message\n                System.out.println(encryptedMessage);\n                out.println(encryptedMessage);\n                //Clears the input box\n                textField.setText(\"\");\n            } catch (    NoSuchAlgorithmException | NoSuchPaddingException | InvalidKeyException | IllegalBlockSizeException | BadPaddingException ex) {\n                Logger.getLogger(ChatClient.class.getName()).log(Level.SEVERE, null, ex);\n            }\n            }\n        });\n    }\n\n    /**\n     * Prompt for and return the address of the server.\n     */\n    private String getServerAddress() {\n        return JOptionPane.showInputDialog(\n            frame,\n            \"Enter IP Address of the Server:\",\n            \"ELECTRON Chatroom\",\n            JOptionPane.QUESTION_MESSAGE);\n    }\n\n    /**\n     * Prompt for and return the desired screen name.\n     */\n    private String getName() {\n        return JOptionPane.showInputDialog(\n            frame,\n            \"Choose a screen name:\",\n            \"Screen name selection\",\n            JOptionPane.PLAIN_MESSAGE);\n    }\n\n    /**\n     * Connects to the server then enters the processing loop.\n     */\n    public void run() throws IOException {\n\n        // Make connection and initialize streams\n        String serverAddress = getServerAddress();\n        Socket socket = new Socket(serverAddress, 9001);\n        in = new BufferedReader(new InputStreamReader(\n            socket.getInputStream()));\n        out = new PrintWriter(socket.getOutputStream(), true);\n        // Process all messages from server, according to the protocol.\n        while (true) {\n            String line = in.readLine();\n         if (line.startsWith(\"SUBMITNAME\")) {\n                out.println(getName());\n            } else if (line.startsWith(\"NAMEACCEPTED\")) {\n                textField.setEditable(true);\n            } else if (line.startsWith(\"MESSAGE\")) {\n                       //DECRYPTION\n                        messageArea.append(line.substring(8) + \"\\n\");\n                        cipher.init(Cipher.DECRYPT_MODE, key);\n                        line = new String(cipher.doFinal(line));\n                        System.out.println(line);\n            }\n        }\n    }\n\n    /**\n     * Runs the client as an application with a closeable frame.\n     */\n    public static void main(String[] args) throws Exception {\n        ChatClient client = new ChatClient();\n        client.frame.setDefaultCloseOperation(JFrame.EXIT_ON_CLOSE);\n        client.frame.setVisible(true);\n        client.run();\n    }\n}\n", "idx": 1920}
{"project": "cipher", "commit_id": "Snippet44237620_26284.java", "target": 1, "func": "public static void encryptFile(File file, PublicKey key,\n        String transformation) throws NoSuchAlgorithmException,\n        NoSuchPaddingException, InvalidKeyException, IOException,\n        InvalidAlgorithmParameterException, NoSuchProviderException {\n    Cipher c = Cipher.getInstance(transformation, \"SunJCE\");\n    byte[] iv = { 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0 };\n    IvParameterSpec ivspec = new IvParameterSpec(iv);\n\n    SecretKeySpec secretKeySpec = new SecretKeySpec(keyb, \"AES\");\n\n    c.init(Cipher.ENCRYPT_MODE, secretKeySpec, ivspec);\n\n    FileInputStream is = new FileInputStream(file);\n    CipherOutputStream os = new CipherOutputStream(new FileOutputStream(\n            new File(file.getName() + \"_enc\")), c);\n\n    copy(is, os);\n}\n\npublic static void decryptFile(File encryptedFile, File decryptedFile,\n        Key privateKey, String transformation) {\n    try {\n        Cipher c = Cipher.getInstance(transformation, \"SunJCE\");\n\n        byte[] iv = { 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0 };\n        IvParameterSpec ivspec = new IvParameterSpec(iv);\n        byte[] keyb = privateKey.getEncoded();\n\n        SecretKeySpec secretKeySpec = new SecretKeySpec(keyb, \"AES\");\n\n        c.init(Cipher.DECRYPT_MODE, secretKeySpec, ivspec);\n        CipherInputStream is = new CipherInputStream(new FileInputStream(\n                encryptedFile), c);\n        FileOutputStream os = new FileOutputStream(decryptedFile);\n\n        copy(is, os);\n    } catch (Exception e) {\n        e.printStackTrace();\n    }\n}\n\npublic static void copy(InputStream is, OutputStream os) {\n\n    try {\n        byte[] buf = new byte[1024];\n        long total = 0;\n        while (true) {\n            int r = is.read(buf);\n            if (r == -1) {\n                break;\n            }\n            os.write(buf, 0, r);\n            total += r;\n        }\n    } catch (Exception e) {\n        e.printStackTrace();\n    } finally {\n        try {\n            is.close();\n            os.flush();\n            os.close();\n        } catch (Exception ex) {\n            ex.printStackTrace();\n        }\n    }\n}\n", "idx": 2609}
{"project": "cipher", "commit_id": "Snippet18093554_1131.java", "target": 0, "func": "static{\n    //install ibm's provider\n    java.security.Security.addProvider(new IBMJCE());\n}\n\npublic byte[] encrypt(byte[] input)throws SecurityException{\n    KeyGenerator kg = KeyGenerator.getInstance(\"DES\");\n    //call ibm's provider\n    SecureRandom sr = SecureRandom.getInstance(\"IBMSecureRandom\", new IBMJCE());\n    sr.setSeed(str.getBytes());\n    kg.init(sr);\n    Key key = kg.generateKey();\n    Cipher cipher = Cipher.getInstance(\"DES\");\n    cipher.init(1, key);\n    byte[] ret = cipher.doFinal(input);\n    return ret;\n}\n", "idx": 2208}
{"project": "cipher", "commit_id": "Snippet1624353_29930.java", "target": 0, "func": "Cipher cip = Cipher.getInstance(\"DES\")\n", "idx": 2211}
{"project": "cipher", "commit_id": "Snippet20110684_2776.java", "target": 1, "func": "Cipher cipher = Cipher.getInstance(\"RSA/ECB/NoPadding\");\n", "idx": 2687}
{"project": "cipher", "commit_id": "Snippet28793353_10934.java", "target": 0, "func": "public void decrypt(Cipher c) throws ClassNotFoundException, IllegalBlockSizeException, BadPaddingException, IOException{\n\n    //decrypting the AES key (CryptoStack.java:110)\n    keyCache = (SecretKey) key.getObject(c);\n\n    //generating Cipher for decryption\n    Cipher c1 = null;\n    try {\n        c1 = Cipher.getInstance(\"AES\");\n        c1.init(Cipher.DECRYPT_MODE, keyCache);\n    } catch (NoSuchAlgorithmException | NoSuchPaddingException | InvalidKeyException e) {\n        // TODO Auto-generated catch block\n        e.printStackTrace();\n    }\n\n    //decrypting Object with previous generated Cipher\n    stackCache = (Stack) stack.getObject(c1);\n}\n", "idx": 1967}
{"project": "cipher", "commit_id": "Snippet15946705_38930.java", "target": 0, "func": "byte[] userPin3DESEncrypted = Base64.decodeBase64(userPin3DESBase64Encrypted.getBytes());\nbyte [] keyByte = \"jgd8f3m8ybjhwlGhr4hihbp0\".getBytes();\nSecretKeySpec secretKeySpec = new SecretKeySpec(keyByte, \"DESEDE\");\nCipher cipher = Cipher.getInstance(\"DESEDE/ECB/PKCS5Padding\");\ncipher.init(Cipher.DECRYPT_MODE, secretKeySpec);\nString userPinDecrypted = new String(cipher.doFinal(userPin3DESEncrypted));\n", "idx": 2142}
{"project": "cipher", "commit_id": "Snippet40019678_21958.java", "target": 0, "func": "    byte[] message = Base64.decodeBase64(encryptedText.getBytes(\"utf-8\"));\n    //byte[] message = encryptedText.getBytes(\"utf-8\");\n\n    MessageDigest md = MessageDigest.getInstance(\"SHA-1\");\n    byte[] digestOfPassword = md.digest(secretKey.getBytes(\"utf-8\"));\n    byte[] keyBytes = Arrays.copyOf(digestOfPassword, 24);\n    SecretKey key = new SecretKeySpec(keyBytes, \"DESede\");\n\n    //Cipher decipher = Cipher.getInstance(\"DESede\");\n    Cipher decipher = Cipher.getInstance(\"DESede/ECB/PKCS5Padding\");\n    decipher.init(Cipher.DECRYPT_MODE, key);\n\n    byte[] plainText = decipher.doFinal(message);\n\n    return new String(plainText, \"UTF-8\");\n}\n", "idx": 2152}
{"project": "cipher", "commit_id": "Snippet664213_29723.java", "target": 1, "func": "byte[] sessionKey = null; //Where you get this from is beyond the scope of this post\nbyte[] iv = null ; //Ditto\nbyte[] plaintext = null; //Whatever you want to encrypt/decrypt\nCipher cipher = Cipher.getInstance(\"AES/CBC/PKCS5Padding\");\n//You can use ENCRYPT_MODE or DECRYPT_MODE\ncipher.calling init(Cipher.ENCRYPT_MODE, new SecretKeySpec(sessionKey, \"AES\"), new IvParameterSpec(iv));\nbyte[] ciphertext = cipher.doFinal(plaintext);\n", "idx": 2705}
{"project": "cipher", "commit_id": "Snippet2052241_30216.java", "target": 1, "func": "import java.security.SecureRandom;\nimport java.security.Security;\n\nimport javax.crypto.Cipher;\nimport javax.crypto.SecretKey;\nimport javax.crypto.SecretKeyFactory;\nimport javax.crypto.spec.IvParameterSpec;\nimport javax.crypto.spec.PBEKeySpec;\n\nimport org.bouncycastle.jce.provider.BouncyCastleProvider;\n\npublic class PBE {\n\n    private static final String salt = \"A long, but constant phrase that will be used each time as the salt.\";\n    private static final int iterations = 2000;\n    private static final int keyLength = 256;\n    private static final SecureRandom random = new SecureRandom();\n\n    public static void main(String [] args) throws Exception {\n        Security.insertProviderAt(new BouncyCastleProvider(), 1);\n\n        String passphrase = \"The quick brown fox jumped over the lazy brown dog\";\n        String plaintext = \"hello world\";\n        byte [] ciphertext = encrypt(passphrase, plaintext);\n        String recoveredPlaintext = decrypt(passphrase, ciphertext);\n\n        System.out.println(recoveredPlaintext);\n    }\n\n    private static byte [] encrypt(String passphrase, String plaintext) throws Exception {\n        SecretKey key = generateKey(passphrase);\n\n        Cipher cipher = Cipher.getInstance(\"AES/CTR/NOPADDING\");\n        cipher.init(Cipher.ENCRYPT_MODE, key, generateIV(cipher), random);\n        return cipher.doFinal(plaintext.getBytes());\n    }\n\n    private static String decrypt(String passphrase, byte [] ciphertext) throws Exception {\n        SecretKey key = generateKey(passphrase);\n\n        Cipher cipher = Cipher.getInstance(\"AES/CTR/NOPADDING\");\n        cipher.init(Cipher.DECRYPT_MODE, key, generateIV(cipher), random);\n        return new String(cipher.doFinal(ciphertext));\n    }\n\n    private static SecretKey generateKey(String passphrase) throws Exception {\n        PBEKeySpec keySpec = new PBEKeySpec(passphrase.toCharArray(), salt.getBytes(), iterations, keyLength);\n        SecretKeyFactory keyFactory = SecretKeyFactory.getInstance(\"PBEWITHSHA256AND256BITAES-CBC-BC\");\n        return keyFactory.generateSecret(keySpec);\n    }\n\n    private static IvParameterSpec generateIV(Cipher cipher) throws Exception {\n        byte [] ivBytes = new byte[cipher.getBlockSize()];\n        random.nextBytes(ivBytes);\n        return new IvParameterSpec(ivBytes);\n    }\n\n}\n", "idx": 2662}
{"project": "cipher", "commit_id": "Snippet43027584_25149.java", "target": 0, "func": "public class Symmetric1 {\n\n    /**\n     * @param args the command line arguments\n     */\n    public static void main(String[] args) throws Exception{\n        // TODO code application logic here\n        KeyGenerator kg = KeyGenerator.getInstance(\"DES\");\n    kg.init(new SecureRandom());\n    SecretKey secretKey = kg.generateKey();\n\n    FileInputStream inFile = new FileInputStream(\"C:/Users/Administrator/Desktop/original.bmp\");\n\n    Cipher cipher = Cipher.getInstance(\"DES/ECB/PKCS5Padding\"); \n    cipher.init(Cipher.ENCRYPT_MODE, secretKey);\n\n    FileOutputStream outFile = new FileOutputStream(\"C:/Users/Administrator/Desktop/ECB_original.bmp\");\n\n    byte[] input = new byte[64];\n    int bytesRead;\n    while((bytesRead = inFile.read(input)) != -1){\n        byte[] output = cipher.update(input,0,bytesRead);\n        if(output != null)\n            outFile.write(output);\n    }\n\n    byte[] output = cipher.doFinal();\n    if(output != null)\n        outFile.write(output);\n\n    inFile.close();\n    outFile.flush();\n    outFile.close();\n    }\n}\n", "idx": 2019}
{"project": "cipher", "commit_id": "Snippet29807841_11882.java", "target": 1, "func": "private static String Encrypt(String DecryptedText, String accountName, String apiKey) {\n    byte[] EncryptedStr = {};\n\n    if (accountName.length() < 5 || apiKey.length() < 5) {\n        System.out.println(\"Name too short\");\n        return DatatypeConverter.printBase64Binary(EncryptedStr);\n    }\n    try {\n        byte[] salt = apiKey.getBytes();\n        SecretKeyFactory factory = SecretKeyFactory.getInstance(\"PBKDF2WithHmacSHA1\");\n\n        KeySpec KeySpec = new PBEKeySpec(accountName.toCharArray(), salt, 1000, 256);\n        SecretKey key = factory.generateSecret(KeySpec);\n\n        KeySpec VectorSpec = new PBEKeySpec(accountName.toCharArray(), salt, 1000, 128);\n        SecretKey vector = (SecretKey) factory.generateSecret(VectorSpec);\n\n        SecretKey secretKey = new SecretKeySpec(key.getEncoded(), \"AES\");\n\n        byte[] ivKeyBytes = vector.getEncoded();\n        byte[] iv = new byte[16]; // Get IV bytes from the\n        for (int i = 0; i < iv.length; ++i)\n                iv[i] = ivKeyBytes[i];\n        IvParameterSpec ivParm = new IvParameterSpec(iv);\n\n        Log(\"Salt:\", false);\n        Log(salt, true);\n        Log(\"Key:\", false);\n        Log(secretKey.getEncoded(), true);\n        Log(\"Vector:\", false);\n        Log(iv, true);\n\n        // IN C# they are using KeySize=256, Mode=CBC, Padding=PKCS7,\n        // PKCS7 padding doesn't exist in java so use PKCS5 and hope it works correctly.\n        Cipher cipher = Cipher.getInstance(\"AES/CBC/PKCS5Padding\");\n\n        // NOTE: Added ivParam to initialize the IV parameter, w/o the first block is off.\n        cipher.init(Cipher.ENCRYPT_MODE, secretKey, ivParm);\n        EncryptedStr = cipher.doFinal(DecryptedText.getBytes(\"UTF-8\"));\n    } catch (Exception e) {\n        System.out.println(\"Exc:\" + e.getMessage());\n        e.printStackTrace(System.out);\n    }\n\n    return DatatypeConverter.printBase64Binary(EncryptedStr);\n}\n", "idx": 2608}
{"project": "cipher", "commit_id": "Snippet13525299_37083.java", "target": 0, "func": "\nimport java.security.SecureRandom;\n\nimport javax.crypto.Cipher;\nimport javax.crypto.KeyGenerator;\nimport javax.crypto.SecretKey;\nimport javax.crypto.spec.SecretKeySpec;\n\npublic class Encryption {\n\n    public static String encrypt(String seed, String cleartext) throws Exception {\n        byte[] rawKey = getRawKey(seed.getBytes());\n        byte[] result = encrypt(rawKey, cleartext.getBytes());\n        return toHex(result);\n    }\n\n    public static String decrypt(String seed, String encrypted) throws Exception {\n        byte[] rawKey = getRawKey(seed.getBytes());\n        byte[] enc = toByte(encrypted);\n        byte[] result = decrypt(rawKey, enc);\n        return new String(result);\n    }\n\n\n    private static byte[] getRawKey(byte[] seed) throws Exception {\n        KeyGenerator kgen = KeyGenerator.getInstance(\"AES\");\n        SecureRandom sr = SecureRandom.getInstance(\"SHA1PRNG\");\n        sr.setSeed(seed);\n        kgen.init(128, sr); // 192 and 256 bits may not be available\n        SecretKey skey = kgen.generateKey();\n        byte[] raw = skey.getEncoded();\n        return raw;\n    }\n\n\n    private static byte[] encrypt(byte[] raw, byte[] clear) throws Exception {\n        SecretKeySpec skeySpec = new SecretKeySpec(raw, \"AES\");\n        Cipher cipher = Cipher.getInstance(\"AES\");\n        cipher.init(Cipher.ENCRYPT_MODE, skeySpec);\n        byte[] encrypted = cipher.doFinal(clear);\n        return encrypted;\n    }\n\n    private static byte[] decrypt(byte[] raw, byte[] encrypted) throws Exception {\n        SecretKeySpec skeySpec = new SecretKeySpec(raw, \"AES\");\n        Cipher cipher = Cipher.getInstance(\"AES\");\n        cipher.init(Cipher.DECRYPT_MODE, skeySpec);\n        byte[] decrypted = cipher.doFinal(encrypted);\n        return decrypted;\n    }\n\n    public static String toHex(String txt) {\n        return toHex(txt.getBytes());\n    }\n    public static String fromHex(String hex) {\n        return new String(toByte(hex));\n    }\n\n    public static byte[] toByte(String hexString) {\n        int len = hexString.length()/2;\n        byte[] result = new byte[len];\n        for (int i = 0; i < len; i++)\n            result[i] = Integer.valueOf(hexString.substring(2*i, 2*i+2), 16).byteValue();\n        return result;\n    }\n\n    public static String toHex(byte[] buf) {\n        if (buf == null)\n            return \"\";\n        StringBuffer result = new StringBuffer(2*buf.length);\n        for (int i = 0; i < buf.length; i++) {\n            appendHex(result, buf[i]);\n        }\n        return result.toString();\n    }\n    private final static String HEX = \"0123456789ABCDEF\";\n    private static void appendHex(StringBuffer sb, byte b) {\n        sb.append(HEX.charAt((b>>4)&0x0f)).append(HEX.charAt(b&0x0f));\n    }\n\n\n}\n", "idx": 1982}
{"project": "cipher", "commit_id": "Snippet10598309_34923.java", "target": 1, "func": "cipher = Cipher.getInstance(\"RSA/ECB/PKCS1Padding\");\ncipher.init(Cipher.DECRYPT_MODE, privateKey);\nbyte[] newPlainText = cipher.doFinal(arg.getBytes());\n", "idx": 2485}
{"project": "cipher", "commit_id": "Snippet32620597_14745.java", "target": 1, "func": "String asymPadding = \"RSA2048/ECB/OAEPWithSHA256AndMGF1Padding\";\nString secKeyEncoded = getSymmetricKey(secKey);\nKeyPair keyPair = getKeyPair(SELF4);\n\nif (asymmPadding.contains(RSA2048)) {\n    asymmPadding = RSA.concat(asymmPadding.substring(asymmPadding.indexOf(\"/\")));\n}\n\nCipher cipher = Cipher.getInstance(asymPadding);\n", "idx": 2574}
{"project": "cipher", "commit_id": "Snippet40799515_22682.java", "target": 0, "func": "public class EncriptionDecriptionUtils {\n    private static byte[] nrlmEncription = { 0x77, 0x71, 0x72, 0x76, 0x52,\n     0x76, 0x44, 0x56, 0x68, 0x66, 0x75, 0x68, 0x77, 0x4b, 0x6f, 0x7d };\n\n    public String decriptionOfData(String data) throws Exception {\n        SecretKeySpec skeySpec = new SecretKeySpec(nrlmEncription, \"AES\");\n        Cipher cipher = Cipher.getInstance(\"AES\");\n        cipher.init(Cipher.DECRYPT_MODE, skeySpec);\n        byte[] decrypted = cipher.doFinal(Base64.decode(data,         Base64.DEFAULT));\n        return new String(decrypted);\n    }\n    public String encriptionOfData(String data) throws Exception {\n       Cipher cipher = Cipher.getInstance(\"AES/ECB/PKCS5Padding\");\n       final SecretKeySpec secretKey = new SecretKeySpec(nrlmEncription, \"AES\");\n       cipher.init(Cipher.ENCRYPT_MODE, secretKey);\n       return Base64.encodeToString(cipher.doFinal(data.getBytes()), Base64.DEFAULT);\n    }\n}\n", "idx": 2154}
{"project": "cipher", "commit_id": "Snippet13774127_37259.java", "target": 1, "func": "    import java.awt.*;\nimport java.math.BigInteger;\nimport java.net.*;\nimport java.security.InvalidKeyException;\nimport java.security.KeyFactory;\nimport java.security.NoSuchAlgorithmException;\nimport java.security.PublicKey;\nimport java.security.spec.InvalidKeySpecException;\nimport java.security.spec.RSAPublicKeySpec;\nimport java.awt.*;          \nimport java.awt.event.*;    \n\nimport javax.crypto.BadPaddingException;\nimport javax.crypto.Cipher;\nimport javax.crypto.IllegalBlockSizeException;\nimport javax.crypto.NoSuchPaddingException;\nimport javax.swing.*;       \nimport javax.swing.event.*;\nimport java.io.*;\n\npublic class chatServer extends SwingChatGUI\n{\n    PrintWriter out;\n    BufferedReader in;\n    BufferedReader stdin;\n    String inputLine, outputLine;\n    public ButtonHandler bHandler = new ButtonHandler();\n    int stage = 1;\n    private static BigInteger l;\n    private static BigInteger m;\n    PublicKey pubKey;\n\n    public chatServer (String title)\n    {\n        super (title);\n        bHandler = new ButtonHandler ();\n        sendButton.addActionListener (bHandler);\n    }\n\n    private class ButtonHandler implements ActionListener\n    {\n        public void actionPerformed (ActionEvent event)\n        {\n            outputLine = txArea.getText ();\n            System.out.println (\"Server > \" + outputLine);\n            encrypt();\n            out.println (outputLine);\n        }\n    }\n\n    public void run () throws IOException\n    {\n        ServerSocket serverSocket = null;\n\n        try\n        {\n            serverSocket = new ServerSocket (4444);\n        }\n        catch (IOException e)\n        {\n            System.err.println (\"Could not listen on port: 4444.\");\n            System.exit (1);\n        }\n\n        Socket clientSocket = null;\n        try\n        {\n            clientSocket = serverSocket.accept ();\n        }\n        catch (IOException e)\n        {\n            System.err.println (\"Accept failed.\");\n            System.exit(1);\n        }\n\n        out = new PrintWriter (clientSocket.getOutputStream (), true);\n        in = new BufferedReader (new InputStreamReader (clientSocket.getInputStream ()));\n        //stdin = new BufferedReader (new InputStreamReader (System.in));\n\n        out.println (\"Welcome to the Chat Server\\n\");\n\n        while ((inputLine = in.readLine ()) != null)\n        {\n            System.out.println (\"Server < \" + inputLine);\n            rxArea.setText (inputLine);\n\n            if (stage == 1)\n            {\n                String[] parts = inputLine.split(\"!e! \", 2);\n                String string1 = parts[0];\n                String string2 = parts[1];\n\n\n                String j = string1.replace(\"!m! \", \"\");\n\n\n                m = new BigInteger(j);\n                l = new BigInteger(string2);\n\n                RSAPublicKeySpec keySpec = new RSAPublicKeySpec(m, l);\n                KeyFactory fact;\n                try {\n                    fact = KeyFactory.getInstance(\"RSA\");\n                     pubKey = fact.generatePublic(keySpec);\n                } catch (NoSuchAlgorithmException e) {\n                    // TODO Auto-generated catch block\n                    e.printStackTrace();\n                } catch (InvalidKeySpecException e) {\n                    // TODO Auto-generated catch block\n                    e.printStackTrace();\n                }\n               stage++;\n            }\n\n\n        }\n\n        out.close();\n        in.close();\n        clientSocket.close();\n        serverSocket.close();\n    }\n\n    public void encrypt() {\n\n        byte[] src = outputLine.getBytes();\n         Cipher cipher;\n        try {\n            cipher = Cipher.getInstance(\"RSA\");\n              cipher.init(Cipher.ENCRYPT_MODE, pubKey);\n              byte[] cipherData = cipher.doFinal(src);\n              outputLine = new String(cipherData);\n              int count = outputLine.length();\n              System.out.println(\"bytes: \" + count);\n        } catch (NoSuchAlgorithmException e) {\n            // TODO Auto-generated catch block\n            e.printStackTrace();\n        } catch (NoSuchPaddingException e) {\n            // TODO Auto-generated catch block\n            e.printStackTrace();\n        } catch (InvalidKeyException e) {\n            // TODO Auto-generated catch block\n            e.printStackTrace();\n        } catch (IllegalBlockSizeException e) {\n            // TODO Auto-generated catch block\n            e.printStackTrace();\n        } catch (BadPaddingException e) {\n            // TODO Auto-generated catch block\n            e.printStackTrace();\n        }\n\n\n    }\n\n    public static void main(String[] args) //throws IOException\n    {\n\n        chatServer f = new chatServer (\"Chat Server Program\");\n\n        f.pack ();\n        f.show ();\n        try\n        {\n            f.run ();\n        }\n        catch (IOException e)\n        {\n            System.err.println(\"Couldn't get I/O for the connection to: to host.\");\n            System.exit(1);\n        }\n\n    }\n}\n", "idx": 2385}
{"project": "cipher", "commit_id": "Snippet14922107_38004.java", "target": 1, "func": "byte[] data = Base64\n    .decodeBase64(\"McBeY73GQ5fawxIunVKpqUupipeRlt9ntyMRzjbPfTI=\");\nbyte[] keyByte = \"f931c96c4a4e7e47\".getBytes(\"UTF-8\");\nbyte[] ivByte = \"1cc251f602cf49f2\".getBytes(\"UTF-8\");\n\nKey key = new SecretKeySpec(keyByte, \"AES\");\nIvParameterSpec iv = new IvParameterSpec(ivByte);\nCipher c = Cipher.getInstance(\"AES/CBC/NoPadding\");\nc.init(Cipher.DECRYPT_MODE, key, iv);\nbyte[] bval = c.doFinal(data);\n\nSystem.out.println(new String(bval)); // Prints My f awesome test !\n", "idx": 2619}
{"project": "cipher", "commit_id": "Snippet2279317_30274.java", "target": 0, "func": "package org.dpdouran.attach;\nimport java.io.ByteArrayOutputStream;import java.io.IOException;import java.io.InputStream;import java.security.InvalidAlgorithmParameterException;import java.security.InvalidKeyException;import java.security.NoSuchAlgorithmException;import java.security.spec.AlgorithmParameterSpec;import javax.crypto.BadPaddingException;\nimport javax.crypto.Cipher;\nimport javax.crypto.IllegalBlockSizeException;\nimport javax.crypto.NoSuchPaddingException;\nimport javax.crypto.spec.IvParameterSpec;\nimport javax.crypto.spec.SecretKeySpec;\n\npublic class CustomClassLoader extends ClassLoader {\n    private static final int BUFFER_SIZE = 8192;\n    @Override\n    protected Class<?> findClass(String className) throws ClassNotFoundException {\n        System.out.println(\"loading...  \"+className);\n        String clsFile = className.replace('.', '/') + \".class\";\n        InputStream in = getResourceAsStream(clsFile);\n        if(in==null)\n            return null;\n        byte[] buffer = new byte[BUFFER_SIZE];\n        ByteArrayOutputStream out = new ByteArrayOutputStream();\n        int n = -1;\n        try {\n            while ((n = in.read(buffer, 0, BUFFER_SIZE)) != -1) {\n                out.write(buffer, 0, n);\n            }\n        } catch (IOException e1) {\n            // TODO Auto-generated catch block\n            e1.printStackTrace();\n        }\n        //do decrypt\n        byte[] classBytes = out.toByteArray();\n        byte[] iv = new byte[] { (byte) 0x8E, 0x12, 0x39, (byte) 0x9C,\n                0x07, 0x72, 0x6F, 0x5A };\n        AlgorithmParameterSpec paramSpec = new IvParameterSpec(iv);\n        Cipher dcipher=null;\n        try {\n            dcipher = Cipher.getInstance(\"DES/CBC/PKCS5Padding\");\n        } catch (NoSuchAlgorithmException e) {\n            // TODO Auto-generated catch block\n            e.printStackTrace();\n        } catch (NoSuchPaddingException e) {\n            // TODO Auto-generated catch block\n            e.printStackTrace();\n        }\n        byte keyBytes[] = \"abcdEFGH\".getBytes();\n        SecretKeySpec secretKey = new SecretKeySpec(keyBytes, \"DES\");\n        try {\n            dcipher.init(Cipher.DECRYPT_MODE, secretKey, paramSpec);\n        } catch (InvalidKeyException e) {\n            // TODO Auto-generated catch block\n            e.printStackTrace();\n        } catch (InvalidAlgorithmParameterException e) {\n            // TODO Auto-generated catch block\n            e.printStackTrace();\n        }\n        byte[] dbytes = null;\n        try {\n            dbytes = dcipher.doFinal(classBytes);\n        } catch (IllegalBlockSizeException e) {\n            // TODO Auto-generated catch block\n            e.printStackTrace();\n        } catch (BadPaddingException e) {\n            // TODO Auto-generated catch block\n            e.printStackTrace();\n        }\n        return defineClass(className, dbytes, 0, dbytes.length);\n    }\n    public CustomClassLoader( ClassLoader parent){\n        super(sun.misc.Launcher.getLauncher().getClassLoader());\n    }\n}\n", "idx": 1947}
{"project": "cipher", "commit_id": "Snippet33818977_15847.java", "target": 0, "func": "Cipher cipher = Cipher.getInstance(\"DES\");\n", "idx": 2248}
{"project": "cipher", "commit_id": "Snippet44638656_26747.java", "target": 0, "func": "import java.io.PrintStream;\nimport javax.crypto.Cipher;\nimport javax.crypto.spec.SecretKeySpec;\nimport java.nio.charset.StandardCharsets;\n\npublic class test\n{\n\n    public static void main(String[] args)\n    throws Exception\n    {\n        //byte[] encryptionKey = \"Es6XYPkgCV75J95Y\".getBytes(StandardCharsets.UTF_8);\n        byte[] encryptionKey = \"Es6XYPkgCV75J95Y\".getBytes(StandardCharsets.ISO_8859_1);\n        //byte[] plainText = args[0].getBytes(StandardCharsets.UTF_8);\n        byte[] plainText = args[0].getBytes(StandardCharsets.ISO_8859_1);\n        MyCrypto aes = new MyCrypto(encryptionKey);\n        byte[] cipherText = aes.encrypt(plainText);\n        byte[] decryptedCipherText = aes.decrypt(cipherText);\n\n        System.out.println(new String(plainText));\n        System.out.println(new String(cipherText));\n        System.out.println(new String(decryptedCipherText));\n    }\n\n}\n\nclass MyCrypto\n{\n    private byte[] key;\n\n    private static final String ALGORITHM = \"AES\";\n\n    public MyCrypto(byte[] key)\n    {\n        this.key = key;\n    }\n\n    /**\n     * Encrypts the given plain text\n     *\n     * @param plainText The plain text to encrypt\n     */\n    public byte[] encrypt(byte[] plainText) throws Exception\n    {\n        SecretKeySpec secretKey = new SecretKeySpec(key, ALGORITHM);\n        Cipher cipher = Cipher.getInstance(ALGORITHM);\n        cipher.init(Cipher.ENCRYPT_MODE, secretKey);\n\n        return cipher.doFinal(plainText);\n    }\n\n    /**\n     * Decrypts the given byte array\n     *\n     * @param cipherText The data to decrypt\n     */\n    public byte[] decrypt(byte[] cipherText) throws Exception\n    {\n        SecretKeySpec secretKey = new SecretKeySpec(key, ALGORITHM);\n        Cipher cipher = Cipher.getInstance(ALGORITHM);\n        cipher.init(Cipher.DECRYPT_MODE, secretKey);\n\n        return cipher.doFinal(cipherText);\n    }\n}\n", "idx": 2155}
{"project": "cipher", "commit_id": "Snippet339769_29697.java", "target": 0, "func": "// only the first 8 Bytes of the constructor argument are used \n// as material for generating the keySpec\nDESKeySpec keySpec = new DESKeySpec(\"YourSecr\".getBytes(\"UTF8\")); \nSecretKeyFactory keyFactory = SecretKeyFactory.getInstance(\"DES\");\nSecretKey key = keyFactory.generateSecret(keySpec);\nsun.misc.BASE64Encoder base64encoder = new BASE64Encoder();\nsun.misc.BASE64Decoder base64decoder = new BASE64Decoder();\n.........\n\n// ENCODE plainTextPassword String\nbyte[] cleartext = plainTextPassword.getBytes(\"UTF8\");      \n\nCipher cipher = Cipher.getInstance(\"DES\"); // cipher is not thread safe\ncipher.init(Cipher.ENCRYPT_MODE, key);\nString encrypedPwd = base64encoder.encode(cipher.doFinal(cleartext));\n// now you can store it \n......\n\n// DECODE encryptedPwd String\nbyte[] encrypedPwdBytes = base64decoder.decodeBuffer(encryptedPwd);\n\nCipher cipher = Cipher.getInstance(\"DES\");// cipher is not thread safe\ncipher.init(Cipher.DECRYPT_MODE, key);\nbyte[] plainTextPwdBytes = (cipher.doFinal(encrypedPwdBytes));\n", "idx": 2075}
{"project": "cipher", "commit_id": "Snippet46205964_28307.java", "target": 1, "func": "val aKey = generateAESKey()\n\nval kG = KeyPairGenerator.getInstance(\"RSA\")\nkG.initialize(2048)\nval own = kG.genKeyPair()\nval strange = kG.genKeyPair()\n\nString(aKey.encoded).encryptRSA(strange.public).encryptRSA(own.public)\n\nfun generateAESKey(): Key {\nval generator = KeyGenerator.getInstance(\"AES\")\ngenerator.init(128)\nreturn generator.generateKey()\n\nfun String.encryptRSA(key: Key): String {\n    val encryptCipher = Cipher.getInstance(\"RSA/ECB/PKCS1Padding\")\n    encryptCipher.init(Cipher.ENCRYPT_MODE, key)\n    val cipherText = encryptCipher.doFinal(this.toByteArray(charset(\"UTF-\n    8\")))\n    return String(cipherText)\n}\n\nfun String.decryptRSA(key: Key): String {\n    val bytes = this.toByteArray()\n    val decryptCipher = Cipher.getInstance(\"RSA/ECB/PKCS1Padding\")\n    decryptCipher.init(Cipher.DECRYPT_MODE, key)\n    return String(decryptCipher.doFinal(bytes), charset(\"UTF-8\"))\n}\n", "idx": 2665}
{"project": "cipher", "commit_id": "Snippet20535447_3130.java", "target": 0, "func": "   @Override\n   protected void onCreate(Bundle savedInstanceState) {\n          super.onCreate(savedInstanceState);\n          setContentView(R.layout.activity_main);\n\n          Button encryptButton = (Button) findViewById(R.id.button1);\n          Button DecryptButton = (Button) findViewById(R.id.button2);\n          encryptButton.setOnClickListener(new OnClickListener() {\n\n                 @Override\n                 public void onClick(View v) {\n                       // TODO Auto-generated method stub\n                       try {\n                              encrypt();\n                       } catch (InvalidKeyException e) {\n                              // TODO Auto-generated catch block\n                              e.printStackTrace();\n                       } catch (NoSuchAlgorithmException e) {\n                              // TODO Auto-generated catch block\n                              e.printStackTrace();\n                       } catch (NoSuchPaddingException e) {\n                              // TODO Auto-generated catch block\n                              e.printStackTrace();\n                       } catch (IOException e) {\n                              // TODO Auto-generated catch block\n                              e.printStackTrace();\n                       }\n                 }\n          });\n\n          DecryptButton.setOnClickListener(new OnClickListener() {\n\n                 @Override\n                 public void onClick(View v) {\n                       // TODO Auto-generated method stub\n                       try {\n                              decrypt();\n                       } catch (InvalidKeyException e) {\n                              // TODO Auto-generated catch block\n                              e.printStackTrace();\n                       } catch (NoSuchAlgorithmException e) {\n                              // TODO Auto-generated catch block\n                              e.printStackTrace();\n                       } catch (NoSuchPaddingException e) {\n                              // TODO Auto-generated catch block\n                              e.printStackTrace();\n                       } catch (IOException e) {\n                              // TODO Auto-generated catch block\n                              e.printStackTrace();\n                       }\n                 }\n          });\n\n   }\n\n   /**\n    * Here is Both function for encrypt and decrypt file in Sdcard folder. we\n    * can not lock folder but we can encrypt file using AES in Android, it may\n    * help you.\n    *\n    * @throws IOException\n    * @throws NoSuchAlgorithmException\n    * @throws NoSuchPaddingException\n    * @throws InvalidKeyException\n    */\n\n   static void encrypt() throws IOException, NoSuchAlgorithmException,\n                 NoSuchPaddingException, InvalidKeyException {\n          // Here you read the cleartext.\n          File extStore = Environment.getExternalStorageDirectory();\n          FileInputStream fis = new FileInputStream(extStore + \"/sampleFile\");\n          // This stream write the encrypted text. This stream will be wrapped by\n          // another stream.\n          FileOutputStream fos = new FileOutputStream(extStore + \"/encrypted\");\n\n          // Length is 16 byte\n          SecretKeySpec sks = new SecretKeySpec(\"MyDifficultPassw\".getBytes(),\n                       \"AES\");\n          // Create cipher\n          Cipher cipher = Cipher.getInstance(\"AES\");\n          cipher.init(Cipher.ENCRYPT_MODE, sks);\n          // Wrap the output stream\n          CipherOutputStream cos = new CipherOutputStream(fos, cipher);\n          // Write bytes\n          int b;\n          byte[] d = new byte[8];\n          while ((b = fis.read(d)) != -1) {\n                 cos.write(d, 0, b);\n          }\n          // Flush and close streams.\n          cos.flush();\n          cos.close();\n          fis.close();\n   }\n\n   static void decrypt() throws IOException, NoSuchAlgorithmException,\n                 NoSuchPaddingException, InvalidKeyException {\n\n          File extStore = Environment.getExternalStorageDirectory();\n          FileInputStream fis = new FileInputStream(extStore + \"/encrypted\");\n\n          FileOutputStream fos = new FileOutputStream(extStore + \"/decrypted\");\n          SecretKeySpec sks = new SecretKeySpec(\"MyDifficultPassw\".getBytes(),\n                       \"AES\");\n          Cipher cipher = Cipher.getInstance(\"AES\");\n          cipher.init(Cipher.DECRYPT_MODE, sks);\n          CipherInputStream cis = new CipherInputStream(fis, cipher);\n          int b;\n          byte[] d = new byte[8];\n          while ((b = cis.read(d)) != -1) {\n                 fos.write(d, 0, b);\n          }\n          fos.flush();\n          fos.close();\n          cis.close();\n   }\n", "idx": 2006}
{"project": "cipher", "commit_id": "Snippet25058903_7394.java", "target": 0, "func": "public static String decrypt3DES(String Key, String data) throws Exception\n{\n    Cipher cipher = null;\n    byte[] text = null;\n    byte[] desKey = null;\n    Key keySpec = null;\n    try {\n\n        if (Key.length() <= 16) {\n            cipher = Cipher.getInstance(\"DES/ECB/NoPadding\");\n            desKey = byteConvertor(Key);\n            keySpec = new SecretKeySpec(desKey, \"DES\");\n        } else if (Key.length() >= 32) {\n            cipher = Cipher.getInstance(\"DESede/ECB/NoPadding\");\n            desKey = byteConvertor(Key);\n            keySpec = new SecretKeySpec(desKey, \"DESede\");\n        }\n        cipher.init(Cipher.DECRYPT_MODE, keySpec);\n\n        text = cipher.doFinal(byteConvertor(data));\n\n    } catch (NoSuchAlgorithmException e) {\n        e.printStackTrace();\n    } catch (NoSuchPaddingException e) {\n        e.printStackTrace();\n    } catch (InvalidKeyException e) {\n        e.printStackTrace();\n    } catch (IllegalBlockSizeException e) {\n        e.printStackTrace();\n    } catch (BadPaddingException e) {\n        e.printStackTrace();\n    }\n\n    return alpha2Hex(byteArr2String(text));\n}\n", "idx": 1988}
{"project": "cipher", "commit_id": "Snippet23380207_5738.java", "target": 1, "func": "private byte[] key = { (byte) 141, 75, 21, 92, (byte) 201, (byte) 255,\n        (byte) 129, (byte) 229, (byte) 203, (byte) 246, (byte) 250, 120,\n        25, 54, 106, 62, (byte) 198, 33, (byte) 166, 86, 65, 108,\n        (byte) 215, (byte) 147 };\n\nprivate final byte[] iv = { 0x1E, 0x39, (byte) 0xF3, 0x69, (byte) 0xE9, 0xD,\n        (byte) 0xB3, 0x3A, (byte) 0xA7, 0x3B, 0x44, 0x2B, (byte) 0xBB,\n        (byte) 0xB6, (byte) 0xB0, (byte) 0xB9 };\n   long start = System.currentTimeMillis();\n\n    // create paths\n    backupPath = Environment.getExternalStorageDirectory()\n            .getAbsolutePath() + \"/WhatsApp/Databases/msgstore.db.crypt5\";\n    outputPath = Environment.getExternalStorageDirectory()\n            .getAbsolutePath() + \"/WhatsApp/Databases/msgstore.db.decrypt\";\n\n    File backup = new File(backupPath);\n\n    // check if file exists / is accessible\n    if (!backup.isFile()) {\n        Log.e(TAG, \"Backup file not found! Path: \" + backupPath);\n        return;\n    }\n\n    // acquire account name\n    AccountManager manager = AccountManager.get(this);\n    Account[] accounts = manager.getAccountsByType(\"com.google\");\n\n    if (accounts.length == 0) {\n        Log.e(TAG, \"Unable to fetch account!\");\n        return;\n    }\n\n    String account = accounts[0].name;\n\n    try {\n        // calculate md5 hash over account name\n        MessageDigest message = MessageDigest.getInstance(\"MD5\");\n        message.update(account.getBytes());\n        byte[] md5 = message.digest();\n\n        // generate key for decryption\n        for (int i = 0; i < 24; i++)\n            key[i] ^= md5[i & 0xF];\n\n        // read encrypted byte stream\n        byte[] data = new byte[(int) backup.length()];\n        DataInputStream reader = new DataInputStream(new FileInputStream(\n                backup));\n        reader.readFully(data);\n        reader.close();\n\n        // create output writer\n        File output = new File(outputPath);\n        DataOutputStream writer = new DataOutputStream(\n                new FileOutputStream(output));\n\n        // decrypt file\n        Cipher cipher = Cipher.getInstance(\"AES/CBC/PKCS5Padding\");\n        SecretKeySpec secret = new SecretKeySpec(key, \"AES\");\n        IvParameterSpec vector = new IvParameterSpec(iv);\n        cipher.init(Cipher.DECRYPT_MODE, secret, vector);\n        writer.write(cipher.update(data));\n        writer.write(cipher.doFinal());\n        writer.close();\n    } catch (NoSuchAlgorithmException e) {\n        Log.e(TAG, \"Could not acquire hash algorithm!\", e);\n        return;\n    } catch (IOException e) {\n        Log.e(TAG, \"Error accessing file!\", e);\n        return;\n    } catch (Exception e) {\n        Log.e(TAG, \"Something went wrong during the encryption!\", e);\n        return;\n    }\n\n    long end = System.currentTimeMillis();\n\n    Log.i(TAG, \"Success! It took \" + (end - start) + \"ms\");\n", "idx": 2520}
{"project": "cipher", "commit_id": "Snippet25324304_7710.java", "target": 0, "func": "  byte [] key = \"AAAAA\".getBytes(\"ASCII\");\n\n  String clearText = \"66\";\n\n\n  Cipher rc4 = Cipher.getInstance(\"RC4\");\n  SecretKeySpec rc4Key = new SecretKeySpec(key, \"RC4\");\n  rc4.init(Cipher.ENCRYPT_MODE, rc4Key);\n  byte [] cipherText = rc4.update(clearText.getBytes(\"ASCII\"));\n", "idx": 2225}
{"project": "cipher", "commit_id": "Snippet14684130_37875.java", "target": 0, "func": "import java.security.SecureRandom;\nimport javax.crypto.Cipher;\nimport javax.crypto.KeyGenerator;\nimport javax.crypto.SecretKey;\nimport javax.crypto.spec.SecretKeySpec;\n\nSecretKeySpec skeySpec = new SecretKeySpec(raw, \"AES\");\nCipher cipher = Cipher.getInstance(\"AES\");\ncipher.init(Cipher.ENCRYPT_MODE, skeySpec);\nbyte[] encrypted = cipher.doFinal(clear);\n", "idx": 2034}
{"project": "cipher", "commit_id": "Snippet37477635_19403.java", "target": 1, "func": "public static String Decrypt(String text, String key) throws Exception {\n    Cipher cipher = Cipher.getInstance(\"AES/CBC/PKCS5Padding\");\n    byte[] keyBytes = new byte[16];\n    byte[] b = key.getBytes(\"UTF-8\");\n    int len = b.length;\n    if (len > keyBytes.length)\n        len = keyBytes.length;\n    System.arraycopy(b, 0, keyBytes, 0, len);\n    SecretKeySpec keySpec = new SecretKeySpec(keyBytes, \"AES\");\n    IvParameterSpec ivSpec = new IvParameterSpec(keyBytes);\n    cipher.init(Cipher.DECRYPT_MODE, keySpec, ivSpec);\n    byte[] results = new byte[text.length()];\n    BASE64Decoder decoder = new BASE64Decoder();\n    try {\n        results = cipher.doFinal(decoder.decodeBuffer(text));\n    } catch (Exception e) {\n        System.out.print(\"Erron in Decryption\");\n    }\n    return new String(results, \"UTF-8\");\n}\n\npublic static String Encrypt(String text, String key) throws Exception {\n    Cipher cipher = Cipher.getInstance(\"AES/CBC/PKCS5Padding\");\n    byte[] keyBytes = new byte[16];\n    byte[] b = key.getBytes(\"UTF-8\");\n    int len = b.length;\n    if (len > keyBytes.length)\n        len = keyBytes.length;\n    System.arraycopy(b, 0, keyBytes, 0, len);\n    SecretKeySpec keySpec = new SecretKeySpec(keyBytes, \"AES\");\n    IvParameterSpec ivSpec = new IvParameterSpec(keyBytes);\n    System.out.println(keyBytes);\n    System.out.println(keySpec);\n    System.out.println(ivSpec);\n    cipher.init(Cipher.ENCRYPT_MODE, keySpec, ivSpec);\n\n    byte[] results = cipher.doFinal(text.getBytes(\"UTF-8\"));\n    BASE64Encoder encoder = new BASE64Encoder();\n    return encoder.encode(results);\n}\n", "idx": 2487}
{"project": "cipher", "commit_id": "Snippet13599267_37128.java", "target": 0, "func": "import java.security.*;\nimport java.security.spec.InvalidKeySpecException;\nimport javax.crypto.*;\nimport javax.crypto.spec.SecretKeySpec;\n\n\nimport sun.misc.*;\n\npublic class AESencrp {\nprivate static final String ALGO = \"AES\";\nprivate static final byte[] keyValue = \n    new byte[] { 'T', 'h', 'e', 'B', 'e', 's', 't','S', 'e', 'c', 'r','e', 't', 'K', 'e', 'y' };\n\npublic static String encrypt(String Data) throws Exception {\n    Key key = generateKey();\n    Cipher c = Cipher.getInstance(ALGO);\n    c.init(Cipher.ENCRYPT_MODE, key);\n    byte[] encVal = c.doFinal(Data.getBytes());\n    String encryptedValue = new BASE64Encoder().encode(encVal);\n    return encryptedValue;\n}\n\npublic static String decrypt(String encryptedData) throws Exception {\n    Key key = generateKey();\n    Cipher c = Cipher.getInstance(ALGO);\n    c.init(Cipher.DECRYPT_MODE, key);\n    byte[] decordedValue = new BASE64Decoder().decodeBuffer(encryptedData);\n    byte[] decValue = c.doFinal(decordedValue);\n    String decryptedValue = new String(decValue);\n    return decryptedValue;\n}\n\nprivate static Key generateKey() throws Exception {\n    Key key = new SecretKeySpec(keyValue, ALGO);\n    return key;\n}\n\n\n\n}\n", "idx": 2035}
{"project": "cipher", "commit_id": "Snippet42236350_24211.java", "target": 1, "func": "    byte[] cipher_key = org.bouncycastle.util.encoders.Hex.decode(\"0123456789ABCDEFFEDCBA9876543210\");\n    final int HALF_BLOCK = 64;\n    byte[] salt = org.bouncycastle.util.encoders.Hex.decode(\"0123456789ABCDEF\");\n    byte[] nonceAndCounter = new byte[16];\n    System.arraycopy(salt, 0, nonceAndCounter, 0, ((int) (HALF_BLOCK / 8)));\n    IvParameterSpec iv = new IvParameterSpec(nonceAndCounter);\n    Cipher cipher = Cipher.getInstance(\"AES/CTR/NoPadding\", \"BC\");\n    SecretKeySpec key = new SecretKeySpec(cipher_key, \"AES\");\n    cipher.init(Cipher.ENCRYPT_MODE, key, iv);\n", "idx": 2466}
{"project": "cipher", "commit_id": "Snippet25087094_7436.java", "target": 0, "func": "Cipher ciph = Cipher.getInstance(\"AES\");\n\nSecretKeySpec AESkeySpec = new SecretKeySpec(keyPass, \"AES\");\nciph.init(ENCRYPT_MODE,AESkeySpec);\n//ciph.update(s.getBytes());\n\nbyte[] encryptedData = ciph.doFinal(s.getBytes());\nreturn encryptedData;\n", "idx": 2092}
{"project": "cipher", "commit_id": "Snippet30151424_12303.java", "target": 0, "func": "package blowfish;\nimport javax.crypto.Cipher;\nimport javax.crypto.spec.SecretKeySpec;\nimport sun.misc.BASE64Decoder;\nimport sun.misc.BASE64Encoder;\n\npublic class Blowfish {\n\npublic static void main(String[] args) throws Exception {\n    encrypt(\"1234\",\"some data\");\n    decrypt(\"1234\",\"A+oDE+RfTx11nT3iGgUvCw==\");\n}\n\nprivate static void encrypt(String key, String string) throws Exception {\n\n        byte[] keyData = (key).getBytes();\n        //System.out.println(keyData);\n        SecretKeySpec secretKeySpec = new SecretKeySpec(keyData, \"Blowfish\");\n        Cipher cipher = Cipher.getInstance(\"Blowfish\");\n        cipher.init(Cipher.ENCRYPT_MODE, secretKeySpec);\n        byte[] hasil = cipher.doFinal(string.getBytes());\n        System.out.println(new BASE64Encoder().encode(hasil));\n    }\n\nprivate static void decrypt(String key, String string) throws Exception {\n        byte[] keyData = (key).getBytes();\n        SecretKeySpec secretKeySpec = new SecretKeySpec(keyData, \"Blowfish\");\n        Cipher cipher = Cipher.getInstance(\"Blowfish\");\n        cipher.init(Cipher.DECRYPT_MODE, secretKeySpec);\n        byte[] hasil = cipher.doFinal(new BASE64Decoder().decodeBuffer(string));\n        System.out.println(new String(hasil));\n    }\n}\n", "idx": 1921}
{"project": "cipher", "commit_id": "Snippet39276955_21065.java", "target": 0, "func": "import java.security.KeyPairGenerator;\nimport java.security.KeyPair;\nimport java.security.NoSuchAlgorithmException;\nimport java.security.PublicKey;\nimport java.security.PrivateKey;\nimport java.security.Signature;\nimport java.io.*;\nimport java.util.*;\nimport java.util.concurrent.TimeUnit;\nimport javax.crypto.Cipher;\nimport javax.crypto.KeyGenerator;\nimport javax.crypto.NoSuchPaddingException;\nimport javax.crypto.SecretKey;\n\n\n\nclass Q5 { //Queue/Buffer   \n    byte[] shipmentConfirmation;//will include the actual message content been delivered\n    boolean valueSet = false;\n    synchronized byte[] get() \n    {       \n        while(!valueSet) \n        try \n        {\n            wait();\n        } \n        catch(InterruptedException e) \n        {\n            System.out.println(\"InterruptedException caught\");\n        }\n        //System.out.println(\"Got: \" + n);\n        valueSet = false;\n        notify();\n        return shipmentConfirmation;\n    }\n    synchronized void put(byte[] shipmentCinfirm) \n    {\n        while(valueSet)\n        try \n        {\n            wait();\n        } \n        catch(InterruptedException e) \n        {\n            System.out.println(\"InterruptedException caught\");\n        }\n        this.shipmentConfirmation = shipmentCinfirm;\n        valueSet = true;\n        //System.out.println(\"Put: \" + n);\n        notify();\n    }\n}\n\nclass Global5{\n    public static int sendcouter = 0;\n    public static SecretKey secret_Key;\n    public static Cipher desCipher;\n}\n\n\n//<<security pattern>> SymmetricEncryptionEncryptor\nclass SecurityEncryptor//<<security>> Encryptor\n{\n    static byte[] Encryptor(byte shipmentConfirmation[],Cipher c) throws Exception //Encryptor\n    {       \n        byte[] ciphertext = SecurityEncryptionAlgorithm.EncryptionAlgorithm(shipmentConfirmation,c,Global5.secret_Key);\n        return ciphertext;\n    }   \n}\nclass SecurityEncryptionAlgorithm//<<security>> EncryptionAlgorithm\n{\n    static byte[] EncryptionAlgorithm(byte shipmentConfirmation[],Cipher c,SecretKey sk) throws Exception \n    {\n        c.init(Cipher.ENCRYPT_MODE, sk);\n        return c.doFinal(shipmentConfirmation);\n    }\n}\n\n\n\n//<<security pattern>> aSecureAsynchronousMCReceiverConnector\nclass SecurityDecryptor//<<Security>> Decryptor\n{\n    static byte[] Decryptor(byte EncryptedShipmentConfirmation[],Cipher c,SecretKey sk) throws Exception //Decryptor\n    {\n        byte[] ct = SecurityDecryptionAlgorithm.DecryptionAlgorithm(EncryptedShipmentConfirmation,c,sk);\n        return ct;\n    }   \n}\nclass SecurityDecryptionAlgorithm//<<Security>> DecryptionAlgorithm\n{\n    static byte[] DecryptionAlgorithm(byte EncryptedShipmentConfirmation[],Cipher c,SecretKey sk) throws Exception \n    {\n        c.init(Cipher.DECRYPT_MODE, sk);\n        return c.doFinal(EncryptedShipmentConfirmation);\n    }\n}\n\n\n\npublic class testFigure1 { //Main\n       public static void main(String args[]) throws Exception {          \n            Q5 q1 = new Q5();//creating buffer/queue\n            Q5 q2 = new Q5();\n\n            System.out.println(\"How many messages to send: \");\n            Scanner in = new Scanner(System.in);\n            int input = in.nextInt();//Get input from the supplier          \n\n            aSupplierInterface Supplier = new aSupplierInterface(q1, input);    \n            aSecuritySenderCoordinator SenderCoordinator = new aSecuritySenderCoordinator(q1, input, q2);           \n            aSecurityReceiverCoordinator receive = new aSecurityReceiverCoordinator(q2, input);   \n            Supplier.t_pro.join();\n            SenderCoordinator.t_coordinator5.join();\n            receive.t_SecurityReceiverCoordinator5.join();\n            System.out.println(\"End of Program!\");\n       }   \n}\n\nclass aSupplierInterface  implements Runnable //<<application Component>> aSupplierInterface\n{\n    Q5 q;   \n    int supinput;\n    Thread t_pro;//pro to represent producer or suppler\n    aSupplierInterface(Q5 qq, int input)\n    {\n        supinput = input;\n        this.q = qq;\n        t_pro = new Thread(this, \"Producer\");\n        t_pro.start();\n    }\n    public void run() \n    {\n        int i = 0;\n        String shipment;\n        byte[] shipmentConfirmation;\n        while(i<supinput)\n        {\n            i++;\n            shipment = \"This is the Delivery Number: \"+ i;\n            shipmentConfirmation = shipment.getBytes();\n\n            q.put(shipmentConfirmation);//Putting supplier's goods in a queue/buffer            \n        }   \n    }       \n}\n\nclass aSecuritySenderCoordinator implements Runnable //<<security coordinator>> aSecuritySenderCoordinator\n{\n    Q5 q;\n    Q5 q2;\n    Thread t_coordinator5;\n    int supinput;\n\n    public aSecuritySenderCoordinator(Q5 qq, int input, Q5 q2) throws Exception\n    {       \n        supinput=input;\n        this.q = qq;    \n        this.q2=q2;\n        t_coordinator5 = new Thread(this, \"coordinator5\");\n        t_coordinator5.start();\n    }\n\n    public void run() \n    {\n        byte[] pkShipmentConfirmation;\n        byte[] shipmentConfirmation;\n        int i = 0;\n        while(i<supinput) \n        {               \n            i++;\n\n                //Getting goods that supplier has put in the queue previously\n            pkShipmentConfirmation=q.get();//This will contain content of the message/delivery you are sending\n            KeyGenerator keygen;\n            try {\n            keygen = KeyGenerator.getInstance(\"DES\");\n            Global5.sendcouter++;//To Create the key once\n            if(Global5.sendcouter==1)//Create once\n            {\n                Global5.secret_Key = keygen.generateKey();\n                Global5.desCipher = Cipher.getInstance(\"DES/ECB/PKCS5Padding\");\n            }           \n            //String st1 = new String(pkShipmentConfirmation);//just to print a message\n            //System.out.println(\"*ORIGINAL MESSAGE:\"+st1);    \n            shipmentConfirmation = SecurityEncryptor.Encryptor(pkShipmentConfirmation,Global5.desCipher);//Encrypting \n\n\n            new anAsynchronousMCReceiver(q2, shipmentConfirmation);     \n\n            } catch (NoSuchAlgorithmException e) {\n                // TODO Auto-generated catch block\n                e.printStackTrace();\n            } catch (Exception e) {\n                // TODO Auto-generated catch block\n                e.printStackTrace();\n            }\n        }\n    }\n}\n\n\n\n\nclass anAsynchronousMCReceiver \n{ //<<communication pattern>> anAsynchronousMCReceiver\n       Q5 q;\n\n       anAsynchronousMCReceiver( Q5 q2, byte[] shipmentConfirm) throws Exception\n       {\n           this.q = q2;\n           q.put(shipmentConfirm);  //Entering received data in to the Queue/Buffer \n       }\n}\n\n\n\nclass aSecurityReceiverCoordinator implements Runnable//<<security coordinator>> aSecurityReceiverCoordinator\n{       \n    Thread t_SecurityReceiverCoordinator5;  \n    Q5 q;\n    int supinput;\n    byte[]encryptedShipmentConfirmation;\n    public aSecurityReceiverCoordinator(Q5 q2, int input) throws Exception\n    {  \n        this.q = q2;    \n        supinput = input;\n        t_SecurityReceiverCoordinator5 = new Thread(this, \"SecurityReceiverCoordinator5\");\n        t_SecurityReceiverCoordinator5.start();\n\n    }\n    public void run() \n    {\n        try {\n            int i = 0;\n            while(i<supinput) \n            {           \n                i++;\n                encryptedShipmentConfirmation = q.get();                \n                byte[] confirmation = SecurityDecryptor.Decryptor(encryptedShipmentConfirmation,Global5.desCipher,Global5.secret_Key);//ERROR HAPPENS HERE              \n                String shipConfirmation = new String(confirmation);\n\n                System.out.println(\"AT DelivertyOrder: \" +  shipConfirmation);\n            }\n        } catch (Exception e) {\n            // TODO Auto-generated catch block\n            e.printStackTrace();\n        }\n    }\n}\n", "idx": 1930}
{"project": "cipher", "commit_id": "Snippet24867933_7200.java", "target": 1, "func": "Provider pkcs11provider = new SunPKCS11(\"C:\\\\Users\\\\manishs525\\\\pkcs11.cfg\");\nCipher rsaCipher2 = Cipher.getInstance(\"RSA/ECB/NoPadding\", pkcs11provider);\nrsaCipher2.init(Cipher.DECRYPT_MODE, privateKey);\nbyte[] paddedPlainText = rsaCipher2.doFinal(cipherText);\n\n/* Ensure leading zeros not stripped */\nif (paddedPlainText.length < keyLength / 8) {\n    byte[] tmp = new byte[keyLength / 8];\n    System.arraycopy(paddedPlainText, 0, tmp, tmp.length - paddedPlainText.length, paddedPlainText.length);\n    System.out.println(\"Zero padding to \" + (keyLength / 8));\n    paddedPlainText = tmp;\n}           \n\nSystem.out.println(\"OAEP padded plain text: \" + DatatypeConverter.printHexBinary(paddedPlainText));\n// === changed the next line ===\nPSource pSrc = (new PSource.PSpecified(iv));\n// === changed the last two parameters to MGF1ParameterSpec.SHA256 and pSrc ===\nOAEPParameterSpec paramSpec = new OAEPParameterSpec(\"SHA-256\", \"MGF1\", MGF1ParameterSpec.SHA256, pSrc);   // where iv is byte array of length 32\nRSAPadding padding = RSAPadding.getInstance(RSAPadding.PAD_OAEP_MGF1, keyLength / 8, new SecureRandom(), paramSpec);\nbyte[] plainText2 = padding.unpad(paddedPlainText);\n", "idx": 2457}
{"project": "cipher", "commit_id": "Snippet13827466_37297.java", "target": 0, "func": "import java.security.*;\nimport javax.crypto.*;\n//\n// encrypt and decrypt using the DES private key algorithm\npublic class PrivateExample {\n\n  public static void main (String[] args) throws Exception {\n  //\n  // check args and get plaintext\n    if (args.length !=1) {\n      System.err.println(\"Usage: java PrivateExample text\");\n      System.exit(1);\n    }\n  byte[] plainText = args[0].getBytes(\"UTF8\");\n  //\n  // get a DES private key\n  System.out.println( \"\\nStart generating DES key\" );\n  KeyGenerator keyGen = KeyGenerator.getInstance(\"DES\");\n  keyGen.init(56);\n  Key key = keyGen.generateKey();\n  System.out.println( \"Finish generating DES key\" );\n//\n// get a DES cipher object and print the provider\nCipher cipher = Cipher.getInstance(\"DES/ECB/PKCS5Padding\");\nSystem.out.println( \"\\n\" + cipher.getProvider().getInfo() );\n//\n// encrypt using the key and the plaintext\nSystem.out.println( \"\\nStart encryption\" );\ncipher.init(Cipher.ENCRYPT_MODE, key);\nbyte[] cipherText = cipher.doFinal(plainText);\nSystem.out.println( \"Finish encryption: \" );\nSystem.out.println( new String(cipherText, \"UTF8\") );\n\n//\n// decrypt the ciphertext using the same key\nSystem.out.println( \"\\nStart decryption\" );\ncipher.init(Cipher.DECRYPT_MODE, key);\nbyte[] newPlainText = cipher.doFinal(cipherText);\nSystem.out.println( \"Finish decryption: \" );\n\nSystem.out.println( new String(newPlainText, \"UTF8\") );\n}\n}\n", "idx": 2167}
{"project": "cipher", "commit_id": "Snippet38356450_20322.java", "target": 0, "func": "val encrypted = encrypt(zipped.toString)\n\ndef encrypt(value: String): String = {\n  val cipher: Cipher = Cipher.getInstance(\"AES/ECB/PKCS5Padding\")\n  cipher.init(Cipher.ENCRYPT_MODE, keyToSpec(encryptionPassword))\n  Base64.encodeBase64String(cipher.doFinal(value.getBytes(\"UTF-8\")))\n}\n", "idx": 2094}
{"project": "cipher", "commit_id": "Snippet15103237_38151.java", "target": 0, "func": "//SecretKey to save data\n    private SecretKey desKey;\n\n    //Complete encryption and decryption work\n    private Cipher c;\n\n    //Save encryption results\n    private byte[] cipherResultByte;\n\n    private final static String Algorithm = \"DESede/ECB/NoPadding\";//Encryption method/operation mode\n\n    private static DESedeKeySpec dks;\n\n    private static SecretKeyFactory keyFactory;   \n\n    public DESeseTest02() {\n\n        Security.addProvider(new com.sun.crypto.provider.SunJCE());\n\n        try {\n\n            dks = new DESedeKeySpec(\"00000000000000000000000000000000\".getBytes());   \n\n             keyFactory = SecretKeyFactory.getInstance(\"DESede\");\n\n\n            //Generate key\n            desKey=keyFactory.generateSecret(dks);\n\n\n            //Generate Cipher object, specify its support DES algorithm\n            c=Cipher.getInstance(Algorithm);\n\n        } catch (NoSuchAlgorithmException e) {\n            e.printStackTrace();\n        } catch (NoSuchPaddingException e) {\n            e.printStackTrace();\n        } catch (InvalidKeyException e) {\n            e.printStackTrace();\n        } catch (InvalidKeySpecException e) {\n            e.printStackTrace();\n        }\n    }\n\n\n    public byte[] createEncryptor(byte[] b){\n\n        try {\n\n//          System.out.println(str);\n            //\u6839\u636e\u5bc6\u94a5\uff0c\u5bf9Cipher\u8fdb\u884c\u521d\u4f7f\u5316\uff0cDECRYPT_MODE\u52a0\u5bc6\u6a21\u5f0f\n            c.init(Cipher.ENCRYPT_MODE, desKey);\n\n//          byte[] input=str.getBytes();\n//          System.out.println(input.length);\n\n            //Encryption, the results will be preserved\n            cipherResultByte=c.doFinal(b);\n\n        } catch (InvalidKeyException e) {\n            e.printStackTrace();\n        } catch (IllegalBlockSizeException e) {\n            e.printStackTrace();\n        } catch (BadPaddingException e) {\n            e.printStackTrace();\n        }\n        return cipherResultByte;\n    }\n", "idx": 2181}
{"project": "cipher", "commit_id": "Snippet15765319_38756.java", "target": 1, "func": "import java.security.InvalidAlgorithmParameterException;\nimport java.security.InvalidKeyException;\nimport java.security.NoSuchAlgorithmException;\n\nimport javax.crypto.BadPaddingException;\nimport javax.crypto.Cipher;\nimport javax.crypto.KeyGenerator;\nimport javax.crypto.IllegalBlockSizeException;\nimport javax.crypto.NoSuchPaddingException;\nimport javax.crypto.SecretKey;\nimport javax.crypto.ShortBufferException;\nimport javax.crypto.spec.IvParameterSpec;\nimport javax.crypto.spec.SecretKeySpec;\n\npublic class CryptoTest\n{\n  private class Slice\n  {\n    byte[] array;\n\n    int offset;\n\n    int size;\n  }\n\n  private Slice[] createSlices(int howMany, int whatSize)\n  {\n    Slice[] slices = new Slice[howMany];\n    for (int i = 0; i < howMany; i++)\n    {\n        slices[i] = new Slice();\n        slices[i].array = new byte[whatSize];\n        slices[i].offset = 0;\n        slices[i].size = 0;\n    }\n\n    return slices;\n  }\n\n  public void testWithOffsets() throws InvalidKeyException, NoSuchAlgorithmException, NoSuchPaddingException, ShortBufferException,\n                IllegalBlockSizeException, BadPaddingException, InvalidAlgorithmParameterException\n  {\n    int num = 10;\n    int size = 32784;\n    Slice[] slices = createSlices(num, size);\n\n    // Create the keys and parameters\n    KeyGenerator keyGenerator = KeyGenerator.getInstance(\"AES\");\n    SecretKey key = keyGenerator.generateKey();\n\n    SecretKey encryptionKey = new SecretKeySpec(key.getEncoded(), \"AES\");\n    Cipher cipher = Cipher.getInstance(\"AES/CBC/PKCS5PADDING\");\n\n    cipher.init(Cipher.ENCRYPT_MODE, encryptionKey);\n\n    // save IV\n    byte iv[] = cipher.getIV();\n\n    // setup input data\n    for (int i = 0; i < num; i++)\n    {\n        slices[i].offset = 16;\n        slices[i].size = 32768;\n    }\n    slices[num - 1].size = 5424;\n\n    // calculate a sum of input data, for comparisson later\n    Long sum = 0L;\n    for (int i = 0; i < num; i++)\n        for (int j = slices[i].offset; j < slices[i].offset + slices[i].size; j++)\n            sum = sum + slices[i].array[j];\n\n    // encrypt\n    int finalSize = 0;\n    for (int i = 0; i < num; i++)\n    {\n        if (i == num - 1)\n            finalSize = cipher.doFinal(slices[i].array, slices[i].offset, slices[i].size, slices[i].array, slices[i].offset);\n        else\n            finalSize = cipher.update(slices[i].array, slices[i].offset, slices[i].size, slices[i].array, slices[i].offset);\n        System.err.println(\"Original size is \" + slices[i].size + \" final size is \" + finalSize);\n        slices[i].size = finalSize;\n    }\n\n    // decrypt\n    SecretKey decryptionKey = new SecretKeySpec(key.getEncoded(), \"AES\");\n    Cipher decipher = Cipher.getInstance(\"AES/CBC/PKCS5PADDING\");\n\n    IvParameterSpec ips = new IvParameterSpec(iv);\n    decipher.init(Cipher.DECRYPT_MODE, decryptionKey, ips);\n\n    for (int i = 0; i < num; i++)\n    {\n    /* ** */\n        if (i == num - 1)\n            finalSize = decipher.doFinal(slices[i].array, slices[i].offset, slices[i].size, slices[i].array, slices[i].offset);\n        else\n            finalSize = decipher.update(slices[i].array, slices[i].offset, slices[i].size, slices[i].array, slices[i].offset);\n        System.err.println(\"Original size is \" + slices[i].size + \" final size is \" + finalSize);\n        slices[i].size = finalSize;\n    }\n\n    // sum of output data, should be the same as the input data\n    Long newsum = 0L;\n    for (int i = 0; i < num; i++)\n        for (int j = slices[i].offset; j < slices[i].offset + slices[i].size; j++)\n            newsum = newsum + slices[i].array[j];\n\n    System.err.println(\"newsum \" + newsum + \" oldsum \" + sum);\n    assert newsum == sum;\n  }\n\n  public static void main(String[] args) throws Exception\n  {\n    CryptoTest ct = new CryptoTest();\n\n    ct.testWithOffsets();\n    ct.testWithoutOffsets();\n  }\n}\n", "idx": 2597}
{"project": "cipher", "commit_id": "Snippet41528481_23462.java", "target": 1, "func": "package nl.owlstead.stackoverflow;\n\nimport java.security.NoSuchAlgorithmException;\nimport java.security.Provider;\nimport java.security.Provider.Service;\nimport java.security.Security;\nimport java.util.Set;\nimport java.util.SortedSet;\nimport java.util.TreeSet;\n\nimport javax.crypto.Cipher;\nimport javax.crypto.KeyGenerator;\nimport javax.crypto.SecretKey;\nimport javax.crypto.spec.SecretKeySpec;\n\nimport org.bouncycastle.jce.provider.BouncyCastleProvider;\n\npublic class FindKeySizes {\n\n    public static void main(String[] args) throws Exception {\n        Security.addProvider(new BouncyCastleProvider());\n        Provider[] providers = Security.getProviders();\n        for (Provider provider : providers) {\n            Set<Service> services = provider.getServices();\n            for (Service service : services) {\n                if (!service.getType().equalsIgnoreCase(\"cipher\")) {\n                    continue;\n                }\n\n                String alg = service.getAlgorithm();\n\n                KeyGenerator skf = null;\n                Cipher cipher;\n                try {\n                    // filters out symmetric algorithms\n                    skf = KeyGenerator.getInstance(alg, provider);\n                } catch (NoSuchAlgorithmException e) {\n                    // OK, that may not exist\n                }\n                try {\n                    cipher = Cipher.getInstance(alg, provider);\n                } catch (NoSuchAlgorithmException e) {\n                    continue;\n                }\n\n                SortedSet<Integer> keySizes = new TreeSet<>();\n                for (int keySize = Byte.SIZE; keySize <= 512; keySize += Byte.SIZE) {\n                    try {\n                        SecretKey key;\n                        if (skf != null) {\n                            try {\n                                skf.init(keySize);\n                                key = skf.generateKey();\n                            } catch (Exception e) {\n                                continue;\n                            }\n                        } else {\n                            key = new SecretKeySpec(new byte[keySize / Byte.SIZE], alg);\n                        }\n                        cipher.init(Cipher.ENCRYPT_MODE, key);\n                        keySizes.add(keySize);\n                    } catch (Exception e) {\n                        // needed for RuntimeException from providers\n                        if (alg.equalsIgnoreCase(\"AES\") && (keySize == 128)) {\n                            e.printStackTrace(System.err);\n                        }\n\n                        continue;\n                    }\n                }\n\n                if (!keySizes.isEmpty()) {\n                    System.out.printf(\"Provider: %s, cipher: %s, key sizes: %s%n\",\n                            provider.getName(), alg, keySizes);\n                }\n            }\n        }\n    }\n}\n", "idx": 2721}
{"project": "cipher", "commit_id": "Snippet21710067_4148.java", "target": 0, "func": "    public class EncryptionClass {\n\npublic static SecretKey mainKey=null;\n\n\n\npublic static SecretKey GenerateKey() throws NoSuchAlgorithmException\n{\n\n    KeyGenerator keygenerator = KeyGenerator.getInstance(\"DES\");\n    SecretKey myDesKey = keygenerator.generateKey();\n    return myDesKey;\n\n    }\n\n\npublic static String Encrypt(String plainText) {\n\n    String encryptedText = \"\";\n\n    try {\n        mainKey=GenerateKey();\n            Cipher desCipher;\n\n            // Create the cipher \n            desCipher = Cipher.getInstance(\"DES/ECB/PKCS5Padding\");\n\n            // Initialize the cipher for encryption\n            desCipher.init(Cipher.ENCRYPT_MODE,mainKey);\n\n            //sensitive information\n            byte[] plainTextAsBytes =plainText.getBytes();\n            Log.d(\"Text [Byte Format] : \" , plainTextAsBytes.toString());\n            Log.d(\"Text : \" ,new String(plainTextAsBytes));\n\n           // Encrypt the text\n            byte[] cipherText = desCipher.doFinal(plainTextAsBytes);\n\n            Log.d(\"Text Encryted : \" ,cipherText.toString());\n\n            encryptedText=cipherText.toString();\n\n    }catch(NoSuchAlgorithmException e){\n        Log.d(\"NoSuchAlgorithmException :\", e.toString());\n    }catch(NoSuchPaddingException e){\n        Log.d(\"NoSuchPaddingException  :\", e.toString());\n    }catch(InvalidKeyException e){\n        Log.d(\"InvalidKeyException:\", e.toString());\n    }catch(IllegalBlockSizeException e){\n        Log.d(\"IllegalBlockSizeException:\", e.toString());\n    }catch(BadPaddingException e){\n        Log.d(\"BadPaddingException:\", e.toString());\n    } \n    finally{\n\n    }\n\n    return encryptedText;\n\n}\n\npublic static String Decrypt(String cipherText) {\n\n    String decryptedText = \"\";\n\n    try {\n\n            Log.d(\"Decrypt MAin Key:\",mainKey.getEncoded().toString());\n            Cipher desCipher;\n\n            // Create the cipher \n            desCipher = Cipher.getInstance(\"DES/ECB/PKCS5Padding\");\n\n            // Initialize the cipher for encryption\n            desCipher.init(Cipher.DECRYPT_MODE,mainKey);\n\n\n           // Encrypt the text\n\n            byte[] cipherTextBytes=cipherText.getBytes();\n            byte[]  plainText= desCipher.doFinal(cipherTextBytes);\n\n            Log.d(\"Text Decryted : \" ,plainText.toString());\n\n            decryptedText=plainText.toString();\n\n    }catch(NoSuchAlgorithmException e){\n        Log.d(\"NoSuchAlgorithmException :\", e.toString());\n    }catch(NoSuchPaddingException e){\n        Log.d(\"NoSuchPaddingException  :\", e.toString());\n    }catch(InvalidKeyException e){\n        Log.d(\"InvalidKeyException:\", e.toString());\n    }catch(IllegalBlockSizeException e){\n        Log.d(\"IllegalBlockSizeException:\", e.toString());\n    }catch(BadPaddingException e){\n        Log.d(\"BadPaddingException:\", e.toString());\n    } \n    finally{\n\n    }\n\n\n    return decryptedText;\n}\n\n}\n", "idx": 1936}
{"project": "cipher", "commit_id": "Snippet13045845_36678.java", "target": 1, "func": "byte[] iv = {0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, }; // use different random value\nAlgorithmParameterSpec algorithmSpec = new IvParameterSpec(iv);\nCipher ecipher = Cipher.getInstance(\"AES/CBC/PKCS7Padding\");\necipher.init(Cipher.ENCRYPT_MODE, skeySpec, algorithmSpec);\n", "idx": 2398}
{"project": "cipher", "commit_id": "Snippet32096951_14156.java", "target": 1, "func": " package org.ferris.aes.crypto;\n\nimport java.io.UnsupportedEncodingException;\nimport java.security.Key;\nimport java.security.spec.KeySpec;\nimport javax.crypto.Cipher;\nimport javax.crypto.SecretKey;\nimport javax.crypto.SecretKeyFactory;\nimport javax.crypto.spec.IvParameterSpec;\nimport javax.crypto.spec.PBEKeySpec;\nimport javax.crypto.spec.SecretKeySpec;\nimport org.apache.commons.codec.binary.Base64;\n\n/**\n *\n * @author Michael Remijan mjremijan@yahoo.com @mjremijan\n */\npublic class AesBase64Wrapper {\n\n    private static String IV = \"IV_VALUE_16_BYTE\"; \n    private static String PASSWORD = \"PASSWORD_VALUE\"; \n    private static String SALT = \"SALT_VALUE\"; \n\n    public String encryptAndEncode(String raw) {\n        try {\n            Cipher c = getCipher(Cipher.ENCRYPT_MODE);\n            byte[] encryptedVal = c.doFinal(getBytes(raw));\n            String s = getString(Base64.encodeBase64(encryptedVal));\n            return s;\n        } catch (Throwable t) {\n            throw new RuntimeException(t);\n        }\n    }\n\n    public String decodeAndDecrypt(String encrypted) throws Exception {\n        byte[] decodedValue = Base64.decodeBase64(getBytes(encrypted));\n        Cipher c = getCipher(Cipher.DECRYPT_MODE);\n        byte[] decValue = c.doFinal(decodedValue);\n        return new String(decValue);\n    }\n\n    private String getString(byte[] bytes) throws UnsupportedEncodingException {\n        return new String(bytes, \"UTF-8\");\n    }\n\n    private byte[] getBytes(String str) throws UnsupportedEncodingException {\n        return str.getBytes(\"UTF-8\");\n    }\n\n    private Cipher getCipher(int mode) throws Exception {\n        Cipher c = Cipher.getInstance(\"AES/CBC/PKCS5Padding\");\n        byte[] iv = getBytes(IV);\n        c.init(mode, generateKey(), new IvParameterSpec(iv));\n        return c;\n    }\n\n    private Key generateKey() throws Exception {\n        SecretKeyFactory factory = SecretKeyFactory.getInstance(\"PBKDF2WithHmacSHA1\");\n        char[] password = PASSWORD.toCharArray();\n        byte[] salt = getBytes(SALT);\n\n        KeySpec spec = new PBEKeySpec(password, salt, 65536, 128);\n        SecretKey tmp = factory.generateSecret(spec);\n        byte[] encoded = tmp.getEncoded();\n        return new SecretKeySpec(encoded, \"AES\");\n    }\n}\n", "idx": 2610}
{"project": "cipher", "commit_id": "Snippet32932928_14955.java", "target": 0, "func": "cipher = Cipher.getInstance(\"DES/CTR/NoPadding\", \"BC\");", "idx": 1929}
{"project": "cipher", "commit_id": "Snippet43621771_25761.java", "target": 1, "func": "                Cipher c = Cipher.getInstance(\"PBEWithHmacSHA256AndAES_128\");\n            c.init(Cipher.DECRYPT_MODE, secretKey, params);\n\n            FileInputStream fis = new FileInputStream(\"repositorios/login.cif\");\n            FileOutputStream fos = new FileOutputStream(\"repositorios/login2.txt\");\n            CipherOutputStream cos = new CipherOutputStream(fos, c);\n\n            byte[] b = new byte[16]; \n            int i = fis.read(b);\n            while (i != -1) {\n                cos.write(b, 0, i);\n                i = fis.read(b);\n            }\n            cos.close();\n            fis.close();\n", "idx": 2426}
{"project": "cipher", "commit_id": "Snippet14695766_37883.java", "target": 1, "func": "byte[] input = \"test\".getBytes();\nString passphrase = \"absnfjtyrufjdngjvhfgksdfrtifghkv\";\nint saltLength = 8; \n\nSecureRandom random = new SecureRandom();\n\n//randomly generate salt\nbyte[] salt = new byte[saltLength];\nrandom.nextBytes(salt);\n\n// generating key from passphrase and salt\nSecretKeyFactory factory = SecretKeyFactory.getInstance(\"PBKDF2WithHmacSHA1\");\nKeySpec spec = new PBEKeySpec(passphrase.toCharArray(), salt, 1024, 256);\nSecretKey key = factory.generateSecret(spec);\nSecretKey kspec = new SecretKeySpec(key.getEncoded(), \"AES\");\n\n// randomly generate IV\nbyte iv[] = new byte[16];\nrandom.nextBytes(iv);\nIvParameterSpec ips = new IvParameterSpec(iv);\n\nCipher c = Cipher.getInstance(\"AES/CBC/PKCS5Padding\");\nc.init(Cipher.ENCRYPT_MODE, kspec, ips);\nbyte[] encryptedData = c.doFinal(input);\nSystem.out.println(new String(Base64.encodeBase64(encryptedData)));\n", "idx": 2555}
{"project": "cipher", "commit_id": "Snippet24434269_6769.java", "target": 1, "func": "//@Override\npublic String getClearText() throws IOException {\n    // Get the body\n    String encrypted = super.getParameter(\"aes\"); //base64\n\n    if (encrypted != null)\n    {\n        //Get the passphras, salt, IV and msg\n        String data[] = encrypted.split(\":\");\n        String passphrase = data[0];\n        String salt_hex = data[1];\n        String iv_hex = data[2];\n        String msg64 = data[3];\n        String jskey_hex = data[4];\n        byte[] jskey = hexStringToByteArray(jskey_hex);\n        byte[] iv = hexStringToByteArray(iv_hex);\n        byte[] salt = hexStringToByteArray(salt_hex);\n        BASE64Decoder decoder = new BASE64Decoder();\n        byte[] msg = decoder.decodeBuffer(msg64);\n        String plaintext = \"\";\n        try {\n            SecretKey key = new SecretKeySpec(jskey, \"AES\");\n            Cipher cipher = Cipher.getInstance(\"AES/CBC/PKCS5Padding\");\n            cipher.init(Cipher.DECRYPT_MODE, key, new IvParameterSpec(iv));\n            plaintext = new String(cipher.doFinal(msg), \"UTF-8\");\n        } catch (Exception e) {\n            // TODO Auto-generated catch block\n            e.printStackTrace();\n        }\n        System.out.println(\"in filter, decrypted: \" +plaintext);\n    }\n    return plaintext;\n}\n", "idx": 2762}
{"project": "cipher", "commit_id": "Snippet45936706_28004.java", "target": 1, "func": "private void newEnc() {\n\n        String secret = \"LSC@SD2017@ps\";\n         String cipherText = \"{\\\"device_type\\\":\\\"iOS\\\",\\\"email\\\" : \\\"jhon@gmail.com\\\",\\\"device_id\\\" : \\\"14105DA4-CEE5-431E-96A2-2331CDA7F062\\\",\\\"password\\\" : \\\"123456\\\",\\\"device_token\\\" : \\\"B44777563552882EC3139A0317E401B55D6FC699D0AC3D279F392927CAF9B566\\\"}\";\n\n\n        KeyGenerator kgen = null;\n        try {\n            kgen = KeyGenerator.getInstance(\"AES\");\n            SecureRandom sr = SecureRandom.getInstance(\"SHA1PRNG\");\n            sr.setSeed(secret.getBytes(\"UTF8\"));\n            kgen.init(256, sr);\n            SecretKey skey = kgen.generateKey();\n\n            Cipher c = Cipher.getInstance(\"AES/CBC/PKCS5Padding\");\n            SecretKeySpec skeySpec = new SecretKeySpec(skey.getEncoded(), \"AES\");\n            c.init(Cipher.ENCRYPT_MODE, skeySpec);\n            byte[] decrypted = c.doFinal(cipherText.getBytes());\n\n            System.out.println(Base64.encodeToString(decrypted, Base64.NO_WRAP));\n\n           // decrypted = Base64.encodeBase64(decrypted);\n          //  byte[] iv = Base64.encodeBase64(c.getIV());\n          //  Log.e(\"encryptString\", new String(decrypted));\n          //  Log.d(\"encryptString iv\", new String(iv));\n\n\n        } catch (NoSuchAlgorithmException e) {\n            e.printStackTrace();\n        } catch (InvalidKeyException e) {\n            e.printStackTrace();\n        } catch (NoSuchPaddingException e) {\n            e.printStackTrace();\n        } catch (BadPaddingException e) {\n            e.printStackTrace();\n        } catch (UnsupportedEncodingException e) {\n            e.printStackTrace();\n        } catch (IllegalBlockSizeException e) {\n            e.printStackTrace();\n        }\n\n\n    }\n", "idx": 2424}
{"project": "cipher", "commit_id": "Snippet6692671_32291.java", "target": 1, "func": "public class Filedecrypt {\n\npublic static void main(String args[]) throws IOException,\n        InvalidKeyException, java.security.InvalidKeyException,\n        NoSuchAlgorithmException, NoSuchPaddingException,\n        BadPaddingException {\n    try {\n\n        byte[] plainData = null;\n        byte[] encryptedData;\n        File f1 = new File(\"C:\\\\Output\\\\Privatekey.txt\");\n        FileInputStream in1 = new FileInputStream(f1);\n        byte[] bytekey = new byte[(int) f1.length()];\n        in1.read(bytekey);\n        KeyFactory keyFac = KeyFactory.getInstance(\"RSA\");\n        PKCS8EncodedKeySpec keySpec = new PKCS8EncodedKeySpec(bytekey);\n\n        PrivateKey key = keyFac.generatePrivate(keySpec);\n        Cipher cipher = Cipher.getInstance(\"RSA\");\n        cipher.init(Cipher.DECRYPT_MODE, key);\n\n        File f = new File(\"C:\\\\Output\\\\encrypted.txt\");\n        FileInputStream in = new FileInputStream(f);\n        encryptedData = new byte[(int) f.length()];\n        in.read(encryptedData);\n\n        try {\n            plainData = cipher.doFinal(encryptedData);\n        } catch (IllegalBlockSizeException e) {\n\n            e.printStackTrace();\n        } catch (BadPaddingException e) {\n\n            e.printStackTrace();\n        }\n\n        FileOutputStream target = new FileOutputStream(\n                new File(\n                        \"C:\\\\Output\\\\text1.txt\"));\n        target.write(plainData);\n        target.close();\n    } catch (IOException e) {\n        e.printStackTrace();\n    } catch (InvalidKeyException ei) {\n        ei.printStackTrace();\n    } catch (InvalidKeySpecException e) {\n        // TODO Auto-generated catch block\n        e.printStackTrace();\n    }\n}\n}\n", "idx": 2404}
{"project": "cipher", "commit_id": "Snippet42821867_24903.java", "target": 0, "func": "class TCPClient {\npublic static void main(String argv[]) throws Exception {\n    byte[] sentence, textEncrypted;\n    String modifiedSentence;\n    String password;\n    BufferedReader inFromUser = new BufferedReader(new InputStreamReader(System.in));\n    Socket clientSocket = new Socket(\"localhost\", 6789);\n    DataOutputStream outToServer = new DataOutputStream(clientSocket.getOutputStream());\n    password = \"Passcode\";\n    byte[] salt = new byte[64];\n    Random rnd = new Random();\n    rnd.nextBytes(salt);\n    byte[] data = deriveKey(password, salt, 64);\n\n    // BufferedReader inFromServer = new BufferedReader(new\n    // InputStreamReader(clientSocket.getInputStream()));\n    System.out.println(\"Enter the Data to be transmisted to server\\n\");\n    sentence = inFromUser.readLine().getBytes();\n    SecretKey desKey = SecretKeyFactory.getInstance(\"DES\").generateSecret(new DESKeySpec(data));\n    Cipher cipher = Cipher.getInstance(\"DES/ECB/PKCS5Padding\");\n    cipher.init(Cipher.ENCRYPT_MODE, desKey);\n    textEncrypted = cipher.doFinal(sentence);\n    outToServer.writeBytes(new String(textEncrypted) + '\\n');\n    clientSocket.close();\n}\n\npublic static byte[] deriveKey(String password, byte[] salt, int keyLen) {\n    SecretKeyFactory kf = null;\n    try {\n        kf = SecretKeyFactory.getInstance(\"PBKDF2WithHmacSHA1\");\n    } catch (NoSuchAlgorithmException e) {\n        // TODO Auto-generated catch block\n        e.printStackTrace();\n    }\n    KeySpec specs = new PBEKeySpec(password.toCharArray(), salt, 1024, keyLen);\n    SecretKey key = null;\n    try {\n        key = kf.generateSecret(specs);\n    } catch (InvalidKeySpecException e) {\n        // TODO Auto-generated catch block\n        e.printStackTrace();\n    }\n    return key.getEncoded();\n}\n}\n", "idx": 2039}
{"project": "cipher", "commit_id": "Snippet22842235_5241.java", "target": 1, "func": "InputStream in = mContext.getResources().openRawResource(R.raw.key);\n\n        CertificateFactory cf = CertificateFactory.getInstance(\"X509\");\n        Certificate cert = cf.generateCertificate(new ByteArrayInputStream(org.apache.commons.io.IOUtils.toByteArray(in)));\n        PublicKey pubKey = cert.getPublicKey();\n        try\n        {\n            Cipher cipher = Cipher.getInstance(\"RSA/ECB/PKCS1Padding\");            \n            cipher.init(Cipher.ENCRYPT_MODE, pubKey);\n            final String encryptedString = Base64.encode(cipher.doFinal(message));\n            return encryptedString;\n        }\n        catch (Exception e)\n        {\n            e.printStackTrace();\n        }\n        return \"\";   \n", "idx": 2451}
{"project": "cipher", "commit_id": "Snippet11882379_35863.java", "target": 0, "func": " public static String generate(String password, String passphase) throws Exception {\n    try {\n        PBEKeySpec pbeKeySpec = new PBEKeySpec(passphase.toCharArray());\n        PBEParameterSpec pbeParamSpec;\n        SecretKeyFactory keyFac;\n        // Salt\n        byte[] salt = {(byte) 0xc8, (byte) 0x73, (byte) 0x61, (byte) 0x1d, (byte) 0x1a, (byte) 0xf2, (byte) 0xa8, (byte) 0x99};\n        // Iteration count\n        int count = 20;\n        // Create PBE parameter set\n        pbeParamSpec = new PBEParameterSpec(salt, count);\n        keyFac = SecretKeyFactory.getInstance(\"PBEWithMD5AndDES\");\n        SecretKey pbeKey = keyFac.generateSecret(pbeKeySpec);\n        // Create PBE Cipher\n        Cipher pbeCipher = Cipher.getInstance(\"PBEWithMD5AndDES\");\n        // Initialize PBE Cipher with key and parameters\n        pbeCipher.init(Cipher.ENCRYPT_MODE, pbeKey, pbeParamSpec);\n        // Our cleartext\n        byte[] cleartext = password.getBytes();\n        // Encrypt the cleartext\n        byte[] ciphertext = pbeCipher.doFinal(cleartext);\n        return byteArrayToHexString(ciphertext).substring(0, 12);\n    } catch (Exception ex) {\n        throw new Exception(ex.getMessage());\n    }\n}\n\npublic static String byteArrayToHexString(byte[] b){\n    StringBuilder sb = new StringBuilder(b.length * 2);\n    for (int i = 0; i < b.length; i++){\n        int v = b[i] & 0xff;\n        if (v < 16) {\n            sb.append('0');\n        }\n        sb.append(Integer.toHexString(v));\n    }\n    return sb.toString().toUpperCase();\n}\n", "idx": 2053}
{"project": "cipher", "commit_id": "Snippet9684114_34158.java", "target": 0, "func": "    public static String decrypt(String seed, String encrypted) throws Exception {\n    byte[] rawKey = getRawKey(seed.getBytes());\n    byte[] enc = toByte(encrypted);\n\n    SecretKeySpec Spec = new SecretKeySpec(rawKey, \"AES\");\n    Cipher cipher = Cipher.getInstance(\"AES\");\n    cipher.init(Cipher.DECRYPT_MODE, Spec);\n\n\n    byte[] result = cipher.doFinal(enc);\n\n    return new String(result);\n}\n", "idx": 1924}
{"project": "cipher", "commit_id": "Snippet4728472_31278.java", "target": 1, "func": "Cipher in = Cipher.getInstance(\"AES/CCM/NoPadding\", \"BC\");\nin.init(Cipher.ENCRYPT_MODE, key, new IvParameterSpec(_nonce));\nencoded = in.doFinal(payload);\n", "idx": 2670}
{"project": "cipher", "commit_id": "Snippet13280669_36844.java", "target": 1, "func": "public static String encryptText(String textToEncrypt) {\n    try {\n        byte[] guid = \"1234567890123456\".getBytes(\"UTF-8\");\n\n        byte[] iv = { 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0 };\n        IvParameterSpec ips = new IvParameterSpec(iv);\n\n        // The secret key from the server needs to be converted to byte array for encryption.\n        byte[] secret = ENCRYPTION_SECRET_HASH.getBytes(\"UTF-8\");\n\n        // we generate a AES SecretKeySpec object which contains the secret key.\n        // SecretKeySpec secretKey = new SecretKeySpec(secret, \"AES\");\n        Cipher cipher = Cipher.getInstance(ENCRYPTION_METHOD);\n        cipher.init(Cipher.ENCRYPT_MODE, SECRET_KEY, ips);\n\n        byte[] cipherText = cipher.doFinal(textToEncrypt.getBytes());\n        byte[] base64encodedSecretData = Base64.encodeBase64(cipherText);\n        String secretString = new String(base64encodedSecretData);\n        return secretString;\n    } catch (Exception e) {\n        e.printStackTrace();\n        Log.e(TAG, \"Encryption error for \" + textToEncrypt, e);\n    }\n    return \"\";\n}\n", "idx": 2379}
{"project": "cipher", "commit_id": "Snippet11767352_35774.java", "target": 1, "func": "Cipher rsaCipher = Cipher.getInstance(\"RSA/NONE/PKCS1Padding\", \"BC\");\n", "idx": 2712}
{"project": "cipher", "commit_id": "Snippet8834667_33552.java", "target": 1, "func": "cipher = Cipher.getInstance(\"RSA/NONE/OAEPWithSHA256AndMGF1Padding\");\ncipher.init(Cipher.ENCRYPT_MODE, getPublicKey());\nbyte[] base64byes = loginMessage.getBytes();\nbyte[] cipherData = cipher.doFinal(base64byes);\nSystem.out.println(\"RSA: \" + cipherData.length); //is 512 long\n//4. Send to scheduler\nBase64PrintWriter base64encoder = new Base64PrintWriter(out);\nbase64encoder.writeln(new String(cipherData)); //send string is 1248 long\nbase64encoder.flush();\n", "idx": 2676}
{"project": "cipher", "commit_id": "Snippet34682894_16672.java", "target": 1, "func": "import org.apache.commons.codec.binary.Base64;\nimport javax.crypto.Cipher;\nimport java.io.*;\nimport java.security.KeyFactory;\nimport java.security.PublicKey;\nimport java.security.spec.X509EncodedKeySpec;\n\npublic class Encrypter {\nString keyFileName;\n\npublic Encrypter(String keyFileName) {\n    this.keyFileName = keyFileName;\n}\n\npublic String rsaEncrypt(String data) throws Exception {\n    PublicKey pubKey = readPublicKeyFromFile(keyFileName);\n            byte[] utf8 = data.getBytes(\"UTF-8\");\n    Cipher cipher = Cipher.getInstance(\"RSA\");\n\n    cipher.init(Cipher.ENCRYPT_MODE, pubKey);\n    byte[] enc = cipher.doFinal(Base64.encodeBase64(utf8));\n    return Base64.encodeBase64String(enc);\n}\n\nprivate PublicKey readPublicKeyFromFile(String keyFileName) throws Exception {\n    File filePublicKey = new File(keyFileName);\n    FileInputStream fis = new FileInputStream(keyFileName);\n    byte[] encodedPublicKey = new byte[(int) filePublicKey.length()];\n    fis.read(encodedPublicKey);\n    fis.close();\n\n    KeyFactory keyFactory = KeyFactory.getInstance(\"RSA\");\n    X509EncodedKeySpec publicKeySpec = new X509EncodedKeySpec(\n            encodedPublicKey);\n    PublicKey pubKey = keyFactory.generatePublic(publicKeySpec);\n    return pubKey;\n}\n}\n", "idx": 2535}
{"project": "cipher", "commit_id": "Snippet39396113_21279.java", "target": 0, "func": "Cipher desCipher = Cipher.getInstance(\"DESede/CBC/NoPadding\");\n", "idx": 2024}
{"project": "cipher", "commit_id": "Snippet4405334_31104.java", "target": 0, "func": "    SecretKeySpec skeySpec = new SecretKeySpec(raw, \"AES\");\n    Cipher cipher = Cipher.getInstance(\"AES\");\n    cipher.init(Cipher.DECRYPT_MODE, skeySpec);\n    byte[] decrypted = cipher.doFinal(encrypted);\n", "idx": 2111}
{"project": "cipher", "commit_id": "Snippet18188089_1225.java", "target": 1, "func": "Cipher rsaCipher = Cipher.getInstance(\"RSA\", \"BC\");\n", "idx": 2523}
{"project": "cipher", "commit_id": "Snippet36856719_18827.java", "target": 0, "func": "public class BillnoxCryptography {\n\nprivate static final String ALGORITHM = \"AES\";\n\npublic static String encrypt(String seed, String cleartext) throws InvalidKeyException, NoSuchAlgorithmException, NoSuchPaddingException,\n        IllegalBlockSizeException, BadPaddingException {\n    byte[] rawKey = getRawKey(seed.getBytes());\n    byte[] result = encrypt(rawKey, cleartext.getBytes());\n    return toHex(result);\n}\n\npublic static String decrypt(String seed, String encrypted) throws InvalidKeyException, NoSuchAlgorithmException, NoSuchPaddingException,\n        IllegalBlockSizeException, BadPaddingException {\n    byte[] rawKey = getRawKey(seed.getBytes());\n    byte[] enc = toByte(encrypted);\n    byte[] result = decrypt(rawKey, enc);\n    return new String(result);\n}\n\nprivate static byte[] getRawKey(byte[] seed) {\n    seed = Arrays.copyOf(seed, 16);\n    SecretKey key = new SecretKeySpec(seed, ALGORITHM);\n    byte[] raw = key.getEncoded();\n    return raw;\n}\n\n// Since the credentials are already secured through shared prefs, we're\n// using this as a lightweight solution for obfuscation. Fixing SecureRandom\n// to provide cryptographically strong values is outside the scope of this\n// application. See\n// http://android-developers.blogspot.com/2013/08/some-securerandom-thoughts.html\n@SuppressLint(\"TrulyRandom\")\nprivate static byte[] encrypt(byte[] raw, byte[] clear) throws NoSuchAlgorithmException, NoSuchPaddingException, InvalidKeyException,\n        IllegalBlockSizeException, BadPaddingException {\n    SecretKeySpec secretKeySpec = new SecretKeySpec(raw, ALGORITHM);\n    Cipher cipher = Cipher.getInstance(ALGORITHM);\n    cipher.init(Cipher.ENCRYPT_MODE, secretKeySpec);\n    byte[] encrypted = cipher.doFinal(clear);\n    return encrypted;\n}\n\nprivate static byte[] decrypt(byte[] raw, byte[] encrypted) throws NoSuchAlgorithmException, NoSuchPaddingException, InvalidKeyException,\n        IllegalBlockSizeException, BadPaddingException {\n    SecretKeySpec skeySpec = new SecretKeySpec(raw, ALGORITHM);\n    Cipher cipher = Cipher.getInstance(ALGORITHM);\n    cipher.init(Cipher.DECRYPT_MODE, skeySpec);\n    byte[] decrypted = cipher.doFinal(encrypted);\n    return decrypted;\n}\n\npublic static byte[] toByte(String hexString) {\n    int len = hexString.length() / 2;\n    byte[] result = new byte[len];\n\n    for (int i = 0; i < len; i++) {\n        result[i] = Integer.valueOf(hexString.substring(2 * i, 2 * i + 2), 16).byteValue();\n    }\n\n    return result;\n}\n\npublic static String toHex(byte[] buf) {\n    if (buf == null) {\n        return \"\";\n    }\n\n    StringBuffer result = new StringBuffer(2 * buf.length);\n\n    for (int i = 0; i < buf.length; i++) {\n        appendHex(result, buf[i]);\n    }\n\n    return result.toString();\n}\n\nprivate final static String HEX = \"0123456789ABCDEF\";\n\nprivate static void appendHex(StringBuffer sb, byte b) {\n    sb.append(HEX.charAt((b >> 4) & 0x0f)).append(HEX.charAt(b & 0x0f));\n}\n}\n\n\npublic class BillNoxApp extends Application {\n\n\n\nprivate Activity localActivity;\npublic static Context mcontext;\nprivate DBHelper db = null;\n@Override\npublic void onConfigurationChanged(Configuration newConfig) {\n    super.onConfigurationChanged(newConfig);\n}\n\n\n\n\n@Override\npublic void onCreate() {\n    super.onCreate();\n    this.mcontext = this.getApplicationContext();\n    try {\n        BillNoxApp.mcontext =this;\n        db = new DBHelper(this);\n        db.open();\n    } catch (Exception e) {\n        Log.i(\"Exception\", e + \"\");\n    }\n\n}\npublic static Context getContext() {\n\n    return mcontext;\n}\n@Override\npublic void onLowMemory() {\n    super.onLowMemory();\n}\n\n@Override\npublic void onTerminate() {\n    db.close();\n    super.onTerminate();\n}\n\npublic DBHelper getDatabase() {\n    return db;\n}\n\n\npublic void setLocalActivity(Activity localActivity) {\n    this.localActivity = localActivity;\n}\n\npublic Activity getLocalActivity() {\n    return this.localActivity;\n}\n\n\n\n\n}\n", "idx": 2129}
{"project": "cipher", "commit_id": "Snippet45078929_27205.java", "target": 1, "func": " import org.apache.commons.codec.binary.Base64;\n import org.apache.log4j.Logger;\n import javax.crypto.*;\n import javax.crypto.spec.IvParameterSpec;\n import javax.crypto.spec.PBEKeySpec;\n import javax.crypto.spec.SecretKeySpec;\n import java.io.UnsupportedEncodingException;\n import java.lang.reflect.Field;\n import java.lang.reflect.Modifier;\n import java.security.InvalidAlgorithmParameterException;\n import java.security.InvalidKeyException;\n import java.security.NoSuchAlgorithmException;\n import java.security.spec.InvalidKeySpecException;\n import java.security.spec.InvalidParameterSpecException;\n import java.security.spec.KeySpec;\n\n public class AESEncrypter {\n\nprivate static final Logger LOGGER = Logger.getLogger(AESEncrypter.class);\nprivate static final byte[] SALT = {\n    (byte) 0xA9, (byte) 0x9B, (byte) 0xC8, (byte) 0x32,\n    (byte) 0x56, (byte) 0x35, (byte) 0xE3, (byte) 0x03\n};\nprivate static final int ITERATION_COUNT = 65536;\nprivate static final int KEY_LENGTH = 256;\nprivate Cipher ecipher;\nprivate Cipher dcipher;\n\npublic AESEncrypter(String passPhrase)  {\n    SecretKeyFactory factory = null;\n    Field field = null;\n    try {\n        // hack for JCE unlimited strength policy jar installations\n        field = Class.forName(\"javax.crypto.JceSecurity\").getDeclaredField(\"isRestricted\");\n        field.setAccessible(true);\n\n        Field modifiersField = Field.class.getDeclaredField(\"modifiers\");\n        modifiersField.setAccessible(true);\n        modifiersField.setInt(field, field.getModifiers() & ~Modifier.FINAL);\n\n        field.set(null, false);\n\n\n        factory = SecretKeyFactory.getInstance(\"PBKDF2WithHmacSHA1\");\n        KeySpec spec = new PBEKeySpec(passPhrase.toCharArray(), SALT, ITERATION_COUNT, KEY_LENGTH);\n        SecretKey tmp = factory.generateSecret(spec);\n        SecretKey secret = new SecretKeySpec(tmp.getEncoded(), \"AES\");\n\n        ecipher = Cipher.getInstance(\"AES/CBC/PKCS5Padding\");\n        ecipher.init(Cipher.ENCRYPT_MODE, secret);\n\n        dcipher = Cipher.getInstance(\"AES/CBC/PKCS5Padding\");\n        byte[] iv = ecipher.getParameters().getParameterSpec(IvParameterSpec.class).getIV();\n        dcipher.init(Cipher.DECRYPT_MODE, secret, new IvParameterSpec(iv));\n    } catch (NoSuchAlgorithmException e) {\n        e.printStackTrace();\n    } catch (InvalidKeyException e) {\n        LOGGER.error(\"Invalid Key Exception\",e);\n    } catch (InvalidAlgorithmParameterException e) {\n        LOGGER.error(\"Invalid Algorithm Parameter Exception\",e);\n    } catch (NoSuchPaddingException e) {\n        LOGGER.error(\"No Such Padding Exception\",e);\n    } catch (InvalidParameterSpecException e) {\n        LOGGER.error(\"Invalid Parameter Exception\",e);\n    } catch (InvalidKeySpecException e) {\n        LOGGER.error(\"Invalid Key Spec Exception\",e);\n    } catch (NoSuchFieldException e) {\n        LOGGER.error(\"No Such field Exception\",e);\n    } catch (ClassNotFoundException e) {\n        LOGGER.error(\"Class Not Found Exception\",e);\n    } catch (IllegalAccessException e) {\n        LOGGER.error(\"Illegal Argument Exception\",e);\n    }\n\n\n}\n\npublic String encrypt(String encrypt) {\n    byte[] bytes = new byte[0];\n    byte[] encrypted = new byte[0];\n    try {\n        bytes = encrypt.getBytes(\"UTF-8\");\n        encrypted = encrypt(bytes);\n    } catch (Exception e) {\n        LOGGER.error(\"Exception\",e);\n    }\n    return Base64.encodeBase64String(encrypted);\n}\n\nprivate byte[] encrypt(byte[] plain)  {\n    try {\n        return ecipher.doFinal(plain);\n    } catch (IllegalBlockSizeException e) {\n        LOGGER.error(\"Illegal Block Size Exception\",e);\n    } catch (BadPaddingException e) {\n        LOGGER.error(\"Bad Padding Exception\",e);\n    }\n    return null;\n}\n\npublic String decrypt(String encrypt) throws UnsupportedEncodingException {\n    byte[] bytes = Base64.decodeBase64(encrypt.getBytes(\"UTF-8\"));\n        byte[] decrypted = decrypt(bytes);\n        return new String(decrypted);\n}\n\npublic byte[] decrypt(byte[] encrypt)  {\n    try {\n        return dcipher.doFinal(encrypt);\n    } catch (IllegalBlockSizeException e) {\n        LOGGER.error(\"Illegal Block Size Exception\",e);\n    } catch (BadPaddingException e) {\n        LOGGER.error(\"Bad Padding Exception\",e);\n    }\n    return null;\n}\n\n\n\n\npublic static void main(String[] args) throws UnsupportedEncodingException {\n        String password = \"F1C0T0N83LL34\";\n        String message = \"{\\\"version\\\":\\\"1.0\\\",\\\"rccCubeType\\\":\\\"TCR_CASE_D\\\",\\\"timeZone\\\":\\\"Asia/Kolkata\\\",\\\"timeOffset\\\":\\\"+05:30\\\",\\\"tenant\\\":\\\"0001\\\",\\\"extractionTime\\\":\\\"20170713162718117\\\"}\";\n        AESEncrypter encrypter = new AESEncrypter(password);\n        String cipher = encrypter.encrypt(message);\n        System.out.println(cipher);\n        System.out.println(new String(encrypter.decrypt(\"I8YbMaRvAw+rzPQu//uXnDDFrk/EtscXpcxBzqonVOpJ1VjvpwtRGwrsEz9R1rroC95Vj9bzPDbkX2qdLXK4jLKlzaoINXOxF+dHslnBVl3xG61qh9QdCuMTBzEEw18K51JJu+13bjuUO20+0uZiY5q6Wg1sQ60C0QEeO/7K9F/TSUN1r5l02Q9NSDQJpkvlglHZEfPJ7ST4179oqlQUjQ==\").getBytes(\"UTF-8\")));\n     }\n }\n", "idx": 2454}
{"project": "cipher", "commit_id": "Snippet20811912_3418.java", "target": 0, "func": "public static String encrypt(String content, String sKey) {\n  try {\n    SecretKey secretKey = null;\n    KeyGenerator kgen = KeyGenerator.getInstance(\"AES\");\n    SecureRandom secureRandom = SecureRandom.getInstance(\"SHA1PRNG\");\n    secureRandom.setSeed(sKey.getBytes());\n    kgen.init(128, secureRandom);\n    secretKey = kgen.generateKey();\n    byte[] enCodeFormat = secretKey.getEncoded();\n    SecretKeySpec key = new SecretKeySpec(enCodeFormat, \"AES\");\n\n    Cipher cipher = Cipher.getInstance(\"AES\");\n    cipher.init(Cipher.ENCRYPT_MODE, key);\n\n    byte[] byteContent = content.getBytes(\"utf-8\");\n    byte[] result = cipher.doFinal(byteContent);\n\n    return ByteUtil.parseByte2HexStr(result);\n  } catch (Exception e) {\n    e.printStackTrace();\n  }\n  return content;\n}\n\n\n## ByteUtil.java\n...\npublic static String parseByte2HexStr(byte buf[]) {\n    StringBuffer sb = new StringBuffer();\n    for (int i = 0; i < buf.length; i++) {\n        String hex = Integer.toHexString(buf[i] & 0xFF);\n        if (hex.length() == 1) {\n            hex = '0' + hex;\n        }\n        sb.append(hex.toUpperCase());\n    }\n    return sb.toString();\n}\n", "idx": 1933}
{"project": "cipher", "commit_id": "Snippet42779492_24838.java", "target": 1, "func": " try {\n        String content = \"hello\";\n        String key = \"57f4dad48e7a4f7cd171c654226feb5a\";\n        KeyGenerator kgen = KeyGenerator.getInstance(\"AES\");\n        kgen.init(128, new SecureRandom(key.getBytes(\"utf-8\")));\n        SecretKey secretKey = kgen.generateKey();\n        byte[] enCodeFormat = secretKey.getEncoded();\n\n\n        SecretKeySpec key1 = new SecretKeySpec(enCodeFormat, \"AES\");\n\n        Cipher cipher = Cipher.getInstance(\"AES/CBC/PKCS5Padding\");\n\n        byte[] byteContent = content.getBytes(\"utf-8\");\n\n\n        cipher.init(Cipher.ENCRYPT_MODE, key1,new IvParameterSpec(\"1234567812345678\".getBytes(\"UTF-8\")));\n\n        byte[] result = cipher.doFinal(byteContent);\n        System.out.println(new String(result).equals(\"QtzDsbCgmA9+XBVEsEm70w==\"));\n\n    } catch (NoSuchAlgorithmException | NoSuchPaddingException e) {\n        e.printStackTrace();\n    } catch (BadPaddingException e) {\n        e.printStackTrace();\n    } catch (IllegalBlockSizeException e) {\n        e.printStackTrace();\n    } catch (InvalidKeyException e) {\n        e.printStackTrace();\n    } catch (UnsupportedEncodingException e) {\n        e.printStackTrace();\n    } catch (InvalidAlgorithmParameterException e) {\n        e.printStackTrace();\n    }\n", "idx": 2533}
{"project": "cipher", "commit_id": "Snippet20554289_3146.java", "target": 1, "func": "KeyStore ks = null;\ntry {\n    ks = KeyStore.getInstance(KeyStore.getDefaultType()); \n    InputStream is = new FileInputStream(\"./raw/./akeystore\");\n    ks.load(is, \"a\".toCharArray());\n} catch (Exception e) {\n    e.printStackTrace();\n}\n\nCertificate cert = ks.getCertificate(\"akeypaircer\");\nRSAPublicKey publicKey = (RSAPublicKey)cert.getPublicKey();\nCipher c = Cipher.getInstance(\"RSA/ECB/PKCS1PADDING\");\nc.init(Cipher.ENCRYPT_MODE, publicKey);\n\nbyte[] decodedString = Base64.decodeBase64(\"how's it going?\".getBytes(\"UTF-8\"));\nbyte [] cipher = c.doFinal(decodedString);\n\nRSAPrivateKey privateKey = (RSAPrivateKey)ks.getKey(\"akeypair\",\"a\".toCharArray());\nc.init(Cipher.DECRYPT_MODE, privateKey);\n\nbyte [] decrypted_cipher = c.doFinal(cipher);\nbyte[] encodedBytes = Base64.encodeBase64(decrypted_cipher);\n\nSystem.out.println(new String(encodedBytes, \"UTF-8\"));\n", "idx": 2462}
{"project": "cipher", "commit_id": "Snippet14054593_37452.java", "target": 1, "func": "public class AES256Cipher {\n\n    public static byte[] ivBytes = { 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00 };\n\n    public static String AES_Encode(String str, String key) throws java.io.UnsupportedEncodingException, NoSuchAlgorithmException, NoSuchPaddingException, InvalidKeyException, InvalidAlgorithmParameterException, IllegalBlockSizeException, BadPaddingException {\n\n        byte[] textBytes = str.getBytes(\"UTF-8\");\n        AlgorithmParameterSpec ivSpec = new IvParameterSpec(ivBytes);\n             SecretKeySpec newKey = new SecretKeySpec(key.getBytes(\"UTF-8\"), \"AES\");\n             Cipher cipher = null;\n        cipher = Cipher.getInstance(\"AES/CBC/PKCS5Padding\");\n        cipher.init(Cipher.ENCRYPT_MODE, newKey, ivSpec);\n\n        return Base64.encodeToString(cipher.doFinal(textBytes), 0);\n    }\n\n    public static String AES_Decode(String str, String key) throws java.io.UnsupportedEncodingException, NoSuchAlgorithmException, NoSuchPaddingException, InvalidKeyException, InvalidAlgorithmParameterException, IllegalBlockSizeException, BadPaddingException {\n\n        byte[] textBytes =Base64.decode(str,0);\n        //byte[] textBytes = str.getBytes(\"UTF-8\");\n        AlgorithmParameterSpec ivSpec = new IvParameterSpec(ivBytes);\n        SecretKeySpec newKey = new SecretKeySpec(key.getBytes(\"UTF-8\"), \"AES\");\n        Cipher cipher = Cipher.getInstance(\"AES/CBC/PKCS5Padding\");\n        cipher.init(Cipher.DECRYPT_MODE, newKey, ivSpec);\n        return new String(cipher.doFinal(textBytes), \"UTF-8\");\n    }\n", "idx": 2465}
{"project": "cipher", "commit_id": "Snippet31771658_13840.java", "target": 1, "func": "Cipher cipher=Cipher.getInstance(\"RSA/ECB/NoPadding\");\ncipher.init(Cipher.ENCRYPT_MODE,publicServerKey);\nbyte[] parametersCipher = cipher.doFinal(urlParameters.getBytes(\"UTF-8\"));\nString encoded=new String(encoder.encode(parametersCipher)); //encoder= base64 encoder \nencoded=encoded.replace(\"+\", \"-\");\nencoded=encoded.replace(\"/\", \"_\");\n", "idx": 2543}
{"project": "cipher", "commit_id": "Snippet38407929_20342.java", "target": 0, "func": "import javax.crypto.Cipher;\nimport javax.crypto.spec.SecretKeySpec;\nimport sun.misc.BASE64Decoder;\nimport sun.misc.BASE64Encoder;\n\npublic class BlowfishTest {\n\n    public static void main(String[] args) throws Exception {\n        encrypt(\"1234567\");\n        decrypt(\"In6uDpDqt1g=\");\n    }\n\n    private static void encrypt(String password) throws Exception {\n        byte[] keyData = (\"ABC\").getBytes();\n        SecretKeySpec secretKeySpec = new SecretKeySpec(keyData, \"Blowfish\");\n        Cipher cipher = Cipher.getInstance(\"Blowfish\");\n        cipher.init(Cipher.ENCRYPT_MODE, secretKeySpec);\n        byte[] hasil = cipher.doFinal(password.getBytes());\n        System.out.println(new BASE64Encoder().encode(hasil));\n    }\n\n    private static void decrypt(String string) throws Exception {\n        byte[] keyData = (\"ABC\").getBytes();\n        SecretKeySpec secretKeySpec = new SecretKeySpec(keyData, \"Blowfish\");\n        Cipher cipher = Cipher.getInstance(\"blowfish/ecb/nopadding\");\n        cipher.init(Cipher.DECRYPT_MODE, secretKeySpec);\n        byte[] hasil = cipher.doFinal(new BASE64Decoder().decodeBuffer(string));\n        System.out.println(new String(hasil));\n    }\n}\n", "idx": 1919}
{"project": "cipher", "commit_id": "Snippet28015194_10152.java", "target": 1, "func": " static void encrypt(String filename) throws IOException, NoSuchAlgorithmException,\n        NoSuchPaddingException, InvalidKeyException {\n\n    // Here you read the cleartext.\n    File extStore = Environment.getExternalStorageDirectory();\n    startTime = System.currentTimeMillis();\n    Log.i(\"Encryption Started\",extStore + \"/5mbtest/\"+filename);\n    FileInputStream fis = new FileInputStream(extStore + \"/5mbtest/\"+filename);\n    // This stream write the encrypted text. This stream will be wrapped by\n    // another stream.\n\n\n\n    FileOutputStream fos = new FileOutputStream(extStore + \"/5mbtest/\"+filename+\".aes\", false);\n\n    // Length is 16 byte\n    SecretKeySpec sks = new SecretKeySpec(\"MyDifficultPassw\".getBytes(),\n            \"AES\");\n    // Create cipher\n    Cipher cipher = Cipher.getInstance(\"AES/CBC/PKCS7Padding\");\n    cipher.init(Cipher.ENCRYPT_MODE, sks);\n    // Wrap the output stream\n    CipherOutputStream cos = new CipherOutputStream(fos, cipher);\n    // Write bytes\n    int b;\n    byte[] d = new byte[8];\n    while ((b = fis.read(d)) != -1) {\n        cos.write(d, 0, b);\n    }\n    // Flush and close streams.\n    cos.flush();\n    cos.close();\n    fis.close();\n    stopTime = System.currentTimeMillis();\n    Log.i(\"Encryption Ended\",extStore + \"/5mbtest/\"+filename+\".aes\");\n    Log.i(\"Time Elapsed\", ((stopTime - startTime)/1000.0)+\"\");\n}\n\nstatic void decrypt(String filename) throws IOException, NoSuchAlgorithmException,\n        NoSuchPaddingException, InvalidKeyException {\n    File extStore = Environment.getExternalStorageDirectory();\n    Log.i(\"Decryption Started\",extStore + \"/5mbtest/\"+filename+\".aes\");\n    FileInputStream fis = new FileInputStream(extStore + \"/5mbtest/\"+filename+\".aes\");\n\n    FileOutputStream fos = new FileOutputStream(extStore + \"/5mbtest/\"+\"decrypted\"+filename,false);\n    SecretKeySpec sks = new SecretKeySpec(\"MyDifficultPassw\".getBytes(),\n            \"AES\");\n    // Create cipher\n    Cipher cipher = Cipher.getInstance(\"AES/CBC/PKCS7Padding\");\n    cipher.init(Cipher.DECRYPT_MODE, sks);\n    startTime = System.currentTimeMillis();\n    CipherInputStream cis = new CipherInputStream(fis, cipher);\n    int b;\n    byte[] d = new byte[8];\n    while ((b = cis.read(d)) != -1) {\n        fos.write(d, 0, b);\n    }\n\n    stopTime = System.currentTimeMillis();\n\n    Log.i(\"Decryption Ended\",extStore + \"/5mbtest/\"+\"decrypted\"+filename);\n    Log.i(\"Time Elapsed\", ((stopTime - startTime)/1000.0)+\"\");\n\n    fos.flush();\n    fos.close();\n    cis.close();\n}\n", "idx": 2529}
{"project": "cipher", "commit_id": "Snippet6094708_31936.java", "target": 1, "func": "Cipher cipher = Cipher.getInstance(\"RSA/ECB/NoPadding\");\n", "idx": 2694}
{"project": "cipher", "commit_id": "Snippet27854473_10005.java", "target": 1, "func": "private final String characterEncoding = \"UTF-8\";\nprivate final String cipherTransformation = \"AES/CBC/PKCS5Padding\";\nprivate final String aesEncryptionAlgorithm = \"AES\";\nprivate final String key=\"83jdkey3jdcmQNAieNanAN==\";\nprivate final String keyPass=\"testhello\";\nprivate final String NAMESPACE = \"http://www.hello.com/\";\nprivate final String URL = \"http://hello/secure.asmx\";\n\nboolean flag = false;\n\npublic byte[] decrypt(byte[] cipherText, byte[] key, byte [] initialVector) throws NoSuchAlgorithmException, NoSuchPaddingException, InvalidKeyException, InvalidAlgorithmParameterException, IllegalBlockSizeException, BadPaddingException, IOException\n{\n    Cipher cipher = Cipher.getInstance(cipherTransformation);\n    SecretKeySpec secretKeySpecy = new SecretKeySpec(key, aesEncryptionAlgorithm);\n    IvParameterSpec ivParameterSpec = new IvParameterSpec(initialVector);\n    cipher.init(Cipher.DECRYPT_MODE, secretKeySpecy, ivParameterSpec);\n    cipherText = cipher.doFinal(cipherText);\n    return cipherText;\n}\n\npublic byte[] encrypt(byte[] plainText, byte[] key, byte [] initialVector) throws NoSuchAlgorithmException, NoSuchPaddingException, InvalidKeyException, InvalidAlgorithmParameterException, IllegalBlockSizeException, BadPaddingException\n{\n    Cipher cipher = Cipher.getInstance(cipherTransformation);\n    SecretKeySpec secretKeySpec = new SecretKeySpec(key, aesEncryptionAlgorithm);\n    IvParameterSpec ivParameterSpec = new IvParameterSpec(initialVector);\n    cipher.init(Cipher.ENCRYPT_MODE, secretKeySpec, ivParameterSpec);\n    plainText = cipher.doFinal(plainText);\n    return plainText;\n}\n\nprivate byte[] getKeyBytes(String key) throws UnsupportedEncodingException\n{\n    byte[] keyBytes= new byte[16];\n    byte[] parameterKeyBytes= key.getBytes(characterEncoding);\n    System.arraycopy(parameterKeyBytes, 0, keyBytes, 0, Math.min(parameterKeyBytes.length, keyBytes.length));\n    return keyBytes;\n}\n\npublic String encrypt(String plainText) throws UnsupportedEncodingException, InvalidKeyException, NoSuchAlgorithmException, NoSuchPaddingException, InvalidAlgorithmParameterException, IllegalBlockSizeException, BadPaddingException\n{\n    byte[] plainTextbytes = plainText.getBytes(characterEncoding);\n    byte[] keyBytes = getKeyBytes(key);\n    return Base64.encodeToString(encrypt(plainTextbytes,keyBytes, keyBytes), Base64.DEFAULT);\n}\n\npublic String decrypt(String encryptedText) throws KeyException, GeneralSecurityException, GeneralSecurityException, InvalidAlgorithmParameterException, IllegalBlockSizeException, BadPaddingException, IOException\n{\n    byte[] cipheredBytes = Base64.decode(encryptedText, Base64.DEFAULT);\n    byte[] keyBytes = getKeyBytes(key);\n    return new String(decrypt(cipheredBytes, keyBytes, keyBytes), characterEncoding);\n}\n", "idx": 2673}
{"project": "cipher", "commit_id": "Snippet2956647_30535.java", "target": 1, "func": "public byte[] rsaEncrypt(byte[] data) {\n  PublicKey pubKey = readKeyFromFile(\"/public.key\");\n  Cipher cipher = Cipher.getInstance(\"RSA\");\n  cipher.init(Cipher.ENCRYPT_MODE, pubKey);\n  byte[] cipherData = cipher.doFinal(src);\n  return cipherData;\n}\n", "idx": 2353}
{"project": "cipher", "commit_id": "Snippet29053269_11125.java", "target": 0, "func": "Protected String ScrambledPic(String ImageNow, String key)\n{\ntry{  \n\n        File ImageOld = new File(Environment.getExternalStorageDirectory(), ImageNow);\n        FileInputStream file = new FileInputStream(ImageOld);       \n        Bitmap bm=null;\n        ByteArrayOutputStream bytes = new ByteArrayOutputStream();\n        bm.compress(Bitmap.CompressFormat.JPEG, 100, bytes);\n        File NewPhoto = new File(Environment.getExternalStorageDirectory()\n               + File.separator + \"picEnc.jpg\");\n        NewPhoto.createNewFile();\n        FileOutputStream outStream = new FileOutputStream(NewPhoto);\n        byte k[]= key.getBytes();\n        SecretKeySpec KEYY=new SecretKeySpec(k, \"DES\");\n        Cipher enc = Cipher.getInstance(\"DES\");\n        enc.init(Cipher.ENCRYPT_MODE, KEYY);\n        CipherOutputStream cos = new CipherOutputStream(outStream,enc);\n        byte[] buffer = new byte[1024];\n        int read;\n        while((read=file.read(buffer))!=-1){\n            cos.write(buffer, 0, read);\n        }\n        file.close();\n        outStream.flush();\n        cos.close();\n        Toast.makeText(getBaseContext(), \"Photo Encrypted\", Toast.LENGTH_LONG).show();\n        NewImageUri = Uri.fromFile(NewPhoto);\n        ImageView scrambled = (ImageView)findViewById(R.id.scrambled);\n\n        return NewImageUri.toString();\n\n    }\n\ncatch(FileNotFoundException e) {\nToast.makeText(getBaseContext(), \"File Not Found\", Toast.LENGTH_LONG).show();\nreturn null;\n}\n    catch (IOException e){\n        Toast.makeText(getBaseContext(), \"IOException\", Toast.LENGTH_LONG).show();\n        return ImageNow;\n    }\n    catch (NoSuchPaddingException e){\n        Toast.makeText(getBaseContext(), \"Padding Error\", Toast.LENGTH_LONG).show();\n        return ImageNow;\n    }\n    catch (NoSuchAlgorithmException e){\n        Toast.makeText(getBaseContext(), \"No Such Algorithm\", Toast.LENGTH_LONG).show();\n        return ImageNow;\n    }\n    catch (InvalidKeyException e){\n        Toast.makeText(getBaseContext(), \"Invalid Key\", Toast.LENGTH_LONG).show();\n        return ImageNow;\n    }\n}\n", "idx": 2238}
{"project": "cipher", "commit_id": "Snippet34502705_16500.java", "target": 1, "func": "package test;\n\nimport java.security.spec.KeySpec;\n\nimport javax.crypto.Cipher;\nimport javax.crypto.SecretKey;\nimport javax.crypto.SecretKeyFactory;\nimport javax.crypto.spec.IvParameterSpec;\nimport javax.crypto.spec.PBEKeySpec;\nimport javax.crypto.spec.SecretKeySpec;\nimport javax.xml.bind.DatatypeConverter;\n\npublic class Test {\n\n    public static final String PASSWORD = \"97DE:4F76\";\n\n    public static String encryptString(String clearText, String password) {\n        return \"\";\n    }\n\n    // echo U2FsdGVkX18PnO/NLSxJ1pg6OKoLyZApMz7aBRfKhJc= | openssl enc -d -a -aes-256-cbc -md sha256 -pass pass:97DE:4F76\n    //\n    // see https://stackoverflow.com/a/992413, https://stackoverflow.com/a/15595200,\n    // https://stackoverflow.com/a/22445878, https://stackoverflow.com/a/11786924\n    public static String decryptString(String cypherText, String password) {\n        byte[] dataBase64 = DatatypeConverter.parseBase64Binary(cypherText);\n        byte[] salt = {\n                (byte)0x0, (byte)0x0, (byte)0x0, (byte)0x0,\n                (byte)0x0, (byte)0x0, (byte)0x0, (byte)0x0\n        };\n\n        try {\n            // generate the key\n            SecretKeyFactory factory = SecretKeyFactory.getInstance(\"PBKDF2WithHmacSHA256\"); // \"PBKDF2WithHmacSHA1\"\n            KeySpec spec = new PBEKeySpec(password.toCharArray(), salt, 65536, 256);\n            SecretKey tmp = factory.generateSecret(spec);\n            SecretKey secret = new SecretKeySpec(tmp.getEncoded(), \"AES\");\n\n            // decrypt the message\n            Cipher cipher = Cipher.getInstance(\"AES/CBC/PKCS5Padding\");\n            byte[] iv = cipher.getParameters().getParameterSpec(IvParameterSpec.class).getIV();\n            cipher.init(Cipher.DECRYPT_MODE, secret, new IvParameterSpec(iv));\n\n            byte[] decrypted = cipher.doFinal(dataBase64);\n            String answer = new String(decrypted, \"UTF-8\");\n            return answer;\n\n        } catch (Exception ex) {\n            ex.printStackTrace();\n        }\n        return \"\";\n    }\n\n    public static void main(String[] args) {\n        System.out.println(decryptString(\"U2FsdGVkX18PnO/NLSxJ1pg6OKoLyZApMz7aBRfKhJc=\", PASSWORD));\n    }\n}\n", "idx": 2686}
{"project": "cipher", "commit_id": "Snippet43693311_25827.java", "target": 1, "func": "public byte[] RSAEncrypt(final String plain) throws NoSuchAlgorithmException, NoSuchPaddingException,\n        InvalidKeyException, IllegalBlockSizeException, BadPaddingException {\n    kpg = KeyPairGenerator.getInstance(\"RSA\");\n    kpg.initialize(1024);\n    kp = kpg.genKeyPair();\n    publicKey = kp.getPublic();\n    privateKey = kp.getPrivate();\n\n    cipher = Cipher.getInstance(\"RSA\");\n    cipher.init(Cipher.ENCRYPT_MODE, publicKey);\n    encryptedBytes = cipher.doFinal(plain.getBytes());\n    System.out.println(\"EEncrypted?????\" + org.apache.commons.codec.binary.Hex.encodeHexString(encryptedBytes));\n    return encryptedBytes;\n}\n\npublic String RSADecrypt(final byte[] encryptedBytes) throws NoSuchAlgorithmException, NoSuchPaddingException,\n        InvalidKeyException, IllegalBlockSizeException, BadPaddingException {\n\n    cipher1 = Cipher.getInstance(\"RSA\");\n    cipher1.init(Cipher.DECRYPT_MODE, privateKey);\n    decryptedBytes = cipher1.doFinal(encryptedBytes);\n    decrypted = new String(decryptedBytes);\n    System.out.println(\"DDecrypted?????\" + decrypted);\n    return decrypted;\n}\n", "idx": 2625}
{"project": "cipher", "commit_id": "Snippet18871770_1781.java", "target": 1, "func": "private static byte[] doThis(String message) {\n    byte[] messageCrypte = null;\n       try {\n        // Certificate Input Stream\n        // LA SSL Certificate to be passed.\n        InputStream inStream = new FileInputStream(certificate);\n\n        // X509Certificate created\n        CertificateFactory cf = CertificateFactory.getInstance(\"X.509\");\n        X509Certificate cert = (X509Certificate) cf.generateCertificate(inStream);\n        inStream.close();\n\n        // Getting Public key using Certficate\n        PublicKey rsaPublicKey = (PublicKey) cert.getPublicKey();\n\n        Cipher encryptCipher = Cipher.getInstance(\"RSA/ECB/PKCS1Padding\", \"SunJCE\");\n        encryptCipher.init(Cipher.ENCRYPT_MODE, rsaPublicKey);\n\n        byte[] messageACrypter = message.getBytes();\n        // Encrypted String\n        messageCrypte = encryptCipher.doFinal(messageACrypter);\n       } catch (Exception e) {\n        // TODO: Exception Handling\n        e.printStackTrace();\n       }\n    return messageCrypte;\n}\n", "idx": 2431}
{"project": "cipher", "commit_id": "Snippet34211780_16230.java", "target": 1, "func": "public class MainActivity extends Activity\n{\n    static\n    {\n        Security.insertProviderAt(new org.spongycastle.jce.provider.BouncyCastleProvider(), 1);\n        Security.removeProvider(\"BC\");\n    }\n\n    @Override\n    protected void onCreate(Bundle savedInstanceState)\n    {\n        try\n        {\n          //this returns provider = \"AndroidKeyStoreBCWorkaround version 1.0\"\n          javax.crypto.Cipher cipher = javax.crypto.Cipher.getInstance(\"AES/CTR/NoPadding\");\n          //this works\n          // cipher = javax.crypto.Cipher.getInstance(\"AES/CTR/NoPadding\", \"SC\");\n        }\n        catch(Exception e)\n        {\n        }\n    }\n}\n", "idx": 2570}
{"project": "cipher", "commit_id": "Snippet2784772_30425.java", "target": 0, "func": "    private static byte[] raw = {-31,   17,   7,  -34,  59, -61, -60,  -16, \n                              26,   87, -35,  114,   0, -53,  99, -116, \n                             -82, -122,  68,   47,  -3, -17, -21,  -82, \n                             -50,  126, 119, -106, -119, -5, 109,   98};\n    private static SecretKeySpec skeySpec;\n    private static Cipher ecipher;\n    private static Cipher dcipher;\n\n    static {\n        try {\n            skeySpec = new SecretKeySpec(raw, \"AES\");\n            // Instantiate the cipher\n            ecipher = Cipher.getInstance(\"AES\");\n            dcipher = Cipher.getInstance(\"AES\");\n            ecipher.init(Cipher.ENCRYPT_MODE, skeySpec);\n            dcipher.init(Cipher.DECRYPT_MODE, skeySpec);\n        } catch (NoSuchAlgorithmException e) {\n            throw new UnhandledException(\"No existe el algoritmo deseado\", e);\n        } catch (NoSuchPaddingException e) {\n            throw new UnhandledException(\"No existe el padding deseado\", e);\n        } catch (InvalidKeyException e) {\n            throw new UnhandledException(\"Clave invalida\", e);\n        }\n    }\n", "idx": 2008}
{"project": "cipher", "commit_id": "Snippet10986930_35227.java", "target": 0, "func": "public String Decrypt(String strText)\n{\n    try\n    {\n        // Text to decrypt\n        byte[] test = strText.getBytes();\n\n        //bytKey is the same key as Python app\n        SecretKeySpec objKey = new SecretKeySpec(bytKey, \"AES\");\n        Cipher objCipher = Cipher.getInstance(\"AES/ECB/PKCS7Padding\", \"BC\");\n        objCipher.init(Cipher.DECRYPT_MODE, objKey);\n\n        // Here I got an exception >>\n        byte[] bytValue = objCipher.doFinal(test);\n\n        return new String(bytValue);\n    }\n    catch (Exception exc)\n    {\n        exc.printStackTrace();\n    }\n\n    return \"\";\n\n}\n", "idx": 1961}
{"project": "cipher", "commit_id": "Snippet19623367_2340.java", "target": 1, "func": "//Create a Cipher object\nCipher rsaCipher = Cipher.getInstance(\"RSA/ECB/NoPadding\");\n", "idx": 2387}
{"project": "cipher", "commit_id": "Snippet20362873_2999.java", "target": 1, "func": "private String AESDecrypt(byte[] keyBytes, byte[] IVBytes, byte[] input)\n            throws Exception {\n        Cipher cipher = Cipher.getInstance(\"AES/CBC/PKCS7Padding\");\n        cipher.init(Cipher.DECRYPT_MODE, new SecretKeySpec(keyBytes, \"AES\"),\n                new IvParameterSpec(IVBytes));\n\n        // decrypt\n        byte[] decrptedBytes = new byte[input.length];\n        cipher.update(input, 0, input.length, decrptedBytes, 0);\n        cipher.doFinal(decrptedBytes, 0);\n\n\n        Log.i(\"demo\", \"Unencrypted MessageBytes: \" + showByteArray(decrptedBytes));\n\n        // find length of value\n        int end = decrptedBytes.length;\n        for (int i = 0; i < decrptedBytes.length; i++) {\n            // Log.i(\"demo\", \"value: \" + decrptedBytes[i]);\n            if (decrptedBytes[i] == 0) {\n                end = i;\n                break;\n            }\n        }\n        // Log.i(\"demo\", \"length: \" + end);\n\n        // make string in ascii\n        byte[] value = Arrays.copyOf(decrptedBytes, end);\n        String message = new String(value, \"US-ASCII\");\n\n        return message;\n    }\n", "idx": 2376}
{"project": "cipher", "commit_id": "Snippet44048908_26126.java", "target": 0, "func": "  XmlPullParser getXpp(InputStream is, String keyString){\n    DESKeySpec ks = new DESKeySpec(keyString.getBytes(\"ASCII\"));\n    SecretKeyFactory skf = SecretKeyFactory.getInstance(\"DES\");\n    SecretKey key = skf.generateSecret(ks);\n\n    Cipher c = Cipher.getInstance(\"DES/CBC/PKCS7Padding\");\n    c.init(Cipher.DECRYPT_MODE, key, new IvParameterSpec(keyString.getBytes(\"ASCII\")));\n    CipherInputStream cis = new CipherInputStream(is, c);\n\n    XmlPullParserFactory factory = XmlPullParserFactory.newInstance();\n    factory.setNamespaceAware(true);\n    XmlPullParser xpp = factory.newPullParser();\n    xpp.setInput(cis, \"UTF-8\");\n    return xpp; \n}\n", "idx": 2221}
{"project": "cipher", "commit_id": "Snippet18265503_1309.java", "target": 1, "func": "public  String decrypt(byte[] cipherText, SecretKey key, byte [] initialVector) throws Exception {\n    Cipher cipher = Cipher.getInstance(\"AES/CBC/PKCS7Padding\");\n    IvParameterSpec ivParameterSpec = new IvParameterSpec(initialVector);\n    cipher.init(Cipher.DECRYPT_MODE, key, ivParameterSpec);\n    cipherText = cipher.doFinal(cipherText);\n\n    return new String(cipherText, \"UTF-8\");\n}\n", "idx": 2753}
{"project": "cipher", "commit_id": "Snippet20121076_2785.java", "target": 0, "func": "    public class TripleDesTest {\n\nprivate KeySpec keySpec;\nprivate SecretKey key;\nprivate IvParameterSpec iv;\n\npublic TripleDesTest() {\n    String keyString = \"THE_KEY\";\n    String ivString = \"THE_IV\";\n\n    try {\n        final MessageDigest md = MessageDigest.getInstance(\"md5\");\n        final byte[] digestOfPassword = md.digest(Base64.decodeBase64(keyString.getBytes(\"UTF-8\")));            \n        final byte[] keyBytes = Arrays.copyOf(digestOfPassword, 24);\n        for (int j = 0, k = 16; j < 8;) {\n            keyBytes[k++] = keyBytes[j++];\n        }\n\n        keySpec = new DESedeKeySpec(keyBytes);\n\n        key = SecretKeyFactory.getInstance(\"DESede\").generateSecret(keySpec);\n\n        iv = new IvParameterSpec(ivString.getBytes(\"UTF-8\"));\n    } catch (Exception e) {\n        e.printStackTrace();\n    }\n\n}\n\n\npublic String decrypt(String value) {\n\n    try {\n        Cipher dcipher = Cipher.getInstance(\"DESede/CBC/PKCS5Padding\", \"SunJCE\");\n        dcipher.init(Cipher.DECRYPT_MODE, key, iv);\n\n        if (value == null)\n            return null;\n\n        // Decode base64 to get bytes\n        byte[] dec = Base64.decodeBase64(value.getBytes(\"UTF-8\"));\n\n        // Decrypt\n        byte[] utf8 = dcipher.doFinal(dec);\n\n        // Decode using UTF-8\n        return new String(utf8, \"UTF-8\");\n    } catch (Exception e) {\n        e.printStackTrace();\n    }\n    return null;\n\n}\n    }\n", "idx": 2096}
{"project": "cipher", "commit_id": "Snippet31474283_13630.java", "target": 1, "func": "public void encrypt(String inputFile){\n    FileInputStream fis = new FileInputStream(inputFile);\n    // Save file: inputFile.enc\n    FileOutputStream fos = new FileOutputStream(inputFile + \".enc\");\n\n    Cipher cipher = Cipher.getInstance(\"AES/CBC/PKCS5Padding\");\n    cipher.init(Cipher.ENCRYPT_MODE, secret);\n\n    AlgorithmParameters params = cipher.getParameters();\n    // Gen Initialization Vector\n    iv = (byte[]) ((IvParameterSpec) params\n            .getParameterSpec(IvParameterSpec.class)).getIV();\n    // read from file (plaint text)  -----> save with .enc\n    int readByte;\n    byte[] buffer = new byte[1024];\n    while ((readByte = fis.read(buffer)) != -1) {\n        fos.write(cipher.doFinal(buffer), 0, readByte);\n    }\n    fis.close();\n    fos.flush();\n    fos.close();\n}\n", "idx": 2434}
{"project": "cipher", "commit_id": "Snippet35203086_17129.java", "target": 0, "func": "import javax.crypto.Cipher;\nimport javax.crypto.spec.SecretKeySpec;\nimport org.apache.commons.codec.binary.Base64;\nimport sun.misc.BASE64Encoder;\n\n\npublic class EncryptAES {\n\n    private static String toHexString(byte[] data) {        \n        StringBuffer buf = new StringBuffer();\n        for (int i = 0; i < data.length; ++i) {\n            String s = Integer.toHexString(data[i] & 0XFF);\n            buf.append((s.length() == 1) ? (\"0\" + s) : s);\n        }\n        return buf.toString();\n    }\n\n    public static String encrypt(String input, String key) {\n        byte[] crypted = null;\n        try {\n            SecretKeySpec skey = new SecretKeySpec(key.getBytes(), \"AES\");\n            Cipher cipher = Cipher.getInstance(\"AES/ECB/PKCS5Padding\");\n            cipher.init(Cipher.ENCRYPT_MODE, skey);\n            crypted = cipher.doFinal(input.getBytes());\n            final String encryptedString = toHexString(Base64.encodeBase64(crypted));\n            return encryptedString;\n        } catch (Exception e) {\n            System.out.println(e.toString());\n        }\n        return new String(new BASE64Encoder().encode(crypted));\n    }\n\n    public static void main(String[] args) {\n        String key = args[0];\n        String plaintext = args[1];\n        System.out.println(\"KEY = \" + key);\n        System.out.println(\"PLAINTEXT = \" + plaintext);\n        System.out.println(\"CIPHER = \" + EncryptAES.encrypt(plaintext, key));\n    }\n}\n", "idx": 2184}
{"project": "cipher", "commit_id": "Snippet22007780_4433.java", "target": 0, "func": "BufferedReader reader = new BufferedReader(new FileReader(keylocation.getFile()));\nString line = null;\nStringBuilder stringBuilder = new StringBuilder();\nwhile ((line = reader.readLine()) != null) {\n  stringBuilder.append(line);\n}\nString secretKey = stringBuilder.toString();\nSecretKeySpec key = new SecretKeySpec(secretKey.getBytes(\"UTF-8\"), \"AES\");\n\nCipher cipher = Cipher.getInstance(\"AES/ECB/PKCS5Padding\");\ncipher.init(Cipher.ENCRYPT_MODE, key);\nencryptedString = (Base64.encodeBase64String(cipher.doFinal(strToEncrypt.getBytes(\"UTF-8\"))));\n", "idx": 2049}
{"project": "cipher", "commit_id": "Snippet17854366_947.java", "target": 1, "func": "    private  String Encrypt(String text, String key)\n        throws Exception {\n        Cipher cipher = Cipher.getInstance(\"AES/CBC/PKCS5Padding\");\n        byte[] keyBytes= new byte[16];\n        byte[] b= key.getBytes(\"UTF-8\");\n        int len= b.length;\n        if (len > keyBytes.length) len = keyBytes.length;\n        System.arraycopy(b, 0, keyBytes, 0, len);\n        SecretKeySpec keySpec = new SecretKeySpec(keyBytes, \"AES\");\n        IvParameterSpec ivSpec = new IvParameterSpec(keyBytes);\n        cipher.init(Cipher.ENCRYPT_MODE,keySpec,ivSpec);\n\n        byte[] results = cipher.doFinal(text.getBytes(\"UTF-8\"));\n        Log.v(\"GET Result from  final:\",results.toString());\n        strMobile_No = Base64.encodeToString(results, 1);\n\n        return strMobile_No;\n\n        }\n", "idx": 2420}
{"project": "cipher", "commit_id": "Snippet24139802_6444.java", "target": 1, "func": "public class Rsa {\n    public static void main(String[] args) throws Throwable {\n    //RSA init\n    KeyPairGenerator keyGen = KeyPairGenerator.getInstance(\"RSA\");\n    keyGen.initialize(512);\n    KeyPair keyPair = keyGen.generateKeyPair();\n    PrivateKey privateKey = keyPair.getPrivate();\n    PublicKey publicKey = keyPair.getPublic();\n\n    //AES init\n    KeyGenerator keyGen2 = KeyGenerator.getInstance(\"AES\");\n    keyGen2.init(192);\n    SecretKey secretKey = keyGen2.generateKey();\n    byte[] encoded = secretKey.getEncoded(); \n    System.out.println(\"Original  AES key:\"+ encoded);\n\n    //Encrypting AES with RSA\n    Cipher cipher  = Cipher.getInstance(\"RSA\");\n    cipher.init(Cipher.ENCRYPT_MODE, publicKey);\n    byte[] encryptedMsg = cipher.doFinal(encoded);\n    System.out.println(\"Encrypted AES Key with RSA:\" + encryptedMsg);\n\n    //Decrypting AES with RSA\n    cipher.init(Cipher.DECRYPT_MODE, privateKey);\n    byte[] decryptedMsg = cipher.doFinal(encryptedMsg);\n    System.out.println(\"Decrypted AES Key:\" + decryptedMsg);\n\n}   \n", "idx": 2745}
{"project": "cipher", "commit_id": "Snippet28174104_10352.java", "target": 1, "func": "public static void main(String[] args) throws Exception {\n\n    Cipher aes = Cipher.getInstance(\"AES/CBC/PKCS5PADDING\");\n    SecretKeySpec key = new SecretKeySpec(\"YELLOW SUBMARINE\".getBytes(), \"AES\");\n    IvParameterSpec iv = new IvParameterSpec(new byte[16]);\n\n    aes.init(Cipher.DECRYPT_MODE, key, iv);\n\n    byte[] cipherText = DatatypeConverter.parseHexBinary(\"60FA36707E45F499DBA0F25B922301A57192FEBE51B66D25BBFCC348138FD3F7\");\n\n    System.out.println(DatatypeConverter.printHexBinary(aes.doFinal(cipherText)));\n    System.out.println(DatatypeConverter.printHexBinary(aes.doFinal(cipherText)));\n}\n", "idx": 2497}
{"project": "cipher", "commit_id": "Snippet22981017_5380.java", "target": 1, "func": "package Main;\n\n\nimport org.bouncycastle.util.encoders.Base64;\n\nimport javax.crypto.Cipher;\nimport javax.xml.bind.DatatypeConverter;\nimport java.io.*;\nimport java.net.Socket;\nimport java.net.UnknownHostException;\nimport java.security.GeneralSecurityException;\nimport java.security.KeyFactory;\nimport java.security.PublicKey;\nimport java.security.Security;\nimport java.security.spec.X509EncodedKeySpec;\n\npublic class EncDecRSA {\n    public static byte[] pemToDer(String pemKey) throws GeneralSecurityException {\n        String[] parts = pemKey.split(\"-----\");\n        return DatatypeConverter.parseBase64Binary(parts[parts.length / 2]);\n    }\n\n    public static PublicKey derToPublicKey(byte[] asn1key) throws GeneralSecurityException {\n        X509EncodedKeySpec spec = new X509EncodedKeySpec(asn1key);\n        KeyFactory keyFactory = KeyFactory.getInstance(\"RSA\", \"BC\");\n        return keyFactory.generatePublic(spec);\n    }\n\n    public static byte[] encrypt(PublicKey publicKey, String text) throws GeneralSecurityException {\n        Cipher rsa = Cipher.getInstance(\"RSA/ECB/OAEPWithSHA1AndMGF1Padding\", \"BC\");//PKCS1-OAEP\n        rsa.init(Cipher.ENCRYPT_MODE, publicKey);\n        byte[] cipher =  rsa.doFinal(text.getBytes());\n        String s = new String(cipher);\n        System.out.print(s);\n//        return cipher;\n//        return Base64.encode(rsa.doFinal(text.getBytes()));\n        cipher = Base64.encode(cipher);\n        return cipher;\n\n    }\n\n    static String readFile(String path)\n            throws IOException\n    {\n        String line = null;\n        BufferedReader br = new BufferedReader(new FileReader(path));\n        try {\n            StringBuilder sb = new StringBuilder();\n            line = br.readLine();\n\n            while (line != null) {\n                sb.append(line);\n                sb.append(\"\\n\");\n                line = br.readLine();\n            }\n            return sb.toString();\n        } finally {\n            br.close();\n\n        }\n\n    }\n    public static void main(String[] args) throws IOException, GeneralSecurityException {\n        Security.addProvider(new org.bouncycastle.jce.provider.BouncyCastleProvider());\n\n        System.out.println(\"Working Directory = \" +\n                System.getProperty(\"user.dir\"));\n        String publicKey = readFile(\"key.public\");\n        byte[] pem = pemToDer(publicKey);\n        PublicKey myKey = derToPublicKey(pem);\n        String sendMessage = \"{'vid_hash': '917ef7e7be4a84e279b74a257953307f1cff4a2e3d221e363ead528c6b556edb', 'state': 'ballot_response', 'userInfo': {'ssn': '700-33-6870', 'pin': '1234', 'vid': '265jMeges'}}\";\n        byte[] encryptedDATA = encrypt(myKey, sendMessage);\n        Socket smtpSocket = null;\n        DataOutputStream os = null;\n        DataInputStream is = null;\n        try {\n            smtpSocket = new Socket(\"192.168.1.124\", 9999);\n            os = new DataOutputStream(smtpSocket.getOutputStream());\n            is = new DataInputStream(smtpSocket.getInputStream());\n        } catch (UnknownHostException e) {\n            System.err.println(\"Don't know about host: hostname\");\n        } catch (IOException e) {\n            System.err.println(\"Couldn't get I/O for the connection to: hostname\");\n        }\n\n        if (smtpSocket != null && os != null && is != null) {\n            try {\n                System.out.println(\"sending message\");\n                os.writeBytes(encryptedDATA+\"\\n\");\n                os.close();\n                is.close();\n                smtpSocket.close();\n            } catch (UnknownHostException e) {\n                System.err.println(\"Trying to connect to unknown host: \" + e);\n            } catch (IOException e) {\n                System.err.println(\"IOException:  \" + e);\n            }\n        }\n    }\n}\n", "idx": 2393}
{"project": "cipher", "commit_id": "Snippet27124931_9284.java", "target": 0, "func": "public final class CipherSpike2 {\n\n  private static final byte[] SECRET_KEY = new byte[]{1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16};\n\n  public static void main(String[] args)\n  throws NoSuchPaddingException, NoSuchAlgorithmException, InvalidKeyException, IOException {\n    encryptDecrypt(511);\n    encryptDecrypt(512);\n  }\n\n  private static void encryptDecrypt(int i)\n  throws NoSuchAlgorithmException, NoSuchPaddingException, InvalidKeyException, IOException {\n\n    byte[] clearText = generateClearText(i);\n    System.out.println(\"Clear text length: \" + clearText.length);\n\n    ByteArrayOutputStream bos = new ByteArrayOutputStream();\n    CipherOutputStream cos = new CipherOutputStream(bos, getCipher(Cipher.ENCRYPT_MODE));\n    cos.write(clearText);\n    cos.close();\n\n    final byte[] content = bos.toByteArray();\n    System.out.println(\"written bytes: \" + content.length);\n\n    CipherInputStream\n    inputStream =\n    new CipherInputStream(new ByteArrayInputStream(content), getCipher(Cipher.DECRYPT_MODE));\n\n    inputStream.read();\n    inputStream.close();\n }\n\n private static byte[] generateClearText(int size) {\n    return new byte[size];\n  }\n\n  private static Cipher getCipher(int encryptMode)\n  throws NoSuchAlgorithmException, NoSuchPaddingException, InvalidKeyException {\n    Cipher cipher = Cipher.getInstance(\"AES/ECB/PKCS5Padding\");\n    SecretKeySpec key = new SecretKeySpec(SECRET_KEY, \"AES\");\n    cipher.init(encryptMode, key);\n    return cipher;\n  }\n}\n", "idx": 1960}
{"project": "cipher", "commit_id": "Snippet33291207_15313.java", "target": 1, "func": "package nl.owlstead.stackoverflow;\n\nimport static java.nio.charset.StandardCharsets.US_ASCII;\n\nimport java.math.BigInteger;\nimport java.security.KeyFactory;\nimport java.security.KeyPairGenerator;\nimport java.security.Security;\nimport java.security.interfaces.ECPublicKey;\nimport java.security.spec.ECGenParameterSpec;\nimport java.security.spec.ECParameterSpec;\nimport java.security.spec.ECPoint;\nimport java.security.spec.ECPublicKeySpec;\n\nimport javax.crypto.Cipher;\n\nimport org.bouncycastle.jce.ECNamedCurveTable;\nimport org.bouncycastle.jce.provider.BouncyCastleProvider;\nimport org.bouncycastle.jce.spec.ECNamedCurveParameterSpec;\nimport org.bouncycastle.jce.spec.ECNamedCurveSpec;\nimport org.bouncycastle.util.encoders.Hex;\n\npublic class ECPublicKeyFactory {\n\n    public static void main(String[] args) throws Exception {\n\n        String name = \"secp256r1\";\n\n        Security.addProvider(new BouncyCastleProvider());\n\n        // === NOT PART OF THE CODE, JUST GETTING TEST VECTOR ===\n        KeyPairGenerator kpg = KeyPairGenerator.getInstance(\"EC\", \"BC\");\n        ECGenParameterSpec ecGenParameterSpec = new ECGenParameterSpec(name);\n        kpg.initialize(ecGenParameterSpec);\n        ECPublicKey key = (ECPublicKey) kpg.generateKeyPair().getPublic();\n        byte[] x = key.getW().getAffineX().toByteArray();\n        byte[] y = key.getW().getAffineY().toByteArray();\n\n        // === here the magic happens ===\n        KeyFactory eckf = KeyFactory.getInstance(\"EC\");\n        ECPoint point = new ECPoint(new BigInteger(1, x), new BigInteger(1, y));\n        ECNamedCurveParameterSpec parameterSpec = ECNamedCurveTable.getParameterSpec(name);\n        ECParameterSpec spec = new ECNamedCurveSpec(name, parameterSpec.getCurve(), parameterSpec.getG(), parameterSpec.getN(), parameterSpec.getH(), parameterSpec.getSeed());\n        ECPublicKey ecPublicKey = (ECPublicKey) eckf.generatePublic(new ECPublicKeySpec(point, spec));\n        System.out.println(ecPublicKey.getClass().getName());\n\n        // === test 123 ===\n        Cipher ecies = Cipher.getInstance(\"ECIESwithAES\", \"BC\");\n        ecies.init(Cipher.ENCRYPT_MODE, ecPublicKey);\n        byte[] ct = ecies.doFinal(\"owlstead\".getBytes(US_ASCII));\n        System.out.println(Hex.toHexString(ct));\n    }\n}\n", "idx": 2757}
{"project": "cipher", "commit_id": "Snippet43779197_25886.java", "target": 1, "func": " Cipher cipher = Cipher.getInstance(\"AES/CBC/PKCS7Padding\");\n", "idx": 2482}
{"project": "cipher", "commit_id": "Snippet42836844_24920.java", "target": 1, "func": "import javax.crypto.Cipher;\n\npublic abstract class Crypto {\n\n\n    private static final String CIPHER_ALGORITHM = \"AES/CTR/NoPadding\";\n    private String AesKeyString = \"ByWelFHCgFqivFZrWs89LQ==\";\n\n    private void setKey() throws NoSuchAlgorithmException{\n        byte[] keyBytes;\n        keyBytes = Base64.getDecoder().decode(AesKeyString);\n        aesKey = new SecretKeySpec(keyBytes, \"AES\");\n    }\n\n    protected byte[] execute(int mode, byte[] target, byte[] iv) \n            throws Exception{\n        Cipher cipher = Cipher.getInstance(CIPHER_ALGORITHM);\n        IvParameterSpec ivSpec = new IvParameterSpec(iv);\n        cipher.init(mode, aesKey, ivSpec);\n        return cipher.doFinal(target);\n    }\n\n}\n", "idx": 2403}
{"project": "cipher", "commit_id": "Snippet42767457_24812.java", "target": 0, "func": "public static void standardExceptionHandling(Exception exc, Logger alog) {\n    StringWriter sw = new StringWriter();\n    PrintWriter pw = new PrintWriter(sw);\n    exc.printStackTrace(pw);\n    alog.info(sw.toString()); /* Line 292 */\n}\n\n/**\n * Method that takes a key/value set, converts it into a standard web parameter string\n * and then encrypts the string.\n *\n * @param values the key value set\n * @return the encrypted string\n *\n */\npublic static String encrypt(Map<String, String> values) {\n    StringBuilder unencrypted = new StringBuilder();\n    boolean first = true;\n    for (Map.Entry<String, String> value : values.entrySet()) {\n        if (first) {\n            first = false;\n        } else {\n            unencrypted.append(\"&\");\n        }\n        unencrypted.append(value.getKey())\n                .append(\"=\")\n                .append(value.getValue());\n    }\n\n    try {\n        Cipher cipher = Cipher.getInstance(\"AES\");\n        Key aesKey = new SecretKeySpec(AES_KEY.getBytes(), \"AES\");\n        cipher.init(Cipher.ENCRYPT_MODE, aesKey);\n        byte[] encrypted = cipher.doFinal(unencrypted.toString().getBytes(\"UTF8\"));\n\n        String enc = new sun.misc.BASE64Encoder().encode(encrypted);\n        return enc;\n    } catch (Exception e) {\n        standardExceptionHandling(e, log);\n        return \"\";\n    }\n}\n\n/**\n * Method that takes an encrypted string containing a standard web parameter string\n * and converts it to a key/value set\n *\n * @param encrypted the encrypted string\n * @return the key value set\n */\npublic static Map<String, String> decrypt(String encrypted) {\n    String decrypted = \"\";\n    try {\n        Cipher cipher = Cipher.getInstance(\"AES\");\n        Key aesKey = new SecretKeySpec(AES_KEY.getBytes(), \"AES\");\n        cipher.init(Cipher.DECRYPT_MODE, aesKey);\n        byte[] dec = new sun.misc.BASE64Decoder().decodeBuffer(encrypted);\n        decrypted = new String(cipher.doFinal(dec), \"UTF8\");\n    } catch (Exception e) {\n        standardExceptionHandling(e, log);\n    }\n\n    Map<String, String> values = new HashMap<String, String>();\n    for (String pair : decrypted.split(\"&\")) {\n        String[] split_pair = pair.split(\"=\");\n        String key, value;\n        if (split_pair.length == 1) {\n            key = split_pair[0];\n            value = \"\";\n        } else if (split_pair.length == 2) {\n            key = split_pair[0];\n            value = split_pair[1];\n        } else if (split_pair.length > 2) {\n            log.debug(\"Error when decrypting string, parameter found with more than 2 parts (\" + pair + \")\");\n            continue;\n        } else {\n            // We should never reach this, as it is impossible to split a string into a 0 length array.\n            log.debug(\"The impossible happened, we split a String into a 0 length array (\" + pair + \")\");\n            continue;\n        }\n        // This is only reach when key and value have been initialised thank to the continue statements when we hit\n        // an error state.\n        values.put(key, value);\n    }\n    return values;\n}\n", "idx": 2132}
{"project": "cipher", "commit_id": "Snippet16513073_39451.java", "target": 1, "func": "SecretKeyFactory factory = SecretKeyFactory.getInstance(\"PBKDF2WithHmacSHA1\");\n// What is salt ??\nKeySpec spec = new PBEKeySpec(\"SOME_KEY\", salt, 65536, 256);\nSecretKey tmp = factory.generateSecret(spec);\nSecretKey secret = new SecretKeySpec(tmp.getEncoded(), \"AES\");\nCipher cipher = Cipher.getInstance(\"AES/CBC/PKCS5Padding\");\ncipher.init(Cipher.DECRYPT_MODE, secret, new IvParameterSpec(iv));\nString plaintext = new String(cipher.doFinal(ciphertext), \"UTF-8\");\nSystem.out.println(plaintext);\n", "idx": 2744}
{"project": "cipher", "commit_id": "Snippet46785447_28845.java", "target": 1, "func": "        Cipher cipher = Cipher.getInstance(\"RSA/NONE/PKCS1Padding\", \"BC\");\n        SecureRandom random = new SecureRandom();\n        KeyPairGenerator generator = KeyPairGenerator.getInstance(\"RSA\", \"BC\");\n        generator.initialize(2048, random);\n        KeyPair pair = generator.generateKeyPair();         \n        Key publicKey = pair.getPublic();\n        Key privateKey = pair.getPrivate();             \n        System.out.println(\"publicKey : \" + byteArrayToHexString(publicKey.getEncoded()));          \n        System.out.println(\"privateKey : \" + byteArrayToHexString(privateKey.getEncoded()));                    \n", "idx": 2480}
{"project": "cipher", "commit_id": "Snippet22671110_5068.java", "target": 1, "func": "import java.nio.charset.Charset;\nimport java.security.GeneralSecurityException;\n\nimport javax.crypto.Cipher;\nimport javax.crypto.spec.IvParameterSpec;\nimport javax.crypto.spec.SecretKeySpec;\n\npublic class EncryptionTest {\n\n  public static void main(String[] args) {\n    try {\n\n      String key = \"ThisIsASecretKey\";\n      byte[] ciphertext = encrypt(key, \"1234567890123456\");\n      System.out.println( new String(ciphertext));\n      System.out.println(\"decrypted value:\" + (decrypt(key, ciphertext)));\n\n    } catch (GeneralSecurityException e) {\n      e.printStackTrace();\n    }\n  }\n\n  public static byte[] encrypt(String key, String value)\n      throws GeneralSecurityException {\n\n    byte[] raw = key.getBytes(Charset.forName(\"US-ASCII\"));\n    if (raw.length != 16) {\n      throw new IllegalArgumentException(\"Invalid key size.\");\n    }\n\n    SecretKeySpec skeySpec = new SecretKeySpec(raw, \"AES\");\n    Cipher cipher = Cipher.getInstance(\"AES/CBC/PKCS5Padding\");\n    cipher.init(Cipher.ENCRYPT_MODE, skeySpec,\n        new IvParameterSpec(new byte[16]));\n    return cipher.doFinal(value.getBytes(Charset.forName(\"US-ASCII\")));\n  }\n\n  public static String decrypt(String key, byte[] encrypted)\n      throws GeneralSecurityException {\n\n    byte[] raw = key.getBytes(Charset.forName(\"US-ASCII\"));\n    if (raw.length != 16) {\n      throw new IllegalArgumentException(\"Invalid key size.\");\n    }\n    SecretKeySpec skeySpec = new SecretKeySpec(raw, \"AES\");\n\n    Cipher cipher = Cipher.getInstance(\"AES/CBC/PKCS5Padding\");\n    cipher.init(Cipher.DECRYPT_MODE, skeySpec,\n        new IvParameterSpec(new byte[16]));\n    byte[] original = cipher.doFinal(encrypted);\n\n    return new String(original, Charset.forName(\"US-ASCII\"));\n  }\n}\n", "idx": 2408}
{"project": "cipher", "commit_id": "Snippet11279903_35434.java", "target": 1, "func": "Cipher cipher = Cipher.getInstance(\"RSA/ECB/PKCS1Padding\");\n", "idx": 2605}
{"project": "cipher", "commit_id": "Snippet36560847_18408.java", "target": 1, "func": "Cipher.getInstance(\"RSA/ECB/OAEPWithSHA-256AndMGF1Padding\");", "idx": 2679}
{"project": "cipher", "commit_id": "Snippet42548283_24588.java", "target": 1, "func": "try {\n        String encryptKey = \"abc123\";\n        byte[] salt = new byte[]{0x49, 0x76, 0x61, 0x6e, 0x20, 0x4d, 0x65, 0x64, 0x76, 0x65, 0x64, 0x65, 0x76};\n        SecretKeyFactory factory = SecretKeyFactory.getInstance(\"PBKDF2WithHmacSHA1\");\n        KeySpec spec = new PBEKeySpec(encryptKey.toCharArray(), salt, 1024, 128);\n        SecretKey tmp = factory.generateSecret(spec);\n        SecretKeySpec secret = new SecretKeySpec(tmp.getEncoded(), \"AES\");\n        System.out.println(\"Key:\" + Base64.encodeToString(secret.getEncoded(), Base64.DEFAULT));\n\n\n        String cleartext = \"12345\";\n        Cipher cipher = Cipher.getInstance(\"AES/CBC/PKCS5Padding\");\n        cipher.init(Cipher.ENCRYPT_MODE, secret);\n        AlgorithmParameters params = cipher.getParameters();\n        byte[] iv = params.getParameterSpec(IvParameterSpec.class).getIV();\n        byte[] ciphertext = cipher.doFinal(cleartext.getBytes(\"UTF-8\"));\n        System.out.println(\"IV:\" + Base64.encodeToString(iv, Base64.DEFAULT));\n        System.out.println(\"Cipher text:\" + Base64.encodeToString(ciphertext, Base64.DEFAULT));;\n    } catch (NoSuchAlgorithmException e) {\n        e.printStackTrace();\n    } catch (InvalidKeySpecException e) {\n        e.printStackTrace();\n    } catch (NoSuchPaddingException e) {\n        e.printStackTrace();\n    } catch (InvalidKeyException e) {\n        e.printStackTrace();\n    } catch (InvalidParameterSpecException e) {\n        e.printStackTrace();\n    } catch (IllegalBlockSizeException e) {\n        e.printStackTrace();\n    } catch (BadPaddingException e) {\n        e.printStackTrace();\n    } catch (UnsupportedEncodingException e) {\n        e.printStackTrace();\n    }\n", "idx": 2373}
{"project": "cipher", "commit_id": "Snippet23070838_5446.java", "target": 0, "func": "public static PrivateKey readPrivateKeyFromFile(File file, String chaveSecreta) {\n    try {\n        SecureRandom r = new SecureRandom(chaveSecreta.getBytes());\n        KeyGenerator keyGen = KeyGenerator.getInstance(\"DES\");\n        keyGen.init(56, r);\n        Key key = keyGen.generateKey();\n\n        byte[] privateKeyBytes = decryptPKFile(file, key);\n\n        KeyFactory keyFactory = KeyFactory.getInstance(\"RSA\");\n        EncodedKeySpec privateKeySpec = new PKCS8EncodedKeySpec(privateKeyBytes);\n        PrivateKey privateKey = null;\n        try {\n            privateKey = keyFactory.generatePrivate(privateKeySpec);\n        } catch (InvalidKeySpecException e) {\n            JOptionPane.showMessageDialog(null, \"Erro 01, tente mais tarde\");\n        }\n        return privateKey;\n    } catch (NoSuchAlgorithmException e) {\n        JOptionPane.showMessageDialog(null, \"Erro 02, tente mais tarde\");\n    }\n    return null;\n}\n\npublic static byte[] decryptPKFile(File file, Key key){\n    try{\n        Cipher cipher = Cipher.getInstance(\"DES/ECB/PKCS5Padding\");\n        byte[] cipherText = readBytes(file);\n        cipher.init(Cipher.DECRYPT_MODE, key);\n        System.out.println(cipher);\n        System.out.println(cipherText);\n        byte[] text = cipher.doFinal(cipherText);\n        return text;\n    }catch(Exception e){\n        e.printStackTrace();\n        return null;\n    }\n}\n\npublic static byte[] readBytes(File file) {\n    try {\n        FileInputStream fs = new FileInputStream(file);\n        byte content[] = new byte[(int) file.length()];\n        fs.read(content);\n        return content;\n    } catch (FileNotFoundException e) {\n        System.out.println(\"Arquivo n\u00e3o encontrado!\");\n        e.printStackTrace();\n    } catch (IOException ioe) {\n        System.out.println(\"Erro ao ler arquivo!\");\n        ioe.printStackTrace();\n    }\n    return null;\n}\n", "idx": 2250}
{"project": "cipher", "commit_id": "Snippet37204839_19151.java", "target": 0, "func": "public class ata {\npublic static byte[] a(byte[] bArr, String str) {\n    try {\n        return ata.a(bArr, str.getBytes(\"UTF-8\"));\n    } catch (UnsupportedEncodingException e) {\n        e.printStackTrace();\n        return null;\n    }\n}\n\npublic static byte[] a(byte[] bArr, byte[] bArr2) {\n    try {\n        Cipher instance = Cipher.getInstance(\"RC4\");\n        instance.init(2, new SecretKeySpec(bArr2, \"RC4\"));\n        return instance.update(bArr);\n    } catch (NoSuchAlgorithmException e) {\n        e.printStackTrace();\n        return null;\n    } catch (NoSuchPaddingException e2) {\n        e2.printStackTrace();\n        return null;\n    } catch (InvalidKeyException e3) {\n        e3.printStackTrace();\n        return null;\n    }\n  }\n}\n", "idx": 1957}
{"project": "cipher", "commit_id": "Snippet25069053_7420.java", "target": 1, "func": "static void setKey(byte[] keybytes, byte[] iv) throws NoSuchAlgorithmException, NoSuchPaddingException, InvalidKeyException, InvalidAlgorithmParameterException, NoSuchProviderException\n{\n    /**\n     * crypto is specifically stated here because without using AndroidOpenSSL for the SHA1PRNG breaks on some phones,\n     * PRNGFixes.apply() should be called if using this\n     * https://android-developers.blogspot.com/2013/08/some-securerandom-thoughts.html \n     */\n    random = SecureRandom.getInstance(\"SHA1PRNG\", \"Crypto\");\n    key = new SecretKeySpec(keybytes, \"AES\");\n    ivspec = new IvParameterSpec(iv);\n    encryptcipher = Cipher.getInstance(\"AES/CFB/NoPadding\", \"SC\");\n    encryptcipher.init(Cipher.ENCRYPT_MODE, key, ivspec, random);\n\n    decryptcipher = Cipher.getInstance(\"AES/CFB/NoPadding\", \"SC\");\n    decryptcipher.init(Cipher.DECRYPT_MODE, key, ivspec, random);       \n}\n", "idx": 2418}
{"project": "cipher", "commit_id": "Snippet34925407_16874.java", "target": 0, "func": "   public static void setKey(String myKey) {\n\n        MessageDigest sha = null;\n        try {\n            key = new byte[]{(byte) '5', (byte) 'F', (byte) '8', (byte) 'p', (byte) 'J', (byte) 't', (byte) 'v', (byte) 'U', (byte) 'm', (byte) 'q', (byte) 'k', (byte) '7', (byte) 'A', (byte) 'M', (byte) 'v', (byte) 'b', (byte) 'q', (byte) 'o', (byte) 'H', (byte) 'M', (byte) '9', (byte) 'a', (byte) 'p', (byte) '4', (byte) '9', (byte) 'm', (byte) 'c', (byte) 'u', (byte) 'u', (byte) '5', (byte) 'B', (byte) 'X'};\n            System.out.println(new String(key, \"UTF-8\"));\n            secretKey = new SecretKeySpec(key, \"AES\");\n        } catch (UnsupportedEncodingException e) {\n            // TODO Auto-generated catch block\n            e.printStackTrace();\n        }\n    }\n\n\n    public static String encrypt(String strToEncrypt) {\n        try {\n            Cipher cipher = Cipher.getInstance(\"AES/ECB/PKCS5Padding\");\n            cipher.init(Cipher.ENCRYPT_MODE, secretKey);\n            setEncryptedarr(cipher.doFinal(strToEncrypt.getBytes(\"UTF-8\")));\n            setEncryptedString(String.valueOf(Base64.encode(cipher.doFinal(strToEncrypt.getBytes(\"UTF-8\")), Base64.DEFAULT)));\n            //setEncryptedString(Base64.encodeBase64String(cipher.doFinal(strToEncrypt.getBytes(\"UTF-8\"))));\n        } catch (Exception e) {\n            e.printStackTrace();\n            System.out.println(\"Error while encrypting: \" + e.toString());\n        }\n        return null;\n    }\n\n    public static String decryptbyte(byte[] strToDecrypt) {\n        try {\n            Cipher cipher = Cipher.getInstance(\"AES/ECB/PKCS5PADDING\");\n            cipher.init(Cipher.DECRYPT_MODE, secretKey);\n            setDecryptedarr(cipher.doFinal(strToDecrypt));\n            System.out.println(\"encrypt : decropted size : \" + getDecryptedarr().length);\n            setDecryptedString(new String(cipher.doFinal(strToDecrypt)));\n        } catch (Exception e) {\n            System.out.println(\"Error wnhile decrypting: \" + e.toString());\n            e.printStackTrace();\n        }\n        return null;\n    }\n\n    public static String decrypt(String strToDecrypt) {\n        try {\n            Cipher cipher = Cipher.getInstance(\"AES/ECB/PKCS5PADDING\");\n            cipher.init(Cipher.DECRYPT_MODE, secretKey);\n            setDecryptedarr(cipher.doFinal(Base64.decode(strToDecrypt, Base64.DEFAULT)));\n            setDecryptedString(new String(cipher.doFinal(Base64.decode(strToDecrypt, Base64.DEFAULT))));\n\n        } catch (Exception e) {\n            e.printStackTrace();\n            System.out.println(\"Error while decrypting: \" + e.toString());\n\n        }\n        return null;\n    }\n", "idx": 2177}
{"project": "cipher", "commit_id": "Snippet10084582_34433.java", "target": 1, "func": "Cipher c1=Cipher.getInstance(\"RSA\");\n", "idx": 2483}
{"project": "cipher", "commit_id": "Snippet35237880_17166.java", "target": 1, "func": "private byte[] getKeyBytes(final byte[] key) throws Exception {\n        byte[] keyBytes = new byte[16];\n        System.arraycopy(key, 0, keyBytes, 0, Math.min(key.length, keyBytes.length));\n        return keyBytes;\n    }\n\n    public Cipher getCipherEncrypt(final byte[] key) throws Exception {\n        byte[] keyBytes = getKeyBytes(key);\n        Cipher cipher = Cipher.getInstance(\"AES/CBC/PKCS5Padding\");\n        SecretKeySpec secretKeySpec = new SecretKeySpec(keyBytes, \"AES\");\n        IvParameterSpec ivParameterSpec = new IvParameterSpec(keyBytes);\n        cipher.init(Cipher.ENCRYPT_MODE, secretKeySpec, ivParameterSpec);\n        return cipher;\n    }\npublic void encrypt() throws Exception {\n        Cipher cipher = getCipherEncrypt(key);\n        FileOutputStream fos = null;\n        CipherOutputStream cos = null;\n        FileInputStream fis = null;\n        try {\n           fis = new FileInputStream(inputFile);\n         fos = new FileOutputStream(outputFile);\n            cos = new CipherOutputStream(fos, cipher);\n            byte[] data = new byte[1024];\n            int read = fis.read(data);\n            while (read != -1) {\n                cos.write(data, 0, read);\n                read = fis.read(data);\n                System.out.println(new String(data, \"UTF-8\").trim());\n            }\n            cos.flush();\n        } finally {\n            cos.close();\n            fos.close();\n            fis.close();\n        }\n    }\n", "idx": 2714}
{"project": "cipher", "commit_id": "Snippet32217751_14334.java", "target": 1, "func": "public static String Decrypt(String text, String key) throws Exception {\n        Cipher cipher = Cipher.getInstance(\"AES/CBC/PKCS5Padding\");\n        byte[] keyBytes = new byte[16];\n        byte[] b = key.getBytes(\"UTF-8\");\n        int len = b.length;\n        if (len > keyBytes.length)\n            len = keyBytes.length;\n        System.arraycopy(b, 0, keyBytes, 0, len);\n        SecretKeySpec keySpec = new SecretKeySpec(keyBytes, \"AES\");\n        IvParameterSpec ivSpec = new IvParameterSpec(keyBytes);\n        cipher.init(Cipher.DECRYPT_MODE, keySpec, ivSpec);\n        byte[] results = new byte[text.length()];\n        BASE64Decoder decoder = new BASE64Decoder();\n        try {\n            results = cipher.doFinal(decoder.decodeBuffer(text));\n        } catch (Exception e) {\n            Log.i(\"Erron in Decryption\", e.toString());\n        }\n\n        return new String(results, \"UTF-8\");\n    }\n", "idx": 2629}
{"project": "cipher", "commit_id": "Snippet21786821_4195.java", "target": 1, "func": "private String encrypt(String str) throws Exception {\n    ClassPathResource classPathResource = new ClassPathResource(\"testcert1.crt\");\n    CertificateFactory certificateFactory = CertificateFactory.getInstance(\"X.509\");\n    X509Certificate certificate = (X509Certificate)certificateFactory.generateCertificate(classPathResource.getInputStream());\n    PublicKey pk = certificate.getPublicKey();\n    Cipher cipher = Cipher.getInstance(\"RSA/ECB/PKCS1PADDING\");\n    cipher.init(Cipher.ENCRYPT_MODE, pk);\n    return Base64.encodeBase64String(cipher.doFinal(str.getBytes()));\n}\n", "idx": 2593}
{"project": "cipher", "commit_id": "Snippet30254560_12408.java", "target": 0, "func": " private final static String HEX = \"0123456789ABCDEF\";\n\n public static String encryptString(String str) throws Exception {\n    return encrypt(\"KeY123\", str);\n}\n\npublic static String decryptString(String str) throws Exception {\n    return decrypt(\"KeY123\", str);\n}\n\npublic static String encrypt(String seed, String cleartext) throws Exception {\n    byte[] rawKey = getRawKey(seed.getBytes());\n    byte[] result = encrypt(rawKey, cleartext.getBytes());\n    return toHex(result);\n}\n\npublic static String decrypt(String seed, String encrypted) throws Exception {\n    byte[] rawKey = getRawKey(seed.getBytes());\n    byte[] enc = toByte(encrypted);\n    byte[] result = decrypt(rawKey, enc);\n    return new String(result);\n}\n\nprivate static byte[] getRawKey(byte[] seed) throws Exception {\n    KeyGenerator kgen = KeyGenerator.getInstance(\"AES\");\n    SecureRandom sr = SecureRandom.getInstance(\"SHA1PRNG\", \"Crypto\");\n    sr.setSeed(seed);\n    kgen.init(128, sr); // 192 and 256 bits may not be available\n    SecretKey skey = kgen.generateKey();\n    byte[] raw = skey.getEncoded();\n    return raw;\n}\n\nprivate static byte[] encrypt(byte[] raw, byte[] clear) throws Exception {\n    SecretKeySpec skeySpec = new SecretKeySpec(raw, \"AES\");\n    Cipher cipher = Cipher.getInstance(\"AES\");\n    cipher.init(Cipher.ENCRYPT_MODE, skeySpec);\n    byte[] encrypted = cipher.doFinal(clear);\n    return encrypted;\n}\n\nprivate static byte[] decrypt(byte[] raw, byte[] encrypted) throws Exception {\n    SecretKeySpec skeySpec = new SecretKeySpec(raw, \"AES\");\n    Cipher cipher = Cipher.getInstance(\"AES\");\n    cipher.init(Cipher.DECRYPT_MODE, skeySpec);\n    byte[] decrypted = cipher.doFinal(encrypted);\n    return decrypted;\n}\n\npublic static String toHex(String txt) {\n    return toHex(txt.getBytes());\n}\n\npublic static String fromHex(String hex) {\n    return new String(toByte(hex));\n}\n\npublic static byte[] toByte(String hexString) {\n    int len = hexString.length() / 2;\n    byte[] result = new byte[len];\n    for (int i = 0; i < len; i++)\n        result[i] = Integer.valueOf(hexString.substring(2 * i, 2 * i + 2), 16).byteValue();\n    return result;\n}\n\npublic static String toHex(byte[] buf) {\n    if (buf == null)\n        return \"\";\n    StringBuffer result = new StringBuffer(2 * buf.length);\n    for (int i = 0; i < buf.length; i++) {\n        appendHex(result, buf[i]);\n    }\n    return result.toString();\n}\n\nprivate static void appendHex(StringBuffer sb, byte b) {\n    sb.append(HEX.charAt((b >> 4) & 0x0f)).append(HEX.charAt(b & 0x0f));\n}\n", "idx": 2196}
{"project": "cipher", "commit_id": "Snippet2957513_30556.java", "target": 1, "func": "String password = \"qwerty\";\nString plainText = \"hello world\";\n\nbyte[] salt = generateSalt();\nbyte[] cipherText = encrypt(plainText, password.toCharArray(), salt);\n\nprivate static byte[] generateSalt() throws NoSuchAlgorithmException {\n    byte salt[] = new byte[8];\n    SecureRandom saltGen = SecureRandom.getInstance(\"SHA1PRNG\");\n    saltGen.nextBytes(salt);\n    return salt;\n}\n\nprivate static byte[] encrypt(String plainText, char[] password, byte[] salt) throws NoSuchAlgorithmException, InvalidKeySpecException, NoSuchPaddingException, InvalidKeyException, InvalidAlgorithmParameterException, IllegalBlockSizeException, BadPaddingException {\n    Security.addProvider(new BouncyCastleProvider());\n\n    PBEParameterSpec pbeParamSpec = new PBEParameterSpec(salt, 20);\n\n    PBEKeySpec pbeKeySpec = new PBEKeySpec(password);\n    SecretKeyFactory keyFac = SecretKeyFactory.getInstance(\"PBEWithSHA256And256BitAES-CBC-BC\");\n    SecretKey pbeKey = keyFac.generateSecret(pbeKeySpec);\n\n    Cipher encryptionCipher = Cipher.getInstance(\"PBEWithSHA256And256BitAES-CBC-BC\");\n    encryptionCipher.init(Cipher.ENCRYPT_MODE, pbeKey, pbeParamSpec);\n\n    return encryptionCipher.doFinal(plainText.getBytes());\n}\n", "idx": 2553}
{"project": "cipher", "commit_id": "Snippet22445878_4839.java", "target": 1, "func": "import javax.crypto.Cipher;\nimport javax.crypto.spec.IvParameterSpec;\nimport javax.crypto.spec.SecretKeySpec;\n\nimport org.apache.commons.codec.binary.Base64;\n\npublic class Encryptor {\n    public static String encrypt(String key, String initVector, String value) {\n        try {\n            IvParameterSpec iv = new IvParameterSpec(initVector.getBytes(\"UTF-8\"));\n            SecretKeySpec skeySpec = new SecretKeySpec(key.getBytes(\"UTF-8\"), \"AES\");\n\n            Cipher cipher = Cipher.getInstance(\"AES/CBC/PKCS5PADDING\");\n            cipher.init(Cipher.ENCRYPT_MODE, skeySpec, iv);\n\n            byte[] encrypted = cipher.doFinal(value.getBytes());\n            System.out.println(\"encrypted string: \"\n                    + Base64.encodeBase64String(encrypted));\n\n            return Base64.encodeBase64String(encrypted);\n        } catch (Exception ex) {\n            ex.printStackTrace();\n        }\n\n        return null;\n    }\n\n    public static String decrypt(String key, String initVector, String encrypted) {\n        try {\n            IvParameterSpec iv = new IvParameterSpec(initVector.getBytes(\"UTF-8\"));\n            SecretKeySpec skeySpec = new SecretKeySpec(key.getBytes(\"UTF-8\"), \"AES\");\n\n            Cipher cipher = Cipher.getInstance(\"AES/CBC/PKCS5PADDING\");\n            cipher.init(Cipher.DECRYPT_MODE, skeySpec, iv);\n\n            byte[] original = cipher.doFinal(Base64.decodeBase64(encrypted));\n\n            return new String(original);\n        } catch (Exception ex) {\n            ex.printStackTrace();\n        }\n\n        return null;\n    }\n\n    public static void main(String[] args) {\n        String key = \"Bar12345Bar12345\"; // 128 bit key\n        String initVector = \"RandomInitVector\"; // 16 bytes IV\n\n        System.out.println(decrypt(key, initVector,\n                encrypt(key, initVector, \"Hello World\")));\n    }\n}\n", "idx": 2417}
{"project": "cipher", "commit_id": "Snippet1303220_29924.java", "target": 1, "func": "public void decrypt(String base64String) {\n    String keyStorePath = \"C:\\Key.keystore\";\n    String storepass = \"1234\";\n    String keypass = \"abcd\";\n    byte[] data = Base64.decode(base64String);\n    byte[] cipherData = null;\n\n    keystore = KeyStore.getInstance(\"JKS\");\n    keystore.load(new FileInputStream(keyStorePath), storepass.toCharArray());\n\n    RSAPrivateKey privateRSAKey = (RSAPrivateKey) keystore.getKey(alias, keypass.toCharArray());\n\n    Cipher cipher = Cipher.getInstance(\"RSA/ECB/PKCS1Padding\");\n    cipher.init(Cipher.DECRYPT_MODE, privateRSAKey);\n    cipherData = cipher.doFinal(data);\n\n    System.out.println(new String(cipherData));\n}\n", "idx": 2722}
{"project": "cipher", "commit_id": "Snippet9526479_33972.java", "target": 1, "func": "    SecretKeyFactory factory = SecretKeyFactory.getInstance(\"PBEWITHSHA256AND128BITAES-CBC-BC\", \n            org.spongycastle.jce.provider.BouncyCastleProvider.PROVIDER_NAME);\n\n    KeySpec spec = new PBEKeySpec(\"password\".toCharArray(), \n            \"8 bytes!\", 1024, 128);\n\n    SecretKey tmp = factory.generateSecret(spec);\n    SecretKey secret = new SecretKeySpec(tmp.getEncoded(), \"AES\");\n\n    Cipher cipher = Cipher.getInstance(\"AES/CBC/PKCS5Padding\");\n    cipher.init(Cipher.ENCRYPT_MODE, secret);\n    AlgorithmParameters params = cipher.getParameters();\n\n    byte[] iv = params.getParameterSpec(IvParameterSpec.class).getIV();\n    byte[] cipherText = cipher.doFinal(\"hello world\".getBytes());\n", "idx": 2396}
{"project": "cipher", "commit_id": "Snippet16613819_27.java", "target": 0, "func": "try{\n   Cipher c = Cipher.getInstance(\"AES\");\n}\ncatch(Exception e){\n   //do something about it\n}\n", "idx": 1951}
{"project": "cipher", "commit_id": "Snippet15508784_38561.java", "target": 0, "func": "import java.io.File;\n\npublic class ProgressBarExa extends Activity {\n\nButton btnStartProgress;\nProgressDialog progressBar;\nprivate int progressBarStatus = 0;\nprivate Handler progressBarHandler = new Handler();\n\n// private long fileSize = 0;\n\n@Override\npublic void onCreate(Bundle savedInstanceState) {\n    super.onCreate(savedInstanceState);\n    setContentView(R.layout.progressbar_view);\n\n    addListenerOnButton();\n\n}\n\npublic void addListenerOnButton() {\n\n    btnStartProgress = (Button) findViewById(R.id.btnStartProgress);\n    btnStartProgress.setOnClickListener(\n             new OnClickListener() {\n\n       @Override\n       public void onClick(View v) {\n\n        // prepare for a progress bar dialog\n        progressBar = new ProgressDialog(v.getContext());\n        progressBar.setCancelable(true);\n        progressBar.setMessage(\"File encrypting...\");\n        progressBar.setProgressStyle(ProgressDialog.STYLE_HORIZONTAL);\n        progressBar.setProgress(0);\n        progressBar.setMax(100);\n        progressBar.show();\n\n        //reset progress bar status\n        progressBarStatus = 0;\n\n        //reset filesize\n        // fileSize = 0;\n\n        new Thread(new Runnable() {\n          public void run() {\n            while (progressBarStatus < 100) {\n\n              // process some tasks\n              progressBarStatus = doSomeTasks();\n\n              // your computer is too fast, sleep 1 second\n              try {\n                Thread.sleep(1000);\n              } catch (InterruptedException e) {\n                e.printStackTrace();\n              }\n\n              // Update the progress bar\n              progressBarHandler.post(new Runnable() {\n                public void run() {\n                  progressBar.setProgress(progressBarStatus);\n                }\n              });\n            }\n\n            // ok, file is downloaded,\n            if (progressBarStatus >= 100) {\n\n                // sleep 2 seconds, so that you can see the 100%\n                try {\n                    Thread.sleep(2000);\n                } catch (InterruptedException e) {\n                    e.printStackTrace();\n                }\n\n                // close the progress bar dialog\n                progressBar.dismiss();\n            }\n          }\n           }).start();\n\n           }\n\n            });\n\n    }\n\n// file download simulator... a really simple\npublic int doSomeTasks() {\n\n    try{\n        String baseDir = Environment.getExternalStorageDirectory().getAbsolutePath();\n        String fileName = \"a.wmv\";\n        String newFileNEE = \"b.wmv\";\n        String newFileNED = \"c.wmv\";\n\n        FileInputStream fis = new FileInputStream(new File(baseDir + File.separator + fileName));\n\n        File outfile = new File(baseDir + File.separator + newFileNEE);\n            int read;\n            if(!outfile.exists())\n                outfile.createNewFile();\n\n            // long outfile_size = outfile.length();\n\n            File decfile = new File(baseDir + File.separator + newFileNED);\n            if(!decfile.exists())\n                decfile.createNewFile();\n\n\n            FileOutputStream fos = new FileOutputStream(outfile);\n            FileInputStream encfis = new FileInputStream(outfile);\n            FileOutputStream decfos = new FileOutputStream(decfile);\n\n            Cipher encipher = Cipher.getInstance(\"AES\");\n            Cipher decipher = Cipher.getInstance(\"AES\");\n\n            KeyGenerator kgen = KeyGenerator.getInstance(\"AES\");\n            SecretKey skey = kgen.generateKey();\n            encipher.init(Cipher.ENCRYPT_MODE, skey);\n            CipherInputStream cis = new CipherInputStream(fis, encipher);\n            decipher.init(Cipher.DECRYPT_MODE, skey);\n            CipherOutputStream cos = new CipherOutputStream(decfos,decipher);\n\n            while((read = cis.read())!=-1)\n                    {\n                        fos.write((char)read);\n                        fos.flush();\n                    }   \n            fos.close();\n            while((read=encfis.read())!=-1)\n            {\n                cos.write(read);\n                cos.flush();\n            }\n            cos.close();\n\n    }catch (Exception e) {\n        // TODO: handle exceptione\n        e.printStackTrace();\n    }\n    return 100;\n}\n", "idx": 1949}
{"project": "cipher", "commit_id": "Snippet26068460_8283.java", "target": 1, "func": "Cipher.getInstance(\"RSA\")", "idx": 2419}
{"project": "cipher", "commit_id": "Snippet27245922_9374.java", "target": 1, "func": "public static String encrypt_cbc(String input, String key, String iv){\n    byte[] crypted = null;\n    try{\n         //byte[] key_byte = Hex.decodeHex(key.toCharArray());\n         byte[] key_byte = DatatypeConverter.parseHexBinary(key); \n         SecretKeySpec key_spec = new SecretKeySpec(key_byte, \"AES\");\n\n         //byte[] iv_byte = Hex.decodeHex(iv.toCharArray());\n         byte[] iv_byte = DatatypeConverter.parseHexBinary(iv); \n         IvParameterSpec iv_spec = new IvParameterSpec(iv_byte);\n\n         Cipher cipher = Cipher.getInstance(\"AES/CBC/PKCS5Padding\");\n\n         cipher.init(Cipher.ENCRYPT_MODE, key_spec, iv_spec);\n         crypted = cipher.doFinal(input.getBytes());\n\n    }catch(Exception e){\n         System.out.println(e.toString());\n    }\n    //String crypted_hex = Hex.encodeHexString(crypted);\n    String crypted_hex = DatatypeConverter.printHexBinary(crypted);\n    return crypted_hex;\n}\n", "idx": 2358}
{"project": "cipher", "commit_id": "Snippet15682840_38698.java", "target": 0, "func": "import java.security.*;\nimport javax.crypto.*;\n\n// encrypt and decrypt using the DES private key algorithm\npublic class PrivateExample {\n\n  public static void main (String[] args) throws Exception {\n    String text=new String();\n    text=\"This is an encryption test\";\n\n    byte[] plainText = text.getBytes(\"UTF8\");\n\n    // get a DES private key\n    System.out.println( \"\\nStart generating DES key\" );\n    KeyGenerator keyGen = KeyGenerator.getInstance(\"DES\");\n    keyGen.init(56);\n    Key key = keyGen.generateKey();\n    System.out.println( \"Finish generating DES key\" );\n    //\n    // get a DES cipher object and print the provider\n    Cipher cipher = Cipher.getInstance(\"DES/ECB/PKCS5Padding\");\n    System.out.println( \"\\n\" + cipher.getProvider().getInfo() );\n    //\n   // encrypt using the key and the plaintext\n    System.out.println( \"\\nStart encryption\" );\n    cipher.init(Cipher.ENCRYPT_MODE, key);\n    byte[] cipherText = cipher.doFinal(plainText);\n    System.out.println( \"Finish encryption: \" );\n    System.out.println( new String(cipherText, \"UTF8\") );\n\n   //Now writing to an ouput file the cipherText\n   try{\n       FileOutputStream fs=new FileOutputStream(\"c:/test.txt\");\n      fs.write(cipherText);\n     }catch(Exception e){\n       e.printStackTrace();\n     }\n//How to proceed from here\n\n}\n}\n", "idx": 2134}
{"project": "cipher", "commit_id": "Snippet10012918_34377.java", "target": 0, "func": "static Cipher createCipher(int mode, String password) throws Exception {\n            PBEKeySpec keySpec = new PBEKeySpec(password.toCharArray());\n            SecretKeyFactory keyFactory = SecretKeyFactory.getInstance(\"PBEWithMD5AndDES\");\n            SecretKey key = keyFactory.generateSecret(keySpec);\n            MessageDigest md = MessageDigest.getInstance(\"MD5\");\n            md.update(\"input\".getBytes());\n            byte[] digest = md.digest();\n            byte[] salt = new byte[8];\n            for (int i = 0; i < 8; ++i)\n              salt[i] = digest[i];\n            PBEParameterSpec paramSpec = new PBEParameterSpec(salt, 20);\n            Cipher cipher = Cipher.getInstance(\"PBEWithMD5AndDES\");\n            cipher.init(mode, key, paramSpec);\n            return cipher;\n    }\n\n     static void applyCipher(String inFile, String outFile, Cipher cipher) throws Exception {\n            String decryption = \"\";\n            CipherInputStream in = new CipherInputStream(new FileInputStream(inFile), cipher);\n            BufferedOutputStream out = new BufferedOutputStream(new FileOutputStream(outFile));\n            int BUFFER_SIZE = 8;\n            byte[] buffer = new byte[BUFFER_SIZE];\n            int numRead = 0;\n            do {\n              numRead = in.read(buffer);\n              System.out.println(buffer + \", 0, \" + numRead);\n              if (numRead > 0){\n                out.write(buffer, 0, numRead);\n                System.out.println(toHexString(buffer, 0, numRead));\n              }\n             } while (numRead == 8);\n            in.close();\n            out.flush();\n            out.close();\n          }\n     private static char[] hex_table = {\n            '0', '1', '2', '3', '4', '5', '6', '7', '8', '9', \n            'a', 'b', 'c', 'd', 'e', 'f'};\n\n     public static String toHexString(byte[] data, int offset, int length)\n     {\n       StringBuffer s = new StringBuffer(length*2);\n       int end = offset+length;\n\n       for (int i = offset; i < end; i++)\n       {\n         int high_nibble = (data[i] & 0xf0) >>> 4;\n         int low_nibble = (data[i] & 0x0f);\n         s.append(hex_table[high_nibble]);\n         s.append(hex_table[low_nibble]);\n       }\n\n       return s.toString();\n     }\n", "idx": 2085}
{"project": "cipher", "commit_id": "Snippet22602496_4996.java", "target": 1, "func": "import java.security.*;\nimport java.security.spec.InvalidParameterSpecException;\nimport java.util.logging.Level;    \nimport java.util.logging.Logger;    \nimport javax.crypto.*;\nimport java.util.*;    \nimport javax.crypto.spec.DHParameterSpec;\n\npublic class Encrypting{\n\n    public static void main(String[] args) {\n    try {\n        KeyPair alice_key;\n\n      KeyPair bob_key ;\n\n        String plaintext=\"hi how r u\";\n\n        KeyPairGenerator keyGen = KeyPairGenerator.getInstance(\"DH\");\n\n        AlgorithmParameterGenerator paramGen = AlgorithmParameterGenerator\n            .getInstance(\"DH\");\n\n        paramGen.init(1024);\n\n        AlgorithmParameters params = paramGen.generateParameters();\n\n        DHParameterSpec dhSpec = (DHParameterSpec) params\n            .getParameterSpec(DHParameterSpec.class);\n\n        keyGen.initialize(dhSpec);\n\n         alice_key = keyGen.generateKeyPair();\n\n         bob_key = keyGen.generateKeyPair();\n\n        Cipher cipher = Cipher.getInstance(\"RSA\");\n\n        SecretKey secret_alice = combine(alice_key.getPrivate(), bob_key.getPublic());\n\n         cipher.init(Cipher.ENCRYPT_MODE, secret_alice);\n\n        byte[] x = cipher.doFinal(plaintext.getBytes());\n\n        System.out.println(\"encrypted message\");\n\n        for(int i=0;i<x.length;i++)\n            System.out.print((char)x[i]);\n\n        cipher.init(Cipher.DECRYPT_MODE, secret_alice);\n\n        byte[] y = cipher.doFinal(x);\n\n        System.out.println();\n\n        System.out.println(\"decrypted message\");\n\n         for(int i=0;i<y.length;i++)\n\n            System.out.print((char)y[i]);\n\n    SecretKey secret_bob = combine(bob_key.getPrivate(),\n\n            alice_key.getPublic());\n\n    System.out.println(Arrays.toString(secret_alice.getEncoded()));\n\n        System.out.println(Arrays.toString(secret_bob.getEncoded())); \n\n    } catch (NoSuchAlgorithmException ex) {\n\n        Logger.getLogger(NewClass.class.getName()).log(Level.SEVERE, null, ex);\n\n    } catch (InvalidParameterSpecException ex) {\n\n        Logger.getLogger(NewClass.class.getName()).log(Level.SEVERE, null, ex);\n\n    } catch (InvalidAlgorithmParameterException ex) {\n\n        Logger.getLogger(NewClass.class.getName()).log(Level.SEVERE, null, ex);\n\n    } catch (NoSuchPaddingException ex) {\n\n        Logger.getLogger(NewClass.class.getName()).log(Level.SEVERE, null, ex);\n\n    } catch (InvalidKeyException ex) {\n\n        Logger.getLogger(NewClass.class.getName()).log(Level.SEVERE, null, ex);\n\n    } catch (IllegalBlockSizeException ex) {\n\n        Logger.getLogger(NewClass.class.getName()).log(Level.SEVERE, null, ex);\n\n    } catch (BadPaddingException ex) {\n\n        Logger.getLogger(NewClass.class.getName()).log(Level.SEVERE, null, ex);\n\n    }\n}\n\nprivate static SecretKey combine(PrivateKey private1, PublicKey public1)  {\n\n     SecretKey secretKey=null;\n\n    try {\n\n        KeyAgreement ka = KeyAgreement.getInstance(\"DH\");\n\n        ka.init(private1);\n\n        ka.doPhase(public1, true);\n\n         secretKey = ka.generateSecret(\"DES\");\n\n        return secretKey;\n\n    } catch (NoSuchAlgorithmException ex) {\n\n        Logger.getLogger(NewClass.class.getName()).log(Level.SEVERE, null, ex);\n\n    } catch (InvalidKeyException ex) {\n\n        Logger.getLogger(NewClass.class.getName()).log(Level.SEVERE, null, ex);\n\n    }\n\n    return secretKey;\n\n}\n\n}\n", "idx": 2509}
{"project": "cipher", "commit_id": "Snippet916061_29797.java", "target": 0, "func": "static\n{\n   Security.addProvider(new BouncyCastleProvider());\n}\n\nprotected String encrypt(byte[] keyData, byte[] data) throws Exception {\n   X509EncodedKeySpec keyspec = new X509EncodedKeySpec(keyData);\n   KeyFactory kf = KeyFactory.getInstance(\"RSA\", \"BC\");\n   PublicKey pk = kf.generatePublic(keyspec);\n   Cipher rsa =  Cipher.getInstance(\"RSA/None/OAEPWithSHA1AndMGF1Padding\", \"BC\");\n   rsa.init(Cipher.ENCRYPT_MODE, pk);\n   byte[] output = rsa.doFinal(data);\n   String result = base64EncodeBytes(output);\n   return result;\n}\n", "idx": 2187}
{"project": "cipher", "commit_id": "Snippet7883954_32988.java", "target": 1, "func": "Cipher cipher = Cipher.getInstance(\"RSA/None/PKCS1Padding\");", "idx": 2720}
{"project": "cipher", "commit_id": "Snippet6531167_32175.java", "target": 1, "func": "String plainText = \"24124124123\";\nString pwd = \"BobsPublicPassword\";\nbyte[] key = pwd.getBytes(); \nkey = cutArray(key, 16);\nbyte[] input = plainText.getBytes();\nbyte[] output = null;\nSecretKeySpec keySpec = null;\nkeySpec = new SecretKeySpec(key, \"AES\");\nCipher cipher = Cipher.getInstance(\"AES/CBC/PKCS7Padding\");\ncipher.init(Cipher.ENCRYPT_MODE, keySpec);\noutput = cipher.doFinal(input);\n\nprivate static byte[] cutArray(byte[] arr, int length){\nbyte[] resultArr = new byte[length];\nfor(int i = 0; i < length; i++ ){\n    resultArr[i] = arr[i];\n}\nreturn resultArr;\n}\n", "idx": 2756}
{"project": "cipher", "commit_id": "Snippet22279138_4676.java", "target": 0, "func": "private static void createKey(char[] password) throws Exception {\n    System.out.println(\"Generating a Blowfish key...\");\n\n    // Create a blowfish key\n    KeyGenerator keyGenerator = KeyGenerator.getInstance(\"Blowfish\");\n    keyGenerator.init(256);\n    Key key = keyGenerator.generateKey();\n\n    System.out.println(\"Done generating the key.\");\n\n    // Now we need to create the file with the key,\n    // encrypting it with a password.\n    byte[] salt = new byte[8];\n    SecureRandom random = new SecureRandom();\n    random.nextBytes(salt);\n    PBEKeySpec pbeKeySpec = new PBEKeySpec(password);\n    SecretKeyFactory keyFactory = SecretKeyFactory.getInstance(\"PBEWithSHAAndTwofish-CBC\");\n    SecretKey pbeKey = keyFactory.generateSecret(pbeKeySpec);\n    PBEParameterSpec pbeParamSpec = new PBEParameterSpec(salt, ITERATIONS);\n\n    //Cipher cipher = Cipher.getInstance(\"PBEWithMD5AndDES-CBC\");\n    //Cipher cipher = Cipher.getInstance(\"PBEWithSHAAndTwofish-CBC\");\n    Cipher cipher = Cipher.getInstance(\"PBEWithSHAAndTwofish-CBC\");\n\n    cipher.init(Cipher.ENCRYPT_MODE, pbeKey, pbeParamSpec);\n\n    // Encrypt the key\n    byte[] encryptedKeyBytes = cipher.doFinal(key.getEncoded());\n\n    // Write out the salt, and then the encrypted key bytes\n    FileOutputStream fos = new FileOutputStream(KEY_FILENAME);\n    fos.write(salt);\n    fos.write(encryptedKeyBytes);\n    fos.close();\n}\n", "idx": 2157}
{"project": "cipher", "commit_id": "Snippet10661644_34964.java", "target": 1, "func": "InputStream is = item.openStream(); // item is obtained from file upload iterator\ntry{\n   PBEKeySpec keySpec = new PBEKeySpec(passphrase.toCharArray(), salt.getBytes(),  iterations, keyLength);\n   SecretKeyFactory keyFactory = SecretKeyFactory.getInstance(\"DESede\"); \n   SecretKey key = keyFactory.generateSecret(keySpec); // Throws Exception\n   CipherInputStream cis;\n   Cipher cipher = Cipher.getInstance(\"RSA\");\n   cis = new CipherInputStream(is, cipher);\n   cipher.init(Cipher.ENCRYPT_MODE, key);\n } catch (Exception ex){\n    // catches the following exceptopn \n    java.security.spec.InvalidKeySpecException: Inappropriate key specification\n    at com.sun.crypto.provider.DESedeKeyFactory.engineGenerateSecret(DashoA13*..)\n   //\n }\n", "idx": 2359}
{"project": "cipher", "commit_id": "Snippet21988552_4413.java", "target": 0, "func": "private Cipher encrypt(byte[] input)\n{\n    try\n    {\n        SecretKeySpec key = new SecretKeySpec(keyBytes, \"AES\");\n\n        Cipher cipher = Cipher.getInstance(\"AES/ECB/PKCS7Padding\", \"BC\");\n\n        // encryption pass\n        cipher.init(Cipher.ENCRYPT_MODE, key);\n        byte[] cipherText = new byte[cipher.getOutputSize(input.length)];\n        int ctLength = cipher.update(input, 0, input.length, cipherText, 0);\n        ctLength += cipher.doFinal(cipherText, ctLength);\n        FileOutputStream fs = new FileOutputStream(savedScoresFileName);\n        fs.write(cipherText);\n\n        return cipher;\n    }\n    catch (Exception e)\n    {\n        Log.e(\"encrtypt\", \"Exception\", e);\n    }\n\n    return null;\n}\n\nprivate String decrypt()\n{\n    try\n    {\n        Cipher cipher = Cipher.getInstance(\"AES/ECB/PKCS7Padding\", \"BC\");\n\n        SecretKeySpec key = new SecretKeySpec(keyBytes, \"AES\");\n        byte[] cipherText = new byte[32];\n\n        FileInputStream fl = new FileInputStream(savedScoresFileName);\n        fl.read(cipherText);\n\n        cipher.init(Cipher.DECRYPT_MODE, key);\n        byte[] plainText = new byte[cipher.getOutputSize(32)];\n        int ptLength = cipher.update(cipherText, 0, 32, plainText, 0);\n        ptLength += cipher.doFinal(plainText, ptLength);\n\n        return new String(plainText).substring(0, ptLength);\n    }\n    catch (Exception e)\n    {\n        Log.e(\"decrypt\", \"Exception\", e);\n    }\n\n    return null;\n}\n", "idx": 2125}
{"project": "cipher", "commit_id": "Snippet12110459_36048.java", "target": 0, "func": "private static final String CIPHER_ALGORITHM = \"DES/ECB/PKCS5Padding\";\nprivate static int KEY_LENGTH = 64;\n\n public static SecretKey deriveKeyDES() {\n        try {\n            long start = System.currentTimeMillis();\n\n            KeyGenerator kgen = KeyGenerator.getInstance(\"DES\");\n            kgen.init(KEY_LENGTH);\n            SecretKey result = kgen.generateKey();\n\n            long elapsed = System.currentTimeMillis() - start;\n            return result;\n\n        } catch (GeneralSecurityException e) {\n            throw new RuntimeException(e);\n        } \n    }\n\n\n    public static String encrypt(String plaintext, SecretKey key) {\n        try {\n\n            long start = System.currentTimeMillis();\n            Cipher cipher = Cipher.getInstance(\"DES/ECB/PKCS5Padding\")\n\n            cipher.init(Cipher.ENCRYPT_MODE, key);\n\n            byte[] cipherText = cipher.doFinal(plaintext.getBytes(\"UTF-8\"));\n\n            long elapsed = System.currentTimeMillis() - start;\n\n            return toBase64(cipherText);\n\n        } catch (GeneralSecurityException e) {\n            throw new RuntimeException(e);\n        } catch (UnsupportedEncodingException e) {\n            throw new RuntimeException(e);\n        }\n    }\n\n    public static String toBase64(byte[] bytes) {\n        return Base64.encodeToString(bytes, Base64.NO_WRAP).trim();\n    }\n\n\n    public static String decrypt(String ciphertext, SecretKey key) {\n        try {\n            byte[] cipherBytes = fromBase64(ciphertext);\n\n                long start = System.currentTimeMillis();\n            Cipher cipher = Cipher.getInstance(CIPHER_ALGORITHM);\n\n            cipher.init(Cipher.DECRYPT_MODE, key);\n            cipher.update(cipherBytes);\n\n             // This is where I get exception\n            byte[] plaintext = cipher.doFinal(cipherBytes);\n\n            String plainrStr = new String(plaintext, \"UTF-8\").trim();\n            long elapsed = System.currentTimeMillis() - start;\n\n            return plainrStr;\n        } catch (GeneralSecurityException e) {\n            throw new RuntimeException(e);\n        } catch (UnsupportedEncodingException e) {\n            throw new RuntimeException(e);\n        }\n    }\n\n    public static byte[] fromBase64(String base64) {\n        return Base64.decode(base64, Base64.NO_WRAP);\n    }\n", "idx": 2183}
{"project": "cipher", "commit_id": "Snippet10709830_35006.java", "target": 0, "func": "Security.addProvider(new BouncyCastleProvider());\n\n    DuncanCipherSecond cipherSecond = new DuncanCipherSecond();\n\n    RSAKeyXMLReader rsaKeyXMLReader = new RSAKeyXMLReader();\n    InputStream inputStream = new ByteArrayInputStream(rsaKeyInXMLString.getBytes());\n    RSAData rsaData = rsaKeyXMLReader.parse(inputStream);\n\n    if (rsaData != null) {\n        byte[] expBytes = Base64.decodeBase64(rsaData.getExponent().trim());\n        byte[] modBytes = Base64.decodeBase64(rsaData.getModulus().trim());\n        byte[] dBytes = Base64.decodeBase64(rsaData.getD().trim());\n\n\n        String nameFromDB = \"8B-FE-BE-28-27-94-0B-32-CE-86-24-9E-F1-DA-86-0F-E1-31-B7-2B-7A-58-2C-E2-3A-6F-05-E9-40-70-48-1D-73-6B-30-E5-95-B9-2A-8A-3F-6E-66-94-DF-8F-7C-11-77-C6-A1-E9-09-04-3B-19-C2-AF-19-CE-EE-22-A3-F9-17-D5-C8-C5-9F-12-F2-C5-72-25-D6-C3-D9-4B-E0-E5-46-19-27-80-9A-11-EC-0F-85-4D-13-0B-94-DB-1B-64-21-95-68-7B-A3-C9-1B-AA-94-E7-26-48-49-BA-CD-97-9D-41-23-1E-B6-F9-26-3C-1E-67-84-98-83-A7-3C-06\";\n        nameFromDB = nameFromDB.replace(\"-\", \"\");\n\n        byte[] newNameFromDB = hexStringToByteArray(nameFromDB);\n\n        BigInteger modules = new BigInteger(1, modBytes);\n        BigInteger exponent = new BigInteger(1, expBytes);\n        BigInteger d = new BigInteger(1, dBytes);\n\n        KeyFactory factory = KeyFactory.getInstance(\"RSA\");\n        Cipher cipher = Cipher.getInstance(\"RSA/None/OAEPWithSHA1AndMGF1Padding\", \"BC\");\n\n        System.out.println(\"\");\n        RSAPrivateKeySpec privSpec = new RSAPrivateKeySpec(modules, d);\n        PrivateKey privKey = factory.generatePrivate(privSpec);\n        cipher.init(Cipher.DECRYPT_MODE, privKey);\n        byte[] decrypted = cipher.doFinal(newNameFromDB);\n        System.out.println(\"decrypted: \" + new String(decrypted));\n", "idx": 1986}
{"project": "cipher", "commit_id": "Snippet3700039_30837.java", "target": 1, "func": "public static byte[] decryptRSA( PrivateKey key, byte[] text) throws Exception\n      { \n          byte[] dectyptedText = null;\n\n          Cipher cipher = Cipher.getInstance(\"RSA/ECB/PKCS1Padding\");\n          cipher.init(Cipher.DECRYPT_MODE, key);\n          dectyptedText = cipher.doFinal(text);\n          return dectyptedText;\n      }\n", "idx": 2654}
{"project": "cipher", "commit_id": "Snippet6252501_32020.java", "target": 1, "func": "final Cipher cipher = Cipher.getInstance(\"AES/CFB/NoPadding\", \"SunJCE\");\nfinal SecretKey skeySpec = KeyGenerator.getInstance(\"AES\")\n        .generateKey();\ncipher.init(Cipher.ENCRYPT_MODE, skeySpec);\nSystem.out.println(Arrays.toString(cipher.doFinal(new byte[] { 0, 1, 2,\n            3 })));\n", "idx": 2392}
{"project": "cipher", "commit_id": "Snippet5136279_31475.java", "target": 0, "func": "SecretKeySpec skeySpec = new SecretKeySpec(key, \"AES\");\ncipher = Cipher.getInstance(\"AES\");\ncipher.init(Cipher.ENCRYPT_MODE, skeySpec );\n", "idx": 1975}
{"project": "cipher", "commit_id": "Snippet1391643_29941.java", "target": 1, "func": "Cipher.getInstance(\"RSA/ECB/nopadding\");", "idx": 2423}
{"project": "cipher", "commit_id": "Snippet9839754_34262.java", "target": 0, "func": "public String decrypt(byte[] pCryptedStringtoDecrypt) throws Exception{\n    byte[] key = {0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0};\n    System.arraycopy(this.passphrase.getBytes(), 0, key, 0, this.passphrase.getBytes().length);\n    SecretKeySpec skeySpec = new SecretKeySpec(key, \"AES\");\n\n    Cipher cipher = Cipher.getInstance(\"AES/ECB/PKCS7Padding\");\n    byte[] encrypted = pCryptedStringtoDecrypt;\n    cipher.init(Cipher.DECRYPT_MODE, skeySpec);\n    byte[] original = cipher.doFinal(encrypted);\n    String originalString = new String(original);\n    return originalString;\n}\n", "idx": 2220}
{"project": "cipher", "commit_id": "Snippet33970325_16032.java", "target": 1, "func": "    byte[] encrypted = getBytesFromInputStream(in);\n\n    String password = \"somepassword\";\n\n    Cipher c = Cipher.getInstance(\"AES/CBC/PKCS5Padding\", \"BC\");\n\n    // Openssl puts SALTED__ then the 8 byte salt at the start of the\n    // file. We simply copy it out.\n    byte[] salt = new byte[8];\n    System.arraycopy(encrypted, 8, salt, 0, 8);\n    SecretKeyFactory fact = SecretKeyFactory.getInstance(\"PBEWITHMD5AND256BITAES-CBC-OPENSSL\", \"BC\");\n    c.init(Cipher.DECRYPT_MODE, fact.generateSecret(new PBEKeySpec(password.toCharArray(), salt, 100)));\n\n    // Decrypt the rest of the byte array (after stripping off the salt)\n    byte[] data = c.doFinal(encrypted, 16, encrypted.length - 16);\n", "idx": 2698}
{"project": "cipher", "commit_id": "Snippet39137994_21015.java", "target": 0, "func": "    MessageDigest md = MessageDigest.getInstance(\"MD5\");\nseed_key = md.digest(new String(key).getBytes());\n\nif (seed_key.length == 16) {\n    byte[] tempkey = new byte[24];\n    System.arraycopy(seed_key, 0, tempkey, 0, 16);\n    System.arraycopy(seed_key, 0, tempkey, 16, 8);\n\n    seed_key = tempkey;\n}\nSecretKeySpec keySpec = new SecretKeySpec(seed_key, \"DESede\");\nnCipher = Cipher.getInstance(\"DESede/CBC/PKCS5Padding\");\nbyte[] IVector = new byte[] { 27, 9, 45, 27, 0, 72, (byte) 171, 54 };\nIvParameterSpec iv = new IvParameterSpec(IVector);\nnCipher.init(Cipher.ENCRYPT_MODE, keySpec, iv);\n\nbyte[] cipherbyte = nCipher.doFinal(data.getBytes());\nencodeTxt = new String(Base64.encodeBase64(cipherbyte));\n", "idx": 2110}
{"project": "cipher", "commit_id": "Snippet6119359_31963.java", "target": 0, "func": "Cipher cipher = Cipher.getInstance(\"BlowFish/ECB/PKCS5Padding\");\n\nbyte[] keyBytes = Encoding.ASCII.GetBytes(key);\n        string keyHex = Hex.ToHexString(keyBytes); //4b334c33315551354f38325059344739\n\n        string parameters = \"{\\\"userId\\\":\\\"6440870\\\"}\";\n        byte[] parametersByte = Encoding.ASCII.GetBytes(parameters);\n        string parametersHex = Hex.ToHexString(parametersByte); //7b22757365724964223a2236343430383730227d\n\n        BlowFish bl = new BlowFish(keyHex);\n        byte[] outputEncryptedByte = bl.Encrypt_ECB(parametersByte);\n        string outputEncrypted = Encoding.ASCII.GetString(outputEncryptedByte); //7lC[t$?mQd?g???kE?W?[?\n        string outputBase64 = System.Convert.\n", "idx": 2170}
{"project": "cipher", "commit_id": "Snippet17952994_1017.java", "target": 0, "func": "package com.nsaers.encryptedsms;\n\nimport java.security.Key;\n\nimport javax.crypto.Cipher;\nimport javax.crypto.spec.SecretKeySpec;\n\npublic class SimpleProtector {\n    private static final String ALGORITHM = \"AES\";\n    private static final byte[] keyValue = new byte[] { 'T', 'h', 'i', 's',\n            'I', 's', 'A', 'S', 'e', 'c', 'r', 'e', 't', 'K', 'e', 'y' };\n\n    public static String encrypt(String valueToEnc) throws Exception {\n        Key key = generateKey();\n        Cipher c = Cipher.getInstance(ALGORITHM);\n        c.init(Cipher.ENCRYPT_MODE, key);\n        byte[] encValue = c.doFinal(valueToEnc.getBytes());\n        String encryptedValue = new BASE64Encoder().encode(encValue);\n        return encryptedValue;\n    }\n\n    public static String decrypt(String encryptedValue) throws Exception {\n        Key key = generateKey();\n        Cipher c = Cipher.getInstance(ALGORITHM);\n        c.init(Cipher.DECRYPT_MODE, key);\n        byte[] decordedValue = new BASE64Decoder().decodeBuffer(encryptedValue);\n        byte[] decValue = c.doFinal(decordedValue);\n        String decryptedValue = new String(decValue);\n        return decryptedValue;\n    }\n\n    private static Key generateKey() throws Exception {\n        Key key = new SecretKeySpec(keyValue, ALGORITHM);\n        // SecretKeyFactory keyFactory =\n        // SecretKeyFactory.getInstance(ALGORITHM);\n        // key = keyFactory.generateSecret(new DESKeySpec(keyValue));\n        return key;\n    }\n}\n", "idx": 2146}
{"project": "cipher", "commit_id": "Snippet6084923_31928.java", "target": 1, "func": "Security.addProvider(new org.bouncycastle.jce.provider.BouncyCastleProvider());\nString password = \"kallisti\"; // only 8, 12, or 16 chars will work as a key\nbyte[] key = password.getBytes(Charset.forName(\"UTF-16LE\"));\nCipher cipher = Cipher.getInstance(\"AES/CBC/PKCS7Padding\", \"BC\");\ncipher.init(Cipher.DECRYPT_MODE, new SecretKeySpec(key, \"AES\"),\n    new IvParameterSpec(key));\nreturn cipher; // then use CipherInputStream(InputStream, Cipher)\n", "idx": 2760}
{"project": "cipher", "commit_id": "Snippet31361403_13490.java", "target": 1, "func": "import java.security.Key;\nimport java.security.KeyPair;\nimport java.security.KeyPairGenerator;\nimport java.security.NoSuchAlgorithmException;\nimport java.security.PrivateKey;\nimport java.security.PublicKey;\nimport java.security.SecureRandom;\nimport javax.crypto.Cipher;\n\npublic class Test {\n\n    private static final String RSA_ECB_PKCS1_PADDING = \"RSA/ECB/PKCS1Padding\";\n\n    public static void main(String[] args) {\n        String data = \"Hello World\";\n\n        KeyPair kp = generateRSAKeyPair();\n\n        PublicKey publicKey = kp.getPublic();\n        PrivateKey privateKey = kp.getPrivate();\n\n        byte[] encryptedValue = encryptRSA(publicKey, data.getBytes());\n        byte[] decrytpedValue = decryptRSA(privateKey, encryptedValue);\n\n        String decryptedData = new String(decrytpedValue);\n\n        System.out.println(decryptedData);\n    }\n\n    public static KeyPair generateRSAKeyPair() {\n        KeyPairGenerator keyGen;\n        try {\n            keyGen = KeyPairGenerator.getInstance(\"RSA\");\n            SecureRandom rnd = new SecureRandom();\n            keyGen.initialize(2048, rnd);\n            KeyPair keyPair = keyGen.genKeyPair();\n            return keyPair;\n        } catch (NoSuchAlgorithmException e) {\n            e.printStackTrace();\n            return null;\n        }\n    }\n\n    public static byte[] encryptRSA(Key key, byte[] data) {\n        byte[] cipherText = null;\n        try {\n            final Cipher cipher = Cipher.getInstance(RSA_ECB_PKCS1_PADDING);\n            cipher.init(Cipher.ENCRYPT_MODE, key);\n            cipherText = cipher.doFinal(data);\n        } catch (Exception e) {\n            e.printStackTrace();\n        }\n        return cipherText;\n    }\n\n    public static byte[] decryptRSA(Key key, byte[] data) {\n        byte[] decryptedText = null;\n        try {\n            final Cipher cipher = Cipher.getInstance(RSA_ECB_PKCS1_PADDING);\n            cipher.init(Cipher.DECRYPT_MODE, key);\n            decryptedText = cipher.doFinal(data);\n        } catch (Exception e) {\n            e.printStackTrace();\n        }\n        return decryptedText;\n    }\n\n}\n", "idx": 2425}
{"project": "cipher", "commit_id": "Snippet22109799_4534.java", "target": 0, "func": "   public static SecretKey generatedessecretkey(String password) throws InvalidKeyException, UnsupportedEncodingException, NoSuchAlgorithmException, InvalidKeySpecException\n      {\n        DESKeySpec keySpec = new DESKeySpec(password.getBytes(\"UTF8\"));\n        SecretKeyFactory keyFactory = SecretKeyFactory.getInstance(\"DES\");\n        SecretKey key = keyFactory.generateSecret(keySpec);\n        return key;\n      }\n\n    public static void encrypt(IOLogger log, byte[] datablock, String grouppw, ArrayList<byte[]> resp)\n      {\n        try\n          {\n            SecretKey ks = generatedessecretkey(grouppw);\n            Cipher cipher = Cipher.getInstance(\"DES\");\n            cipher.init(Cipher.ENCRYPT_MODE, ks);\n            byte[] b = cipher.doFinal(datablock);\n            resp.clear();\n            resp.add(b);\n            return;\n          }\n        catch (Exception e)\n          {\n          }\n      }\n", "idx": 2137}
{"project": "cipher", "commit_id": "Snippet26516035_8663.java", "target": 1, "func": "SecretKeyFactory factory = SecretKeyFactory.getInstance(\"PBKDF2WithHmacSHA1\");\nPBEKeySpec pbeKeySpec = new PBEKeySpec(password, salt, 1000, 384);\nKey secretKey = factory.generateSecret(pbeKeySpec);\nbyte[] key = new byte[32];\nbyte[] iv = new byte[16];\nSystem.arraycopy(secretKey.getEncoded(), 0, key, 0, 32);\nSystem.arraycopy(secretKey.getEncoded(), 32, iv, 0, 16);\n\nSecretKeySpec secret = new SecretKeySpec(key, \"AES\");\nAlgorithmParameterSpec ivSpec = new IvParameterSpec(iv);\nCipher cipher = Cipher.getInstance(\"AES/CBC/PKCS5Padding\");\ncipher.init(Cipher.ENCRYPT_MODE, secret, ivSpec);\nbyte[] result = cipher.doFinal(\"asdfasdf\".getBytes(\"UTF-8\"));\n", "idx": 2364}
{"project": "cipher", "commit_id": "Snippet41193731_23114.java", "target": 1, "func": "public static byte[] encrypt(byte[] data, String pubKey64) {\n\n    try {\n         byte[] key = Toolkit.base64Decode(pubKey64);\n         KeyFactory rsaKeyFac = KeyFactory.getInstance(\"RSA\");\n         X509EncodedKeySpec keySpec = new X509EncodedKeySpec(key);\n         RSAPublicKey pbk = (RSAPublicKey) rsaKeyFac.generatePublic(keySpec);\n         System.out.println(\"MODE:\"+Cipher.ENCRYPT_MODE);\n        Cipher cipher = Cipher.getInstance(\"RSA/ECB/PKCS1PADDING\");\n        cipher.init(Cipher.ENCRYPT_MODE, pbk);\n\n        byte[] encDate = cipher.doFinal(data);\n        return encDate;\n    } catch (Exception e) {\n        e.printStackTrace();\n        return null;\n    }\n}\n", "idx": 2669}
{"project": "cipher", "commit_id": "Snippet11366257_35503.java", "target": 1, "func": "private static byte[] decrypt(byte[] raw, byte[] encrypted) throws Exception {\n    SecretKeySpec skeySpec = new SecretKeySpec(raw, \"AES\");\n    Cipher cipher = Cipher.getInstance(encryptionAlgorithim);\n    cipher.init(Cipher.DECRYPT_MODE, skeySpec, new IvParameterSpec(iVector));\n    byte[] decrypted = cipher.doFinal(encrypted);\n    return decrypted;\n}\n\npublic String decrypt(String encryptedString, String key) {\n\n    byte[] keyBytes = key.getBytes();\n    byte[] decoded = Base64.decode(encryptedString); // Decodes the string from base64 to byte[]\n    byte[] result = decrypt(keyBytes, decoded);\n    return new String(result);\n}\n", "idx": 2406}
{"project": "cipher", "commit_id": "Snippet33818911_15901.java", "target": 0, "func": "public ArrayList<FootballClub> FootBallInputStream() throws FileNotFoundException, IOException, ClassNotFoundException, NoSuchAlgorithmException, NoSuchPaddingException, InvalidKeyException, IllegalBlockSizeException, BadPaddingException {\n\n        File file = new File(\"FootballClub.ser\");\n        fileIn = new FileInputStream(file);\n\n        SecretKey key = KeyGenerator.getInstance(\"AES\").generateKey();\n        Cipher cipher = Cipher.getInstance(\"AES\");\n        cipher.init(Cipher.DECRYPT_MODE, key);\n\n        CipherInputStream cipherIn = new CipherInputStream(fileIn, cipher);\n        in = new ObjectInputStream(cipherIn);\n\n        SealedObject sealed = (SealedObject) in.readObject();\n\n        ArrayList<FootballClub> e = (ArrayList<FootballClub>) sealed.getObject(cipher);\n\n        in.close();\n\n        fileIn.close();\n\n        return e;\n\n    }\n\n    public void FootBallOutputStream(ArrayList<FootballClub> e) throws FileNotFoundException, IOException, NoSuchAlgorithmException, NoSuchPaddingException, InvalidKeyException, IllegalBlockSizeException {\n        File file = new File(\"FootballClub.ser\");\n        fileOut = new FileOutputStream(file);\n\n\n        SecretKey key = KeyGenerator.getInstance(\"AES\").generateKey();\n        Cipher cipher = (Cipher.getInstance(\"AES\"));\n        cipher.init(Cipher.ENCRYPT_MODE, key);\n        SealedObject sealed = new SealedObject(e, cipher);\n\n        CipherOutputStream cipherOut = new CipherOutputStream(fileOut, cipher);\n        out = new ObjectOutputStream(cipherOut);\n        out.writeObject(sealed);\n        out.close();\n        fileOut.close();\n    }\n", "idx": 1943}
{"project": "cipher", "commit_id": "Snippet20655099_3256.java", "target": 1, "func": "public String decryptXml() {\n    String data = null;\n    File file = new File(context.getFilesDir().getParentFile().getPath() + \"/download/\" + id + \"/xmldata.xml\");\n    int size = (int) file.length();\n    byte[] bytes = new byte[size];\n try {\n        SecretKeySpec secretKeySpec = new SecretKeySpec(getSecretKey(context).getEncoded(), \"AES\");\n        Cipher cipher = Cipher.getInstance(\"AES/CBC/PKCS5Padding\");\n        cipher.init(Cipher.DECRYPT_MODE, secretKeySpec, DownloadBookAsyncTask.spec);\n        BufferedInputStream bis = new BufferedInputStream(new FileInputStream(file));\n        bis.read(bytes, 0, bytes.length);\n        bis.close();\n        byte[] decrypted = cipher.doFinal(bytes);\n    }\n", "idx": 2650}
{"project": "cipher", "commit_id": "Snippet9077136_33639.java", "target": 1, "func": "public static String[] decrypt(String input, String key){\n\n    String iv = input.substring(0, 24);\n    String encrypted = input.substring(24);\n    try {\n        IvParameterSpec ips = new IvParameterSpec(Base64.decodeBase64(iv));\n        byte[] keybytes = md5(key);//This isn't final. Don't worry ;)\n        byte[] output = null;\n        SecretKeySpec skey = new SecretKeySpec(keybytes, \"AES\");\n        Cipher cipher = Cipher.getInstance(\"AES/CBC/NoPadding\"); //Change here\n        cipher.init(Cipher.DECRYPT_MODE, skey, ips);\n        output = cipher.doFinal(Base64.decodeBase64(encrypted));\n        if(output==null){\n            throw new Exception();\n        }\n\n        return new String[]{new String(output),iv};\n    }catch(Exception e){\n        e.printStackTrace();\n    }\n}\n", "idx": 2618}
{"project": "cipher", "commit_id": "Snippet29335981_11368.java", "target": 1, "func": "public class AES {\n\nprivate static ArrayList<String> uncryptedArrayList = new ArrayList<>();\nprivate static String pinString;\n\nprivate SecretKeyFactory factory;\nprivate KeySpec spec;\nprivate SecretKey tmp;\nprivate Cipher dcipher;\nprivate byte[] salt, iv, decodedData, decryptedData, pin, pass, encryptedData, encodedData;\nprivate int iterationCount = 1024;\nprivate int keyStrength = 128;\nprivate SecretKey key;\nprivate String magic;\nprivate AlgorithmParameters params;\n\npublic AES() {\n\n    try {\n\n        salt = new String(\"TheBestSaltEvers\").getBytes();\n        magic = new String(\"ABCDEFGHIJKLMNOP\");\n        factory = SecretKeyFactory.getInstance(\"PBKDF2WithHmacSHA1\");\n        spec = new PBEKeySpec(magic.toCharArray(), salt, iterationCount, keyStrength);\n        tmp = factory.generateSecret(spec);\n        key = new SecretKeySpec(tmp.getEncoded(), \"AES\");\n        dcipher = Cipher.getInstance(\"AES/CBC/PKCS5Padding\");\n        params = dcipher.getParameters();\n        iv = params.getParameterSpec(IvParameterSpec.class).getIV();\n\n    } catch (NoSuchAlgorithmException e) {\n        e.printStackTrace();\n    } catch (InvalidKeySpecException e) {\n        e.printStackTrace();\n    } catch (NoSuchPaddingException e) {\n        e.printStackTrace();\n    } catch (InvalidParameterSpecException e) {\n        e.printStackTrace();\n    }\n}\n\npublic byte[] encrypt(String data) {\n\n    try {\n\n        dcipher.init(Cipher.ENCRYPT_MODE, key);\n        encryptedData = dcipher.doFinal(data.getBytes(\"UTF8\"));\n        encodedData = new Base64().encode(encryptedData);\n\n    } catch (InvalidKeyException e) {\n        e.printStackTrace();\n    } catch (IllegalBlockSizeException e) {\n        e.printStackTrace();\n    } catch (BadPaddingException e) {\n        e.printStackTrace();\n    } catch (UnsupportedEncodingException e) {\n        e.printStackTrace();\n    }\n\n    return encodedData;\n}\n\npublic String decrypt(byte[] data) {\n\n    String result = null;\n\n    try {\n\n        dcipher.init(Cipher.DECRYPT_MODE, key, new IvParameterSpec(iv));\n        decodedData = new Base64().decode(data);\n        decryptedData = dcipher.doFinal(decodedData);\n\n        result = new String(decryptedData, \"UTF8\");\n\n    } catch (InvalidKeyException e) {\n        e.printStackTrace();\n    } catch (InvalidAlgorithmParameterException e) {\n        e.printStackTrace();\n    } catch (IllegalBlockSizeException e) {\n        e.printStackTrace();\n    } catch (BadPaddingException e) {\n        e.printStackTrace();\n    } catch (UnsupportedEncodingException e) {\n        e.printStackTrace();\n    }\n\n    return result;\n}\n", "idx": 2580}
{"project": "cipher", "commit_id": "Snippet31018086_13199.java", "target": 0, "func": "public class SampleEncryptor extends SecretKeyWrapper{\nprivate static final SecureRandom RANDOM = new SecureRandom();\n\nprivate SharedPreferences pref;\nprivate SecretKey secretKey;\nprivate byte[] encryptedKey;\n\npublic SampleEncryptor(Context context)\n        throws GeneralSecurityException, IOException {\n    super(context, \"myalias\");\n    this.pref = context.getSharedPreferences(\"mySecretKeyStore\", Context.MODE_PRIVATE);\n    String base64key = pref.getString(\"key\", null);\n    if(base64key==null){\n        this.secretKey = KeyGenerator.getInstance(\"AES\").generateKey();\n        this.encryptedKey = this.wrap(this.secretKey);\n        pref.edit().putString(\"key\", Base64.encodeToString(encryptedKey, Base64.DEFAULT)).commit();\n    }else{\n        this.encryptedKey = Base64.decode(base64key, Base64.DEFAULT);\n        this.secretKey = this.unwrap(this.encryptedKey);\n    }\n}\n\npublic byte[] encrypt(byte[] data) throws GeneralSecurityException{     \n    Cipher cipher = Cipher.getInstance(\"AES\");\n    cipher.init(Cipher.ENCRYPT_MODE, secretKey);\n    return  cipher.doFinal(data);\n}\n\npublic byte[] decrypt(byte[] data) throws GeneralSecurityException{\n    Cipher cipher = Cipher.getInstance(\"AES\");\n    cipher.init(Cipher.DECRYPT_MODE, secretKey);\n    return  cipher.doFinal(data);\n}\n\npublic String encryptBoolean(boolean value) throws GeneralSecurityException{\n    BigInteger i = new BigInteger(128, RANDOM);\n    if(value){\n        i = i.setBit(0);\n    }else{\n        i = i.clearBit(0);\n    }\n    byte[] encrypted =  encrypt(i.toByteArray());\n\n    return Base64.encodeToString(encrypted, Base64.DEFAULT);\n}\n\npublic Boolean decryptBoolean(String encrypted) throws GeneralSecurityException{\n    byte[] data = Base64.decode(encrypted, Base64.DEFAULT);     \n    BigInteger i = new BigInteger(decrypt(data));\n    return i.testBit(0);\n}\n", "idx": 2241}
{"project": "cipher", "commit_id": "Snippet30402135_12568.java", "target": 1, "func": "public static String decrypt(String inputString, byte[] keyBytes) {\n        String resultStr = null;\n        Calendar cal = Calendar.getInstance();\n        int mDay = cal.get(Calendar.DAY_OF_MONTH);\n        Random generator = new Random(mDay);\n        int num = (generator.nextInt()) % 100;\n        String salt = \"qqq\" + num;\n        PrivateKey privateKey = null;\n        try {\n            KeyFactory keyFactory = KeyFactory.getInstance(\"RSA\");\n            EncodedKeySpec privateKeySpec = new PKCS8EncodedKeySpec(keyBytes);\n            privateKey = keyFactory.generatePrivate(privateKeySpec);\n        } catch (Exception e) {\n            System.out.println(\"Exception privateKey:::::::::::::::::  \"\n                    + e.getMessage());\n        }\n        byte[] decodedBytes = null;\n        try {\n            Cipher c = Cipher.getInstance(\"RSA/ECB/PKCS1Padding\");\n            // Cipher c = Cipher.getInstance(\"RSA\");\n            c.init(Cipher.DECRYPT_MODE, privateKey);\n            // decodedBytes = c.doFinal(Base64.decodeBase64(inputString));\n            decodedBytes = c.doFinal(Base64InputStream());\n\n        } catch (Exception e) {\n            System.out.println(\"Exception privateKey1:::::::::::::::::  \"\n                    + e.getMessage());\n            e.printStackTrace();\n        }\n        if (decodedBytes != null) {\n            resultStr = new String(decodedBytes);\n            System.out.println(\"resultStr:::\" + resultStr + \":::::\");\n            resultStr = resultStr.replace(salt, \"\");\n        }\n        return resultStr;\n\n    }\n", "idx": 2422}
{"project": "cipher", "commit_id": "Snippet19760634_2475.java", "target": 0, "func": "static void encrypt(String strInput , String strOutput) throws IOException,\n    NoSuchAlgorithmException,NoSuchPaddingException, InvalidKeyException {\n    FileInputStream fis = new FileInputStream(strInput);\n    FileOutputStream fos = new FileOutputStream(strOutput);\n\n    SecretKeySpec sks = new SecretKeySpec(\"MyDifficultPassw\".getBytes(),\n            \"AES\");\n    Cipher cipher = Cipher.getInstance(\"AES\");\n    cipher.init(Cipher.ENCRYPT_MODE, sks);\n    CipherOutputStream cos = new CipherOutputStream(fos, cipher);\n    int b;\n    byte[] d = new byte[8];\n    while ((b = fis.read(d)) != -1) {\n        cos.write(d, 0, b);\n    }\n    // Flush and close streams.\n    cos.flush();\n    cos.close();\n    fis.close();\n}\n", "idx": 1923}
{"project": "cipher", "commit_id": "Snippet13420065_36947.java", "target": 0, "func": "Cipher localCipher = Cipher.getInstance(\"AES\");", "idx": 1945}
{"project": "cipher", "commit_id": "Snippet6669181_32270.java", "target": 1, "func": "    public class KeyHandler {\n        Scanner scan = new Scanner(System.in);\n\n        public KeyHandler(){\n            try {\n                startMenu();\n            } catch (Exception e) {\n                System.out.println(\"fel n\u00e5gonstanns :)\");\n            }\n        }\n\n        public void startMenu() throws Exception{\n\n            System.out.println(\"Hej. Med detta program kan du generera en hemlig nyckel\"+\"\\n\"+\"Vill du:\"+\"\\n\"+ \"1. Generera en nyckel\"+\"\\n\"+\"2. Avsluta\");\n            int val=Integer.parseInt(scan.nextLine());\n        do{ \n            switch (val){\n            case 1: generateKey(); break;\n            case 2: System.exit(1);\n\n            default: System.out.println(\"Du m\u00e5ste v\u00e4lja val 1 eller 2\");\n            }\n        }\n            while (val!=3);\n        }\n\n        public void generateKey() throws Exception{\n            try {\n                KeyGenerator gen = KeyGenerator.getInstance(\"AES\");\n                gen.init(128);\n\n                SecretKey key=gen.generateKey();\n                byte[] keyBytes = key.getEncoded();\n                System.out.print(\"Ge nyckeln ett filnamn: \");\n                String filename = scan.next();\n                System.out.println(\"Genererar nyckeln...\");\n                FileOutputStream fileOut = new FileOutputStream(filename);\n                fileOut.write(keyBytes);\n                fileOut.close();\n                System.out.println(\"Nyckeln \u00e4r genererad med filnamnet: \"+filename+\"...\");\n                System.exit(1);\n                 } catch (NoSuchAlgorithmException e) {\n                    }\n\n        }\n\n        public static void main(String[] args){\n            new KeyHandler();\n        }\n\n    }\n\n\n    public class EncryptHandler {\n        private String encryptedDataString;\n        private Cipher ecipher; \n\n        AlgorithmParameterSpec paramSpec;\n        byte[] iv;\n\n        public EncryptHandler(String dataString, String secretKey, String encryptedDataString){\n            this.encryptedDataString=encryptedDataString;\n            try {\n                encryptFile(dataString, secretKey);\n            } catch (Exception e) {\n\n            }\n        }\n\n            public void encryptFile(String dataString, String secretKey) throws Exception{\n\n                    FileInputStream fis = new FileInputStream(secretKey);\n                    ByteArrayOutputStream baos = new ByteArrayOutputStream();\n\n                    int theByte = 0;\n                    while ((theByte = fis.read()) != -1)\n                    {\n                      baos.write(theByte);\n                    }\n                    fis.close();\n\n                    byte[] keyBytes = baos.toByteArray();\n                    baos.close();\n                    SecretKeySpec keySpec = new SecretKeySpec(keyBytes, \"AES\");\n\n                try \n                { \n                ecipher = Cipher.getInstance(\"AES/CBC/PKCS5Padding\"); \n                ecipher.init(Cipher.ENCRYPT_MODE, keySpec);     \n\n                } \n                catch (Exception e) \n                    { \n                e.printStackTrace(); \n            } \n\n                System.out.println(\"Encrypting file...\");\n                try \n                { \n\n                    encryptStream(new FileInputStream(dataString),new FileOutputStream(encryptedDataString)); \n                }\n                catch(Exception e){\n                e.printStackTrace();\n                }\n\n                }\n    public void encryptStream(InputStream in, OutputStream out){\n                ByteArrayOutputStream bOut = new ByteArrayOutputStream();\n                byte[] buf = new byte[1024]; \n                try { \n                out = new CipherOutputStream(out, ecipher); \n\n             // read the cleartext and write it to out\n                int numRead = 0; \n                while ((numRead = in.read(buf)) >= 0) {\n                out.write(buf, 0, numRead); \n\n                }\n                bOut.writeTo(out);\n                out.close();\n                bOut.reset();\n\n                } \n                catch (java.io.IOException e) \n                { \n                } \n\n                }\n\n\n        public static void main(String[] args){\n            String data = \"test.txt\";\n            String keyFileName=\"a\";\n            String encryptedFile=\"krypterad.txt\";\n            //String encryptedFile =args[2];\n            new EncryptHandler(data, keyFileName, encryptedFile);\n        }\n\n    }\n\n\npublic class DecryptHandler {\n    public DecryptHandler(){\n\n    try {\n        decryptFile();\n    } catch (Exception e) {\n        System.out.println(\"n\u00e5got gick fel :) \");\n        }\n    }\n\n\n    public void decryptFile()throws Exception{\n        byte[] buf = new byte[1024]; \n        String keyFilename = \"hemlig\";\n        FileInputStream fis = new FileInputStream(keyFilename);\n        ByteArrayOutputStream baos = new ByteArrayOutputStream();\n\n        int theByte = 0;\n        while ((theByte = fis.read()) != -1)\n        {\n          baos.write(theByte);\n        }\n        fis.close();\n\n        byte[] keyBytes = baos.toByteArray();\n        baos.close();\n        SecretKeySpec keySpec = new SecretKeySpec(keyBytes, \"AES\");\n\n\n        Cipher c = Cipher.getInstance(\"AES/CBC/PKCS5Padding\");\n                System.out.println(\"h\u00e4r\");\n        c.init(Cipher.DECRYPT_MODE, keySpec); \n\n        System.out.println(\"Decrypting file...\");\n        try{\n        decryptStream(new FileInputStream(\"krypterad.txt\"),new FileOutputStream(\"Dekryperad.txt\"), c, buf);\n        }\n            catch (java.io.IOException e){\n\n            }\n            System.out.println(\"File decrypted!\");\n        }\n    public void decryptStream(InputStream in, OutputStream out, Cipher dcipher, byte[] buf){\n        try \n        { \n\n        in = new CipherInputStream(in, dcipher); \n\n        // Read in the decrypted bytes and write the cleartext to out \n        int numRead = 0; \n\n\n        while ((numRead = in.read(buf)) >= 0) \n        { \n        out.write(buf, 0, numRead);\n\n        } \n        out.close();\n\n\n        } \n        catch (java.io.IOException e){ \n\n        } \n    } \n    public static void main(String[]args){\n        new DecryptHandler();\n    }\n}\n", "idx": 2630}
{"project": "cipher", "commit_id": "Snippet11187720_35381.java", "target": 1, "func": "SecretKeySpec skeySpec = new SecretKeySpec(getCryptoKeyByteArray(length=16)); \nCipher encryptor = Cipher.getInstance(\"AES/CTR/NoPadding\");\n\n// Initialisation vector:\nbyte[] iv = new byte[encryptor.getBlockSize()];\nSecureRandom.getInstance(\"SHA1PRNG\").nextBytes(iv); // If storing separately\nIvParameterSpec ivParameterSpec = new IvParameterSpec(iv);\n\nencryptor.init(Cipher.ENCRYPT_MODE, skeySpec, ivParameterSpec); \nbyte[] encrypted = encryptor.doFinal(plain); \n", "idx": 2658}
{"project": "cipher", "commit_id": "Snippet1624353_30005.java", "target": 0, "func": "Cipher cip = Cipher.getInstance(\"DES\",\"Sun\")\n", "idx": 2065}
{"project": "cipher", "commit_id": "Snippet12929001_36571.java", "target": 1, "func": "byte[] modulusBytes = Base64.decode(\"zgfXY1oUe4nyndX4qtobP1BMxtJ1/rfKU5csdAcWrSVu6ZaEAX3rL3cWnaSLzX4E1BNjSP9pjge6TH7UoaWqOQ==\");\nbyte[] exponentBytes = Base64.decode(\"AQAB\");\n\nBigInteger modulus = new BigInteger(1, modulusBytes );               \nBigInteger exponent = new BigInteger(1, exponentBytes);\n\nRSAPublicKeySpec rsaPubKey = new RSAPublicKeySpec(modulus, exponent);\n\nKeyFactory fact = KeyFactory.getInstance(\"RSA\");\n\nPublicKey pubKey = fact.generatePublic(rsaPubKey);\n\nCipher cipher = Cipher.getInstance(\"RSA/ECB/PKCS1Padding\");\n\ncipher.init(Cipher.ENCRYPT_MODE, pubKey);\n\nbyte[] plainBytes = new String(\"Admin123\").getBytes(\"UTF-8\");\n\nbyte[] cipherData = cipher.doFinal( plainBytes );\n\nString encryptedString = Base64.encodeBytes(cipherData);\n\nSystem.out.println(URLEncoder.encode(encryptedString));\n", "idx": 2437}
{"project": "cipher", "commit_id": "Snippet42685426_24717.java", "target": 0, "func": "final Cipher cipher = Cipher.getInstance(\"AES\");\n", "idx": 2160}
{"project": "cipher", "commit_id": "Snippet13209169_36779.java", "target": 0, "func": "Cipher.getInstance(\"AES\")", "idx": 2202}
{"project": "cipher", "commit_id": "Snippet46159066_28267.java", "target": 1, "func": "Cipher cipher = Cipher.getInstance(\"RSA/ECB/OAEPWithSHA-256AndMGF1Padding\");\ncipher.init(Cipher.DECRYPT_MODE, this.getPrivateKey(context));\n", "idx": 2561}
{"project": "cipher", "commit_id": "Snippet43415059_25512.java", "target": 0, "func": "Cipher cipher = Cipher.getInstance(\"AES\");\ncipher.init(Cipher.ENCRYPT_MODE, secretKey);\n\nbyte[] stringBytes = message.getBytes(\"UTF8\");\nbyte[] raw = cipher.doFinal(stringBytes);\n\nBASE64Encoder encoder = new BASE64Encoder();\nString base64 = encoder.encode(raw);\nreturn base64;\n", "idx": 1977}
{"project": "cipher", "commit_id": "Snippet18921263_1831.java", "target": 0, "func": "public static String encrypt(String input, String key){\n    byte[] crypted = null;\n    try{\n        SecretKeySpec skey = new SecretKeySpec(key.getBytes(), \"AES\");\n        Cipher cipher = Cipher.getInstance(\"AES/ECB/PKCS5Padding\");\n        cipher.init(Cipher.ENCRYPT_MODE, skey);\n        crypted = cipher.doFinal(input.getBytes());\n    } catch(Exception e) {\n        //Log.e(\"ERR\", e.toString());\n    }\n    return new String(Base64.encode(crypted, Base64.DEFAULT));\n}\n\npublic static String decrypt(String input, String key){\n    byte[] output = null;\n    try{\n        SecretKeySpec skey = new SecretKeySpec(key.getBytes(), \"AES\");\n        Cipher cipher = Cipher.getInstance(\"AES/ECB/PKCS5Padding\");\n        cipher.init(Cipher.DECRYPT_MODE, skey);\n        output = cipher.doFinal(Base64.decode(input, Base64.DEFAULT));\n    } catch(Exception e) {\n    //Log.e(\"ERR\", e.toString());\n    }\n    return new String(output);\n}\n", "idx": 2163}
{"project": "cipher", "commit_id": "Snippet1226083_29894.java", "target": 0, "func": "decryptCipher = Cipher.getInstance(\"AES\");\ndecryptCipher.init(Cipher.DECRYPT_MODE, aesKey);\n", "idx": 1956}
{"project": "cipher", "commit_id": "Snippet17811009_922.java", "target": 1, "func": "public String RSAEncrypt(String plain) throws NoSuchAlgorithmException, NoSuchPaddingException,InvalidKeyException, IllegalBlockSizeException, BadPaddingException, InvalidKeySpecException, UnsupportedEncodingException {\n\n    publicKey = getPublicKey();\n    Cipher cipher = Cipher.getInstance(\"RSA\");\n    cipher.init(Cipher.ENCRYPT_MODE, publicKey);\n    byte[] cipherData = cipher.doFinal(plain.getBytes());\n    return Base64.encodeToString(cipherData, Base64.DEFAULT);\n}\n\npublic String RSADecrypt(byte[] encryptedBytes) throws NoSuchAlgorithmException, NoSuchPaddingException,InvalidKeyException, IllegalBlockSizeException, BadPaddingException, InvalidKeySpecException, UnsupportedEncodingException {\n\n    privateKey = getPrivateKey();\n    Cipher cipher = Cipher.getInstance(\"RSA\");\n    cipher.init(Cipher.DECRYPT_MODE, privateKey);      \n    byte[] cipherData = cipher.doFinal(encryptedBytes);\n    return Base64.encodeToString(cipherData, Base64.DEFAULT);\n}\n", "idx": 2729}
{"project": "cipher", "commit_id": "Snippet44691029_26781.java", "target": 1, "func": "KeyPairGenerator kpg = KeyPairGenerator.getInstance(\"RSA\", \"BC\");\nkpg.initialize(1024, new SecureRandom());\nKeyPair kp = kpg.generateKeyPair();\nPrivateKey privateKey = kp.getPrivate();\nbyte[] encryptedBytes = \"SAMPLE\".getBytes();\nCipher cipher = Cipher.getInstance(\"RSA\");\ncipher.init(Cipher.DECRYPT_MODE, privateKey);\nbyte[] decryptedBytes = cipher.doFinal(encryptedBytes);\n", "idx": 2518}
{"project": "cipher", "commit_id": "Snippet27785263_9951.java", "target": 0, "func": "import java.io.UnsupportedEncodingException;\nimport java.security.MessageDigest;\nimport java.security.NoSuchAlgorithmException;\nimport java.util.Arrays;\nimport javax.crypto.Cipher;\nimport javax.crypto.spec.SecretKeySpec;\nimport org.apache.commons.codec.binary.Base64;\n/**\nAes encryption\n*/\npublic class AES\n{\n\n    private static SecretKeySpec secretKey ;\n    private static byte[] key ;\n\n    private static String decryptedString;\n    private static String encryptedString;\n\n    public static void setKey(String myKey){\n\n\n        MessageDigest sha = null;\n        try {\n            key = myKey.getBytes(\"UTF-8\");\n            System.out.println(key.length);\n            sha = MessageDigest.getInstance(\"SHA-1\");\n            key = sha.digest(key);\n            key = Arrays.copyOf(key, 16); // use only first 128 bit\n            System.out.println(key.length);\n            System.out.println(new String(key,\"UTF-8\"));\n            secretKey = new SecretKeySpec(key, \"AES\");\n\n\n        } catch (NoSuchAlgorithmException e) {\n            // TODO Auto-generated catch block\n            e.printStackTrace();\n        } catch (UnsupportedEncodingException e) {\n            // TODO Auto-generated catch block\n            e.printStackTrace();\n        }\n\n\n\n    }\n\n    public static String getDecryptedString() {\n        return decryptedString;\n    }\n    public static void setDecryptedString(String decryptedString) {\n        AES.decryptedString = decryptedString;\n    }\n    public static String getEncryptedString() {\n        return encryptedString;\n    }\n    public static void setEncryptedString(String encryptedString) {\n        AES.encryptedString = encryptedString;\n    }\n    public static String encrypt(String strToEncrypt)\n    {\n        try\n        {\n            Cipher cipher = Cipher.getInstance(\"AES/ECB/PKCS5Padding\");\n\n            cipher.init(Cipher.ENCRYPT_MODE, secretKey);\n\n\n            setEncryptedString(Base64.encodeBase64String(cipher.doFinal(strToEncrypt.getBytes(\"UTF-8\"))));\n\n        }\n        catch (Exception e)\n        {\n\n            System.out.println(\"Error while encrypting: \"+e.toString());\n        }\n        return null;\n    }\n    public static String decrypt(String strToDecrypt)\n    {\n        try\n        {\n            Cipher cipher = Cipher.getInstance(\"AES/ECB/PKCS5PADDING\");\n\n            cipher.init(Cipher.DECRYPT_MODE, secretKey);\n            setDecryptedString(new String(cipher.doFinal(Base64.decodeBase64(strToDecrypt))));\n\n        }\n        catch (Exception e)\n        {\n\n            System.out.println(\"Error while decrypting: \"+e.toString());\n        }\n        return null;\n    }\n    public static void main(String args[])\n    {\n                final String strToEncrypt = \"My text to encrypt\";\n                final String strPssword = \"encryptor key\";\n                AES.setKey(strPssword);\n\n                AES.encrypt(strToEncrypt.trim());\n\n                System.out.println(\"String to Encrypt: \" + strToEncrypt); \n                System.out.println(\"Encrypted: \" + AES.getEncryptedString());\n\n                final String strToDecrypt =  AES.getEncryptedString();\n                AES.decrypt(strToDecrypt.trim());\n\n                System.out.println(\"String To Decrypt : \" + strToDecrypt);\n                System.out.println(\"Decrypted : \" + AES.getDecryptedString());\n\n    }\n\n}\n", "idx": 1981}
{"project": "cipher", "commit_id": "Snippet43528181_25672.java", "target": 1, "func": "public class Encryptor {\n  public static String encrypt(String key, String initVector, String value) {\n    try {\n      IvParameterSpec iv = new IvParameterSpec(initVector.getBytes(\"UTF-8\"));\n      SecretKeySpec skeySpec = new SecretKeySpec(key.getBytes(\"UTF-8\"), \"AES\");\n\n      Cipher cipher = Cipher.getInstance(\"AES/CTR/PKCS5PADDING\");\n      cipher.init(Cipher.ENCRYPT_MODE, skeySpec, iv);\n\n      byte[] encrypted = cipher.doFinal(value.getBytes());\n      return DatatypeConverter.printHexBinary(encrypted);\n    }\n    catch (Exception ex) {\n      throw new RuntimeException(ex);\n    }\n  }\n\n  public static String decrypt(String key, String initVector, String encrypted) {\n    try {\n      IvParameterSpec iv = new IvParameterSpec(initVector.getBytes(\"UTF-8\"));\n      SecretKeySpec skeySpec = new SecretKeySpec(key.getBytes(\"UTF-8\"), \"AES\");\n\n      Cipher cipher = Cipher.getInstance(\"AES/CTR/PKCS5PADDING\");\n      cipher.init(Cipher.DECRYPT_MODE, skeySpec, iv);\n\n      byte[] decrypted = cipher.doFinal(DatatypeConverter.parseHexBinary(encrypted));\n      return new String(decrypted);\n    }\n    catch (Exception ex) {\n      ex.printStackTrace();\n    }\n\n    return null;\n  }\n\n  public static void main(String[] args) {\n    String key = \"Bar12345Bar12345\"; // 128 bit key\n    String initVector = \"RandomInitVector\"; // 16 bytes IV\n\n    System.out.println(decrypt(key, initVector,\n        encrypt(key, initVector, \"Hello World\")));\n    for (int i = 0; i < 1000; ++i) {\n      String encrypted = encrypt(key, initVector, StringUtils.leftPad(\"\" + i, 3, '0'));\n      String decrypted = decrypt(key, initVector, encrypted);\n      int encLen = encrypted.length();\n      System.out.println(\"i = \" + i + \": enc='\" + encrypted + \"', dec='\" + decrypted + \"', length=\" + encLen);\n    }\n  }\n}\n", "idx": 2556}
{"project": "cipher", "commit_id": "Snippet27885726_10042.java", "target": 1, "func": "Cipher cipher = Cipher.getInstance(\"RSA/ECB/PKCS1Padding\");\n", "idx": 2468}
{"project": "cipher", "commit_id": "Snippet14128072_37489.java", "target": 1, "func": "public static void main(String[] args) throws Exception {\n    SecureRandom secRandom = SecureRandom.getInstance(\"SHA1PRNG\");\n    KeyGenerator kg = KeyGenerator.getInstance(\"AES\");\n    kg.init(128, secRandom);\n    Key secretKey = kg.generateKey();\n    Cipher AESCipher = Cipher.getInstance(\"AES/CBC/PKCS5Padding\");\n    AESCipher.init(Cipher.ENCRYPT_MODE, secretKey, secRandom);\n    IvParameterSpec iv = new IvParameterSpec(AESCipher.getIV());\n    AESCipher = Cipher.getInstance(\"AES/CBC/PKCS5Padding\");\n    AESCipher.init(Cipher.DECRYPT_MODE, secretKey,iv, secRandom);\n}\n", "idx": 2488}
{"project": "cipher", "commit_id": "Snippet21190413_3733.java", "target": 0, "func": "import java.io.UnsupportedEncodingException;\nimport java.security.GeneralSecurityException;\n\nimport android.util.Base64\n\nimport javax.crypto.Cipher;\nimport javax.crypto.SecretKey;\nimport javax.crypto.SecretKeyFactory;\nimport javax.crypto.spec.DESKeySpec;\n\npublic class EncryptDecryptTest {\n\n  public static void main(String[] args) throws Exception {\n    String key = \"12345678\";\n    String ciphertext = encrypt(key, \"foo\");\n\n    String decrypted = decrypt(key, ciphertext.trim());\n    String encrypted = encrypt(key, decrypted.trim());\n\n    if (ciphertext.contentEquals(encrypted.trim())) {\n      System.out.println(\"decrypted!\");\n    } else {\n      System.out.println(\"wrong key!\");\n    }\n  }\n\n  public static String encrypt(String key, String data)\n      throws GeneralSecurityException, UnsupportedEncodingException {\n    DESKeySpec desKeySpec = new DESKeySpec(key.getBytes(\"UTF8\"));\n    SecretKeyFactory secretKeyFactory = SecretKeyFactory.getInstance(\"DES\");\n    SecretKey secretKey = secretKeyFactory.generateSecret(desKeySpec);\n    byte[] dataBytes = data.getBytes(\"UTF8\");\n    Cipher cipher = Cipher.getInstance(\"DES\");\n    cipher.init(Cipher.ENCRYPT_MODE, secretKey);\n    return Base64.encodeToString(cipher.doFinal(dataBytes), Base64.DEFAULT);\n  }\n\n  public static String decrypt(String key, String data)\n      throws GeneralSecurityException, UnsupportedEncodingException {\n    byte[] dataBytes = Base64.decode(data, Base64.DEFAULT);\n    DESKeySpec desKeySpec = new DESKeySpec(key.getBytes(\"UTF8\"));\n    SecretKeyFactory secretKeyFactory = SecretKeyFactory.getInstance(\"DES\");\n    SecretKey secretKey = secretKeyFactory.generateSecret(desKeySpec);\n    Cipher cipher = Cipher.getInstance(\"DES\");\n    cipher.init(Cipher.DECRYPT_MODE, secretKey);\n    byte[] dataBytesDecrypted = (cipher.doFinal(dataBytes));\n    return new String(dataBytesDecrypted);\n  }    \n}\n", "idx": 2218}
{"project": "cipher", "commit_id": "Snippet18852299_1760.java", "target": 1, "func": "public static String enc(String message) {\n\n    byte[] keyInBytes = KEY.getBytes();\n    byte[] encryptedData = null;\n    KeyGenerator kgen;\n    try {\n        kgen = KeyGenerator.getInstance(\"AES\");\n        SecureRandom secureRandom = SecureRandom.getInstance(\"SHA1PRNG\");\n        secureRandom.setSeed(keyInBytes);\n\n        kgen.init(256, secureRandom);\n\n        SecretKey skey = kgen.generateKey();\n\n        key = skey.getEncoded();\n\n        try {\n            encryptedData = encrypt(key, message.getBytes());\n            Log.w(\"ENC \", new String(encryptedData));\n        } catch (Exception e) {\n            // TODO Auto-generated catch block\n            e.printStackTrace();\n        }\n\n    } catch (NoSuchAlgorithmException e1) {\n        // TODO Auto-generated catch block\n        e1.printStackTrace();\n    }\n\n    return Base64.encodeToString(encryptedData, Base64.DEFAULT);\n\n    // return message;\n}\n\nprivate static byte[] encrypt(byte[] raw, byte[] testMessage)\n        throws Exception {\n    SecretKeySpec skeySpec = new SecretKeySpec(raw, /* \"PBEWithSHA1And128BitAES-CBC-BC\" */\n    \"AES\");\n    final byte[] iv = KEY.getBytes();\n\n    IvParameterSpec ivParameterSpec = new IvParameterSpec(iv);\n\n    Cipher cipher = Cipher.getInstance(\"AES/CBC/PKCS7Padding\");\n\n    cipher.init(Cipher.ENCRYPT_MODE, skeySpec, ivParameterSpec);\n    byte[] encrypted = cipher.doFinal(testMessage);\n    try {\n        decrypt(raw, encrypted);\n    } catch (Exception e) {\n        e.getMessage();\n        // TODO: handle exception\n    }\n    return encrypted;\n}\n", "idx": 2544}
{"project": "cipher", "commit_id": "Snippet23208113_5563.java", "target": 1, "func": "final Provider bc = new BouncyCastleProvider();\n\n// generating the key from modulus & private exponent\nKeyFactory rsaFactory = KeyFactory.getInstance(\"RSA\", bc);\nRSAPrivateKeySpec spec = new RSAPrivateKeySpec(key.getModulus(), key.getPrivateExponent());\nRSAPrivateKey testKey = (RSAPrivateKey) rsaFactory.generatePrivate(spec);\n\n// using it in a raw cipher\nCipher c= Cipher.getInstance(\"RSA/ECB/NoPadding\", bc);\nc.init(Cipher.DECRYPT_MODE, testKey);\nc.doFinal(new byte[] {(byte) 0x7F, (byte) 0xFF, (byte) 0xFF, (byte) 0xFF, (byte) 0xFF, (byte) 0xFF, (byte) 0xFF, (byte) 0xFF, });\n", "idx": 2604}
{"project": "cipher", "commit_id": "Snippet30396370_12482.java", "target": 1, "func": "public static byte[] RSAEncrypt(byte[] data) {\nbyte[] cipherData = null;\ntry {\nPublicKey pubKey = readKeysFromFile();\nCipher cipher = Cipher.getInstance(\"RSA\");\ncipher.init(Cipher.ENCRYPT_MODE, pubKey);\ncipherData = cipher.doFinal(data);\n}\ncatch (Exception e) {}\n\nreturn cipherData;\n}\n", "idx": 2503}
{"project": "cipher", "commit_id": "Snippet23885234_6186.java", "target": 1, "func": "public static byte[] encrypt(SecretKey secret, byte[] buffer) throws NoSuchAlgorithmException, NoSuchPaddingException, InvalidKeyException, InvalidParameterSpecException, IllegalBlockSizeException, BadPaddingException, UnsupportedEncodingException\n{\n    /* Encrypt the message. */\n    cipher = Cipher.getInstance(\"AES/CTR/NoPadding\");\n    cipher.init(Cipher.ENCRYPT_MODE, secret);\n    byte[] ciphertext = cipher.doFinal(buffer);\n\n    return ciphertext;\n}\n\npublic static byte[] decrypt(SecretKey secret, byte[] buffer) throws NoSuchAlgorithmException, NoSuchPaddingException, InvalidKeyException, InvalidParameterSpecException, IllegalBlockSizeException, BadPaddingException, UnsupportedEncodingException\n{\n    /* Decrypt the message. - use cipher instance created at encrypt */\n    cipher.init(Cipher.DECRYPT_MODE, secret);\n    byte[] clear = cipher.doFinal(buffer);\n\n    return clear;\n}\n", "idx": 2615}
{"project": "cipher", "commit_id": "Snippet18319769_1367.java", "target": 0, "func": "public class CryptClass\n{\n\n    public byte[] encrypt(String seed, byte[] cleartext) throws Exception\n    {\n\n        byte[] rawKey = getRawKey(seed.getBytes());\n        byte[] result = encrypt(rawKey, cleartext);\n        //  return toHex(result);\n        return result;\n    }\n\n    public byte[] decrypt(String seed, byte[] encrypted) throws Exception\n    {\n        byte[] rawKey = getRawKey(seed.getBytes());\n        byte[] enc = encrypted;\n        byte[] result = decrypt(rawKey, enc);\n\n        return result;\n    }\n\n    //done\n    private byte[] getRawKey(byte[] seed) throws Exception\n    {\n        KeyGenerator kgen = KeyGenerator.getInstance(\"AES\");\n        SecureRandom sr = SecureRandom.getInstance(\"SHA1PRNG\");\n        sr.setSeed(seed);\n        kgen.init(128, sr);\n        SecretKey skey = kgen.generateKey();\n        byte[] raw = skey.getEncoded();\n        return raw;\n    }\n\n    private byte[] encrypt(byte[] raw, byte[] clear) throws Exception\n    {\n        SecretKeySpec skeySpec = new SecretKeySpec(raw, \"AES\");\n        Cipher cipher = Cipher.getInstance(\"AES\");\n        cipher.init(Cipher.ENCRYPT_MODE, skeySpec);\n        byte[] encrypted = cipher.doFinal(clear);\n        return encrypted;\n    }\n\n    private byte[] decrypt(byte[] raw, byte[] encrypted) throws Exception\n    {\n        SecretKeySpec skeySpec = new SecretKeySpec(raw, \"AES\");\n        Cipher cipher = Cipher.getInstance(\"AES\");\n        cipher.init(Cipher.DECRYPT_MODE, skeySpec);\n        byte[] decrypted = cipher.doFinal(encrypted);\n        return decrypted;\n    }\n}\n", "idx": 2165}
{"project": "cipher", "commit_id": "Snippet16722684_120.java", "target": 1, "func": "Cipher.getInstance(\"AES/CBC/ZeroPadding\")", "idx": 2740}
{"project": "cipher", "commit_id": "Snippet40427139_22295.java", "target": 1, "func": "import javax.crypto.*;\nimport javax.crypto.spec.*;\nimport java.security.SecureRandom;\nimport java.util.Scanner;\nimport java.security.spec.*;\nimport java.security.AlgorithmParameters;\nimport javax.crypto.SecretKeyFactory.*;\n\nclass AES\n{\n    static public String encrypt(String input, String password)\n    {\n        SecureRandom random = new SecureRandom();\n        byte salt[] = new byte[8];\n        random.nextBytes(salt);\n\n        SecretKeyFactory factory = SecretKeyFactory.getInstance(\"PBKDF2WithHmacSHA1\");\n        KeySpec spec = new PBEKeySpec(password.toCharArray(), salt, 65536, 256);\n        SecretKey tmp = factory.generateSecret(spec);\n        SecretKey secret = new SecretKeySpec(tmp.getEncoded(), \"AES\");\n\n        Cipher cipher = Cipher.getInstance(\"AES/CBC/PKCS5Padding\");\n        cipher.init(Cipher.ENCRYPT_MODE, secret);\n        AlgorithmParameters params = cipher.getParameters();\n        byte[] iv = params.getParameterSpec(IvParameterSpec.class).getIV();\n        byte[] ciphertext = cipher.doFinal(input.getBytes(\"UTF-8\"));\n\n        String text = new String(ciphertext, \"UTF-8\");\n        return text;\n    }\n}\n", "idx": 2552}
{"project": "cipher", "commit_id": "Snippet29671662_11734.java", "target": 1, "func": "public static void main(String[] args) throws UnsupportedEncodingException {\n            String KEY = \"AB1CD237690AF13B6721AD237A\";\n            String IV = \"por874hyufijdue7w63ysxwet4320o90\";\n            SecretKeySpec key = generateKey(KEY);\n            String message = \"password\";\n\n            final Cipher cipher = Cipher.getInstance(\"AES/CBC/PKCS5Padding\");\n            IvParameterSpec ivSpec = new IvParameterSpec(IV.getBytes());\n            cipher.init(Cipher.ENCRYPT_MODE, key, ivSpec);\n            byte[] ciphedText = cipher.doFinal(message.getBytes());\n            String encoded = Base64.encodeBase64String(ciphedText);\n\n            System.out.println(\"ENCRYPTED text= \" + encoded);\n}\n\npublic  static SecretKeySpec generateKey(final String password) throws NoSuchAlgorithmException, UnsupportedEncodingException {\n        final MessageDigest digest = MessageDigest.getInstance(\"MD5\");\n        byte[] bytes = password.getBytes(\"UTF-8\");\n        digest.update(bytes, 0, bytes.length);\n        byte[] key = digest.digest();       \n        SecretKeySpec secretKeySpec = new SecretKeySpec(key, \"AES\");\n        return secretKeySpec;\n    }\n", "idx": 2484}
{"project": "cipher", "commit_id": "Snippet21805065_4219.java", "target": 1, "func": " public static Serializable AESObjectDedcoder(String password, String path) {\n        Cipher cipher = null;\n        Serializable userList = null;\n        cipher = Cipher.getInstance(\"AES/CBC/PKCS7Pdding\");\n\n        //Code to write your object to file\n        cipher.init(Cipher.DECRYPT_MODE, fromStringToAESkey(password));         \n        CipherInputStream cipherInputStream = null;\n        cipherInputStream = new CipherInputStream(new BufferedInputStream(new FileInputStream(path)), cipher);\n\n        ObjectInputStream inputStream = null;\n        inputStream = new ObjectInputStream(cipherInputStream);\n        SealedObject sealedObject = null;\n        sealedObject = (SealedObject) inputStream.readObject();\n        userList = (Serializable) sealedObject.getObject(ciper);  \n        return userList;\n    }\n", "idx": 2633}
{"project": "cipher", "commit_id": "Snippet17790868_910.java", "target": 1, "func": "//get private key \nString privateKeyString = \"MIICWwIBAAKBgQDVIJ8H3Oszc5fWdgpwymWksF1WxkXJHIfdS6Ta1bHeqwEzPIkN f3iVk14LfaoSZpRb9Yvi/jvkXxIzJbHq6aKfnQOC6tKIiixvVvpCfxr1eV4urDdz H9RNy9bqGdXzTQdgQi+KRx0Dcy9RNsl7ZGLAGrUFRnPI4GTdH+7wm4QogQIDAQAB AoGAcUcKX7KC7HDm5h0NRY+94H/AzItLsi3Q5MT81Tc5d+EqHSJysdLrs4yFMtRS 3b7Z4dqrxDVefe4uDTNe0j3lqboKz8oKwAU+paKx3wubHb7aeQnfzwM9mPQJHgEO zBjlvbL4oEa/gklu3VohZAc1daqpPajdWuOQQp4S+jUllrECQQDrITlSjvkxt8ud /vYIcEXHew3iW4nzaAH3z4PRAGZofRpk/OusGZ6cdZoYMTZcdxYTCCbZ5eeyGukW 5QCadie1AkEA6Atx8Z0F7WhLI2lGvCGy+vIOL0vBDZSma0cvLYLAXMx8duoWQ9J2 LwT7SsnRXMeq/8wlNHL7mFEf+YFZBKKlHQJAO78kfrr/zUdjwREBWaGVyZuWKpeS FTyvi1W6rAgK/bAUXeb6x69241DqyAzxQEuuW0WuAZ5u4o39/qhQH++4JQJAAepe RW1TaDNNM3yh/dmVXabz4QYSEOeiPA55YDnNFrcFbAHgryyklxzGakaiOM7ZJYVs 5TLxyr8YsXmU34nsLQJALzC8CaFXJcnU0+6+KoKX7iq1aP3X4LgP4Gianix6pfRo aV8UHnfFLRSgPdn1ZYmKtJfnsJXJYoE+o9xEErb5EQ==\";\n\n// converts the String to a PublicKey instance\nKeyFactory keyFactory = KeyFactory.getInstance(\"RSA\");\nPrivateKey key = keyFactory.generatePrivate(new PKCS8EncodedKeySpec(Base64.decode(privateKeyString.toString(), Base64.DEFAULT)));\n\n// encrypts the message\nCipher cipher = Cipher.getInstance(\"RSA\");\ncipher.init(Cipher.ENCRYPT_MODE, key);\nbyte[] encrpytedText = cipher.doFinal(Base64.encode(phoneUid.getBytes(\"CP1252\"), Base64.DEFAULT));\ndata = new String(encrpytedText, \"CP1252\");\n", "idx": 2391}
{"project": "cipher", "commit_id": "Snippet11143705_35357.java", "target": 0, "func": "try {\n        Cipher cipher = Cipher.getInstance(\"DESEDE/ECB/PKCS5Padding\");\n        SecretKeySpec myKey = new SecretKeySpec(hash,\"DESede\");\n\n        cipher.init(Cipher.ENCRYPT_MODE, myKey);\n\n        try {\n            byte[] encryptedPlainText = cipher.doFinal(plaintextByte);\n\n            encrypted = Base64.encodeToString(encryptedPlainText, 0); \n            Log.i(\"ENCRYPT\", \"Pwd encrypted: \"+encrypted);\n            return encrypted;\n\n        } catch (IllegalBlockSizeException e) {\n            // TODO Auto-generated catch block\n            e.printStackTrace();\n        } catch (BadPaddingException e) {\n            // TODO Auto-generated catch block\n            e.printStackTrace();\n        }\n\n    } catch (NoSuchAlgorithmException e) {\n        // TODO Auto-generated catch block\n        e.printStackTrace();\n    } catch (NoSuchPaddingException e) {\n        // TODO Auto-generated catch block\n        e.printStackTrace();\n    } catch (InvalidKeyException e) {\n        // TODO Auto-generated catch block\n        e.printStackTrace();\n    }       \n", "idx": 2018}
{"project": "cipher", "commit_id": "Snippet23190431_5528.java", "target": 1, "func": "import java.security.*;\nimport javax.crypto.*;\nimport javax.crypto.spec.*;\n\npublic class AESKeGenFromRSA\n{\npublic static void main(String[] args)\n{\n    try\n    {\n        // Generate RSA KeyPair for Alice\n        Cipher alice_rsa = Cipher.getInstance(\"RSA/ECB/PKCS1Padding\");\n        // Get RSA KeyPairGenerator Object Instance\n        KeyPairGenerator alice_gen = KeyPairGenerator.getInstance(\"RSA\");\n        // Generate RSA Assymetric KeyPair\n        KeyPair alice_pair = alice_gen.generateKeyPair();\n        // Extract Public Key\n        PublicKey alice_pub = alice_pair.getPublic();\n        // Extract Private Key\n        PrivateKey alice_pvt = alice_pair.getPrivate();\n\n        System.out.println();\n        System.out.println(\"Alice Public: \" + alice_pub);\n        System.out.println();\n        System.out.println(\"Alice Private: \" + alice_pvt);\n\n        // Generate RSA KeyPair for Bob\n        Cipher bob_rsa = Cipher.getInstance(\"RSA/ECB/PKCS1Padding\");\n        // Get RSA KeyPairGenerator Object Instance\n        KeyPairGenerator bob_gen = KeyPairGenerator.getInstance(\"RSA\");\n        // Generate RSA Assymetric KeyPair\n        KeyPair bob_pair = bob_gen.generateKeyPair();\n        // Extract Public Key\n        PublicKey bob_pub = bob_pair.getPublic();\n        // Extract Private Key\n        PrivateKey bob_pvt = bob_pair.getPrivate();\n\n        System.out.println();\n        System.out.println(\"Bob Public: \" + bob_pub);\n        System.out.println();\n        System.out.println(\"Bob Private: \" + bob_pvt);\n\n        // Create KeyAgreement for Alice\n        KeyAgreement alice_agreement =     KeyAgreement.getInstance(\"DiffieHellman\");\n        alice_agreement.init(alice_pvt);\n        alice_agreement.doPhase(bob_pub, true);\n        byte[] alice_secret = alice_agreement.generateSecret();\n        SecretKeySpec alice_aes = new SecretKeySpec(alice_secret, \"AES\");\n\n        // Create KeyAgreement for Bob\n        KeyAgreement bob_agreement = KeyAgreement.getInstance(\"DiffieHellman\");\n        bob_agreement.init(bob_pvt);\n        bob_agreement.doPhase(alice_pub, true);\n        byte[] bob_secret = bob_agreement.generateSecret();\n        SecretKeySpec bob_aes = new SecretKeySpec(bob_secret, \"AES\");\n\n        System.out.println();\n        System.out.println(alice_aes.equals(bob_aes));\n    }\n    catch (NoSuchAlgorithmException e)\n    {e.printStackTrace();}\n    catch (NoSuchPaddingException e)\n    {e.printStackTrace();}\n    catch (InvalidKeyException e)\n    {e.printStackTrace();}\n}\n}\n", "idx": 2742}
{"project": "cipher", "commit_id": "Snippet28154780_10319.java", "target": 0, "func": "package test;\n\nimport java.io.FileInputStream;\nimport java.io.FileOutputStream;\nimport java.io.IOException;\nimport java.security.InvalidKeyException;\nimport java.security.MessageDigest;\nimport java.security.NoSuchAlgorithmException;\nimport java.util.Arrays;\n\nimport javax.crypto.Cipher;\nimport javax.crypto.CipherInputStream;\nimport javax.crypto.CipherOutputStream;\nimport javax.crypto.NoSuchPaddingException;\nimport javax.crypto.spec.SecretKeySpec;\n\npublic class TestCrypt{\n\n    private static final String salt = \"t784\";\n    private static final String cryptPassword = \"873147cbn9x5'2 79'79314\";\n    private static final String fileToBeCrypted = \"c:\\\\Temp\\\\sampleFile.conf\";\n    private static final String fileToBeDecrypted = \"c:\\\\Temp\\\\sampleFile.conf.crypt\";\n    private static final String fileDecryptedOutput = \"c:\\\\Temp\\\\sampleFile.conf.decrypted\";\n\n    public static void main(String[] args) throws Exception\n    {\n        for (int i=0; i<100; i++)\n        {\n            encryptfile(fileToBeCrypted, cryptPassword);\n            decrypt(fileToBeDecrypted, cryptPassword, fileDecryptedOutput);\n            System.out.println(i);\n        }\n    }\n\n    public static void encryptfile(String path,String password) throws IOException, NoSuchAlgorithmException, NoSuchPaddingException, InvalidKeyException {\n        FileInputStream fis = new FileInputStream(path);\n        FileOutputStream fos = new FileOutputStream(path.concat(\".crypt\"));\n        byte[] key = (salt + password).getBytes(\"UTF-8\");\n        MessageDigest sha = MessageDigest.getInstance(\"SHA-1\");\n        key = sha.digest(key);\n        key = Arrays.copyOf(key,16);\n        SecretKeySpec sks = new SecretKeySpec(key, \"AES\");\n        Cipher cipher = Cipher.getInstance(\"AES\");\n        cipher.init(Cipher.ENCRYPT_MODE, sks);\n        CipherOutputStream cos = new CipherOutputStream(fos, cipher);\n        int b;\n        byte[] d = new byte[8];\n        while((b = fis.read(d)) != -1) {\n            cos.write(d, 0, b);\n        }\n        cos.flush();\n        cos.close();\n        fis.close();\n    }\n\n    public static void decrypt(String path,String password, String outPath) throws IOException, NoSuchAlgorithmException, NoSuchPaddingException, InvalidKeyException {\n        FileInputStream fis = new FileInputStream(path);\n        FileOutputStream fos = new FileOutputStream(outPath);\n        byte[] key = (salt + password).getBytes(\"UTF-8\");\n        MessageDigest sha = MessageDigest.getInstance(\"SHA-1\");\n        key = sha.digest(key);\n        key = Arrays.copyOf(key,16);\n        SecretKeySpec sks = new SecretKeySpec(key, \"AES\");\n        Cipher cipher = Cipher.getInstance(\"AES\");\n        cipher.init(Cipher.DECRYPT_MODE, sks);\n        CipherInputStream cis = new CipherInputStream(fis, cipher);\n        int b;\n        byte[] d = new byte[8];\n        while((b = cis.read(d)) != -1) {\n            fos.write(d, 0, b);\n        }\n        fos.flush();\n        fos.close();\n        cis.close();\n    }\n\n}\n", "idx": 1979}
{"project": "cipher", "commit_id": "Snippet43566912_25725.java", "target": 1, "func": " public static String decryptPrivateKey(String privateKeyFilename) throws Exception {\n    String password = getPassword();\n\n    String fileExtension = privateKeyFilename.substring(privateKeyFilename.lastIndexOf(\".\"), privateKeyFilename.length());\n    String decryptedFilename = privateKeyFilename.replace(fileExtension, \"\") + \" decrypted\" + fileExtension;\n\n    FileOutputStream output = new FileOutputStream(decryptedFilename);\n    FileInputStream privateKeyInput = new FileInputStream(privateKeyFilename);\n\n    byte[] nonce = new byte[12];\n    int nonceLen = privateKeyInput.read(nonce, 0, 11);\n    System.out.print(nonceLen);\n    byte[] bytes = new byte[1024];\n    int num = privateKeyInput.read(bytes);\n\n    SecretKeySpec passwordKey = new SecretKeySpec(password.getBytes(), \"AES\");\n    Cipher c = Cipher.getInstance(\"AES/GCM/NoPadding\");\n    GCMParameterSpec spec = new GCMParameterSpec(128, nonce);\n    c.init(Cipher.DECRYPT_MODE, passwordKey, spec);\n    CipherOutputStream cipherOutput = new CipherOutputStream(output, c);\n\n\n    while (num >= 0) {\n        cipherOutput.write(bytes, 0, num);\n        num = privateKeyInput.read(bytes);\n    }\n\n    cipherOutput.flush();\n    cipherOutput.close();\n    output.close();\n    privateKeyInput.close();\n\n    return decryptedFilename;\n}\n", "idx": 2668}
{"project": "cipher", "commit_id": "Snippet23804594_6106.java", "target": 1, "func": "public static byte[] encrypt(byte[] plainData, int offset, int length) throws Exception \n    Cipher cipher = Cipher.getInstance(\"AES/CBC/PKCS5Padding\", \"SunJCE\");\n    SecretKeySpec key = new SecretKeySpec(encryptionKey.getBytes(\"UTF-8\"), \"AES\");\n    cipher.init(Cipher.ENCRYPT_MODE, key,new IvParameterSpec(IV.getBytes(\"UTF-8\")));\n    return cipher.doFinal(plainData, offset, length);\n}\n", "idx": 2448}
{"project": "cipher", "commit_id": "Snippet19247140_2081.java", "target": 0, "func": " PBEKeySpec keySpec = new PBEKeySpec(password);\n\n SecretKeyFactory keyFactory = SecretKeyFactory\n        .getInstance(\"PBEWITHMD5ANDTRIPLEDES\"/* \"PBEWithSHAAndTwofish-CBC\" */);\n\n SecretKey key = keyFactory.generateSecret(keySpec);\n\n PBEParameterSpec paramSpec = new PBEParameterSpec(salt,\n                    MD5_ITERATIONS);\n\nCipher cipher = Cipher.getInstance(\"PBEWITHMD5ANDTRIPLEDES\");\n            cipher.init(Cipher.ENCRYPT_MODE, key, paramSpec);//here Ex.\n\nbyte[] ciphertext = cipher.doFinal(plaintext); \n", "idx": 2014}
{"project": "cipher", "commit_id": "Snippet30497256_12663.java", "target": 0, "func": "import javax.crypto.*;\nimport javax.crypto.spec.SecretKeySpec;\nimport sun.misc.*;\n\npublic class AES128Encryption {\n\n    private static final String ALGO = \"AES/ECB/PKCS5Padding\";\n    public static String decrypt(String encryptedData) throws Exception {\n        Cipher c = Cipher.getInstance(ALGO);\n        byte[] raw = \"************\".getBytes();\n        SecretKeySpec skeySpec = new SecretKeySpec(raw, \"AES\");\n        c.init(Cipher.DECRYPT_MODE, skeySpec);\n        byte[] decordedValue = new BASE64Decoder().decodeBuffer(encryptedData);\n        byte[] decValue = c.doFinal(decordedValue);\n        String decryptedValue = new String(decValue);\n        return decryptedValue;\n    }\n   }\n", "idx": 2150}
{"project": "cipher", "commit_id": "Snippet41673845_23617.java", "target": 1, "func": "Cipher c = Cipher.getInstance(\"AES/CBC/PKCS5Padding\");", "idx": 2506}
{"project": "cipher", "commit_id": "Snippet41974603_23963.java", "target": 0, "func": "Cipher.getInstance(\"AES/ECB/NoPadding\");", "idx": 2249}
{"project": "cipher", "commit_id": "Snippet40693206_22560.java", "target": 1, "func": "private byte[] decrypt(byte[] data, String corporateId, String algorithm)\n        throws Exception {\n    String path = corporateId + \".key\";\n\n    byte[] key = (byte[]) null;\n    try {\n        key = returnbyte(path);\n    } catch (IOException e) {\n        e.printStackTrace();\n    }\n    Cipher cipher = Cipher.getInstance(\"AES/CBC/PKCS5Padding\");\n    this.logger.info(\"Provider Info \" + cipher.getProvider().getInfo());\n    byte[] keyBytes = new byte[16];\n\n    int len = key.length;\n    if (len > keyBytes.length) {\n        len = keyBytes.length;\n    }\n    System.arraycopy(key, 0, keyBytes, 0, len);\n    SecretKeySpec keySpec = new SecretKeySpec(keyBytes, \"AES\");\n\n    IvParameterSpec ivSpec = new IvParameterSpec(keyBytes);\n    cipher.init(2, keySpec, ivSpec);\n    BASE64Decoder decoder = new BASE64Decoder();\n\n    byte[] results = decoder.decodeBuffer(hexStringFromBytes(data));\n\n    byte[] ciphertext = cipher.doFinal(results);\n\n    return ciphertext;\n}\n", "idx": 2628}
{"project": "cipher", "commit_id": "Snippet47614489_29643.java", "target": 1, "func": "    byte[] randomSalt = new byte[8];\n    SecureRandom secRand = new SecureRandom();\n    secRand.nextBytes(randomSalt);\n\n    String randomPassword = new BigInteger(130, secRand).toString(32);\n\n    SecretKeyFactory factory = SecretKeyFactory.getInstance(\"PBKDF2WithHmacSHA256\");\n    KeySpec spec = new PBEKeySpec(randomPassword.toCharArray(), randomSalt, 65536, 256);\n    SecretKey tmp = factory.generateSecret(spec);\n    SecretKey secret = new SecretKeySpec(tmp.getEncoded(), \"AES\");\n\n    Cipher cipher = Cipher.getInstance(\"AES/CTR/NoPadding\");\n    cipher.init(Cipher.ENCRYPT_MODE, secret);\n    AlgorithmParameters params = cipher.getParameters();\n    byte[] iv = params.getParameterSpec(IvParameterSpec.class).getIV();\n", "idx": 2588}
{"project": "cipher", "commit_id": "Snippet40209218_22124.java", "target": 0, "func": "boolean dbase64 = true;\ndkey = \"thisiskey\";\nmessageToDecrypt = \"m\u00f1q\u00e8\u2022\u00c0P\u0152\ufffd\u00f8f\\\"\u00df\u00a6\\\u00b1\u00f5\u00a4\u00f9'\u00c89\u00a2\u00ebyT \u00cdQE\u00c1|;\u00eb\u00e2\u00c9\u00f7JW\u00fa\"; // Message from above code\n\nSecretKeyFactory MyKeyFactory = SecretKeyFactory.getInstance(\"DES\");\nbyte[] dkeyBytes = dkey.getBytes();\n\nDESKeySpec generatedKeySpec = new DESKeySpec(dkeyBytes);\nSecretKey generatedSecretKey = MyKeyFactory.generateSecret(generatedKeySpec);\n\nCipher generatedCipher = Cipher.getInstance(\"DES\");\ngeneratedCipher.init(Cipher.DECRYPT_MODE, generatedSecretKey);\n\nif (dbase64) {\n    byte[] decodedBytes = Base64.getDecoder().decode(dencryptedText);\n    dencryptedText = new String(decodedBytes, \"utf-8\");\n}\n\nbyte[] messsageStringBytes = dencryptedText.getBytes();\nbyte[] encryptedMessage = generatedCipher.doFinal(messsageStringBytes);\n\nString decryptedMessageString = new String(encryptedMessage);\n\nreturn decryptedMessageString;\n", "idx": 2095}
{"project": "cipher", "commit_id": "Snippet13776916_37265.java", "target": 1, "func": "KeyGenerator keyGen  = KeyGenerator.getInstance(\"AES\");\nkeyGen.init(256, new SecureRandom());\nSecretKey secretKey = keyGen.generateKey();\n\nbyte[] publicKeyBytes = getBytes(publicKey.getKey());\nPublicKey rsaKey = KeyFactory.getInstance(\"RSA\")\n    .generatePublic(new X509EncodedKeySpec(publicKeyBytes));\n\nCipher cipher = Cipher.getInstance(RSA);\ncipher.init(Cipher.ENCRYPT_MODE, rsaKey);\n\nString keyEncoded = getString(key);\n\nreturn getString(encryptedKeyBytes));\n", "idx": 2713}
{"project": "cipher", "commit_id": "Snippet12744784_36426.java", "target": 1, "func": "Cipher cipher = Cipher.getInstance(\"AES/CFB8/NoPadding\"); \nSecretKeySpec keySpec = new SecretKeySpec(\"password12345678\".getBytes(), \"AES\");\ncipher.init(Cipher.ENCRYPT_MODE, keySpec);\n\nAlgorithmParameters params = cipher.getParameters();\nbyte[] iv = params.getParameterSpec(IvParameterSpec.class).getIV();\n\nout.write(iv); //Send IV to Server\nout.flush();\n\n// THE ENCRYPTET STREAM\ncos = new CipherOutputStream(out, cipher);  \n\nwhile ((val = byteArrayInputStream.read(buffer, 0, 1024)) > 0) {\n       cos.write(buffer, 0, val);\n       cos.flush();\n}\n\ncipher.doFinal()\n", "idx": 2680}
{"project": "cipher", "commit_id": "Snippet25656469_7999.java", "target": 0, "func": "MyAESKey myAESKey = new MyAESKey(new byte[16]);\nCipher aes = Cipher.getInstance(\"AES\");\naes.init(Cipher.ENCRYPT_MODE, myAESKey);\naes.doFinal(\"owlstead\".getBytes());\nmyAESKey.destroy();\naes.doFinal(\"owlstead\".getBytes());\naes.init(Cipher.ENCRYPT_MODE, myAESKey);\naes.doFinal(\"owlstead\".getBytes());\n", "idx": 2255}
{"project": "cipher", "commit_id": "Snippet42646980_24671.java", "target": 1, "func": " byte[] b = new byte[40000];\n new Random().nextBytes(b);\n\n Cipher cipher = Cipher.getInstance(\"AES/GCM/NoPadding\");\n cipher.init(Cipher.ENCRYPT_MODE, key);\n\n byte[] first = cipher.doFinal(b);\n", "idx": 2547}
{"project": "cipher", "commit_id": "Snippet34188763_16200.java", "target": 1, "func": "import java.io.FileNotFoundException;\nimport java.io.*;\nimport java.util.Scanner;\n\nimport java.io.File;\nimport java.io.FileInputStream;\nimport java.io.FileOutputStream;\nimport java.security.AlgorithmParameters;\nimport java.security.SecureRandom;\nimport java.security.spec.KeySpec;\n\nimport javax.crypto.Cipher;\nimport javax.crypto.SecretKey;\nimport javax.crypto.SecretKeyFactory;\nimport javax.crypto.spec.IvParameterSpec;\nimport javax.crypto.spec.PBEKeySpec;\nimport javax.crypto.spec.SecretKeySpec;\n\npublic class AESFileEncryption {\n\n/*public AESFileEncryption(String nameoffile){\n\n}\npublic String FileReturn(String filename){\n    String fl = filename;       \n    return fl;      \n}*/\n\npublic static void main(String[] args) throws Exception {\n\n    File f = new File(\"plainfile.txt\");\n    File g = new File(\"plainfile.txt.8102\");\n    File fl = new File(\"plainfile.txt.8102\");\n\n    if(g.exists() && !g.isDirectory()){\n        System.out.println(\"The file is already encrypted...\");\n        String fname = fl.getAbsolutePath();\n        System.out.print(\"Absolute Encrypted File Pathname => \"+ fname);\n        System.exit(0);\n    }       \n    else if(f.exists() && !f.isDirectory()) { \n         System.out.println(\" The file is found.The encryption process is going to begin...\");\n\n    }       \n    else{\n         System.out.println(\" The file is missing!!!!\");\n         System.exit(0);\n    }\n\n    // file to be encrypted\n    FileInputStream inFile = new FileInputStream(\"plainfile.txt\");       \n\n    // encrypted file\n    FileOutputStream outFile = new FileOutputStream(\"plainfile.txt.8102\");\n\n\n    // password to encrypt the file\n    Scanner scan= new Scanner(System.in);\n    System.out.println(\"Enter the password : => \");\n    String password= scan.nextLine();\n\n    //String password = \"javapapers\";\n\n    // password, iv and salt should be transferred to the other end\n    // in a secure manner\n\n    // salt is used for encoding\n    // writing it to a file\n    // salt should be transferred to the recipient securely\n    // for decryption\n    byte[] salt = new byte[8];\n    SecureRandom secureRandom = new SecureRandom();\n    secureRandom.nextBytes(salt);\n    FileOutputStream saltOutFile = new FileOutputStream(\"salt.enc\");\n    saltOutFile.write(salt);\n    saltOutFile.close();\n\n    SecretKeyFactory factory = SecretKeyFactory\n            .getInstance(\"PBKDF2WithHmacSHA1\");\n    KeySpec keySpec = new PBEKeySpec(password.toCharArray(), salt, 65536,\n            256);\n    SecretKey secretKey = factory.generateSecret(keySpec);\n    SecretKey secret = new SecretKeySpec(secretKey.getEncoded(), \"AES\");\n\n    //\n    Cipher cipher = Cipher.getInstance(\"AES/CBC/PKCS5Padding\");\n    cipher.init(Cipher.ENCRYPT_MODE, secret);\n    AlgorithmParameters params = cipher.getParameters();\n\n    // iv adds randomness to the text and just makes the mechanism more\n    // secure\n    // used while initializing the cipher\n    // file to store the iv\n    FileOutputStream ivOutFile = new FileOutputStream(\"iv.enc\");\n    byte[] iv = params.getParameterSpec(IvParameterSpec.class).getIV();\n    ivOutFile.write(iv);\n    ivOutFile.close();\n\n    //file encryption\n    byte[] input = new byte[64];\n    int bytesRead;\n\n    while ((bytesRead = inFile.read(input)) != -1) {\n        byte[] output = cipher.update(input, 0, bytesRead);\n        if (output != null)\n            outFile.write(output);\n    }\n\n    byte[] output = cipher.doFinal();\n    if (output != null)\n        outFile.write(output);\n\n    inFile.close();\n    outFile.flush();\n    outFile.close();\n\n    System.out.println(\"File Encrypted.\");\n\n    }\n\n}\n", "idx": 2443}
{"project": "cipher", "commit_id": "Snippet31851612_13907.java", "target": 1, "func": "class Encryptor {\n  Key key;\n\n  Encryptor(byte[] key) {\n    if (key.length != 32) throw new IllegalArgumentException();\n    this.key = new SecretKeySpec(key, \"AES\");\n  }\n\n  // the output is sent to users\n  byte[] encrypt(byte[] src) throws Exception {\n    Cipher cipher = Cipher.getInstance(\"AES/GCM/NoPadding\");\n    cipher.init(Cipher.ENCRYPT_MODE, key);\n    byte[] iv = cipher.getIV(); // See question #1\n    assert iv.length == 12; // See question #2\n    byte[] cipherText = cipher.doFinal(src);\n    assert cipherText.length == src.length + 16; // See question #3\n    byte[] message = new byte[12 + src.length + 16]; // See question #4\n    System.arraycopy(iv, 0, message, 0, 12);\n    System.arraycopy(cipherText, 0, message, 12, cipherText.length);\n    return message;\n  }\n\n  // the input comes from users\n  byte[] decrypt(byte[] message) throws Exception {\n    if (message.length < 12 + 16) throw new IllegalArgumentException();\n    Cipher cipher = Cipher.getInstance(\"AES/GCM/NoPadding\");\n    GCMParameterSpec params = new GCMParameterSpec(128, message, 0, 12);\n    cipher.init(Cipher.DECRYPT_MODE, key, params);\n    return cipher.doFinal(message, 12, message.length - 12);\n  }\n}\n", "idx": 2546}
{"project": "cipher", "commit_id": "Snippet20110684_2773.java", "target": 1, "func": "import java.io.*;\nimport java.net.*;\nimport java.security.*;\nimport javax.crypto.*;\n\npublic class PKServer\n{\n    public void decryptMessage(InputStream inStream) throws IOException, NoSuchAlgorithmException\n    {\n        try {\n\n            //Create the Data input stream from the socket\n            DataInputStream dis = new DataInputStream(inStream);\n\n            //Get the key\n            ObjectInputStream in = new ObjectInputStream(new FileInputStream(\"KeyFile.xx\"));\n\n            //ObjectOutputStream outSocket = new ObjectOutputStream(s.getOutputStream());\n\n            PrivateKey privatekey = (PrivateKey) in.readObject();\n            System.out.println(\"Key Used: \" + in.toString());\n            in.close();\n\n            //Initiate the cipher\n            Cipher cipher = Cipher.getInstance(\"RSA/ECB/PKCS1Padding\");                        \n            cipher.init(Cipher.DECRYPT_MODE,privatekey);\n\n            int len = dis.readInt();\n            byte[] encryptedMsg = new byte[len];\n            dis.readFully(encryptedMsg);         \n\n            System.out.println(\"Server - Msg Length: \" + len);\n            System.out.println(\"Server - Encrypted: \" + asHex(encryptedMsg));\n\n            // -Print out the decrypt String to see if it matches the original message.\n            byte[] plainText = cipher.doFinal(encryptedMsg);\n            System.out.println(\"Decrypted Message: \" + new String(plainText, \"SHA\"));\n\n\n        } catch (Exception e) {\n            e.printStackTrace();\n        }\n    }\n\n    //Function to make the bytes printable (hex format)\n    public static String asHex(byte buf[]) {\n        StringBuilder strbuf = new StringBuilder(buf.length * 2);\n        int i;\n        for (i = 0; i < buf.length; i++) {\n            if (((int) buf[i] & 0xff) < 0x10) {\n                strbuf.append(\"0\");\n            }\n            strbuf.append(Long.toString((int) buf[i] & 0xff, 16));\n        }\n        return strbuf.toString();\n    }\n    public static void main(String[] args) throws Exception \n    {\n        int port = 7999;\n        ServerSocket server = new ServerSocket(port);\n        Socket s = server.accept();                     \n\n\n        PKServer cs = new PKServer();\n        cs.decryptMessage(s.getInputStream());\n\n        server.close();\n    }\n}\n", "idx": 2653}
{"project": "cipher", "commit_id": "Snippet9381270_33863.java", "target": 1, "func": "Cipher cipher = Cipher.getInstance(\"AES/CBC/PKCS5Padding\");\nAlgorithmParameters.getInstance(\"AES\");\ncipher.init(Cipher.DECRYPT_MODE, aesKey, new IvParameterSpec(iv));\nbyte[] decrypted = cipher.doFinal(data);\n", "idx": 2632}
{"project": "cipher", "commit_id": "Snippet29642271_11710.java", "target": 0, "func": "public Decrypt(String path, String pathcode) {\n        // TODO Auto-generated constructor stub\n        filepath = path;\n        try {\n            fis = new FileInputStream(new File(path));\n            this.passcode = pathcode;\n        } catch (FileNotFoundException e) {\n            // TODO Auto-generated catch block\n            e.printStackTrace();\n        }\n\n    }\n\n    static String decrypt() throws IOException, NoSuchAlgorithmException,\n    NoSuchPaddingException, InvalidKeyException {\n\n        SecretKeySpec sks = new SecretKeySpec(passcode.getBytes(), \"AES\");\n        Cipher cipher = Cipher.getInstance(\"AES\");\n        cipher.init(Cipher.DECRYPT_MODE, sks);\n        CipherInputStream cis = new CipherInputStream(fis, cipher);\n        int size = fis.available();\n        byte[] resdata = new byte[size];\n        cis.read(resdata, 0, size);\n        String newres = new String(resdata, \"UTF-8\").trim();\n        //write(\"decrypted_file.xhtml\",newres);  \n        if(fis!=null)\n        {\n        fis.close();\n        }\n        if(cis!=null)\n            cis.close();\n        return newres;\n    }\n", "idx": 2235}
{"project": "cipher", "commit_id": "Snippet31061831_13235.java", "target": 0, "func": "Cipher c = Cipher.getInstance(\"AES/ECB/NoPadding\");\nKey aesKey = new SecretKeySpec(key, \"AES\");\nc.init(Cipher.ENCRYPT_MODE, aesKey);\nfor (long i = 0; i < rounds; ++i) {\n     data = c.doFinal(data);\n}\n", "idx": 2231}
{"project": "cipher", "commit_id": "Snippet36671630_18532.java", "target": 0, "func": "import java.io.IOException;\nimport java.io.UnsupportedEncodingException;\nimport java.security.InvalidKeyException;\nimport java.security.Key;\nimport java.security.NoSuchAlgorithmException;\nimport java.util.Scanner;\n\nimport javax.crypto.BadPaddingException;\nimport javax.crypto.Cipher;\nimport javax.crypto.IllegalBlockSizeException;\nimport javax.crypto.NoSuchPaddingException;\nimport javax.crypto.spec.SecretKeySpec;\n\nimport sun.misc.BASE64Encoder;\nimport sun.misc.BASE64Decoder;\n\npublic class Application { \n\n    public Application() {\n        // TODO Auto-generated constructor stub\n    }\n\n    public static void main ( String[] args ) {\n        Scanner input = new Scanner(System.in);\n        String textToEncrypt = \"Hello World\";\n        String textToDecrypt;\n        String textToDecryptAscii;\n        String result;\n        int operation;\n        Cipher cipher = null;\n        try {\n            cipher = Cipher.getInstance(\"AES\");\n        } catch (NoSuchAlgorithmException e1) {\n            e1.printStackTrace();\n        } catch (NoSuchPaddingException e1) {\n            e1.printStackTrace();\n        }\n\n        //String key = \"Bar12345Bar12345\"; // 128 bit key\n        String key = null;\n        //byte[] key = null;\n\n        //BASE64Encoder asciiEncoder = new BASE64Encoder();\n        //BASE64Decoder asciiDecoder = new BASE64Decoder();\n\n        //System.out.printf(\"Enter:\\n1 for encryption\\n2 for decryption\\n\\nChoice: \");\n        //operation = input.nextInt();\n        //input.nextLine();\n\n        try { \n            System.out.print(\"Enter a 128-bit key to be used for encryption: \");\n            key = input.nextLine();\n\n            if ( key.length() != 16 ) {\n                while ( key.length() != 16 ) {\n                    System.out.print(\"You need to enter a *128-bit* key: \");\n                    key = input.nextLine();\n                }\n            }\n            System.out.println ( \"128-bit encryption key.......................[\"+key+\"] length [\"+key.length ()+\"]\");\n\n            System.out.printf ( \"Text to encrypt..............................[\");\n            //System.out.printf(\"\\n---------\\n\\nText to encrypt: \");\n            textToEncrypt = input.nextLine();\n            System.out.println ( \"Text to encrypt..............................[\"+textToEncrypt+\"] length [\"+textToEncrypt.length ()+\"]\");\n\n            //Create key and cipher\n            Key aesKey = new SecretKeySpec(key.trim().getBytes(), \"AES\");\n            //Cipher cipher = Cipher.getInstance(\"AES\");\n\n            //encrypt the text\n            cipher.init(Cipher.ENCRYPT_MODE, aesKey);\n            byte[] encrypted = cipher.doFinal(textToEncrypt.getBytes ());\n\n            StringBuilder sb = new StringBuilder();\n            for (byte b: encrypted) {\n                sb.append((char)b);\n            }\n\n            // the encrypted String\n            String enc = sb.toString();\n            System.out.println ( \"Encrypted text...............................[\"+enc+\"] length [\"+enc.length ()+\"]\");\n            //System.out.println(\"encrypted:\" + enc);\n\n            //String asciiEncodedEncryptedResult = asciiEncoder.encodeBuffer(enc.getBytes()).trim ();\n            String asciiEncodedEncryptedResult = enc.trim ();\n            System.out.println ( \"Encoded text.................................[\"+asciiEncodedEncryptedResult+\"] length [\"+asciiEncodedEncryptedResult.length ()+\"]\");\n\n            //asciiEncodedEncryptedResult = asciiEncodedEncryptedResult.replace(\"\\n\", \"\").replace(\"\\r\", \"\");\n            asciiEncodedEncryptedResult = asciiEncodedEncryptedResult.trim ();\n\n            System.out.println ( \"Encrypted text...............................[\"+asciiEncodedEncryptedResult+\"] length [\"+asciiEncodedEncryptedResult.length ()+\"]\");\n\n\n            //byte[] decodedBytes = null;\n            //try {\n            //    decodedBytes = asciiDecoder.decodeBuffer(asciiEncodedEncryptedResult);\n            //} \n            //catch (IOException e1) {\n            //    e1.printStackTrace();\n            //}\n            //System.out.println ( \"Decoded Bytes................................[\"+decodedBytes+\"] length [\"+decodedBytes.length+\"]\");\n\n            //textToDecrypt = new String(decodedBytes);\n            textToDecrypt = asciiEncodedEncryptedResult;\n\n            System.out.println ( \"Text to Decrypt..............................[\"+textToDecrypt+\"] length [\"+textToDecrypt.length()+\"]\");\n\n            //Convert the string to byte array\n            //for decryption\n            byte[] bb = new byte[textToDecrypt.length()];\n            for ( int i=0; i<textToDecrypt.length(); i++ ) {\n                bb[i] = (byte) textToDecrypt.charAt(i);\n            }\n\n            //decrypt the text\n            //Key aesKey = null;\n            String decrypted = null;\n            try {\n                //aesKey = new SecretKeySpec(key.trim ().getBytes (), \"AES\");\n                cipher.init(Cipher.DECRYPT_MODE, aesKey);\n                decrypted = new String(cipher.doFinal(bb));\n            }\n            catch (InvalidKeyException e) {\n                e.printStackTrace();\n            }\n            catch (IllegalBlockSizeException e) {\n                e.printStackTrace();\n            }\n            catch (BadPaddingException e) {\n                e.printStackTrace();\n            }\n            catch ( Exception ltheXcp ) { \n                ltheXcp.printStackTrace ();\n            }\n\n            if ( decrypted != null ) {\n                System.out.println ( \"Decrypted text...............................[\"+decrypted+\"] length [\"+decrypted.length ()+\"]\");\n            }\n            else { \n                System.out.println ( \"Decrypted text...............................[\"+decrypted+\"] length []\");\n            }\n\n        }\n        catch ( Exception ltheXcp ) { \n            ltheXcp.printStackTrace ();\n        }\n\n    }\n}\n", "idx": 2237}
{"project": "cipher", "commit_id": "Snippet18998124_1882.java", "target": 1, "func": " static byte[] decryptLast64KBytes(String inputPath) throws IOException,\nNoSuchAlgorithmException, NoSuchPaddingException,\nInvalidKeyException {\n\n        FileInputStream fis = new FileInputStream(inputPath);\n\n        SecretKeySpec sks = new SecretKeySpec(\"MyDifficultPassw\".getBytes(), \"AES\");\n        Cipher cipher = Cipher.getInstance(\"AES/CBC/PKCS5Padding\");\n        byte[] iv = new byte[] { '3', 'd', '0', 'c', 'd', '7', 'A', '9', '7', 'e', '2', '0', 'b', 'x', 'g', 'y' };\n        IvParameterSpec ivParameterSpec = new IvParameterSpec(iv);\n        try {\n            cipher.init(Cipher.DECRYPT_MODE, sks, ivParameterSpec);\n        } catch (InvalidAlgorithmParameterException e) {\n            e.printStackTrace();\n        }\n        CipherInputStream cis = new CipherInputStream(fis, cipher);\n\n        int b;\n        byte[] d = new byte[1024];\n        ByteArrayOutputStream bos = new ByteArrayOutputStream();\n        int count =0;\n\n        int offset = 0;\n        while((b = fis.read(d)) != -1) {\n            offset = offset + b;\n            Log.d(TAG, \"Offset: \"+offset);\n            Log.d(TAG, \"b: \"+b);\n            if((offset)>=fis.available())\n            {\n                Log.d(TAG, \"last 64 Kbytes\");\n                while((b = cis.read(d, offset, offset+b))!=-1)\n                {\n                    bos.write(d);\n                    offset = offset + b;\n                }\n\n            }\n            else\n            {\n                Log.d(TAG, \"rest of the bytes\");\n                bos.write(d);\n            }\n\n        }\n\n        byte[] completeBytes = bos.toByteArray();\n        cis.close();\n        return completeBytes;\n\n}\n", "idx": 2678}
{"project": "cipher", "commit_id": "Snippet39610952_21488.java", "target": 1, "func": "static String IV = \"AAAAAAAAAAAAAAAA\";\nstatic String plaintext = \"test text 123\\0\\0\\0\"; /*Note null padding*/\nstatic String encryptionKey = \"0123456789abcdef\";\n\npublic static String decrypt(byte[] cipherText, String encryptionKey) throws Exception{\n    Cipher cipher = Cipher.getInstance(\"AES/CBC/NoPadding\", \"SunJCE\");\n    SecretKeySpec key = new SecretKeySpec(encryptionKey.getBytes(\"UTF-8\"), \"AES\");\n    cipher.init(Cipher.DECRYPT_MODE, key,new IvParameterSpec(IV.getBytes(\"UTF-8\")));\n    return new String(cipher.doFinal(cipherText),\"UTF-8\");\n}\n", "idx": 2524}
{"project": "cipher", "commit_id": "Snippet25546069_7876.java", "target": 0, "func": "private final static String ALGORITM = \"Blowfish\";\nprivate final static String KEY = \"2356a3a42ba5781f80a72dad3f90aeee8ba93c7637aaf218a8b8c18c\";\nprivate final static String PLAIN_TEXT = \"here is your text\";\n\npublic void run(View v) {\n\n    try {\n\n        byte[] encrypted = encrypt(KEY, PLAIN_TEXT);\n        Log.i(\"FOO\", \"Encrypted: \" + bytesToHex(encrypted));\n\n        String decrypted = decrypt(KEY, encrypted);\n        Log.i(\"FOO\", \"Decrypted: \" + decrypted);\n\n    } catch (GeneralSecurityException e) {\n        e.printStackTrace();\n    }\n}\n\nprivate byte[] encrypt(String key, String plainText) throws GeneralSecurityException {\n\n    SecretKey secret_key = new SecretKeySpec(key.getBytes(), ALGORITM);\n\n    Cipher cipher = Cipher.getInstance(ALGORITM);\n    cipher.init(Cipher.ENCRYPT_MODE, secret_key);\n\n    return cipher.doFinal(plainText.getBytes());\n}\n\nprivate String decrypt(String key, byte[] encryptedText) throws GeneralSecurityException {\n\n    SecretKey secret_key = new SecretKeySpec(key.getBytes(), ALGORITM);\n\n    Cipher cipher = Cipher.getInstance(ALGORITM);\n    cipher.init(Cipher.DECRYPT_MODE, secret_key);\n\n    byte[] decrypted = cipher.doFinal(encryptedText);\n\n    return new String(decrypted);\n}\n\npublic static String bytesToHex(byte[] data) {\n\n    if (data == null)\n        return null;\n\n    String str = \"\";\n\n    for (int i = 0; i < data.length; i++) {\n        if ((data[i] & 0xFF) < 16)\n            str = str + \"0\" + java.lang.Integer.toHexString(data[i] & 0xFF);\n        else\n            str = str + java.lang.Integer.toHexString(data[i] & 0xFF);\n    }\n\n    return str;\n\n}\n", "idx": 2113}
{"project": "cipher", "commit_id": "Snippet44211175_26125.java", "target": 0, "func": "Cipher cipher = Cipher.getInstance(\"PBEWITHSHA1ANDDESEDE\");\n", "idx": 2224}
{"project": "cipher", "commit_id": "Snippet5879339_31826.java", "target": 1, "func": "    CipherInputStream cis;\n    String salt = \"1234567890123456\";\n    String password = \"abcdEFGH\";\n\n    password = password.concat(salt);\n    String validpassword = password.substring(0, 16);\n    SecretKeySpec secretKey = new SecretKeySpec(validpassword.getBytes(),\"AES\");   \n    AlgorithmParameterSpec paramSpec = new IvParameterSpec(salt.getBytes());\n\n    try  {\n        // Creation of Cipher objects\n        Cipher encrypt = \n         Cipher.getInstance(\"AES/CFB8/NoPadding\");\n        encrypt.init(Cipher.ENCRYPT_MODE, secretKey,paramSpec);\n\n        // Open the file\n        try {\n             fis = new FileInputStream(file);\n        } catch(IOException err) {\n             System.out.println(\"Cannot open file!\");\n             return null;\n        }\n        cis = new CipherInputStream(fis, encrypt);\n\n        // Write to the Encrypted file\n        fos = new FileOutputStream(desFile);\n        byte[] b = new byte[256];\n        int i = cis.read(b);\n        while (i != -1) {\n             fos.write(b, 0, i);\n             i = cis.read(b);\n        }\n", "idx": 2390}
{"project": "cipher", "commit_id": "Snippet44503051_26586.java", "target": 1, "func": "public static String decrypt(String src) {\n    String decrypted = \"\";\n    try {\n        Cipher cipher = Cipher.getInstance(\"AES/CBC/NoPadding\");\n        cipher.init(Cipher.DECRYPT_MODE, makeKey(), makeIv());\n        byte[] array = Base64.decode(src);\n        byte[] encrypted = Arrays.copyOfRange(array, 16, array.length);\n        decrypted = new String(cipher.doFinal(encrypted));\n    } catch (Exception e) {\n        throw new RuntimeException(e);\n    }\n    return decrypted;\n}\n", "idx": 2601}
{"project": "cipher", "commit_id": "Snippet32166377_14273.java", "target": 0, "func": "public static void register(){\n\n    try{\n        // CREATE KEY AND CIPHER\n        byte[] key = username.getBytes();\n        Cipher cipher = Cipher.getInstance(\"AES/ECB/PKCS5Padding\");\n        SecretKeySpec secretKey = new SecretKeySpec(key, \"AES\");\n\n        // ENCRYPT DATA\n        cipher.init(Cipher.ENCRYPT_MODE, secretKey);\n        byte[] cipherText = cipher.doFinal(password.getBytes(\"UTF8\"));\n\n        // ENCODE DATA\n        String encodedString = new String(Base64.encodeBase64(cipherText), \"UTF-8\");\n\n        // SAVE VARIABLE\n        p = new String(encodedString);\n\n        // PRINT DATA\n        System.out.println(\"PLAINTEXT KEY:      \" + username);\n        System.out.println(\"MODIFIED PASSWORD:  \" + password);\n        System.out.println(\"ENCRYPTED PASSWORD: \" + new String(cipherText));\n        System.out.println(\"ENCODED PASSWORD:   \" + encodedString);\n        System.out.println(\"P (ENCODED):        \" + p);\n        System.out.println(\"\");\n\n        // SAVE TO DISK\n        try {\n            File file = new File(\"C://Welcome/License.txt\");\n            file.getParentFile().mkdirs();\n            FileWriter fw = new FileWriter(file);\n            BufferedWriter bw = new BufferedWriter(fw);\n\n            bw.write(new String(p));\n            bw.close();\n        }\n        catch(FileNotFoundException ex){\n            ex.printStackTrace();\n        }\n        catch(IOException ex){\n            ex.printStackTrace();\n        }\n        p = \"\";\n\n        // CREATE A FOLDER FOR FILES\n        try {\n            File dir = new File(\"C://IronFortress/Files\");\n            dir.mkdir();\n        }\n        catch(Exception e){\n            e.printStackTrace();\n        }\n\n\n        // READ DATA FROM DISK\n        String fileName = \"C:/Welcome/License.txt\";\n        String line0 = null;\n\n        try {\n            FileReader fr = new FileReader(fileName);\n            BufferedReader br = new BufferedReader(fr);\n\n            if((line0 = br.readLine()) != null){\n                p = (line0);\n            }\n\n            br.close();\n        }\n        catch(FileNotFoundException e) {\n            e.printStackTrace();\n        }\n        catch (IOException e) {\n            e.printStackTrace();\n        }\n\n        // DECODE PASSWORD\n        String decodedString = new String(Base64.decodeBase64(p));\n\n        // CREATE KEY AND CIPHER\n        key = username.getBytes();\n        Cipher cipher2 = Cipher.getInstance(\"AES/ECB/PKCS5Padding\");\n        SecretKeySpec secretKey2 = new SecretKeySpec(key, \"AES\");\n\n        // DECRYPT PASSWORD\n        cipher2.init(Cipher.DECRYPT_MODE, secretKey2);\n        byte[] cipherText2 = cipher.doFinal(decodedString.getBytes(\"UTF8\"));\n\n        // PRINT DATA\n        System.out.println(\"P (DECODED):        \" + p);\n        System.out.println(\"ENCODED PASSWORD:   \" + decodedString);\n        System.out.println(\"DECRYPTED PASSWORD: \" + new String(cipherText2));\n    }\n    catch (Exception e){\n        e.printStackTrace();\n    }\n}\n", "idx": 2020}
{"project": "cipher", "commit_id": "Snippet11719743_35731.java", "target": 0, "func": "KeyGenerator kgen = KeyGenerator.getInstance(\"Blowfish\");\nSecretKey skey = kgen.generateKey();\nbyte[] raw = skey.getEncoded();\nSecretKeySpec skeySpec = new SecretKeySpec(raw, \"Blowfish\");\n\nCipher cipher = Cipher.getInstance(\"Blowfish\");\ncipher.init(Cipher.ENCRYPT_MODE, skeySpec);\nString inputString = \"This is just an example\";\nbyte[] encrypted = cipher.doFinal(inputString.getBytes());\n\nCipher decCipher = Cipher.getInstance(\"Blowfish\");\ndecCipher.init(Cipher.DECRYPT_MODE, skeySpec);\nbyte[] decrypted = decCipher.doFinal(encrypted);\n\nassertEquals(inputString, new String(decrypted));\n", "idx": 1963}
{"project": "cipher", "commit_id": "Snippet18031179_1089.java", "target": 1, "func": "public static String decrypt(String text){\n    try {           \n        Cipher cipher = Cipher.getInstance(\"AES/CBC/PKCS5Padding\");\n        byte[] keyBytes= new byte[16];\n        byte[] b= KEY.getBytes(\"UTF-8\");\n        int len= b.length;\n        if (len > keyBytes.length) len = keyBytes.length;\n        System.arraycopy(b, 0, keyBytes, 0, len);\n        SecretKeySpec keySpec = new SecretKeySpec(keyBytes, \"AES\");\n        IvParameterSpec ivSpec = new IvParameterSpec(keyBytes);\n        cipher.init(Cipher.DECRYPT_MODE,keySpec,ivSpec);\n        byte[] results = cipher.doFinal(Base64.decode(text, 0));\n        return new String(results, \"UTF-8\");\n    } catch (Exception e) {\n        // TODO: handle exception\n        Log.d(\"decryption\", e.getMessage());\n        return null;\n    }\n}   \n", "idx": 2568}
{"project": "cipher", "commit_id": "Snippet16264093_39229.java", "target": 1, "func": "public static String generatePswdBasedKey(String password){\nString finalKey = null;\nSecretKey sk = null;\nKeySpec keySpec = new PBEKeySpec(password.toCharArray(), salt, IT, KEY_LENGTH);\nSecretKeyFactory keyFactory = SecretKeyFactory.getInstance(\"PBKDF2WithHmacSHA1\");\nbyte[] keyBytes = keyFactory.generateSecret(keySpec).getEncoded();\nsk = new SecretKeySpec(keyBytes, \"AES\");\nCipher cipher = Cipher.getInstance(Cifrador.AES_MODE);//AES_MODE = AES/CBC/PKCS5Padding\nIvParameterSpec ivParams = new IvParameterSpec(iv);//IV already initialized\ncipher.init(Cipher.ENCRYPT_MODE, sk, ivParams);\nbyte pwdbytes[] = password.getBytes();//I also tried using Base64 to decode... without success\nbyte cc[] = cipher.doFinal(pwdbytes);\nfinalKey = Base64.encodeToString(cc, false);  //.encodeToString(byte[] sArr, boolean lineSep)\nreturn finalKey;\n", "idx": 2701}
{"project": "cipher", "commit_id": "Snippet36327153_18176.java", "target": 1, "func": "public void demoSymmetricEncryption() throws NoSuchAlgorithmException, InvalidKeyException, NoSuchPaddingException, InvalidAlgorithmParameterException, UnsupportedEncodingException, IllegalBlockSizeException, BadPaddingException {\n\n    String keyAlgorithm = \"DiffieHellman\";\n    String keyAgreementAlgorithm = \"DiffieHellman\";\n    String keySpecAlgorithm = \"AES\";\n    String cipherAlgorithm = \"AES/CBC/PKCS5Padding\";\n\n    KeyPairGenerator keyGenerator = KeyPairGenerator.getInstance(keyAlgorithm);\n    keyGenerator.initialize(1024, new SecureRandom());\n    KeyPair tomKeyPair = keyGenerator.generateKeyPair();\n    PrivateKey tomPrivateKey = tomKeyPair.getPrivate();\n    PublicKey tomPublicKey = tomKeyPair.getPublic();\n\n    KeyPair steveKeyPair = keyGenerator.generateKeyPair();\n    PrivateKey stevePrivateKey = steveKeyPair.getPrivate();\n    PublicKey stevePublicKey = steveKeyPair.getPublic();\n\n    int maxKeyLen = Cipher.getMaxAllowedKeyLength(\"AES\");\n    System.out.println(\"Limited encryption policy files installed : \" + (maxKeyLen == 128)); // returns false\n\n    KeyAgreement tomKeyAgreement = KeyAgreement.getInstance(keyAgreementAlgorithm);\n    keyGenerator.initialize(1024, new SecureRandom());\n    tomKeyAgreement.init(tomPrivateKey);\n    tomKeyAgreement.doPhase(stevePublicKey, true);\n    byte[] tomSecret = tomKeyAgreement.generateSecret();\n\n    SecretKeySpec tomSecretKeySpec = new SecretKeySpec(tomSecret, keySpecAlgorithm);\n\n    KeyAgreement steveKeyAgreement = KeyAgreement.getInstance(keyAgreementAlgorithm);\n    steveKeyAgreement.init(stevePrivateKey);\n    steveKeyAgreement.doPhase(tomPublicKey, true);\n    byte[] steveSecret = steveKeyAgreement.generateSecret();\n\n    SecretKeySpec steveSecretKeySpec = new SecretKeySpec(steveSecret, keySpecAlgorithm);\n\n    System.out.println(\"Secret Keys are identical : \" + steveSecretKeySpec.equals(tomSecretKeySpec)); // returns true\n\n    String initVector = \"RandomInitVector\";\n\n    Cipher encryptCipher = Cipher.getInstance(cipherAlgorithm);\n    IvParameterSpec iv = new IvParameterSpec(initVector.getBytes(\"UTF-8\"));\n\n    // fails because AES key is 128 bytes not 128 bits in length - think I need to use KDF hash to shrink it appropriately.\n    encryptCipher.init(Cipher.ENCRYPT_MODE, tomSecretKeySpec, iv);\n\n\n    // Attempt to use the cipher\n\n    byte[] encryptedData = encryptCipher.doFinal(\"Hello\".getBytes());\n\n    Cipher decryptCipher = Cipher.getInstance(cipherAlgorithm);\n    iv = new IvParameterSpec(initVector.getBytes(\"UTF-8\"));\n    decryptCipher.init(Cipher.DECRYPT_MODE, steveSecretKeySpec, iv);\n\n    byte[] decryptedData = decryptCipher.doFinal(encryptedData);\n\n    System.out.println(\"Decrypted Data : \" + new String(decryptedData));\n\n}\n", "idx": 2661}
{"project": "cipher", "commit_id": "Snippet14261084_37600.java", "target": 0, "func": "...\n    //*********************************************\n    byte[] bArray = {23, 42, 55};\n    String stringRepresentation = bArray[0] + \",\" + bArray[1] + \",\" + bArray[2];\n    System.out.println(\"Plain Byte Array: \" + Arrays.toString(bArray));\n    String eba = EncryptByteArray(bArray);\n    System.out.println(\"Encrypted Byte Array: \"+eba);\n    byte[] deba = decryptByteArray(eba);\n    System.out.println(\"Decrypted Byte Array: \"+Arrays.toString(deba));\n    //*********************************************\n}\n\npublic static String EncryptByteArray(byte[] array) throws Exception\n{\n    Cipher cipher = Cipher.getInstance(\"AES/ECB/PKCS5Padding\");\n    SecretKeySpec secretKey = new SecretKeySpec(key, \"AES\");\n    cipher.init(Cipher.ENCRYPT_MODE, secretKey);\n    String encryptedString = Base64.encodeBase64String(cipher.doFinal(array));\n    return encryptedString;\n}\n\npublic static byte[] decryptByteArray(String strToDecrypt) throws Exception\n{\n    Cipher cipher = Cipher.getInstance(\"AES/ECB/PKCS5PADDING\");\n    SecretKeySpec secretKey = new SecretKeySpec(key, \"AES\");\n    cipher.init(Cipher.DECRYPT_MODE, secretKey);\n    return cipher.doFinal(Base64.decodeBase64(strToDecrypt));\n}\n", "idx": 2145}
{"project": "cipher", "commit_id": "Snippet34835923_16063.java", "target": 1, "func": "Cipher.getInstance(\"RSA/ECB/OAEPWithSHA1AndMGF1Padding\");\n", "idx": 2674}
{"project": "cipher", "commit_id": "Snippet45332189_27440.java", "target": 1, "func": "import java.security._\nimport javax.crypto._\nimport javax.crypto.spec._\nimport sun.misc.BASE64Decoder\nimport sun.misc.BASE64Encoder\n\nobject Main {\n  private val cryptographyKeySize: Int = 0\n  private val cryptographyMethod: String = null\n  private val kgen: KeyGenerator = null\n  private val secretKeyFieldIndex: Int = 0\n  private val myDecryptedSecretFieldIndex: Int = 0\n\n  private val encryptedTextFieldIndex1: Int = 0\n  private val encryptedTextFieldIndex2: Int = 0\n\n\n  private val COL1Index1: Int = 0\n  private val COL2Index1: Int = 0\n  private val COL1Index2: Int = 0\n  private val COL2Index2: Int = 0\n  private val symmKey: String = \"9d6ea4d3e6f8c4f8\"\n  private val ivSpec: String = \"1c5dd32d7ba54bdd\"\n\n  def processRow(smi: StepMetaInterface, sdi: StepDataInterface): Boolean = {\n    val r: Array[Any] = getRow()\n\n    if (r == null) {\n      setOutputDone()\n      false\n    } else {\n        val outputRowData: Array[Any] = createOutputRow(r, data.outputRowMeta.size())\n\n        try {\n          val raw: Array[Byte] = symmKey.getBytes(\"UTF-8\")\n          val skeySpec: SecretKeySpec = new SecretKeySpec(raw, \"AES\")\n          val cipher: Cipher = Cipher.getInstance(\"AES/CBC/ISO10126PADDING\")\n          val ivParameterSpec: IvParameterSpec = new IvParameterSpec(ivSpec.getBytes(\"UTF-8\"))\n          cipher.init(Cipher.DECRYPT_MODE, skeySpec, ivParameterSpec)\n\n          val ecordedValue: Array[Byte] = new BASE64Decoder().decodeBuffer(r[encryptedTextFieldIndex1].asInstanceOf[String])\n          val decryped: Array[Byte] = cipher.doFinal(decordedValue)\n          outputRowData[myDecryptedSecretFieldIndex] = new String(decrypted)\n          outputRowData[COL1Index2] = r[COL1Index1]\n          outputRowData[COL2Index2] = r[COL2Index1]\n          outputRowData[encryptedTextFieldIndex2] = r[encryptedTextFieldIndex1]\n\n          putRow(data.outputRowMeta, outputRowData)\n        } catch {\n          case t: Throwable => \n              val exMessage: String = \"failed during decryption::\" + r[encryptedTextFieldIndex1].asInstanceOf[String]\n        }\n      true\n      }\n    }\n  }\n}\n", "idx": 2428}
{"project": "cipher", "commit_id": "Snippet42839925_24939.java", "target": 1, "func": "private String byte[] decodeBase64(String dataToDecode)\n{\n    byte[] dataDecoded = Base64.decode(dataToDecode, Base64.DEFAULT);\n    return dataDecoded;\n}\npublic static void decrypt(String s) throws Exception\n{\n\n    String modulus = \"your modulus here\";\n    String dD = \"your D here\"; \n\n    byte[] modBytes = decodeBase64(modulus.trim());\n    byte[] dBytes = decodeBase64(dD.trim());\n\n    BigInteger modules = new BigInteger(1, modBytes);\n    BigInteger d = new BigInteger(1, dBytes);\n\n    KeyFactory factory = KeyFactory.getInstance(\"RSA\");\n    Cipher cipher = Cipher.getInstance(\"RSA/ECB/PKCS1Padding\");\n\n    RSAPrivateKeySpec privSpec = new RSAPrivateKeySpec(modules, d);\n    PrivateKey privKey = factory.generatePrivate(privSpec);\n    cipher.init(Cipher.DECRYPT_MODE, privKey);\n    byte[] decrypted = cipher.doFinal(decodeBase64(s));\n    return new String(decrypted);\n}\n", "idx": 2395}
{"project": "cipher", "commit_id": "Snippet21083313_3678.java", "target": 0, "func": "public class myDesCbc2 {\n\npublic static void main(String[] args) throws FileNotFoundException, UnsupportedEncodingException, IOException, NoSuchAlgorithmException, NoSuchPaddingException, InvalidAlgorithmParameterException, InvalidKeyException, IllegalBlockSizeException, BadPaddingException {\n\n\n        JFrame frame = null;\n        JFileChooser fChoose = new JFileChooser(System.getProperty(\"user.home\"));\n        int returnVal = fChoose.showOpenDialog(frame);\n        File myFile = fChoose.getSelectedFile();\n\n        FileInputStream fis = new FileInputStream(myFile);\n        BufferedReader stream = new BufferedReader(new InputStreamReader(fis, \"ISO-8859-1\"));\n        String file;\n        while ((file = stream.readLine()) != null) {\n\n            JOptionPane.showOptionDialog(\n                    null, \"Generating a 56-bit DES key...\", \"Processing...\", JOptionPane.DEFAULT_OPTION, JOptionPane.INFORMATION_MESSAGE, null, new Object[]{}, null);\n\n        }\n        // Create an 8-byte initialization vector\n        SecureRandom sr = new SecureRandom();\n        byte[] iv = new byte[8];\n        sr.nextBytes(iv);\n        IvParameterSpec IV = new IvParameterSpec(iv);\n\n        // Create a 56-bit DES key\n        KeyGenerator kg = KeyGenerator.getInstance(\"DES\");\n\n        // Initialize with keysize\n        kg.init(56);\n        Key mykey = kg.generateKey();\n\n        JOptionPane.showOptionDialog(\n                null, \"Your key has been generated!\", \"Processing...\", JOptionPane.DEFAULT_OPTION, JOptionPane.INFORMATION_MESSAGE, null, new Object[]{}, null);\n\n        // Create a cipher object and use the generated key to initialize it\n        Cipher cipher = Cipher.getInstance(\"DES/CBC/PKCS5Padding\");\n\n        cipher.init(Cipher.ENCRYPT_MODE, mykey, IV);\n\n        byte[] plaintext = file.getBytes(\"UTF8\");\n\n        // Encrypt the text\n        byte[] ciphertext = cipher.doFinal(plaintext);\n\n        JOptionPane.showMessageDialog(\n                null, \"Your ciphertext is\" + asHex(ciphertext), \"Done!\", JOptionPane.PLAIN_MESSAGE);\n\n    }\n}\n", "idx": 2100}
{"project": "cipher", "commit_id": "Snippet13556295_37102.java", "target": 1, "func": "Cipher cipher2 = Cipher.getInstance(\"RSA\");\ncipher2.init(Cipher.DECRYPT_MODE, privateKey);\nbyte[] plainData = cipher.doFinal(cipherData);\nString p  = new String(plainData);\nLog.d(\"decrypted data is:\",p);\n", "idx": 2699}
{"project": "cipher", "commit_id": "Snippet23101320_5461.java", "target": 0, "func": "Cipher.getInstance(\"AES\")", "idx": 2044}
{"project": "cipher", "commit_id": "Snippet2580473_30349.java", "target": 1, "func": "import java.math.BigInteger;\nimport java.security.KeyFactory;\nimport java.security.interfaces.RSAPrivateKey;\nimport java.security.interfaces.RSAPublicKey;\nimport java.security.spec.RSAPrivateKeySpec;\nimport java.security.spec.RSAPublicKeySpec;\n\nimport javax.crypto.Cipher;\n\n/**\n * Basic RSA example.\n */\npublic class TestRSA {\n\n    public static void main(String[] args) throws Exception {\n\n byte[] input = new byte[100];\n\n Cipher cipher = Cipher.getInstance(\"RSA/None/NoPadding\", \"BC\");\n KeyFactory keyFactory = KeyFactory.getInstance(\"RSA\", \"BC\");\n\n // create the keys\n\n RSAPublicKeySpec pubKeySpec = new RSAPublicKeySpec(new BigInteger(\"d46f473a2d746537de2056ae3092c451\",\n  16), new BigInteger(\"11\", 16));\n RSAPrivateKeySpec privKeySpec = new RSAPrivateKeySpec(new BigInteger(\n  \"d46f473a2d746537de2056ae3092c451\", 16), new BigInteger(\"57791d5430d593164082036ad8b29fb1\",\n  16));\n\n RSAPublicKey pubKey = (RSAPublicKey) keyFactory.generatePublic(pubKeySpec);\n RSAPrivateKey privKey = (RSAPrivateKey) keyFactory.generatePrivate(privKeySpec);\n\n // encryption step\n\n cipher.init(Cipher.ENCRYPT_MODE, pubKey);\n\n byte[] cipherText = cipher.doFinal(input);\n\n // decryption step\n\n cipher.init(Cipher.DECRYPT_MODE, privKey);\n\n byte[] plainText = cipher.doFinal(cipherText);\n\n    }\n}\n", "idx": 2558}
{"project": "cipher", "commit_id": "Snippet42988736_25116.java", "target": 1, "func": "import java.io.ByteArrayOutputStream;\nimport java.io.IOException;\nimport java.math.BigInteger;\nimport java.security.InvalidKeyException;\nimport java.security.KeyFactory;\nimport java.security.NoSuchAlgorithmException;\nimport java.security.PrivateKey;\nimport java.security.PublicKey;\nimport java.security.interfaces.RSAPrivateKey;\nimport java.security.spec.InvalidKeySpecException;\nimport java.security.spec.RSAPrivateCrtKeySpec;\nimport java.security.spec.RSAPrivateKeySpec;\nimport java.security.spec.RSAPublicKeySpec;\nimport java.util.ArrayList;\nimport java.util.List;\n\nimport javax.crypto.BadPaddingException;\nimport javax.crypto.Cipher;\nimport javax.crypto.IllegalBlockSizeException;\nimport javax.crypto.NoSuchPaddingException;\n\nimport org.apache.commons.codec.binary.Base64;\n\npublic class RsaKeys {\nprivate final String rsaDecAlgorithm = \"RSA\";\nprivate static KeyFactory kf;\nprivate static Cipher cipher;\n\npublic PublicKey publicKey;\npublic PrivateKey privateKey;\nprivate RsaKeyValue rsaKeyVal = new RsaKeyValue();\n\npublic RsaKeys(String path) {\n    this.rsaKeyVal = new RsaKeyValue(path);\n    this.privateKey = makePrivateKey();\n    //this.privateKey = makePrivateKeyTwo();\n    this.publicKey = makePublicKey();\n\n}\n\npublic String encryptString(byte[] input) {\n    try {\n        cipher = Cipher.getInstance(\"RSA/ECB/PKCS1Padding\");\n        cipher.init(Cipher.ENCRYPT_MODE, publicKey);\n        byte[] ret = cipher.doFinal(input);\n        return Base64.encodeBase64String(ret);\n\n    } catch (InvalidKeyException e) {\n        // TODO Auto-generated catch block\n        e.printStackTrace();\n    } catch (IllegalBlockSizeException e) {\n        // TODO Auto-generated catch block\n        e.printStackTrace();\n    } catch (BadPaddingException e) {\n        // TODO Auto-generated catch block\n        e.printStackTrace();\n    } catch (NoSuchAlgorithmException e) {\n        // TODO Auto-generated catch block\n        e.printStackTrace();\n    } catch (NoSuchPaddingException e) {\n        // TODO Auto-generated catch block\n        e.printStackTrace();\n    }\n\n    return null;\n\n}\n\npublic String decrypt(String encryptedString) {\n    try {\n        cipher = Cipher.getInstance(\"RSA/ECB/PKCS1Padding\");\n        cipher.init(Cipher.DECRYPT_MODE, privateKey);\n    } catch (InvalidKeyException | NoSuchAlgorithmException | NoSuchPaddingException e) {\n        // TODO Auto-generated catch block\n        e.printStackTrace();\n    }\n\n    int base64BlockSize = (this.rsaKeyVal.getBitStrength() / 8) % 3 != 0\n            ? (((this.rsaKeyVal.getBitStrength() / 8) / 3) * 4) + 4\n            : (((this.rsaKeyVal.getBitStrength() / 8)) / 3) * 4;\n\n    int iterations = encryptedString.length() / base64BlockSize;\n    List<byte[]> temp = new ArrayList<byte[]>();\n\n    /**/\n    System.out.println(\"base64BlockSize: \" + base64BlockSize);\n    System.out.println(\"Iterations: \" + iterations);\n    /**/\n\n    for (int i = 0; i < iterations; i++) {\n        try {\n            byte[] bytesArray = Base64\n                    .decodeBase64(encryptedString.substring(base64BlockSize * i, base64BlockSize));\n\n            /**/\n            System.out.println(\"Byte Array Encrypted String Length: \" + bytesArray.length);\n            System.out.println(\"Encoded Byte Array Encrypted String: \" + Base64.encodeBase64String((bytesArray)));\n            /**/\n\n            temp.add(cipher.doFinal(bytesArray));\n\n        } catch (IllegalBlockSizeException e) {\n\n            e.printStackTrace();\n        } catch (BadPaddingException e) {\n\n            e.printStackTrace();\n        }\n    }\n\n    ByteArrayOutputStream bStr = new ByteArrayOutputStream();\n    byte[] retBal = null;\n    try {\n\n        temp.stream().forEach(x -> {\n            try {\n                bStr.write(x);\n            } catch (IOException e) {\n                // TODO Auto-generated catch block\n                e.printStackTrace();\n            }\n        });\n\n        retBal = bStr.toByteArray();\n    } catch (Exception e) {\n        e.printStackTrace();\n    } finally {\n        try {\n            bStr.close();\n        } catch (IOException e) {\n            // TODO Auto-generated catch block\n            e.printStackTrace();\n        }\n    }\n\n    return Base64.encodeBase64String(retBal).toString();\n}\n\npublic String getPrivateKeyModulus() {\n    RSAPrivateKey temp = (RSAPrivateKey) privateKey;\n    return \"Modulus: \" + temp.getModulus();\n}\n\nprivate PublicKey makePublicKey() {\n\n    try {\n        byte[] modBytes = Base64.decodeBase64(this.rsaKeyVal.getModulus());\n        byte[] expBytes = Base64.decodeBase64(this.rsaKeyVal.getExponent());\n\n        kf = KeyFactory.getInstance(rsaDecAlgorithm);\n\n        BigInteger mod = new BigInteger(1, modBytes);\n        BigInteger exp = new BigInteger(1, expBytes);\n\n        RSAPublicKeySpec pubSpec = new RSAPublicKeySpec(mod, exp);\n        PublicKey pubKey = kf.generatePublic(pubSpec);\n\n        return pubKey;\n    } catch (InvalidKeySpecException e) {\n        // TODO Auto-generated catch block\n        e.printStackTrace();\n    } catch (NoSuchAlgorithmException e) {\n        // TODO Auto-generated catch block\n        e.printStackTrace();\n    }\n\n    return null;\n}\n\nprivate PrivateKey makePrivateKey() {\n\n    try {\n        byte[] modBytes = Base64.decodeBase64(this.rsaKeyVal.getModulus());\n        byte[] dBytes = Base64.decodeBase64(this.rsaKeyVal.getD());\n\n        kf = KeyFactory.getInstance(rsaDecAlgorithm);\n\n        BigInteger mod = new BigInteger(1, modBytes);\n        BigInteger d = new BigInteger(1, dBytes);\n\n        RSAPrivateKeySpec privSpec = new RSAPrivateKeySpec(mod, d);\n        PrivateKey pKey = kf.generatePrivate(privSpec);\n\n        return pKey;\n    } catch (InvalidKeySpecException e) {\n        // TODO Auto-generated catch block\n        e.printStackTrace();\n    } catch (NoSuchAlgorithmException e) {\n        // TODO Auto-generated catch block\n        e.printStackTrace();\n    } \n\n    return null;\n}\n\nprivate PrivateKey makePrivateKeyTwo() {\n\n    byte[] modBytes = Base64.decodeBase64(this.rsaKeyVal.getModulus());\n    byte[] expBytes = Base64.decodeBase64(this.rsaKeyVal.getExponent());\n    byte[] dBytes = Base64.decodeBase64(this.rsaKeyVal.getD());\n    byte[] pBytes = Base64.decodeBase64(this.rsaKeyVal.getP());\n    byte[] qBytes = Base64.decodeBase64(this.rsaKeyVal.getQ());\n    byte[] dpBytes = Base64.decodeBase64(this.rsaKeyVal.getDp());\n    byte[] dqBytes = Base64.decodeBase64(this.rsaKeyVal.getDq());\n    byte[] inverseQBytes = Base64.decodeBase64(this.rsaKeyVal.getInverseQ());\n\n    BigInteger mod = new BigInteger(1, modBytes);\n    BigInteger exp = new BigInteger(1, expBytes);\n    BigInteger d = new BigInteger(1, dBytes);\n    BigInteger p = new BigInteger(1, pBytes);\n    BigInteger q = new BigInteger(1, qBytes);\n    BigInteger dp = new BigInteger(1, dpBytes);\n    BigInteger dq = new BigInteger(1, dqBytes);\n    BigInteger inverseQ = new BigInteger(1, inverseQBytes);\n\n    RSAPrivateCrtKeySpec keySpec = \n            new RSAPrivateCrtKeySpec(\n                    mod,\n                    exp,\n                    d,\n                    p,\n                    q,\n                    dp,\n                    dq,\n                    inverseQ\n                    );\n\n    try {\n        kf = KeyFactory.getInstance(rsaDecAlgorithm);\n        PrivateKey key = kf.generatePrivate(keySpec);\n\n        return key;\n    } catch (NoSuchAlgorithmException e) {\n        // TODO Auto-generated catch block\n        e.printStackTrace();\n    } catch (InvalidKeySpecException e) {\n        // TODO Auto-generated catch block\n        e.printStackTrace();\n    }\n\n    return null;\n}\n}\n", "idx": 2672}
{"project": "cipher", "commit_id": "Snippet9497876_33967.java", "target": 0, "func": "public static void encryptVideos(File fil,File outfile)\n{ \n  try{\n    FileInputStream fis = new FileInputStream(fil);\n    //File outfile = new File(fil2);\n    int read;\n    if(!outfile.exists())\n      outfile.createNewFile();\n    FileOutputStream fos = new FileOutputStream(outfile);\n    FileInputStream encfis = new FileInputStream(outfile);\n    Cipher encipher = Cipher.getInstance(\"AES\");\n    KeyGenerator kgen = KeyGenerator.getInstance(\"AES\");\n    //byte key[] = {0x00,0x32,0x22,0x11,0x00,0x00,0x00,0x00,0x00,0x23,0x00,0x00,0x00,0x00,0x00,0x00,0x00};\n    SecretKey skey = kgen.generateKey();\n    //Lgo\n    encipher.init(Cipher.ENCRYPT_MODE, skey);\n    CipherInputStream cis = new CipherInputStream(fis, encipher);\n    while((read = cis.read())!=-1)\n      {\n        fos.write(read);\n        fos.flush();\n      }   \n    fos.close();\n  }catch (Exception e) {\n    // TODO: handle exception\n  }\n}\n", "idx": 2135}
{"project": "cipher", "commit_id": "Snippet30018667_12089.java", "target": 1, "func": "protected String doInBackground(String... args) {\n   \n   runOnUiThread(new Runnable() {\n    public void run() {\n     userStr = inputUsername.getText().toString();\n     passStr = inputPassword.getText().toString();\n     confirmpass = inputConfirmPass.getText().toString();\n     \n     if(userStr.equals(\"\") || passStr.equals(\"\") || confirmpass.equals(\"\"))\n     {\n      Toast.makeText(getApplicationContext(),\"Enter all the fields\" ,Toast.LENGTH_SHORT).show();\n     }\n     else\n     {\n      if(passStr.equals(confirmpass))\n      {\n       //Encoding the string using RSA Algorithm\n       \n          // Original text\n       valid=1;\n       \n          // Generate key pair for 1024-bit RSA encryption and decryption\n          Key publicKey = null;\n          Key privateKey = null;\n          String publicKeyStr;\n          try {\n              KeyPairGenerator kpg = KeyPairGenerator.getInstance(\"RSA\");\n              kpg.initialize(1024);\n              KeyPair kp = kpg.genKeyPair();\n              publicKey = kp.getPublic();\n              privateKey = kp.getPrivate();\n          } catch (Exception e) {\n              Log.e(\"\", \"RSA key pair error\");\n          }\n  \n          byte[] encodedUser = null,encodedPassword = null;\n          \n          //Changing public key to str to transfer it between activities\n          publicKeyStr = Base64.encodeToString(publicKey.getEncoded(), Base64.DEFAULT);\n  \n          try {\n              //Encoding Username\n           // Encode the original data with RSA private key\n           Cipher c = Cipher.getInstance(\"RSA/ECB/PKCS1Padding\");\n              c.init(Cipher.ENCRYPT_MODE, privateKey);\n              encodedUser = c.doFinal(Base64.encode(userStr.getBytes(\"utf-8\"),Base64.DEFAULT));\n              \n              //Encoding Password\n              encodedPassword = c.doFinal(Base64.encode(passStr.getBytes(\"utf-8\"),Base64.DEFAULT));\n          } catch (Exception e) {\n              Log.e(\"Error Type:\", \"RSA encryption error\");\n          }\n          \n       String UsernameStrEncod,PasswordStrEncod;\n          UsernameStrEncod = Base64.encodeToString(encodedUser, Base64.DEFAULT);\n          PasswordStrEncod = Base64.encodeToString(encodedPassword, Base64.DEFAULT);\n          \n          \n          List<NameValuePair> params = new ArrayList<NameValuePair>();\n       params.add(new BasicNameValuePair(\"username\", UsernameStrEncod));\n       params.add(new BasicNameValuePair(\"password\", PasswordStrEncod));\n       params.add(new BasicNameValuePair(\"publickey\", publicKeyStr));\n       // getting JSON Object\n       // Note that create product url accepts POST method\n       JSONObject json = jsonParser.makeHttpRequest(url_register_user,\"POST\", params);\n       \n       // check log cat fro response\n       Log.d(\"Create Response\", json.toString());\n    \n       // check for success tag\n       try {\n        int success = json.getInt(TAG_SUCCESS);\n    \n        if (success == 1) {\n         // successfully created product\n         Intent i = new Intent(getApplicationContext(), LoginActivity.class);\n         //i.putExtra(\"encodedUser\", encodedUser);\n         //i.putExtra(\"publicKey\", publicKeyStr);\n         startActivity(i);\n         \n         // closing this screen\n         finish();\n        } else {\n         // failed to create product\n        }\n       } catch (JSONException e) {\n        e.printStackTrace();\n       }\n      }\n      else\n       Toast.makeText(getApplicationContext(),\"Both the passwords do not match\" ,Toast.LENGTH_SHORT).show();\n     }\n    }\n   }); \n   return null;\n  }", "idx": 2447}
{"project": "cipher", "commit_id": "Snippet6900542_32438.java", "target": 1, "func": "Cipher cipher = Cipher.getInstance(\"AES/CBC/PKCS5Padding\");\nSecretKeySpec keySpec = new SecretKeySpec(CHUNK_ENCRYPTION_KEY.getBytes(), 0, 32, \"AES\");\nIvParameterSpec initVector = new IvParameterSpec(AES_INITIALIZATION_VECTOR.getBytes(), 0 , 16);\ncipher.init(Cipher.ENCRYPT_MODE, keySpec, initVector);\n", "idx": 2719}
{"project": "cipher", "commit_id": "Snippet33579333_15628.java", "target": 0, "func": "public static String Encrypt(String plainText, byte[] key2) throws NoSuchAlgorithmException, NoSuchPaddingException, InvalidKeyException, IllegalBlockSizeException, BadPaddingException, UnsupportedEncodingException {\n      byte[] encryptedTextBytes=null;\n      byte[] key3 =null;\n      MessageDigest sha = MessageDigest.getInstance(\"SHA-1\");\n      key3= sha.digest(key2);\n      key3 = copyOf(key3, 16);\n      SecretKeySpec keySpec = new SecretKeySpec(key3, \"AES\");\n      // Instantiate the cipher\n      Cipher cipher = Cipher.getInstance(\"AES/ECB/PKCS5Padding\");\n      cipher.init(Cipher.ENCRYPT_MODE, keySpec);\n      encryptedTextBytes = cipher.doFinal(plainText.getBytes(\"UTF-8\"));\n      return new Base64().encode(encryptedTextBytes);\n}\n", "idx": 2222}
{"project": "cipher", "commit_id": "Snippet36680064_18552.java", "target": 1, "func": "public static SecretKey generateKey(Context c, char[] passphraseOrPin) throws NoSuchAlgorithmException, InvalidKeySpecException {\n    // Number of PBKDF2 hardening rounds to use. Larger values increase\n    // computation time. You should select a value that causes computation\n    // to take >100ms.\n    byte[] salt = Settings.Secure.getString(c.getContentResolver(),\n            Settings.Secure.ANDROID_ID).getBytes();\n\n    final int iterations = 1000;\n\n    final int outputKeyLength = 128;\n\n    SecretKeyFactory secretKeyFactory = SecretKeyFactory.getInstance(\"PBKDF2WithHmacSHA1\");\n    KeySpec keySpec = new PBEKeySpec(passphraseOrPin, salt, iterations, outputKeyLength);\n    SecretKey secretKey = secretKeyFactory.generateSecret(keySpec);\n    Log.d(\"HIDEMYPICS\",\"Secret Key: \" + toHex(secretKey.getEncoded()) );\n    return secretKey;\n}\n\npublic static boolean decryptFileFromUri(Context context, Uri file, String keyphrase) {\n    try {\n        File f = new File(getRealPathFromURI(context, file));\n        FileInputStream fis = new FileInputStream(f);\n\n        File ef = new File(f.toString().replace(\".epf\", \"\"));\n        FileOutputStream fos = new FileOutputStream(ef);\n\n        Log.d(\"HIDEMYPICS\",\"Decrypting: \" + f.toString());\n\n        SecretKey key = generateKey(context, keyphrase.toCharArray());\n        Cipher cipher = Cipher.getInstance(\"AES/CBC/PKCS5Padding\");\n        cipher.init(Cipher.DECRYPT_MODE, key);\n        // Wrap the output stream\n        CipherOutputStream cos = new CipherOutputStream(fos, cipher);\n        // Write bytes\n        int b;\n        byte[] d = new byte[8];\n        while ((b = fis.read(d)) != -1) {\n            cos.write(d, 0, b);\n        }\n        // Flush and close streams.\n        cos.flush();\n        cos.close();\n        fis.close();\n\n        Log.d(\"HIDEMYPICS\",\"Decrypted to: \" + ef.toString());\n        return true;\n    } catch (IOException e){\n        e.printStackTrace();\n    } catch (NoSuchPaddingException e) {\n        e.printStackTrace();\n    } catch (NoSuchAlgorithmException e) {\n        e.printStackTrace();\n    } catch (InvalidKeyException e) {\n        e.printStackTrace();\n    } catch (InvalidKeySpecException e) {\n        e.printStackTrace();\n    }\n    return false;\n}\n\npublic static boolean encryptFileFromUri(Context context, Uri file, String keyphrase) {\n    try {\n        File f = new File(getRealPathFromURI(context, file));\n        FileInputStream fis = new FileInputStream(f);\n\n        File ef = new File(f.toString() + \".epf\");\n        FileOutputStream fos = new FileOutputStream(ef);\n\n        Log.d(\"HIDEMYPICS\",\"Encrypting: \" + f.toString());\n\n        SecretKey key = generateKey(context, keyphrase.toCharArray());\n        Cipher cipher = Cipher.getInstance(\"AES/CBC/PKCS5Padding\");\n        cipher.init(Cipher.ENCRYPT_MODE, key);\n        // Wrap the output stream\n        CipherOutputStream cos = new CipherOutputStream(fos, cipher);\n        // Write bytes\n        int b;\n        byte[] d = new byte[8];\n        while ((b = fis.read(d)) != -1) {\n            cos.write(d, 0, b);\n        }\n        // Flush and close streams.\n        cos.flush();\n        cos.close();\n        fis.close();\n        Log.d(\"HIDEMYPICS\",\"Encrypted to: \" + ef.toString());\n        return true;\n    } catch (IOException e){\n        e.printStackTrace();\n    } catch (NoSuchPaddingException e) {\n        e.printStackTrace();\n    } catch (NoSuchAlgorithmException e) {\n        e.printStackTrace();\n    } catch (InvalidKeyException e) {\n        e.printStackTrace();\n    } catch (InvalidKeySpecException e) {\n        e.printStackTrace();\n    }\n    return false;\n}\n", "idx": 2642}
{"project": "cipher", "commit_id": "Snippet2264038_30273.java", "target": 1, "func": "public static final byte[] IV = new byte[]\n{ 0x04, 0x08, 0x15, 0x16, 0x23, 0x42, 0x00, 0x00, 0x00, 0x00,0x0a, 0x0b, 0x0c, 0x0d, 0x0e, 0x0f};\nprotected final IvParameterSpec params = new IvParameterSpec(IV);\nprotected Cipher myCipher;\n\npublic AESEncryptor(String passwd, InputStream source, String destinationFile)\n{\n    try\n    {           \n        myCipher = Cipher.getInstance(\"AES/CBC/PKCS5Padding\");\n        Log.d(\"System.out.println\", \"Block Size: \"+myCipher.getBlockSize());\n        myCipher.init(Cipher.ENCRYPT_MODE, AESEncryptor.generateSecretKeyFromPassword(passwd),params);\n    }\n    catch (Exception e)\n    {\n        e.printStackTrace();\n    }\n}\n", "idx": 2600}
{"project": "cipher", "commit_id": "Snippet23027359_5413.java", "target": 0, "func": "package custom_enc;\n\nimport java.io.File;\nimport java.io.FileInputStream;\nimport java.io.FileOutputStream;\nimport java.util.Scanner;\nimport javax.crypto.Cipher;\nimport javax.crypto.CipherInputStream;\nimport javax.crypto.CipherOutputStream;\nimport javax.crypto.spec.SecretKeySpec;\npublic class Custom_enc {\n\nString ekey=\"\";\nString algorithm=\"\";\nString path1=\"\";\nFile f;\n\npublic void Custom_enc()\n{\n    System.out.println(\"Enter the file name with extension and path : \\n\");\n    Scanner s = new Scanner(System.in);\n    String path1 = s.nextLine();\n    f = new File(path1);\n    System.out.println(\"Enter secret key : \\n\");\n    ekey = s.nextLine();\n}\n\npublic void encrypt() throws Exception\n{\n   Custom_enc();\n   this.algorithm=\"DES/ECB/PKCS5Padding\";\n    FileInputStream fis =new FileInputStream(f);\n    f=new File(f.getAbsolutePath()+\"_encrypted_file.txt\");\n    FileOutputStream fos =new FileOutputStream(f);\n\n    byte k[] = ekey.getBytes();\n    SecretKeySpec key = new SecretKeySpec(k,\"DES\");\n    Cipher encrypt = Cipher.getInstance(algorithm);\n\n    encrypt.init(Cipher.ENCRYPT_MODE, key);\n    CipherOutputStream cout=new CipherOutputStream(fos, encrypt);\n    byte[] buf = new byte[1024];\n    int read;\n\n    while((read=fis.read(buf))!=-1) //reading data\n        cout.write(buf,0,read); //writing encrypted data\n\n    fis.close();\n    cout.flush();\n    cout.close();\n    System.out.println(\"Encryption Done!!\");\n    //exit();\n}\n\npublic void decrypt() throws Exception\n{\n    Custom_enc();\n    this.algorithm=\"DES/ECB/PKCS5Padding\";\n    FileInputStream fis =new FileInputStream(f);\n    f=new File(f.getAbsolutePath()+\"_decrypted_file.txt\");\n    FileOutputStream fos =new FileOutputStream(f);\n\n    byte k[] = ekey.getBytes();\n    SecretKeySpec key = new SecretKeySpec(k,\"DES\");\n\n    Cipher decrypt = Cipher.getInstance(algorithm);\n    decrypt.init(Cipher.DECRYPT_MODE, key);\n    CipherInputStream cin=new CipherInputStream(fis, decrypt);\n\n    byte[] buf = new byte[1024];\n    int read=0;\n\n    while((read=cin.read(buf))!=-1) //reading encrypted data\n    {\n        fos.write(buf,0,read); //writing decrypted data\n    }\n\n    cin.close();\n    fos.flush();\n    fos.close();\n\n    System.out.println(\"Encryption Done!!\");\n    //1exit();\n\n}\n\npublic static void main(String[] args) throws Exception,     java.security.InvalidKeyException {\n    Custom_enc obj = new Custom_enc();\n    System.out.println(\"Enter your choice : \\n 1 For Encryption \\n 2 For Decryption\");\n    Scanner s1 = new Scanner(System.in);\n    int choice = s1.nextInt();\n    if(choice==1)\n    {\n        System.out.println(\"You've chosen to Encrypt\\n\");\n        obj.encrypt();\n    }\n    else if(choice==2)\n    {\n        System.out.println(\"You've chosen to Decrypt\\n\");\n        obj.decrypt();\n    }\n    else\n    {\n        System.out.println(\"Invalid Choice, Try again...\");\n    }\n}\n\n}\n", "idx": 2090}
{"project": "cipher", "commit_id": "Snippet20323765_2965.java", "target": 0, "func": "public static String encrypt(String data) throws Exception {\n    byte[] keyValue = encryptionKey.getBytes();\n    Key key = new SecretKeySpec(keyValue, \"AES\");\n    Cipher c = Cipher.getInstance(\"AES/ECB/PKCS5Padding\");\n    c.init(Cipher.ENCRYPT_MODE, key);\n    byte[] encVal = c.doFinal(data.getBytes());\n    String encryptedValue = new BASE64Encoder().encode(encVal);\n    return encryptedValue;\n}\n", "idx": 2207}
{"project": "cipher", "commit_id": "Snippet8723979_33455.java", "target": 0, "func": "    input = new FileInputStream(file);\n    output = new FileOutputStream(newFile);\n\n    Cipher cipher = Cipher.getInstance(\"DES\");\n    cipher.init(Cipher.DECRYPT_MODE, mySecretKey);\n\n    byte[] buf = new byte[1024];\n\n    count = input.read(buf);\n\n    while (count >= 0) {\n        output.write(cipher.update(buf, 0, count)); // HERE I WAS DOING doFinal() method\n\n        //AND HERE WAS THE BadPaddingExceotion -- the first pass in the while structure\n\n        count = input.read(buf);\n    }\n    output.write(cipher.doFinal()); // AND I DID NOT HAD THIS LINE BEFORE\n    output.flush();\n", "idx": 2158}
{"project": "cipher", "commit_id": "Snippet40693831_22567.java", "target": 1, "func": "ServerSocket server;\nint listenPort = 8877;\nWritableGUI gui;\nLoginScreen sc = new LoginScreen();\n\npublic MessageListener(WritableGUI gui, int port){\n    this.listenPort = port;\n    this.gui = gui;\n    try {\n        server = new ServerSocket(port);\n    } catch (IOException ex) {\n        Logger.getLogger(MessageListener.class.getName()).log(Level.SEVERE, null, ex);\n    }\n}\npublic void decryptMessage(InputStream inStream) throws IOException, NoSuchAlgorithmException\n{\n    try {\n\n        //Create the Data input stream from the socket\n        DataInputStream dis = new DataInputStream(inStream);\n\n        //Get the key\n        ObjectInputStream in = new ObjectInputStream(new FileInputStream(\"KeyFile.xx\"));\n\n        PrivateKey privatekey = (PrivateKey) in.readObject();\n        System.out.println(\"Key Used: \" + in.toString());\n        in.close();\n\n        //Initiate the cipher\n        Cipher cipher = Cipher.getInstance(\"RSA/ECB/PKCS1Padding\");                        \n        cipher.init(Cipher.DECRYPT_MODE,privatekey);\n\n        int len = dis.readInt();\n        byte[] encryptedMsg = new byte[len];\n        dis.readFully(encryptedMsg);         \n\n        System.out.println(\"Server - Msg Length: \" + len);\n        System.out.println(\"Server - Encrypted: \" + asHex(encryptedMsg));\n\n        // -Print out the decrypt String to see if it matches the original message.\n        byte[] plainText = cipher.doFinal(encryptedMsg);\n        System.out.println(\"Decrypted Message: \" + new String(plainText, \"SHA\"));\n\n\n    } catch (Exception e) {\n        e.printStackTrace();\n    }\n}\n\n//Function to make the bytes printable (hex format)\npublic static String asHex(byte buf[]) {\n    StringBuilder strbuf = new StringBuilder(buf.length * 2);\n    int i;\n    for (i = 0; i < buf.length; i++) {\n        if (((int) buf[i] & 0xff) < 0x10) {\n            strbuf.append(\"0\");\n        }\n        strbuf.append(Long.toString((int) buf[i] & 0xff, 16));\n    }\n    return strbuf.toString();\n}\n\n@Override\npublic void run() {\n    Socket clientSocket;\n\n    try {\n        while((clientSocket = server.accept()) != null){\n            InputStream is = clientSocket.getInputStream();\n            decryptMessage(is);\n            BufferedReader br = new BufferedReader(new InputStreamReader(is)); \n            String line = br.readLine();\n            if(line != null){\n                gui.write(line);\n            }\n        }\n", "idx": 2542}
{"project": "cipher", "commit_id": "Snippet45030293_27148.java", "target": 1, "func": " public static String encryptStringToBase64(String messageString) { \n        byte[] messageBytes = messageString.getBytes(\"UTF-8\"); \n        byte[] encrypted = convert(1, messageBytes); \n        return Base64.encodeBytes(encrypted); \n    } \n\nprivate static byte[] convert(int mode, byte[] messageBytes) { \n\n    MessageDigest sha256 = MessageDigest.getInstance(\"SHA-256\"); \n    sha256.update(\"abcdefgh\".getBytes(\"UTF-8\")); \n    byte[] keyBytes = sha256.digest(); \n    byte[] hash = Arrays.copyOfRange(keyBytes, 0, 16); \n\n    SecretKeySpec keySpec = new SecretKeySpec(hash, \"AES\"); \n    byte[] ivBytes = new byte[16]; \n    IvParameterSpec ivSpec = new IvParameterSpec(ivBytes); \n    Cipher cipher = Cipher.getInstance(\"AES/CBC/PKCS5Padding\"); \n    cipher.init(mode, keySpec, ivSpec); \n    return cipher.doFinal(messageBytes); \n}\n", "idx": 2677}
{"project": "cipher", "commit_id": "Snippet16525310_39458.java", "target": 1, "func": "public static KeyPair generateDSAKey() {\n    KeyPair pair = null;\n    try {\n        KeyPairGenerator keyGen = KeyPairGenerator\n                .getInstance(\"DSA\", \"SUN\");\n        SecureRandom random = SecureRandom.getInstance(\"SHA1PRNG\", \"SUN\");\n        keyGen.initialize(1024, random);\n        pair = keyGen.generateKeyPair();\n    } catch (Exception e) {\n        e.printStackTrace();\n    }\n    return pair;\n}\npublic static KeyPair generateRSAKey() {\n    KeyPairGenerator kpg;\n    KeyPair kp = null;\n    try {\n        kpg = KeyPairGenerator.getInstance(\"RSA\");\n        kpg.initialize(2048);\n        kp = kpg.genKeyPair();\n    } catch (NoSuchAlgorithmException e) {\n        e.printStackTrace();\n    }\n    return kp;\n}\n\npublic static byte[] encryptRSA(byte[] msg, PublicKey pubKey) {\n    byte[] cipherData = null;\n    try {\n        Cipher cipher = Cipher.getInstance(\"RSA\");\n        cipher.init(Cipher.ENCRYPT_MODE, pubKey);\n        cipherData = cipher.doFinal(msg);\n    } catch (Exception e) {\n        e.printStackTrace();\n    }\n    return cipherData;\n}\n", "idx": 2382}
{"project": "cipher", "commit_id": "Snippet33818911_15898.java", "target": 0, "func": " public ArrayList<FootballClub> FootBallInputStream() throws FileNotFoundException, IOException, ClassNotFoundException, NoSuchAlgorithmException, NoSuchPaddingException, InvalidKeyException {\n\n        SecretKey key = KeyGenerator.getInstance(\"DES\").generateKey();\n        Cipher cipher = Cipher.getInstance(\"DES\");\n        cipher.init(Cipher.DECRYPT_MODE, key);\n        File file = new File(\"FootballClub.ser\");\n        fileIn = new FileInputStream(file);\n        CipherInputStream CipherIn = new CipherInputStream(fileIn, cipher);\n        in = new ObjectInputStream(CipherIn);\n        ArrayList<FootballClub> e = (ArrayList<FootballClub>) in.readObject();\n        in.close();\n        fileIn.close();\n\n        return e;\n\n    }\n\n    public void FootBallOutputStream(ArrayList<FootballClub> e) throws FileNotFoundException, IOException, NoSuchAlgorithmException, NoSuchPaddingException, InvalidKeyException {\n\n        SecretKey key = KeyGenerator.getInstance(\"DES\").generateKey();\n        Cipher cipher = (Cipher.getInstance(\"DES\"));\n        cipher.init(Cipher.ENCRYPT_MODE, key);\n        File file = new File(\"FootballClub.ser\");\n        fileOut = new FileOutputStream(file);\n        CipherOutputStream cipherOut = new CipherOutputStream(fileOut, cipher);\n        out = new ObjectOutputStream(cipherOut);\n        out.writeObject(e);\n        out.close();\n        fileOut.close();\n    }\n", "idx": 1995}
{"project": "cipher", "commit_id": "Snippet30302000_12443.java", "target": 0, "func": "package blowfishcbc;\nimport java.security.MessageDigest;\nimport java.security.SecureRandom;\nimport javax.crypto.Cipher;\nimport javax.crypto.spec.IvParameterSpec;\nimport javax.crypto.spec.SecretKeySpec;\nimport sun.misc.BASE64Decoder;\nimport sun.misc.BASE64Encoder;\n\npublic class BlowfishCBC {\n\n    public static void main(String[] args) throws Exception {\n\n        String keyString = \"7890\";\n        String input = \"some data\";\n\n        Cipher cipher = Cipher.getInstance(\"Blowfish/CBC/PKCS5Padding\");\n\n        // for IV\n        byte[] iv = new byte[cipher.getBlockSize()];\n        new SecureRandom().nextBytes(iv);\n        IvParameterSpec ivSpec = new IvParameterSpec(iv);\n\n        // for key\n        byte[] keyData = (keyString).getBytes();\n        SecretKeySpec keySpec = new SecretKeySpec(keyData, \"Blowfish\");\n\n        // encrypt\n        cipher.init(Cipher.ENCRYPT_MODE, keySpec, ivSpec);\n        byte[] encrypted = cipher.doFinal(input.getBytes(\"UTF-8\"));\n        String enc = new BASE64Encoder().encode(encrypted);\n        System.out.println(\"encrypted: \" + new String(enc));\n\n        // decrypt\n        cipher.init(Cipher.DECRYPT_MODE, keySpec, ivSpec);\n        byte[] dec = new BASE64Decoder().decodeBuffer(enc);\n        byte[] decrypted = cipher.doFinal(dec);\n        System.out.println(\"decrypted: \" + new String(decrypted, \"UTF-8\"));\n    }\n}\n", "idx": 1935}
{"project": "cipher", "commit_id": "Snippet22742097_5145.java", "target": 1, "func": "byte[] expBytes = Base64.decode(\"AQAB\".getBytes(\"UTF-8\"), Base64.DEFAULT);\nbyte[] modBytes = Base64.decode(\"rFsMn+idg8jmVMk249DzJc7AFft3+/jcnYDTh9wHee3tgFu1gBRh7e+ao+MWq7NEN0N7kUHa7O4c/ND2Ahcx/h4mXD5KDoixFRBUsxYqCJVA68qYJ7vozVPMjNr4jeOo1xt+oevO5+mUWtcaib5Iw51u1Jq/6qCqLsm8Eq3cnsE=\".getBytes(\"UTF-8\"), Base64.DEFAULT);\nbyte[] dBytes = Base64.decode(\"Gs8mzZDPP3p2aWXLBfCwgYcBVeoBpc318wHg5VcSSqL5uGeLedqxyOLmOOvP0PFXgQkcJWIK/aOkGqcePQECo3TNiK+uLSwc97V3spZah70FFJVyh23Y+o0wlRGHAm5Nj9QieHlVwhgJPkNUJYgH9qkwB9aCpl+rdAG3da2fQ2E=\".getBytes(\"UTF-8\"), Base64.DEFAULT);\n\nBigInteger modules = new BigInteger(1, modBytes);\nBigInteger exponent = new BigInteger(1, expBytes);\nBigInteger d = new BigInteger(1, dBytes);\n\nKeyFactory factory = KeyFactory.getInstance(\"RSA\");\nCipher cipher = Cipher.getInstance(\"RSA\");\nString input = \"test\";\n\nRSAPublicKeySpec pubSpec = new RSAPublicKeySpec(modules, exponent);\nPublicKey pubKey = factory.generatePublic(pubSpec);\ncipher.init(Cipher.ENCRYPT_MODE, pubKey);\nbyte[] encrypted = cipher.doFinal(input.getBytes());\n\nString strEncrypted = Base64.encodeToString(encrypted, Base64.DEFAULT);\n", "idx": 2357}
{"project": "cipher", "commit_id": "Snippet45130483_27275.java", "target": 1, "func": "import java.io.FileInputStream;\nimport java.io.FileNotFoundException;\nimport java.io.IOException;\nimport java.security.InvalidKeyException;\nimport java.security.NoSuchAlgorithmException;\nimport java.security.PublicKey;\n\nimport javax.crypto.BadPaddingException;\nimport javax.crypto.Cipher;\nimport javax.crypto.IllegalBlockSizeException;\nimport javax.crypto.NoSuchPaddingException;\n\n\npublic class MakePublicKey {\n\n    static byte[] signature = null;\n\n\n    public static void main(String[] args) {\n\n        try {\n            FileInputStream ecPubKeyFIS = new FileInputStream(\"D__TCC40-1.bin\");\n\n            try {\n                int certificateLength = ecPubKeyFIS.available();\n                byte[] certificate = new byte[certificateLength];\n                ecPubKeyFIS.read(certificate);\n\n                MakePublicKey.signature = new byte[128];\n                System.arraycopy(certificate, 0, MakePublicKey.signature, 0, 128);\n\n                // How can I make of the signature byte[] an  PublicKey Object to call the method as the following: encrypte(\"Hellow World!\", pk)?\n\n\n            } catch (IOException e1) {\n                // TODO Auto-generated catch block\n                e1.printStackTrace();\n            }\n            // }\n        } catch (FileNotFoundException e) {\n            // TODO Auto-generated catch block\n            e.printStackTrace();\n        }\n\n    }\n\n\n    public static byte[] encrypte(String message, PublicKey pk) {\n\n        Cipher cipher = null;\n        byte[] encrypted = null;\n        try {\n            cipher = Cipher.getInstance(\"RSA\");\n        } catch (NoSuchAlgorithmException e) {\n            // TODO Auto-generated catch block\n            e.printStackTrace();\n        } catch (NoSuchPaddingException e) {\n            // TODO Auto-generated catch block\n            e.printStackTrace();\n        }\n        try {\n            cipher.init(Cipher.ENCRYPT_MODE, pk);\n        } catch (InvalidKeyException e) {\n            // TODO Auto-generated catch block\n            e.printStackTrace();\n        }\n        try {\n            encrypted = cipher.doFinal(message.getBytes());\n        } catch (IllegalBlockSizeException e) {\n            // TODO Auto-generated catch block\n            e.printStackTrace();\n        } catch (BadPaddingException e) {\n            // TODO Auto-generated catch block\n            e.printStackTrace();\n        }\n        return encrypted;\n\n    }\n\n}\n", "idx": 2702}
{"project": "cipher", "commit_id": "Snippet41202589_23173.java", "target": 0, "func": " // We must use a PasswordBasedEncryption algorithm in order to encrypt the private key, you may use any common algorithm supported by openssl, you can check them in the openssl documentation http://www.openssl.org/docs/apps/pkcs8.html\nString MYPBEALG = \"PBEWithSHA1AndDESede\";\nString password = \"pleaseChangeit!\";\n\nint count = 20;// hash iteration count\nSecureRandom random = new SecureRandom();\nbyte[] salt = new byte[8];\nrandom.nextBytes(salt);\n\n// Create PBE parameter set\nPBEParameterSpec pbeParamSpec = new PBEParameterSpec(salt, count);\nPBEKeySpec pbeKeySpec = new PBEKeySpec(password.toCharArray());\nSecretKeyFactory keyFac = SecretKeyFactory.getInstance(MYPBEALG);\nSecretKey pbeKey = keyFac.generateSecret(pbeKeySpec);\n\nCipher pbeCipher = Cipher.getInstance(MYPBEALG);\n\n// Initialize PBE Cipher with key and parameters\npbeCipher.init(Cipher.ENCRYPT_MODE, pbeKey, pbeParamSpec);\n\n// Encrypt the encoded Private Key with the PBE key\nbyte[] ciphertext = pbeCipher.doFinal(encodedPrivateKey);\n\n// Now construct  PKCS #8 EncryptedPrivateKeyInfo object\nAlgorithmParameters algparms = AlgorithmParameters.getInstance(MYPBEALG);\nalgparms.init(pbeParamSpec);\nEncryptedPrivateKeyInfo encinfo = new EncryptedPrivateKeyInfo(algparms, ciphertext);\n\n// and here we have it! a DER encoded PKCS#8 encrypted key!\nbyte[] encryptedPkcs8 = encinfo.getEncoded();\n", "idx": 2070}
{"project": "cipher", "commit_id": "Snippet41783932_23758.java", "target": 0, "func": "import javax.xml.bind.DatatypeConverter;\nimport java.security.SecureRandom;\nimport javax.crypto.Cipher;\nimport javax.crypto.KeyGenerator;\nimport javax.crypto.SecretKey;\n\npublic class CryptoTest\n{\n\n  private static final String ADMIN_PASSWORD = \"admin\";\n  private static final String ADMIN_ENCRYPTED_PASSWORD = \"532C05C5B5\";                             // RC4 encrypted password using KEY\n  private static final String ADMIN_AUTH_KEY = \"1391a8a860b7d6e2e86df513700e490c16dae47cdae227ca\"; // PBKDF2(username,password,salt)\n  private static final String CRYPTO_ALGORITHM = \"RC4\";\n\n  protected static String encryptPassword(String passwordDataToEncrypt, String userskey) throws Exception \n  {\n    SecureRandom sr = new SecureRandom(userskey.getBytes());\n    KeyGenerator kg = KeyGenerator.getInstance(CRYPTO_ALGORITHM);\n    kg.init(sr);\n    SecretKey sk = kg.generateKey();\n    Cipher cipher = Cipher.getInstance(CRYPTO_ALGORITHM);\n    cipher.init(Cipher.ENCRYPT_MODE, sk);\n    return bytesToHex(cipher.doFinal(passwordDataToEncrypt.getBytes()));\n  }\n\n  private static String bytesToHex(byte[] in) \n  {\n    return DatatypeConverter.printHexBinary(in);\n  }\n\n  private static byte[] hexStringToByteArray(String s) \n  {\n    return DatatypeConverter.parseHexBinary(s);\n  }\n\n  protected static String decryptPassword(byte[] toDecryptPassword, String key) throws Exception \n  {\n    SecureRandom sr = new SecureRandom(key.getBytes());\n    KeyGenerator kg = KeyGenerator.getInstance(CRYPTO_ALGORITHM);\n    kg.init(sr);\n    SecretKey sk = kg.generateKey();\n    Cipher cipher = Cipher.getInstance(CRYPTO_ALGORITHM);\n    cipher.init(Cipher.DECRYPT_MODE, sk);\n    return new String(cipher.doFinal(toDecryptPassword));\n  }\n\n  public static void assertEquals(String arg1, String arg2)\n  {\n    if (! arg1.equals(arg2))\n    {\n      System.out.println(String.format(\"%s does not equal %s\", arg1, arg2));\n    }\n  }\n\n  public static void testGetDecryptedPassword() throws Exception\n  {\n    String decryptedPassword = decryptPassword(hexStringToByteArray(ADMIN_ENCRYPTED_PASSWORD), ADMIN_AUTH_KEY);\n    assertEquals(ADMIN_PASSWORD, decryptedPassword);\n  }\n\n  public static void testGetEncryptedPassword() throws Exception\n  {\n    String encryptedPassword = encryptPassword(ADMIN_PASSWORD, ADMIN_AUTH_KEY);\n    assertEquals(ADMIN_ENCRYPTED_PASSWORD, encryptedPassword);\n  }\n\n  public static void testEncryptAndDecryptPasswords() throws Exception\n  {\n    String originalPassword = \"password\";\n    String encryptedPassword = encryptPassword(originalPassword, ADMIN_AUTH_KEY);\n    String decryptedPassword = decryptPassword(hexStringToByteArray(encryptedPassword), ADMIN_AUTH_KEY);\n    assertEquals(originalPassword, decryptedPassword);\n\n    originalPassword = \"This is a STRONG password 4 me!!!@#$^\";\n    encryptedPassword = encryptPassword(originalPassword, ADMIN_AUTH_KEY);\n    decryptedPassword = decryptPassword(hexStringToByteArray(encryptedPassword), ADMIN_AUTH_KEY);\n    assertEquals(originalPassword, decryptedPassword);\n  }\n\n  public static void main(final String[] args)\n  {\n    try\n    {\n      int strength =  Cipher.getMaxAllowedKeyLength(\"AES\");\n      if ( strength > 128 ){\n        System.out.printf(\"isUnlimitedSupported=TRUE,strength: %d%n\",strength);\n      } else {\n        System.out.printf(\"isUnlimitedSupported=FALSE,strength: %d%n\",strength);\n      }\n\n      testGetDecryptedPassword();\n      testGetEncryptedPassword();\n      testEncryptAndDecryptPasswords();\n    }\n    catch (Exception e)\n    {\n      System.out.printf(\"Caught exception: %s\\n\", e.getMessage());\n      e.printStackTrace(System.out);\n    }\n  }\n}\n", "idx": 2011}
{"project": "cipher", "commit_id": "Snippet46628867_28732.java", "target": 0, "func": "package tripledes;\n\nimport javax.crypto.*;\nimport javax.crypto.spec.*;\nimport java.security.*;\nimport java.security.spec.*;\nimport java.io.*;\n\npublic class TripleDES {\n\npublic static void main(String[] args) {\n\n    try {\n        try {\n            Cipher c = Cipher.getInstance(\"DESede\");\n        } catch (Exception e) {\n            System.err.println(\"Installing SunJCE provicer\");\n            Provider sunjce = new com.sun.crypto.provider.SunJCE();\n            Security.addProvider(sunjce);\n        }\n\n        File keyfile = new File(args[1]);\n\n        if (args[0].equals(\"-g\")) {\n            System.out.println(\"Generating key. This may take some time...\");\n            System.out.flush();\n            SecretKey key = generateKey();\n            writeKey(key, keyfile);\n            System.out.println(\"Done\");\n            System.out.println(\"Secret key written to \" + args[1] + \". Protect that file!\");\n        } else if (args[0].equals(\"-e\")) {\n            SecretKey key = readKey(keyfile);\n            encrypt(key, System.in, System.out);\n        } else if (args[0].equals(\"-d\")) {\n            SecretKey key = readKey(keyfile);\n            decrypt(key, System.in, System.out);\n        }\n    } catch (Exception e) {\n        System.err.println(e);\n        System.err.println(\"Usage: java \" + TripleDES.class.getName() + \"-d|-e|-g <keyfile>\");\n    }\n\n}\n\npublic static SecretKey generateKey() throws NoSuchAlgorithmException {\n    KeyGenerator keygen = KeyGenerator.getInstance(\"DESede\");\n    return keygen.generateKey();\n}\n\npublic static void writeKey(SecretKey key, File f) throws IOException, NoSuchAlgorithmException, InvalidKeySpecException {\n    SecretKeyFactory keyfactory = SecretKeyFactory.getInstance(\"DESede\");\n    DESedeKeySpec keyspec = (DESedeKeySpec) keyfactory.getKeySpec(key, DESedeKeySpec.class);\n    byte[] rawkey = keyspec.getKey();\n\n    FileOutputStream out = new FileOutputStream(f);\n    out.write(rawkey);\n    out.close();\n}\n\npublic static SecretKey readKey(File f) throws IOException, NoSuchAlgorithmException, InvalidKeyException, InvalidKeySpecException {\n    DataInputStream in = new DataInputStream(new FileInputStream(f));\n    byte[] rawkey = new byte[(int) f.length()];\n    in.readFully(rawkey);\n    in.close();\n\n    DESedeKeySpec keyspec = new DESedeKeySpec(rawkey);\n    SecretKeyFactory keyfactory = SecretKeyFactory.getInstance(\"DESede\");\n    SecretKey key = keyfactory.generateSecret(keyspec);\n    return key;\n}\n\npublic static void encrypt(SecretKey key, InputStream in, OutputStream out)\n        throws NoSuchAlgorithmException, InvalidKeyException, NoSuchPaddingException, IOException {\n    Cipher cipher = Cipher.getInstance(\"DESede\");\n    cipher.init(Cipher.ENCRYPT_MODE, key);\n\n    CipherOutputStream cos = new CipherOutputStream(out, cipher);\n\n    byte[] buffer = new byte[2048];\n    int bytesRead;\n    while ((bytesRead = in.read(buffer)) != -1) {\n        cos.write(buffer, 0, bytesRead);\n    }\n    cos.close();\n\n    java.util.Arrays.fill(buffer, (byte) 0);\n}\n\npublic static void decrypt(SecretKey key, InputStream in, OutputStream out)\n        throws NoSuchAlgorithmException, InvalidKeyException, IOException, IllegalBlockSizeException,\n        NoSuchPaddingException, BadPaddingException {\n    Cipher cipher = Cipher.getInstance(\"DESede\");\n    cipher.init(Cipher.DECRYPT_MODE, key);\n\n    byte[] buffer = new byte[2048];\n    int bytesRead;\n    while ((bytesRead = in.read(buffer)) != -1) {\n        out.write(cipher.update(buffer, 0, bytesRead));\n    }\n    out.write(cipher.doFinal());\n    out.flush();\n}\n\n}\n", "idx": 2112}
{"project": "cipher", "commit_id": "Snippet38161830_20141.java", "target": 0, "func": "package com.myapplication;\n\n\n\nimport javax.crypto.KeyGenerator;\n\n    import java.security.SecureRandom;\n\n    import javax.crypto.Cipher;\n    import javax.crypto.KeyGenerator;\n    import javax.crypto.SecretKey;\n    import javax.crypto.spec.SecretKeySpec;\n\npublic class AESHelper {\n\npublic static String encrypt(String seed, String cleartext) throws Exception {\n    byte[] rawKey = getRawKey(seed.getBytes());\n    byte[] result = encrypt(rawKey, cleartext.getBytes());\n    return toHex(result);\n}\n\npublic static String decrypt(String seed, String encrypted) throws Exception {\n    byte[] rawKey = getRawKey(seed.getBytes());\n    byte[] enc = toByte(encrypted);\n    byte[] result = decrypt(rawKey, enc);\n    return new String(result);\n}\n\nprivate static byte[] getRawKey(byte[] seed) throws Exception {\n    KeyGenerator kgen = KeyGenerator.getInstance(\"AES\");\n    SecureRandom sr = SecureRandom.getInstance(\"SHA1PRNG\");\n    sr.setSeed(seed);\n    kgen.init(128, sr); // 192 and 256 bits may not be available\n    SecretKey skey = kgen.generateKey();\n    byte[] raw = skey.getEncoded();\n    return raw;\n}\n\n\nprivate static byte[] encrypt(byte[] raw, byte[] clear) throws Exception {\n    SecretKeySpec skeySpec = new SecretKeySpec(raw, \"AES\");\n    Cipher cipher = Cipher.getInstance(\"AES\");\n    cipher.init(Cipher.ENCRYPT_MODE, skeySpec);\n    byte[] encrypted = cipher.doFinal(clear);\n    return encrypted;\n}\n\nprivate static byte[] decrypt(byte[] raw, byte[] encrypted) throws Exception {\n    SecretKeySpec skeySpec = new SecretKeySpec(raw, \"AES\");\n    Cipher cipher = Cipher.getInstance(\"AES\");\n    cipher.init(Cipher.DECRYPT_MODE, skeySpec);\n    byte[] decrypted = cipher.doFinal(encrypted);\n    return decrypted;\n}\n\npublic static String toHex(String txt) {\n    return toHex(txt.getBytes());\n}\npublic static String fromHex(String hex) {\n    return new String(toByte(hex));\n}\n\npublic static byte[] toByte(String hexString) {\n    int len = hexString.length()/2;\n    byte[] result = new byte[len];\n    for (int i = 0; i < len; i++)\n        result[i] = Integer.valueOf(hexString.substring(2*i, 2*i+2), 16).byteValue();\n    return result;\n}\n\npublic static String toHex(byte[] buf) {\n    if (buf == null)\n        return \"\";\n    StringBuffer result = new StringBuffer(2*buf.length);\n    for (int i = 0; i < buf.length; i++) {\n        appendHex(result, buf[i]);\n    }\n    return result.toString();\n}\nprivate final static String HEX = \"0123456789ABCDEF\";\nprivate static void appendHex(StringBuffer sb, byte b) {\n    sb.append(HEX.charAt((b>>4)&0x0f)).append(HEX.charAt(b&0x0f));\n}\n\n\n}\n", "idx": 2030}
{"project": "cipher", "commit_id": "Snippet36458857_18286.java", "target": 0, "func": "PasswordDeriveBytes myPass = new PasswordDeriveBytes(password, salt);\nSecretKeyFactory kf;\n    try {\n        Cipher desEDE = Cipher.getInstance(\"DESede/CB/NoPadding\");\n        kf = SecretKeyFactory.getInstance(\"DESede\");\n        key = myPass.getBytes(192);\n        desEDEKey= kf.generateSecret(new DESedeKeySpec(key));           \n        byte[] iv = DatatypeConverter.parseBase64Binary(ivText);\n        desEDE.init(Cipher.DECRYPT_MODE, desEDEKey, new IvParameterSpec(iv));\n        byte[] ct = desEDE.doFinal(DatatypeConverter.parseBase64Binary(texts));   \n    }\n", "idx": 2013}
{"project": "cipher", "commit_id": "Snippet40615753_22477.java", "target": 1, "func": "SecretKeySpec key = new SecretKeySpec(cipher_key, \"AES\");\nIvParameterSpec ivSpec = new IvParameterSpec(salt, 0, HALF_BLOCK / 8);\nCipher cipher = Cipher.getInstance(\"AES/CTR/NoPadding\", \"BC\");\ncipher.init(Cipher.ENCRYPT_MODE, key, ivSpec);\n", "idx": 2554}
{"project": "cipher", "commit_id": "Snippet12897260_36539.java", "target": 1, "func": "java.security.InvalidKeyException: Illegal key size\n    at javax.crypto.Cipher.checkCryptoPerm(Cipher.java:1023)\n    at javax.crypto.Cipher.implInit(Cipher.java:789)\n    at javax.crypto.Cipher.chooseProvider(Cipher.java:848)\n    at javax.crypto.Cipher.init(Cipher.java:1347)\n    at javax.crypto.Cipher.init(Cipher.java:1281)\n    at test.net.zomis.ZomisTest.decryptCipher(ZomisTest.java:112)\n@Test\npublic void decryptCipher() throws UnsupportedEncodingException, NoSuchAlgorithmException, NoSuchPaddingException, InvalidKeyException, InvalidAlgorithmParameterException, IllegalBlockSizeException, BadPaddingException {\n    String iv = \"0df1eff724d50157ab048d9ff214b73c\";\n    String cryptext = \"2743be20314cdc768065b794904a0724e64e339ea6b4f13c510e2d2e8c95dd7409aa0aefd20daae80956dd2978c98d6e914d1d7b5b5be47b491d91e7e4f16f7f30d991ba80a81bafd8f0d7d83755ba0ca66d6b208424529c7111bc9cd6d11786f3f604a0715f\";\n    String key = \"375f22c03371803ca6d36ec42ae1f97541961f7359cf5611bbed399b42c7c0be\"; // Hexadecimal String, will be converted to non-hexadecimal String\n    String expectedResult = \"01020506080b10131c22292d313536393b464c535466696d6e7d7f808a8e9899a2adb1b8babcbebfc1c6c7c8cecfd8e0e4e8ef\";\n\n    byte[] kdata = Util.hex2byte(key);\n\n    Assert.assertEquals(32, kdata.length); // 32 bytes = 256-bit key\n\n    String result;\n\n    Cipher cipher;\n    cipher = Cipher.getInstance(\"AES/OFB/NoPadding\");\n    // Below line is 112, which is causing exception\n    cipher.init(Cipher.DECRYPT_MODE, new SecretKeySpec(kdata, \"AES\"), new IvParameterSpec(iv.getBytes(\"UTF-8\")));\n    byte[] cryptData = Util.hex2byte(cryptext);\n    byte[] ciphertext = cipher.doFinal(cryptData);\n    result = new String(ciphertext);\n\n\n    Assert.assertEquals(expectedResult, result);\n}\n\n@Test\npublic void decryptAES() {\n    String iv = \"0df1eff724d50157ab048d9ff214b73c\"; \n    // Problem: Where should I specify the IV ???? Currently it is an unused variable...\n\n    String cryptext = \"2743be20314cdc768065b794904a0724e64e339ea6b4f13c510e2d2e8c95dd7409aa0aefd20daae80956dd2978c98d6e914d1d7b5b5be47b491d91e7e4f16f7f30d991ba80a81bafd8f0d7d83755ba0ca66d6b208424529c7111bc9cd6d11786f3f604a0715f\";\n    String key = \"375f22c03371803ca6d36ec42ae1f97541961f7359cf5611bbed399b42c7c0be\"; // Hexadecimal String, will be converted to non-hexadecimal String\n    String expectedResult = \"01020506080b10131c22292d313536393b464c535466696d6e7d7f808a8e9899a2adb1b8babcbebfc1c6c7c8cecfd8e0e4e8ef\";\n\n    Assert.assertEquals(64, key.length());\n\n    AES aes = new AES();\n    aes.setKey(Util.hex2byte(key));\n    byte[] byteCryptedData = Util.hex2byte(cryptext);\n    String byteCryptedString = new String(byteCryptedData);\n\n    while (byteCryptedString.length() % 16 != 0) byteCryptedString += \" \";\n\n\n    String result = aes.Decrypt(byteCryptedString);\n    Assert.assertEquals(expectedResult, result); // Assertion Failed\n}\n", "idx": 2442}
{"project": "cipher", "commit_id": "Snippet29293790_11333.java", "target": 1, "func": "   public class AES2 {\n\n    private static final String TRANSFORMATION = \"AES/CFB8/NoPadding\";\n    private static final String ALGO_MD5       = \"MD5\";\n    private static final String ALGO_AES       = \"AES\";\n\n    /**\n     * See http://www.logikdev.com/2012/12/12/md5-generates-31-bytes-instead-of-32/ form more detail.\n     * \n     * @param input\n     * @return\n     * @throws NoSuchAlgorithmException\n     */\n    private static String md5(String input) throws NoSuchAlgorithmException {\n        MessageDigest md = MessageDigest.getInstance(ALGO_MD5);\n        byte[] messageDigest = md.digest(input.getBytes());\n        BigInteger number = new BigInteger(1, messageDigest);\n        return String.format(\"%032x\", number);\n    }\n\n    public static String decrypt(String encryptedData, String initialVectorString, String secretKey) {\n        String decryptedData = null;\n        try {\n            String md5Key = md5(secretKey);\n            SecretKeySpec skeySpec = new SecretKeySpec(md5Key.getBytes(), ALGO_AES);\n            IvParameterSpec initialVector = new IvParameterSpec(initialVectorString.getBytes());\n            Cipher cipher = Cipher.getInstance(TRANSFORMATION);\n            cipher.init(Cipher.DECRYPT_MODE, skeySpec, initialVector);\n            byte[] encryptedByteArray = Base64.decode(encryptedData.getBytes(), Base64.DEFAULT);\n            byte[] decryptedByteArray = cipher.doFinal(encryptedByteArray);\n            decryptedData = new String(decryptedByteArray);\n        } catch (NoSuchAlgorithmException e) {\n            e.printStackTrace();\n        } catch (NoSuchPaddingException e) {\n            e.printStackTrace();\n        } catch (InvalidKeyException e) {\n            e.printStackTrace();\n        } catch (InvalidAlgorithmParameterException e) {\n            e.printStackTrace();\n        } catch (IllegalBlockSizeException e) {\n            e.printStackTrace();\n        } catch (BadPaddingException e) {\n            e.printStackTrace();\n        }\n\n        return decryptedData;\n    }\n\n}\n", "idx": 2693}
{"project": "cipher", "commit_id": "Snippet39736092_21630.java", "target": 1, "func": "    public class AESTest {\n           private static String AESStr = \"<Encrypted KEY>\";\n           public static void main(String[] args) throws Exception {\n                    Security.addProvider(new    org.bouncycastle.jce.provider.BouncyCastleProvider());\n                System.out.println(decrypt(AESStr, \"Test\"));\n           }\n        public static String decrypt(String responseStr, String passPhrase) throws        GeneralSecurityException {\n             String decryptedStr = \"\";\n             try {\n                        Cipher cipher = getCipher(Cipher.DECRYPT_MODE, passPhrase);\n                        byte[] decoded = Base64.decodeBase64(responseStr.getBytes());\n                        byte[] decryptedWithKey = cipher.doFinal(decoded);\n                        byte[] decrypted = Arrays.copyOfRange(decryptedWithKey, 16, decryptedWithKey.length);\n                        decryptedStr = new String(decrypted, \"UTF-8\");\n                } catch (Exception e) {\n                        e.printStackTrace();\n                }\n                return decryptedStr;\n        }\n\n        private static Cipher getCipher(int mode, String passPhrase) throws Exception {\n                SecretKeySpec secretKeySpec = new SecretKeySpec(passPhrase.getBytes(), \"AES\");\n                byte[] IV = new byte[16];\n                new Random().nextBytes(IV);\n                AlgorithmParameterSpec paramSpec = new IvParameterSpec(IV);\n                Cipher cipher = Cipher.getInstance(\"AES/CBC/PKCS7Padding\");\n                cipher.init(mode, secretKeySpec, paramSpec);\n                return cipher;\n        }\n}\n", "idx": 2469}
{"project": "cipher", "commit_id": "Snippet8622367_33373.java", "target": 1, "func": "import java.security.MessageDigest;\nimport java.security.NoSuchAlgorithmException;\nimport java.security.NoSuchProviderException;\nimport java.security.SecureRandom;\n\nimport javax.crypto.Cipher;\nimport javax.crypto.SecretKey;\nimport javax.crypto.SecretKeyFactory;\nimport javax.crypto.spec.IvParameterSpec;\nimport javax.crypto.spec.PBEKeySpec;\nimport javax.crypto.spec.SecretKeySpec;\n\npublic class AdvancedCrypto implements ICrypto {\n\n        public static final String PROVIDER = \"BC\";\n        public static final int SALT_LENGTH = 20;\n        public static final int IV_LENGTH = 16;\n        public static final int PBE_ITERATION_COUNT = 100;\n\n        private static final String RANDOM_ALGORITHM = \"SHA1PRNG\";\n        private static final String HASH_ALGORITHM = \"SHA-512\";\n        private static final String PBE_ALGORITHM = \"PBEWithSHA256And256BitAES-CBC-BC\";\n        private static final String CIPHER_ALGORITHM = \"AES/CBC/PKCS5Padding\";\n        private static final String SECRET_KEY_ALGORITHM = \"AES\";\n\n        public String encrypt(SecretKey secret, String cleartext) throws CryptoException {\n                try {\n\n                        byte[] iv = generateIv();\n                        String ivHex = HexEncoder.toHex(iv);\n                        IvParameterSpec ivspec = new IvParameterSpec(iv);\n\n                        Cipher encryptionCipher = Cipher.getInstance(CIPHER_ALGORITHM, PROVIDER);\n                        encryptionCipher.init(Cipher.ENCRYPT_MODE, secret, ivspec);\n                        byte[] encryptedText = encryptionCipher.doFinal(cleartext.getBytes(\"UTF-8\"));\n                        String encryptedHex = HexEncoder.toHex(encryptedText);\n\n                        return ivHex + encryptedHex;\n\n                } catch (Exception e) {\n                        throw new CryptoException(\"Unable to encrypt\", e);\n                }\n        }\n\n        public String decrypt(SecretKey secret, String encrypted) throws CryptoException {\n                try {\n                        Cipher decryptionCipher = Cipher.getInstance(CIPHER_ALGORITHM, PROVIDER);\n                        String ivHex = encrypted.substring(0, IV_LENGTH * 2);\n                        String encryptedHex = encrypted.substring(IV_LENGTH * 2);\n                        IvParameterSpec ivspec = new IvParameterSpec(HexEncoder.toByte(ivHex));\n                        decryptionCipher.init(Cipher.DECRYPT_MODE, secret, ivspec);\n                        byte[] decryptedText = decryptionCipher.doFinal(HexEncoder.toByte(encryptedHex));\n                        String decrypted = new String(decryptedText, \"UTF-8\");\n                        return decrypted;\n                } catch (Exception e) {\n                        throw new CryptoException(\"Unable to decrypt\", e);\n                }\n        }\n\n        public SecretKey getSecretKey(String password, String salt) throws CryptoException {\n                try {\n                        PBEKeySpec pbeKeySpec = new PBEKeySpec(password.toCharArray(), HexEncoder.toByte(salt), PBE_ITERATION_COUNT, 256);\n                        SecretKeyFactory factory = SecretKeyFactory.getInstance(PBE_ALGORITHM, PROVIDER);\n                        SecretKey tmp = factory.generateSecret(pbeKeySpec);\n                        SecretKey secret = new SecretKeySpec(tmp.getEncoded(), SECRET_KEY_ALGORITHM);\n                        return secret;\n                } catch (Exception e) {\n                        throw new CryptoException(\"Unable to get secret key\", e);\n                }\n        }\n\n        public String getHash(String password, String salt) throws CryptoException {\n                try {\n                        String input = password + salt;\n                        MessageDigest md = MessageDigest.getInstance(HASH_ALGORITHM, PROVIDER);\n                        byte[] out = md.digest(input.getBytes(\"UTF-8\"));\n                        return HexEncoder.toHex(out);\n                } catch (Exception e) {\n                        throw new CryptoException(\"Unable to get hash\", e);\n                }\n        }\n\n        public String generateSalt() throws CryptoException {\n                try {\n                        SecureRandom random = SecureRandom.getInstance(RANDOM_ALGORITHM);\n                        byte[] salt = new byte[SALT_LENGTH];\n                        random.nextBytes(salt);\n                        String saltHex = HexEncoder.toHex(salt);\n                        return saltHex;\n                } catch (Exception e) {\n                        throw new CryptoException(\"Unable to generate salt\", e);\n                }\n        }\n\n        private byte[] generateIv() throws NoSuchAlgorithmException, NoSuchProviderException {\n                SecureRandom random = SecureRandom.getInstance(RANDOM_ALGORITHM);\n                byte[] iv = new byte[IV_LENGTH];\n                random.nextBytes(iv);\n                return iv;\n        }\n\n}\n", "idx": 2754}
{"project": "cipher", "commit_id": "Snippet15279642_38351.java", "target": 1, "func": "import java.security.NoSuchAlgorithmException;\n\n    import javax.crypto.Cipher;\n    import javax.crypto.NoSuchPaddingException;\n    import javax.crypto.spec.IvParameterSpec;\n    import javax.crypto.spec.SecretKeySpec;\n\n    public class MCrypt {\n\n        private String iv = \"fedcba9876543210\";//Dummy iv (CHANGE IT!)\n        private IvParameterSpec ivspec;\n        private SecretKeySpec keyspec;\n        private Cipher cipher;\n\n        private String SecretKey = \"0123456789abcdef\";//Dummy secretKey (CHANGE IT!)\n\n        public MCrypt()\n        {\n            ivspec = new IvParameterSpec(iv.getBytes());\n\n            keyspec = new SecretKeySpec(SecretKey.getBytes(), \"AES\");\n\n            try {\n                cipher = Cipher.getInstance(\"AES/CBC/NoPadding\");\n            } catch (NoSuchAlgorithmException e) {\n                // TODO Auto-generated catch block\n                e.printStackTrace();\n            } catch (NoSuchPaddingException e) {\n                // TODO Auto-generated catch block\n                e.printStackTrace();\n            }\n        }\n\n        public byte[] encrypt(String text) throws Exception\n        {\n            if(text == null || text.length() == 0)\n                throw new Exception(\"Empty string\");\n\n            byte[] encrypted = null;\n\n            try {\n                cipher.init(Cipher.ENCRYPT_MODE, keyspec, ivspec);\n\n                encrypted = cipher.doFinal(padString(text).getBytes());\n            } catch (Exception e)\n            {           \n                throw new Exception(\"[encrypt] \" + e.getMessage());\n            }\n\n            return encrypted;\n        }\n\n        public byte[] decrypt(String code) throws Exception\n        {\n            if(code == null || code.length() == 0)\n                throw new Exception(\"Empty string\");\n\n            byte[] decrypted = null;\n\n\n            try {\n                cipher.init(Cipher.DECRYPT_MODE, keyspec, ivspec);\n\n                decrypted = cipher.doFinal(hexToBytes(code));\n                if( decrypted.length > 0)\n                {\n                    int trim = 0;\n                    for( int i = decrypted.length - 1; i >= 0; i-- ) if( decrypted[i] == 0 ) trim++;\n\n                    if( trim > 0 )\n                    {\n                        byte[] newArray = new byte[decrypted.length - trim];\n                        System.arraycopy(decrypted, 0, newArray, 0, decrypted.length - trim);\n                        decrypted = newArray;\n                    }\n                }\n            } catch (Exception e)\n            {\n                throw new Exception(\"[decrypt] \" + e.getMessage());\n            }\n            return decrypted;\n        }\n\n\n\n        public static String bytesToHex(byte[] data)\n        {\n            if (data==null)\n            {\n                return null;\n            }\n\n            int len = data.length;\n            String str = \"\";\n            for (int i=0; i<len; i++) {\n                if ((data[i]&0xFF)<16)\n                    str = str + \"0\" + java.lang.Integer.toHexString(data[i]&0xFF);\n                else\n                    str = str + java.lang.Integer.toHexString(data[i]&0xFF);\n            }\n            return str;\n        }\n\n\n        public static byte[] hexToBytes(String str) {\n            if (str==null) {\n                return null;\n            } else if (str.length() < 2) {\n                return null;\n            } else {\n                int len = str.length() / 2;\n                byte[] buffer = new byte[len];\n                for (int i=0; i<len; i++) {\n                    buffer[i] = (byte) Integer.parseInt(str.substring(i*2,i*2+2),16);\n                }\n                return buffer;\n            }\n        }\n\n\n\n        private static String padString(String source)\n        {\n          char paddingChar = ' ';\n          int size = 16;\n          int x = source.length() % size;\n          int padLength = size - x;\n\n          for (int i = 0; i < padLength; i++)\n          {\n              source += paddingChar;\n          }\n\n          return source;\n        }\n    }\n", "idx": 2711}
{"project": "cipher", "commit_id": "Snippet16987336_279.java", "target": 1, "func": "SecretKeyFactory factory = SecretKeyFactory.getInstance(\"PBKDF2WithHmacSHA1\");\nKeySpec spec = new PBEKeySpec(secretkey.toCharArray(), salt, iterationCount, keyStrength);    \nSecretKey tmp = factory.generateSecret(spec);\nkey = new SecretKeySpec(tmp.getEncoded(), \"AES\");\ndcipher = Cipher.getInstance(\"AES/CBC/PKCS5Padding\");\nAlgorithmParameters params = dcipher.getParameters();\niv = \"0000000000000000\".getBytes();\nSystem.out.println(\"IV \" + new sun.misc.BASE64Encoder().encodeBuffer(iv));\ndcipher.init(Cipher.DECRYPT_MODE, key, new IvParameterSpec(iv));      \nbyte[] decryptedData = new sun.misc.BASE64Decoder().decodeBuffer(base64EncryptedData);\nbyte[] utf8 = dcipher.doFinal(decryptedData);\n", "idx": 2402}
{"project": "cipher", "commit_id": "Snippet29355140_11395.java", "target": 1, "func": "import java.io.StringReader;\nimport java.io.File;\nimport java.io.IOException;\n\nimport java.security.KeyPair;\nimport java.security.interfaces.RSAPrivateKey;\nimport java.security.GeneralSecurityException;\nimport java.security.interfaces.RSAPublicKey;\n\nimport javax.crypto.Cipher;\n\nimport org.apache.commons.io.FileUtils;\nimport org.bouncycastle.openssl.PEMKeyPair;\nimport org.bouncycastle.openssl.PEMParser;\nimport org.bouncycastle.openssl.jcajce.JcaPEMKeyConverter;\n\npublic class RsaEncryption {\n    private Cipher _pkCipher;\n    private RSAPrivateKey _PrivateKey;\n    private RSAPublicKey  _PublicKey;\n\n    public RsaEncryption(String privateKey) throws GeneralSecurityException, IOException {\n        loadKey(privateKey);\n        // create RSA public key cipher\n        _pkCipher = Cipher.getInstance(\"RSA/None/PKCS1Padding\", \"BC\");\n    }\n\n    private void loadKey(String privateKey) throws IOException {\n        PEMParser pemParser          = new PEMParser(new StringReader(privateKey));\n        PEMKeyPair pemKeyPair        = (PEMKeyPair) pemParser.readObject();\n        JcaPEMKeyConverter converter = new JcaPEMKeyConverter().setProvider(\"BC\");\n        KeyPair keyPair              = converter.getKeyPair(pemKeyPair);\n        _PrivateKey                  = (RSAPrivateKey) keyPair.getPrivate();\n        _PublicKey                   = (RSAPublicKey) keyPair.getPublic();\n        pemParser.close();\n    }\n\n    public String decrypt(File in) throws GeneralSecurityException , IOException{\n        _pkCipher.init(Cipher.DECRYPT_MODE, _PrivateKey);\n        byte[] encryptedBytes = FileUtils.readFileToByteArray(in);\n        String key = new String(_pkCipher.doFinal(encryptedBytes));\n        System.out.println(key);\n        return key;\n    }\n\n\n    public RSAPrivateKey getPrivateKey() { return _PrivateKey; }\n    public RSAPublicKey getPublicKey()   { return _PublicKey;  }\n}\n", "idx": 2519}
{"project": "cipher", "commit_id": "Snippet30431207_12585.java", "target": 0, "func": "import javax.crypto.Cipher;\nimport javax.crypto.SecretKey;\nimport javax.crypto.SecretKeyFactory;\nimport javax.crypto.spec.DESKeySpec;\nimport android.util.Base64;\n\npublic class SimpleCrypto {\n\n    private String charsetName = \"UTF8\";\n    private String algorithm = \"DES\";\n    private int base64Mode = Base64.DEFAULT;\n\n    public String getCharsetName() {\n        return charsetName;\n    }\n\n    public void setCharsetName(String charsetName) {\n        this.charsetName = charsetName;\n    }\n\n    public String getAlgorithm() {\n        return algorithm;\n    }\n\n    public void setAlgorithm(String algorithm) {\n        this.algorithm = algorithm;\n    }\n\n    public int getBase64Mode() {\n        return base64Mode;\n    }\n\n    public void setBase64Mode(int base64Mode) {\n        this.base64Mode = base64Mode;\n    }\n\n    public String encrypt(String key, String data) {\n        if (key == null || data == null)\n            return null;\n        try {\n            DESKeySpec desKeySpec = new DESKeySpec(key.getBytes(charsetName));\n            SecretKeyFactory secretKeyFactory = SecretKeyFactory.getInstance(algorithm);\n            SecretKey secretKey = secretKeyFactory.generateSecret(desKeySpec);\n            byte[] dataBytes = data.getBytes(charsetName);\n            Cipher cipher = Cipher.getInstance(algorithm);\n            cipher.init(Cipher.ENCRYPT_MODE, secretKey);\n            return Base64.encodeToString(cipher.doFinal(dataBytes), base64Mode);\n        } catch (Exception e) {\n            return null;\n        }\n    }\n\n    public String decrypt(String key, String data) {\n        if (key == null || data == null)\n            return null;\n        try {\n            byte[] dataBytes = Base64.decode(data, base64Mode);\n            DESKeySpec desKeySpec = new DESKeySpec(key.getBytes(charsetName));\n            SecretKeyFactory secretKeyFactory = SecretKeyFactory.getInstance(algorithm);\n            SecretKey secretKey = secretKeyFactory.generateSecret(desKeySpec);\n            Cipher cipher = Cipher.getInstance(algorithm);\n            cipher.init(Cipher.DECRYPT_MODE, secretKey);\n            byte[] dataBytesDecrypted = (cipher.doFinal(dataBytes));\n            return new String(dataBytesDecrypted);\n        } catch (Exception e) {\n            return null;\n        }\n    }\n}\n", "idx": 2253}
{"project": "cipher", "commit_id": "Snippet42091948_24066.java", "target": 1, "func": "package so;\n\nimport java.nio.charset.StandardCharsets;\nimport java.security.GeneralSecurityException;\n\nimport javax.crypto.Cipher;\nimport javax.crypto.spec.IvParameterSpec;\nimport javax.crypto.spec.SecretKeySpec;\n\nimport org.bouncycastle.util.encoders.Hex;\n\npublic class AESdecryptor {\n    public static String[] KeyIvEncrypted = new String[]{\n            new String(\"0123456789abcdef\"),\n            new String(\"0000000000000000\"),\n            new String(\"1ff4ec7cef0e00d81b2d55a4bfdad4ba\")\n            };\n\n    public static void main(String[] args) throws GeneralSecurityException {\n        // Security.addProvider(new BouncyCastleProvider());\n        byte[] decrypted = decrypt();\n        System.out.println(new String(decrypted, StandardCharsets.ISO_8859_1));\n    }\n\n    private static byte[] transform(int mode, byte[] keyBytes, byte[] ivBytes, byte[] messageBytes)\n            throws GeneralSecurityException {\n        final SecretKeySpec keySpec = new SecretKeySpec(keyBytes, \"AES\");\n        final IvParameterSpec ivSpec = new IvParameterSpec(ivBytes);\n        final Cipher cipher = Cipher.getInstance(\"AES/CBC/PKCS5Padding\");\n        cipher.init(mode, keySpec, ivSpec);\n        return cipher.doFinal(messageBytes);\n    }\n\n    public static byte[] decrypt() throws GeneralSecurityException {\n         return AESdecryptor.transform(Cipher.DECRYPT_MODE, KeyIvEncrypted[0].getBytes(), KeyIvEncrypted[1].getBytes(), Hex.decode(KeyIvEncrypted[2]));\n    }\n}\n", "idx": 2361}
{"project": "cipher", "commit_id": "Snippet21039119_3619.java", "target": 0, "func": "   package com.devleb.encdecapp;\n\nimport java.io.UnsupportedEncodingException;\nimport java.security.GeneralSecurityException;\nimport java.security.SecureRandom;\n\nimport javax.crypto.Cipher;\nimport javax.crypto.KeyGenerator;\nimport javax.crypto.SecretKey;\nimport javax.crypto.SecretKeyFactory;\nimport javax.crypto.spec.IvParameterSpec;\nimport javax.crypto.spec.PBEKeySpec;\nimport javax.crypto.spec.PBEParameterSpec;\n\nimport android.app.Activity;\nimport android.os.Bundle;\nimport android.util.Base64;\nimport android.util.Log;\nimport android.view.ContextMenu;\nimport android.view.ContextMenu.ContextMenuInfo;\nimport android.view.Menu;\nimport android.view.MenuItem;\nimport android.view.View;\nimport android.view.View.OnClickListener;\nimport android.widget.AdapterView;\nimport android.widget.AdapterView.OnItemSelectedListener;\nimport android.widget.ArrayAdapter;\nimport android.widget.Button;\nimport android.widget.EditText;\nimport android.widget.Spinner;\n\npublic class MainActivity extends Activity implements OnClickListener {\n    // views for the layout\n    Spinner spin;\n    EditText edit_txt_pass;\n    static EditText edit_txt_enc_string;\n    EditText edit_txt_raw;\n    static EditText edit_txt_dec_string;\n    Button btn_encrypt, btn_decrypt, btn_clear;\n\n    static String cyphertext = \"\";\n    static String STReditTxtPass;\n    String strPaddingencryption;\n    static int iterations = 1000;\n    private static final String[] items = { \"Padding Key derivation\",\n            \"SHA1PRNG key derivation\", \"PBKDF2 key derivation\",\n            \"PKCS#12 key derivation\" };\n\n    private static final String TAG = MainActivity.class.getSimpleName();\n    private static final String[] Passwords = { \"password\", \"cryptography\",\n            \"cipher\", \"algorithm\", \"qwerty\" };\n\n    // mesage that will be binded with the key to generate the cypher text\n    private static String PlainText = \"this is the text that will be encrypted\";\n\n    // the list that will be used for the OnItemSelection method\n    private static final int PADDING_ENC_IDX = 0;\n    private static final int SHA1PRNG_ENC_IDX = 1;\n    private static final int PBKDF2_ENC_IDX = 2;\n    private static final int PKCS12_ENC_IDX = 3;\n\n    byte[] salt = { (byte) 0x11, (byte) 0x9B, (byte) 0xC6, (byte) 0xFE,\n            (byte) 0x33, (byte) 0x44, (byte) 0x55, (byte) 0x77 };;\n\n    static byte[] ivBytes = {0,0,0,0,0,0,0,0};\n\n    @Override\n    protected void onCreate(Bundle savedInstanceState) {\n        super.onCreate(savedInstanceState);\n        setContentView(R.layout.activity_main);\n\n        // creation of the spinner with setting Array adapter and\n        // DropDownresourse\n        spin = (Spinner) findViewById(R.id.spiner);\n        spin.setOnItemSelectedListener(new OnItemSelectedListener() {\n\n            @Override\n            public void onItemSelected(AdapterView<?> arg0, View arg1,\n                    int arg2, long arg3) {\n                // TODO Auto-generated method stub\n\n            }\n\n            @Override\n            public void onNothingSelected(AdapterView<?> arg0) {\n                // TODO Auto-generated method stub\n\n            }\n        });\n\n        ArrayAdapter<String> aa = new ArrayAdapter<String>(this,\n                android.R.layout.simple_spinner_item, items);\n        aa.setDropDownViewResource(android.R.layout.simple_dropdown_item_1line);\n        spin.setAdapter(aa);\n        // end of the spinner code\n\n        edit_txt_pass = (EditText) findViewById(R.id.editTxtPass);\n        edit_txt_enc_string = (EditText) findViewById(R.id.editTxtEncString);\n        edit_txt_raw = (EditText) findViewById(R.id.editTxtRawKey);\n        edit_txt_dec_string = (EditText) findViewById(R.id.editTxtDecString);\n\n        btn_encrypt = (Button) findViewById(R.id.btnEncrypt);\n        btn_encrypt.setOnClickListener(this);\n\n        btn_decrypt = (Button) findViewById(R.id.btnDecrypt);\n        btn_decrypt.setOnClickListener(this);\n\n        btn_clear = (Button) findViewById(R.id.btnClear);\n        btn_clear.setOnClickListener(this);\n\n        // / for registering the editText to the Context Menu\n        registerForContextMenu(edit_txt_pass);\n\n    }\n\n    // for the ciphering of the plainText using the base 64\n    public static String toBase64(byte[] bytes) {\n        return Base64.encodeToString(bytes, Base64.NO_WRAP);\n    }\n\n    public static byte[] fromBase64(byte[] bytes) {\n        // return Base64.encodeToString(bytes, Base64.NO_WRAP);\n        return Base64.decode(bytes, Base64.DEFAULT);\n    }\n\n    @Override\n    public void onCreateContextMenu(ContextMenu menu, View v,\n            ContextMenuInfo menuInfo) {\n        // TODO Auto-generated method stub\n\n        int groupId = 0;\n        menu.add(groupId, 1, 1, \"password\");\n        menu.add(groupId, 2, 2, \"cryptography\");\n        menu.add(groupId, 3, 3, \"cipher\");\n        menu.add(groupId, 4, 4, \"algorithm\");\n        menu.add(groupId, 5, 5, \"qwerty\");\n\n        super.onCreateContextMenu(menu, v, menuInfo);\n    }\n\n    @Override\n    public boolean onContextItemSelected(MenuItem item) {\n        // TODO Auto-generated method stub\n\n        return getText(item);\n\n        // return super.onContextItemSelected(item);\n    }\n\n    private boolean getText(MenuItem item) {\n        // TODO Auto-generated method stub\n\n        int menuItemId = item.getItemId();\n\n        if (menuItemId == 1) {\n            edit_txt_pass.setText(\"password\");\n        }\n        if (menuItemId == 2) {\n            edit_txt_pass.setText(\"cryptography\");\n        }\n        if (menuItemId == 3) {\n            edit_txt_pass.setText(\"cipher\");\n        }\n        if (menuItemId == 4) {\n            edit_txt_pass.setText(\"algorithm\");\n        }\n        if (menuItemId == 5) {\n            edit_txt_pass.setText(\"qwerty\");\n        }\n        STReditTxtPass = edit_txt_pass.getText().toString();\n\n        Log.w(\"the String of the Password text\", STReditTxtPass);\n        return false;\n    }\n\n    @Override\n    public boolean onCreateOptionsMenu(Menu menu) {\n        // Inflate the menu; this adds items to the action bar if it is present.\n        getMenuInflater().inflate(R.menu.main, menu);\n        return true;\n    }\n\n    @Override\n    public void onClick(View v) {\n        // TODO Auto-generated method stub\n\n        if (v == btn_encrypt) {\n\n            encryptPadding(PlainText, salt);\n        } else if (v == btn_clear) {\n            edit_txt_enc_string.setText(\"\");\n        } else if (v == btn_decrypt) {\n            decryptPadding(cyphertext, salt);\n        }\n    }\n\n    public static String encryptPadding(String plaintext, byte[] salt) {\n        try {\n            KeyGenerator kg = KeyGenerator.getInstance(\"DES\");\n            Cipher cipher = Cipher.getInstance(\"DES/CBC/PKCS5Padding\");\n\n            SecretKey SKey = kg.generateKey();\n\n            cipher.init(Cipher.ENCRYPT_MODE, SKey);\n\n            byte[] cipherText = cipher.doFinal(PlainText.getBytes(\"UTF-8\"));\n\n            cyphertext = String.format(\"%s%s%s\", toBase64(salt), \"]\",\n                    toBase64(cipherText));\n            edit_txt_enc_string.setText(cyphertext);\n            return cyphertext;\n        } catch (GeneralSecurityException e) {\n            throw new RuntimeException(e);\n        } catch (UnsupportedEncodingException e) {\n            throw new RuntimeException(e);\n        }\n    }\n\n    public static String decryptPadding(String ctext, byte[] salt) {\n        try {\n            KeyGenerator kg = KeyGenerator.getInstance(\"DES\");\n            Cipher cipher = Cipher.getInstance(\"DES/CBC/PKCS5Padding\");\n\n            SecretKey SKey = kg.generateKey();\n\n            IvParameterSpec ivSpec = new IvParameterSpec(ivBytes);\n            cipher.init(Cipher.DECRYPT_MODE, SKey, ivSpec);\n\n            byte[] plaintxt = cipher.doFinal(cyphertext.getBytes(\"UTF-8\"));\n\n            PlainText = String.format(\"%s%s%s\", fromBase64(salt), \"]\",\n                    fromBase64(plaintxt));\n            edit_txt_dec_string.setText(PlainText);\n            return PlainText;\n        } catch (GeneralSecurityException e) {\n            throw new RuntimeException(e);\n        } catch (UnsupportedEncodingException e) {\n            throw new RuntimeException(e);\n        }\n    }\n\n}\n", "idx": 2159}
{"project": "cipher", "commit_id": "Snippet24811837_7138.java", "target": 0, "func": "public class SimpleCrypto {\n\npublic static String encrypt(String seed, String cleartext) throws Exception {\n    byte[] rawKey = getRawKey(seed.getBytes());\n    byte[] result = encrypt(rawKey, cleartext.getBytes());\n    return toHex(result);\n}\n\npublic static String decrypt(String seed, String encrypted) throws Exception {\n    byte[] rawKey = getRawKey(seed.getBytes());\n    byte[] enc = toByte(encrypted);\n    byte[] result = decrypt(rawKey, enc);\n    return new String(result);\n}\n\nprivate static byte[] getRawKey(byte[] seed) throws Exception {\n    KeyGenerator kgen = KeyGenerator.getInstance(\"AES\");\n    final SecureRandom sr = SecureRandom.getInstance(\"SHA1PRNG\");\n    sr.setSeed(seed);\n    kgen.init(128, sr); // 192 and 256 bits may not be available\n    SecretKey skey = kgen.generateKey();\n    byte[] raw = skey.getEncoded();\n    return raw;\n}\n\n\nprivate static byte[] encrypt(byte[] raw, byte[] clear) throws Exception {\n    SecretKeySpec skeySpec = new SecretKeySpec(raw, \"AES\");\n    Cipher cipher = Cipher.getInstance(\"AES\");\n    cipher.init(Cipher.ENCRYPT_MODE, skeySpec);\n    byte[] encrypted = cipher.doFinal(clear);\n    return encrypted;\n}\n\nprivate static byte[] decrypt(byte[] raw, byte[] encrypted) throws Exception {\n    SecretKeySpec skeySpec = new SecretKeySpec(raw, \"AES\");\n    Cipher cipher = Cipher.getInstance(\"AES\");\n    cipher.init(Cipher.DECRYPT_MODE, skeySpec);\n    byte[] decrypted = cipher.doFinal(encrypted);\n    return decrypted;\n}\n\npublic static String toHex(String txt) {\n    return toHex(txt.getBytes());\n}\npublic static String fromHex(String hex) {\n    return new String(toByte(hex));\n}\n\npublic static byte[] toByte(String hexString) {\n    int len = hexString.length()/2;\n    byte[] result = new byte[len];\n    for (int i = 0; i < len; i++)\n        result[i] = Integer.valueOf(hexString.substring(2*i, 2*i+2), 16).byteValue();\n    return result;\n}\n\npublic static String toHex(byte[] buf) {\n    if (buf == null)\n        return \"\";\n    StringBuffer result = new StringBuffer(2*buf.length);\n    for (int i = 0; i < buf.length; i++) {\n        appendHex(result, buf[i]);\n    }\n    return result.toString();\n}\nprivate final static String HEX = \"0123456789ABCDEF\";\nprivate static void appendHex(StringBuffer sb, byte b) {\n    sb.append(HEX.charAt((b>>4)&0x0f)).append(HEX.charAt(b&0x0f));\n}\n\n}\n", "idx": 1926}
{"project": "cipher", "commit_id": "Snippet14255916_37594.java", "target": 1, "func": "public class Test {\n    static {\n        Security.addProvider(new BouncyCastleProvider());\n    }\n    public static void main(String[] args) throws Exception {\n        try {\n            Cipher cipher = Cipher.getInstance(\"AES/CBC/PKCS5Padding\", \"BC\");\n        } catch (Exception ex) {\n            ex.printStackTrace();\n        }\n    }\n}\n", "idx": 2751}
{"project": "cipher", "commit_id": "Snippet41925096_23919.java", "target": 1, "func": "public static String encryptRSA(String text) throws Exception {\n\n    byte[] encoded = Base64.getDecoder().decode(RSA_PUBLIC_KEY);\n\n    PKCS8EncodedKeySpec keySpec = new PKCS8EncodedKeySpec(encoded);\n    KeyFactory kf = KeyFactory.getInstance(\"RSA\");\n\n    RSAPublicKey pubKey = (RSAPublicKey) kf.generatePublic(new X509EncodedKeySpec(encoded));\n    Cipher cipher = Cipher.getInstance(\"RSA\");\n    cipher.init(Cipher.ENCRYPT_MODE, pubKey);\n\n    byte[] encrypted = cipher.doFinal(text.getBytes());\n\n    return Base64.getEncoder().encodeToString(encrypted);\n}\n", "idx": 2449}
{"project": "cipher", "commit_id": "Snippet6729834_32310.java", "target": 1, "func": " byte[] sessionKey = {00000000000000000000000000000000};\n byte[] iv = {00000000000000000000000000000000};\n byte[] plaintext = \"6a84867cd77e12ad07ea1be895c53fa3\".getBytes();\n Cipher cipher = Cipher.getInstance(\"AES/CBC/PKCS5Padding\");\n\n cipher.init(Cipher.ENCRYPT_MODE, new SecretKeySpec(sessionKey, \"AES\"), new IvParameterSpec(iv));\n byte[] ciphertext = cipher.doFinal(plaintext);\n\n cipher.init(Cipher.DECRYPT_MODE, new SecretKeySpec(sessionKey, \"AES\"), new IvParameterSpec(iv));\n byte[] deciphertext = cipher.doFinal(ciphertext);\n", "idx": 2586}
{"project": "cipher", "commit_id": "Snippet10498968_34838.java", "target": 1, "func": "public String encryption(String inputData, String key, String certificate) // Certificate is nothing but aliase name\n{\n    String encriptData = null;\n\n    String verify = checkForCertificateConfig();\n    if (!verify.equals(\"OK\")) {\n        return verify;\n    }\n    System.out.println(\"ENCRYPTION INPUTDATA : \" + inputData);\n    System.out.println(\"ENCRYPTION KEY : \" + key);\n    System.out.println(\"ENCRYPTION CERTIFICATE : \" + certificate);\n    try {\n        if (key.equalsIgnoreCase(\"Private\")) {\n            // System.out.println(\"ENCRYPTION WITH PRIVATE KEY\");\n            PrivateKey privateKey = (PrivateKey) keyStore.getKey(\n                    certificate, null);\n            encriptData = encryptString(inputData, privateKey);\n        } else {\n            // System.out.println(\"ENCRYPTION WITH PUBLIC KEY\");\n            encriptData = encryptString(inputData,\n                    keyStore.getCertificate(certificate).getPublicKey());\n        }\n    } catch (NoSuchPaddingException ex) {\n        encriptData = ex.getMessage();\n        ex.printStackTrace();\n\n    } catch (IllegalBlockSizeException ex) {\n        encriptData = ex.getMessage();\n        ex.printStackTrace();\n\n    } catch (NoSuchAlgorithmException ex) {\n        encriptData = ex.getMessage();\n        ex.printStackTrace();\n\n    } catch (UnrecoverableKeyException ex) {\n        encriptData = ex.getMessage();\n        ex.printStackTrace();\n\n    } catch (InvalidKeyException ex) {\n        encriptData = ex.getMessage();\n        ex.printStackTrace();\n\n    } catch (KeyStoreException ex) {\n        encriptData = ex.getMessage();\n        ex.printStackTrace();\n\n    } catch (BadPaddingException ex) {\n        encriptData = ex.getMessage();\n        ex.printStackTrace();\n\n    } catch (Exception ex) {\n        encriptData = ex.getMessage();\n        ex.printStackTrace();\n\n    }\n    return encriptData;\n}\n\nprivate String encryptString(String encStr, PrivateKey key)\n        throws NoSuchAlgorithmException, NoSuchPaddingException,\n        InvalidKeyException, IllegalBlockSizeException, BadPaddingException {\n    String encoutStr = null;\n\n    /**\n     * first check key generation algorithm and initialize Cipher object\n     * according algorithm\n     */\n    if (key.getAlgorithm().equalsIgnoreCase(\"RSA\")) {\n        edCipher = Cipher.getInstance(\"RSA/ECB/PKCS1Padding\");\n    } else if (key.getAlgorithm().equalsIgnoreCase(\"DSA\")) {\n        edCipher = Cipher.getInstance(\"DSA/ECB/PKCS1Padding\");\n    }\n\n    /**\n     * Initialize Cipher Object with Private key and mode of Encryption\n     */\n    edCipher.init(Cipher.ENCRYPT_MODE, key);\n    byte[] buff = encStr.getBytes();\n    /**\n     * Encrypt the String and get binary data\n     */\n    byte[] encryptedDataStringBytes = edCipher.doFinal(buff);\n    /**\n     * Encode the binary data into String formate\n     */\n    encoutStr = this.bASE64Encoder.encode(encryptedDataStringBytes);\n\n    return encoutStr;\n}\n", "idx": 2372}
{"project": "cipher", "commit_id": "Snippet29520106_11555.java", "target": 1, "func": "Cipher.getInstance(\"ECIESwithAES/DHAES/PKCS7Padding\", \"SC\");\n", "idx": 2352}
{"project": "cipher", "commit_id": "Snippet32536886_14652.java", "target": 1, "func": "private String encryptString(String origString) {\n    String encryptedString = \"\";\n    Cipher cipher = null;\n    byte[] encoded = null;\n    byte[] rawEnc =null;\n    try {\n        //Code which is working\n        cipher = Cipher.getInstance(\"AES/CBC/PKCS5Padding\", \"SunJCE\");\n        SecretKeySpec key = new SecretKeySpec(SECRET_KEY.getBytes(\"UTF-8\"), \"AES\");\n        cipher.init(Cipher.ENCRYPT_MODE, key, new IvParameterSpec(INITIALIZATIO_VECTOR.getBytes(\"UTF-8\")));\n        rawEnc = cipher.doFinal(origString.getBytes(\"UTF-8\"));\n        encoded = Base64.encodeBase64(rawEnc);\n        encryptedString = new String(encoded, \"UTF-8\");\n\n    } catch (NoSuchAlgorithmException e) {\n        System.out.println(\"No Such Algorithm Exception:\" + e.getMessage());\n    } catch (NoSuchProviderException e) {\n        System.out.println(\"No Such Provider Exception:\" + e.getMessage());\n    } catch (NoSuchPaddingException e) {\n        System.out.println(\"No Such Padding Exception:\" + e.getMessage());\n    } catch (InvalidKeyException | InvalidAlgorithmParameterException\n             | UnsupportedEncodingException e) {\n        System.out.println(\"Exception:\" + e.getMessage());\n    } catch (Exception e) {\n        System.out.println(\"Exception:\" + e.getMessage());\n    }\n    return encryptedString;\n}\nprivate static final String SECRET_KEY = \"secret_key\";\nprivate static final String INITIALIZATIO_VECTOR = \"123456\";\n\n}\n", "idx": 2704}
{"project": "cipher", "commit_id": "Snippet18589000_1617.java", "target": 0, "func": "public class SymmetricCipherTest {\n    private static final String DEFAULT_ENCRYPTION_ALGORITHM = \"PBEWithMD5AndTripleDES\";\n    public final String ENCODE_INDICATOR_START = \"ENC(\";\n    public final String ENCODE_INDICATOR_END = \")\";\n    public final String APP_ENCRYPTION_KEY_FILE = \"application/.encryption.key\";\n    public static final int INTERATION = 15;\n    private static final byte[] SALT = { (byte) 0xd7, (byte) 0x73, (byte) 0x21, (byte) 0x8c, (byte) 0x7e, (byte) 0xc8, (byte) 0xee,\n            (byte) 0x99 };\n\n//  private static SymmetricCipherTest instance = initApplicaitonKey();\n    private static Base64 base64 = new Base64();\n    private static Cipher encrypter;\n    private static Cipher decrypter;\n//  private final Base64 base64 = new Base64();\n\n    public final String ERROR_KEY_GENERATION = \"Encryption key generation failed. Please verify the logs.\";\n    public static void main(String[] args) throws InvalidKeySpecException, NoSuchPaddingException, InvalidKeyException, InvalidAlgorithmParameterException, IllegalBlockSizeException, BadPaddingException, DecoderException, NoSuchAlgorithmException {\n        String applicationKey=\"abcdefghijklmnopqrstu\";\n        String password=\"HellowWorld\";\n            encrypter=getCipherObject(applicationKey);\n            String encriptedString=new String(base64.encode(encrypter.doFinal(password.getBytes())));\n            System.out.println(encriptedString);\n\n            decrypter=getCipherObject(applicationKey);\n             String decryiptedString=new String(decrypter.doFinal(base64.decode(encriptedString.getBytes())));\n            System.out.println(decryiptedString);\n\n    }\n\n    public static Cipher getCipherObject(String applicationKey) throws NoSuchAlgorithmException, InvalidKeySpecException, NoSuchPaddingException, InvalidKeyException, InvalidAlgorithmParameterException{\n        SecretKeyFactory kf = SecretKeyFactory.getInstance(DEFAULT_ENCRYPTION_ALGORITHM);\n        PBEKeySpec keySpec = new PBEKeySpec(applicationKey.toCharArray());\n        SecretKey key = kf.generateSecret(keySpec);\n        Cipher ciph = Cipher.getInstance(DEFAULT_ENCRYPTION_ALGORITHM);\n\n        PBEParameterSpec params = new PBEParameterSpec(SALT, INTERATION);\n        ciph.init(Cipher.ENCRYPT_MODE, key, params);\n        return ciph;\n    }\n}\n", "idx": 2188}
{"project": "cipher", "commit_id": "Snippet4437076_31119.java", "target": 0, "func": "import javax.crypto.Cipher;\nimport javax.crypto.SecretKey;\nimport javax.crypto.spec.SecretKeySpec;\nimport javax.crypto.spec.IvParameterSpec;\nimport java.security.Security;\n\nimport org.bouncycastle.jce.provider.BouncyCastleProvider;\n\npublic class Main{\n    public static void main(String[] args) throws Exception {\n        Security.addProvider(new BouncyCastleProvider());\n\n        byte [] plain = \"I eat fish every day\".getBytes(\"utf-8\");\n\n        byte [] keyBytes = new byte [] { (byte) 0xC1, (byte) 0x57, (byte) 0x45, (byte) 0x08,\n            (byte) 0x85, (byte) 0x02, (byte) 0xB0, (byte) 0xD3,\n            (byte) 0xA2, (byte) 0xEF, (byte) 0x68, (byte) 0x43,\n            (byte) 0x5E, (byte) 0xE6, (byte) 0xD0, (byte) 0x75 };\n\n\n        SecretKey keySpec = new SecretKeySpec(keyBytes, \"DESede\");\n\n        IvParameterSpec iv = new IvParameterSpec(new byte[8]);\n\n        Cipher e_cipher = Cipher.getInstance(\"DESede/CBC/PKCS5Padding\", \"BC\");\n\n        e_cipher.init(Cipher.ENCRYPT_MODE, keySpec, iv);\n\n        byte [] cipherText = e_cipher.doFinal(plain);\n\n        System.out.println(\"Ciphertext: \" + new sun.misc.BASE64Encoder().encode(cipherText));\n    }\n}\n", "idx": 2017}
{"project": "cipher", "commit_id": "Snippet22052528_4469.java", "target": 1, "func": " final MessageDigest md = MessageDigest.getInstance(\"SHA-1\");\n byte[] digest = md.digest(dataBuffer.array());\n\n Cipher c2 = Cipher.getInstance(\"RSA/ECB/PKCS1Padding\");\n c2.init(Cipher.DECRYPT_MODE, cert.getPublicKey());\n byte[] decrypted2 = c2.doFinal(sigToCheck);\n final byte[] unpaddedSHA1 = Utils.unpadSHA1(decrypted2);\n\n System.out.println(\"signature verifies: \" + Arrays.equals(digest, unpaddedSHA1));\n", "idx": 2749}
{"project": "cipher", "commit_id": "Snippet16384493_39329.java", "target": 0, "func": "        Cipher cipher = Cipher.getInstance(\"DES\");\n        cipher.init(Cipher.ENCRYPT_MODE, password);\n        String encrypedStr = base64encoder.encode(cipher.doFinal(cleartext));\n", "idx": 2127}
{"project": "cipher", "commit_id": "Snippet16987832_282.java", "target": 1, "func": " public static byte[] Encrypt_RSA(byte[] plaintext,PublicKey key) throws\n        InvalidKeyException, NoSuchAlgorithmException, NoSuchPaddingException,\n        IllegalBlockSizeException, BadPaddingException,NoSuchProviderException{\n   Cipher c = Cipher.getInstance(\"RSA/ECB/PKCS1Padding\");\n    c.init(Cipher.ENCRYPT_MODE,key);\n    byte [] ciphertext = c.doFinal(plaintext);\n    return ciphertext;\n}\n\npublic static byte[] Decrypt_RSA(byte []ciphertext,PrivateKey key) throws\n       NoSuchAlgorithmException, NoSuchPaddingException, InvalidKeyException,\n       IllegalBlockSizeException, BadPaddingException,NoSuchProviderException{\n    Cipher c = Cipher.getInstance(\"RSA/ECB/PKCS1Padding\");\n    c.init(Cipher.DECRYPT_MODE,key);\n    byte [] plaintext=c.doFinal(ciphertext);\n    return plaintext;\n}\n\npublic static byte[] Encrypt_RSA_Pr(byte[] plaintext,PrivateKey key) throws\n       NoSuchAlgorithmException, NoSuchPaddingException,\n       IllegalBlockSizeException, BadPaddingException, InvalidKeyException{\n    Cipher c = Cipher.getInstance(\"RSA/ECB/PKCS1Padding\");\n    c.init(Cipher.ENCRYPT_MODE,key);\n    byte [] ciphertext = c.doFinal(plaintext);\n    return ciphertext;\n}\n\n public static byte[] Decrypt_RSA_Pub(byte []ciphertext,PublicKey key) throws\n        NoSuchAlgorithmException, NoSuchPaddingException, InvalidKeyException,\n        IllegalBlockSizeException,BadPaddingException,NoSuchProviderException{\n    Cipher c = Cipher.getInstance(\"RSA/ECB/PKCS1Padding\");\n    c.init(Cipher.DECRYPT_MODE,key);\n    byte [] plaintext=c.doFinal(ciphertext);\n    return plaintext;\n}\n", "idx": 2723}
{"project": "cipher", "commit_id": "Snippet24626781_6978.java", "target": 0, "func": "import java.security.GeneralSecurityException;\nimport java.security.Key;\nimport java.security.Security;\n\nimport javax.crypto.Cipher;\nimport javax.crypto.spec.SecretKeySpec;\n\nimport android.util.Base64;\n\npublic class AESTest {\n\n    public enum Mode {\n        CBC, ECB, CFB, OFB, PCBC\n    };\n\n    public enum Padding {\n        NoPadding, PKCS5Padding, PKCS7Padding, ISO10126d2Padding, X932Padding, ISO7816d4Padding, ZeroBytePadding\n    }\n\n    private static final String ALGORITHM = \"AES\";\n\n    private static final byte[] keyValue =\"myKey\".getBytes();\n\n\n    String decrypt(String valueToDec, Mode modeOption,\n            Padding paddingOption) throws GeneralSecurityException {\n\n\n\n        byte[] decodeBase64 = Base64.decode(valueToDec.getBytes(),0);\n\n        Key key = new SecretKeySpec(keyValue, ALGORITHM); \n        Cipher c = Cipher.getInstance(\"AES/ECB/NoPadding\"); \n        c.init(Cipher.DECRYPT_MODE, key); \n        byte[] encValue = c.doFinal(decodeBase64); \n        return new String(encValue).trim();\n\n    }\n\n}\n", "idx": 1938}
{"project": "cipher", "commit_id": "Snippet45257272_27393.java", "target": 1, "func": " try\n        {\n            if(txtPrivateKey.getText()==\"\")\n            {\n                Toast.makeText(MainActivity.this, \"Generate key first please!!!\", Toast.LENGTH_SHORT).show();\n            }\n            else\n            {\n                String origin = txtChuoi.getText().toString();\n                Cipher c = Cipher.getInstance(\"EC\");\n                c.init(Cipher.ENCRYPT_MODE,privateKey);\n                encodeBytes = c.doFinal(origin.getBytes());\n                txtMaHoa.setText(Base64.encodeToString(encodeBytes,Base64.DEFAULT));\n            }\n        }\n        catch (Exception e)\n        {\n            e.printStackTrace();\n        }\n", "idx": 2474}
{"project": "cipher", "commit_id": "Snippet42910006_25030.java", "target": 0, "func": "public static byte[] encryptWithAES(byte[] message, Key AESkey) throws Exception {\nbyte[] decryptedMessage = null;\ntry {\n    Cipher encrypt = Cipher.getInstance(\"AES/ECB/PKCS5Padding\"); // here is the change\n    encrypt.init(Cipher.ENCRYPT_MODE, AESkey);\n    decryptedMessage = encrypt.doFinal(message);\n} catch (Exception ex) {\n    System.err.println(ex.getMessage());\n    throw ex;\n}\nreturn decryptedMessage;\n}\n", "idx": 2072}
{"project": "cipher", "commit_id": "Snippet23683940_6010.java", "target": 1, "func": "RSAPrivateKey sKey = getPrivateKey(keyFile);\nCipher cipher = Cipher.getInstance(\"RSA/None/OAEPWithSHA512AndMGF1Padding\");\ncipher.init(Cipher.DECRYPT_MODE, sKey);\n", "idx": 2560}
{"project": "cipher", "commit_id": "Snippet40192680_22091.java", "target": 1, "func": "   try {\n        String arg = \"b74420f5a4d9abfd2072c9d936dd53e2de2aa790822ad1608807bda3e176b335c51902ca2177824198181ce8bea85de132aaea1104fd043e4ad2c0af705bda966b5d2f92a6ab5170d161eb1e8f7a6b1d5fba673f8a4dcebe55407ef9707782c91b17527af820a2c3a3b586341ae54ef03739074d4738e3ff35257bdfb9233c53\";\n        String message = \"plain text\";\n        byte[] publicBytes = org.apache.commons.codec.binary.Hex.decodeHex(arg.toCharArray());\n\n        BigInteger modulus = new BigInteger(1, publicBytes);\n        BigInteger publicExponent = BigInteger.valueOf(65537L);\n\n        RSAPublicKeySpec keySpec = new RSAPublicKeySpec(modulus, publicExponent);\n\n        KeyFactory keyFactory = KeyFactory.getInstance(\"RSA\");\n        PublicKey pubKey = keyFactory.generatePublic(keySpec);\n\n        try {\n            // decrypts the message\n            byte[] encryptedBytes = null;\n            Cipher cipher = Cipher.getInstance(\"RSA/ECB/PKCS1Padding\");\n            cipher.init(Cipher.ENCRYPT_MODE, pubKey);\n            encryptedBytes = cipher.doFinal(message.getBytes());\n\n            System.out.println( \"Encrypted text : \"+ convertToHexString(encryptedBytes));\n        } catch (BadPaddingException | IllegalBlockSizeException | InvalidKeyException\n                | NoSuchPaddingException | NoSuchAlgorithmException k) {\n            k.printStackTrace();\n        }\n    } catch (DecoderException e) {\n        e.printStackTrace();\n    }\n", "idx": 2728}
{"project": "cipher", "commit_id": "Snippet25279781_7649.java", "target": 1, "func": "public static Cipher RSA1024Cipher(int mode)\n        throws NoSuchAlgorithmException, NoSuchPaddingException,\n        InvalidKeyException, InvalidKeySpecException,\n        UnsupportedEncodingException {\n    Cipher RsaCipher;\n    RsaCipher = Cipher.getInstance(\"RSA/ECB/PKCS1Padding\");\n    BigInteger modulus = new BigInteger(Base64.decode(RSAModulus,\n            Base64.DEFAULT));//RSAModulus is provided out of this block of code.\n\n    // Log.d(\"RSA Encryption:\", \"modulus:\" + modulus);\n    BigInteger exponent = new BigInteger(Base64.decode(RSAExponent,\n            Base64.DEFAULT));//RSAExponent is provided out of this block of code.\n    // Log.d(\"RSA Encryption:\", \"Exponent:\" + exponent);\n    RSAPublicKeySpec KeySpec = new RSAPublicKeySpec(modulus, exponent);\n    KeyFactory keyFact = KeyFactory.getInstance(\"RSA\");\n    PublicKey pk = keyFact.generatePublic(KeySpec);\n    RsaCipher.init(mode, pk);\n\n    return RsaCipher;\n\n}\n// the data byte array should always be size of 8, UTF-8 based.\npublic static String RSA1024EncryptionToBase64String(final byte[] data) {\n    try {\n\n        Cipher RsaCipher = RSA1024Cipher(Cipher.ENCRYPT_MODE);\n\n        System.out.println(RsaCipher.getBlockSize());//i got 117\n        System.out.println(data.length);//this return 8\n        // Log.d(\"Base64UnEncryptedByteData\", new String(data));\n        byte[] CipherText = RsaCipher.doFinal(data);\n        System.out.println(CipherText.length);\n        System.out.println(new String(CipherText));\n        byte[] base64 = Base64.encode(CipherText, Base64.NO_WRAP);//NO_WRAP for sure\n        // Log.d(\"Base64ByteData\", new String(base64));\n        return new String(base64);\n    } catch (NoSuchAlgorithmException e) {\n        e.printStackTrace();\n    } catch (NoSuchPaddingException e) {\n        e.printStackTrace();\n    } catch (InvalidKeyException e) {\n        e.printStackTrace();\n    } catch (InvalidKeySpecException e) {\n        e.printStackTrace();\n    } catch (IllegalBlockSizeException e) {\n        e.printStackTrace();\n    } catch (BadPaddingException e) {\n        e.printStackTrace();\n    } catch (UnsupportedEncodingException e) {\n        e.printStackTrace();\n    } catch (IOException e) {\n        // TODO Auto-generated catch block\n        e.printStackTrace();\n    }\n    return \"\";\n}\n", "idx": 2700}
{"project": "cipher", "commit_id": "Snippet1133815_29869.java", "target": 1, "func": "import java.io.IOException;\nimport java.io.UnsupportedEncodingException;\nimport java.security.AlgorithmParameters;\nimport java.security.GeneralSecurityException;\nimport java.security.NoSuchAlgorithmException;\nimport java.security.spec.InvalidKeySpecException;\nimport java.util.Base64;\nimport javax.crypto.Cipher;\nimport javax.crypto.SecretKey;\nimport javax.crypto.SecretKeyFactory;\nimport javax.crypto.spec.IvParameterSpec;\nimport javax.crypto.spec.PBEKeySpec;\nimport javax.crypto.spec.SecretKeySpec;\n\npublic class ProtectedConfigFile {\n\n    public static void main(String[] args) throws Exception {\n        String password = System.getProperty(\"password\");\n        if (password == null) {\n            throw new IllegalArgumentException(\"Run with -Dpassword=<password>\");\n        }\n\n        // The salt (probably) can be stored along with the encrypted data\n        byte[] salt = new String(\"12345678\").getBytes();\n\n        // Decreasing this speeds down startup time and can be useful during testing, but it also makes it easier for brute force attackers\n        int iterationCount = 40000;\n        // Other values give me java.security.InvalidKeyException: Illegal key size or default parameters\n        int keyLength = 128;\n        SecretKeySpec key = createSecretKey(System.getProperty(\"password\").toCharArray(),\n                salt, iterationCount, keyLength);\n\n        String originalPassword = \"secret\";\n        System.out.println(\"Original password: \" + originalPassword);\n        String encryptedPassword = encrypt(originalPassword, key);\n        System.out.println(\"Encrypted password: \" + encryptedPassword);\n        String decryptedPassword = decrypt(encryptedPassword, key);\n        System.out.println(\"Decrypted password: \" + decryptedPassword);\n    }\n\n    private static SecretKeySpec createSecretKey(char[] password, byte[] salt, int iterationCount, int keyLength) throws NoSuchAlgorithmException, InvalidKeySpecException {\n        SecretKeyFactory keyFactory = SecretKeyFactory.getInstance(\"PBKDF2WithHmacSHA512\");\n        PBEKeySpec keySpec = new PBEKeySpec(password, salt, iterationCount, keyLength);\n        SecretKey keyTmp = keyFactory.generateSecret(keySpec);\n        return new SecretKeySpec(keyTmp.getEncoded(), \"AES\");\n    }\n\n    private static String encrypt(String property, SecretKeySpec key) throws GeneralSecurityException, UnsupportedEncodingException {\n        Cipher pbeCipher = Cipher.getInstance(\"AES/CBC/PKCS5Padding\");\n        pbeCipher.init(Cipher.ENCRYPT_MODE, key);\n        AlgorithmParameters parameters = pbeCipher.getParameters();\n        IvParameterSpec ivParameterSpec = parameters.getParameterSpec(IvParameterSpec.class);\n        byte[] cryptoText = pbeCipher.doFinal(property.getBytes(\"UTF-8\"));\n        byte[] iv = ivParameterSpec.getIV();\n        return base64Encode(iv) + \":\" + base64Encode(cryptoText);\n    }\n\n    private static String base64Encode(byte[] bytes) {\n        return Base64.getEncoder().encodeToString(bytes);\n    }\n\n    private static String decrypt(String string, SecretKeySpec key) throws GeneralSecurityException, IOException {\n        String iv = string.split(\":\")[0];\n        String property = string.split(\":\")[1];\n        Cipher pbeCipher = Cipher.getInstance(\"AES/CBC/PKCS5Padding\");\n        pbeCipher.init(Cipher.DECRYPT_MODE, key, new IvParameterSpec(base64Decode(iv)));\n        return new String(pbeCipher.doFinal(base64Decode(property)), \"UTF-8\");\n    }\n\n    private static byte[] base64Decode(String property) throws IOException {\n        return Base64.getDecoder().decode(property);\n    }\n}\n", "idx": 2565}
{"project": "cipher", "commit_id": "Snippet27375908_9566.java", "target": 0, "func": "private static final String AES_CIPHER_METHOD = \"AES\";\n\npublic static SecretKeySpec createAesKeySpec(byte[] aesKey) {\n    return new SecretKeySpec(aesKey, AES_CIPHER_METHOD);\n}\n\npublic static String aesEncrypt(String data, SecretKeySpec aesKeySpec) throws EncryptionException {\n    try {\n        Cipher aesCipher = Cipher.getInstance(AES_CIPHER_METHOD);\n        aesCipher.init(Cipher.ENCRYPT_MODE, aesKeySpec);\n        byte[] encVal = aesCipher.doFinal(data.getBytes(\"UTF8\"));\n        return new BASE64Encoder().encode(encVal);\n    } catch (NoSuchAlgorithmException | NoSuchPaddingException | InvalidKeyException | IOException | BadPaddingException| IllegalBlockSizeException e) {\n        throw new EncryptionException(e.getMessage(), e);\n    }\n}\n\npublic static void aesEncryptFile(File in, File out, SecretKeySpec aesKeySpec) throws EncryptionException {\n    try {\n        Cipher aesCipher = Cipher.getInstance(AES_CIPHER_METHOD);\n        aesCipher.init(Cipher.ENCRYPT_MODE, aesKeySpec);\n\n        try (InputStream inputStream = new FileInputStream(in)) {\n            try (OutputStream outputStream = new CipherOutputStream(new FileOutputStream(out), aesCipher)){\n                IOUtils.copy(inputStream, outputStream);\n            }\n        }\n    } catch (InvalidKeyException | NoSuchAlgorithmException | NoSuchPaddingException | IOException e){\n        throw new EncryptionException(e.getMessage(), e);\n    }\n}\n", "idx": 1941}
{"project": "cipher", "commit_id": "Snippet14023167_37437.java", "target": 1, "func": "public class SecurityUtils {\n\npublic static final String KEY_DERIVATION_ALGORITHM = \"PBKDF2WithHmacSHA1\";\n\nprivate static final String CIPHER_ALGORITHM = \"AES/CBC/PKCS5Padding\";\n\nprivate static final String DELIMITER = \"]\";\n\nprivate static final int KEY_LENGTH = 256;\n\nprivate static final int ITERATION_COUNT = 1000;\n\nprivate static final int SALT_LENGTH = 8;\n\nprivate static SecureRandom random = new SecureRandom();\n\nstatic {\n    Security.addProvider(new org.spongycastle.jce.provider.BouncyCastleProvider());\n}\n\n\npublic static String encrypt(Context context, String plaintext)\n        throws Exception {\n    byte[] salt = generateSalt();\n    return encrypt(plaintext, getKey(salt, getPassword(context)), salt);\n}\n\nprivate static String encrypt(String plaintext, SecretKey key, byte[] salt)\n        throws Exception {\n    try {\n        Cipher cipher = Cipher.getInstance(CIPHER_ALGORITHM, \"BC\");\n\n        byte[] iv = generateIv(cipher.getBlockSize());\n        IvParameterSpec ivParams = new IvParameterSpec(iv);\n\n        cipher.init(Cipher.ENCRYPT_MODE, key, ivParams);\n        byte[] cipherText = cipher.doFinal(plaintext.getBytes(\"UTF-8\"));\n\n        if (salt != null) {\n            return String.format(\"%s%s%s%s%s\",\n                    new String(Base64.encode(salt)), DELIMITER, new String(\n                            Base64.encode(iv)), DELIMITER, new String(\n                            Base64.encode(cipherText)));\n        }\n\n        return String.format(\"%s%s%s\", new String(Base64.encode(iv)),\n                DELIMITER, new String(Base64.encode(cipherText)));\n    } catch (Throwable e) {\n        throw new Exception(\"Error while encryption\", e);\n    }\n}\n\npublic static String decrypt(Context context, String ciphertext)\n        throws Exception {\n    return decrypt(ciphertext, getPassword(context));\n}\n\nprivate static String decrypt(String ciphertext, String password)\n        throws Exception {\n    String[] fields = ciphertext.split(DELIMITER);\n    if (fields.length != 3) {\n        throw new IllegalArgumentException(\"Invalid encypted text format\");\n    }\n    try {\n        byte[] salt = Base64.decode(fields[0]);\n        byte[] iv = Base64.decode(fields[1]);\n        byte[] cipherBytes = Base64.decode(fields[2]);\n\n        SecretKey key = getKey(salt, password);\n        Cipher cipher = Cipher.getInstance(CIPHER_ALGORITHM, \"BC\");\n        IvParameterSpec ivParams = new IvParameterSpec(iv);\n        cipher.init(Cipher.DECRYPT_MODE, key, ivParams);\n        byte[] plaintext = cipher.doFinal(cipherBytes);\n        String plainrStr = new String(plaintext, \"UTF-8\");\n\n        return plainrStr;\n    } catch (Throwable e) {\n        throw new Exception(\"Error while decryption\", e);\n    }\n}\n\nprivate static String getPassword(Context context) {\n\n    return \"My secret password\";\n}\n\nprivate static SecretKey getKey(byte[] salt, String password)\n        throws Exception {\n    try {\n        KeySpec keySpec = new PBEKeySpec(password.toCharArray(), salt,\n                ITERATION_COUNT, KEY_LENGTH);\n        SecretKeyFactory keyFactory = SecretKeyFactory.getInstance(\n                KEY_DERIVATION_ALGORITHM, \"BC\");\n        byte[] keyBytes = keyFactory.generateSecret(keySpec).getEncoded();\n        return new SecretKeySpec(keyBytes, \"AES\");\n    } catch (Throwable e) {\n        throw new Exception(\"Error while generating key\", e);\n    }\n}\n\nprivate static byte[] generateIv(int length) {\n    byte[] b = new byte[length];\n    random.nextBytes(b);\n\n    return b;\n}\n\nprivate static byte[] generateSalt() {\n    byte[] b = new byte[SALT_LENGTH];\n    random.nextBytes(b);\n\n    return b;\n}\n", "idx": 2695}
{"project": "cipher", "commit_id": "Snippet10843168_35131.java", "target": 1, "func": "import java.nio.charset.Charset;\n\nimport javax.crypto.Cipher;\nimport javax.crypto.SecretKey;\nimport javax.crypto.spec.IvParameterSpec;\nimport javax.crypto.spec.SecretKeySpec;\n\nimport org.apache.commons.codec.binary.Base64;\nimport org.apache.commons.codec.binary.Hex;\n\npublic class AESToy3 {\n\n    private static final Charset ASCII = Charset.forName(\"US-ASCII\");\n\n    public static void main(String[] args) throws Exception {\n        String base64Cipher = \"iz1qFlQJfs6Ycp+gcc2z4w==\";\n        byte [] cipherBytes = Base64.decodeBase64(base64Cipher);\n        byte [] iv = \"1234567812345678\".getBytes(ASCII);\n        byte [] keyBytes = \"1234567812345678\".getBytes(ASCII);\n\n        SecretKey aesKey = new SecretKeySpec(keyBytes, \"AES\");\n\n        Cipher cipher = Cipher.getInstance(\"AES/CBC/NOPADDING\");\n        cipher.init(Cipher.DECRYPT_MODE, aesKey, new IvParameterSpec(iv));\n\n        byte[] result = cipher.doFinal(cipherBytes);\n        System.out.println(Hex.encodeHexString(result));\n    }\n\n}\n", "idx": 2595}
{"project": "cipher", "commit_id": "Snippet10691899_34986.java", "target": 1, "func": "public String decryptText (byte[] encryptedText) throws Exception {\n\n    String decryptedText = null;\n\n    if (rsaData != null) {\n        byte[] modBytes = Base64.decodeBase64(rsaData.getModulus().trim());\n        byte[] dBytes = Base64.decodeBase64(rsaData.getD().trim());\n\n        BigInteger modules = new BigInteger(1, modBytes);\n        BigInteger d = new BigInteger(1, dBytes);\n\n        KeyFactory factory = KeyFactory.getInstance(\"RSA\");\n        Cipher cipher = Cipher.getInstance(\"RSA\");\n\n        RSAPrivateKeySpec privSpec = new RSAPrivateKeySpec(modules, d);\n        PrivateKey privKey = factory.generatePrivate(privSpec);\n        cipher.init(Cipher.DECRYPT_MODE, privKey);\n        byte[] decrypted = cipher.doFinal(encryptedText);\n\n        decryptedText = new String(decrypted);\n\n    }\n\n    return decryptedText;\n}\n", "idx": 2445}
{"project": "cipher", "commit_id": "Snippet18174587_1209.java", "target": 1, "func": "public static Packet decompile(PacketWrapper wrapper, PrivateKey privateKey)\n        throws Exception {\n    for (Provider provider : Security.getProviders()) {\n        System.out.println(provider.getName());\n        System.out.println(provider.getInfo());\n        System.out.println(System.lineSeparator());\n    }\n    Cipher cipher = Cipher.getInstance(\"RSA\");\n    cipher.init(Cipher.DECRYPT_MODE, privateKey);\n    byte[] data = cipher.doFinal(wrapper.data);\n    return (Packet) bytesToObj(data);\n}\n", "idx": 2522}
{"project": "cipher", "commit_id": "Snippet11385706_35543.java", "target": 1, "func": "        BigInteger modulus = new BigInteger(\"blah\");\n        BigInteger exponent = new BigInteger(\"blah\");\n\n        RSAPublicKeySpec keySpec = new RSAPublicKeySpec(modulus, exponent);\n\n        KeyFactory encryptfact = KeyFactory.getInstance(\"RSA\");\n        PublicKey pubKey = encryptfact.generatePublic(keySpec);\n\n        String dataToEncrypt = \"Hello World\";\n\n        /**\n         * Encrypt data\n         */\n        Cipher encrypt = Cipher.getInstance(\"RSA\");\n        encrypt.init(Cipher.ENCRYPT_MODE, pubKey);\n        byte[] cipherData = encrypt.doFinal(dataToEncrypt.getBytes());\n\n        System.out.println(\"cipherData: \" + new String(cipherData));\n\n        /**\n         * Decrypt data\n         */\n        BigInteger privatemodulus = new BigInteger(\"blah\");\n        BigInteger privateexponent = new BigInteger(\"blah\");\n\n        RSAPrivateKeySpec privateKeySpec = new RSAPrivateKeySpec(privatemodulus, privateexponent);\n\n        PrivateKey privateKey = encryptfact.generatePrivate(privateKeySpec);\n\n        Cipher decrypt = Cipher.getInstance(\"RSA\");\n        decrypt.init(Cipher.DECRYPT_MODE, privateKey);\n        byte[] decData = decrypt.doFinal(cipherData);\n\n        System.out.println(new String(decData));\n", "idx": 2549}
{"project": "cipher", "commit_id": "Snippet43270291_25412.java", "target": 0, "func": "public static void main(String[] args) {\n\n    // Creates a socket to the local host on port 6789\n    Socket clientSocket = null;\n    try {\n        clientSocket = new Socket(\"localhost\", 6789);\n    } catch (IOException e1) {\n        e1.printStackTrace();\n    }\n    try{\n        double k1, B, A;\n        double n = 13;\n        double g = 61;\n        long x = 3;\n\n        // Sends an unencrypted number to the server\n        A = (Math.pow(g, x))%n;\n        DataOutputStream outToServer = new DataOutputStream(clientSocket.getOutputStream());\n        DataInputStream inFromServer = new DataInputStream(clientSocket.getInputStream());  \n\n        // Transforms A into a byte array and sends it over\n        outToServer.writeDouble(A);\n        outToServer.flush();\n        System.out.println(\"Sending \" + A);\n\n        // Reads the incoming data from the server\n        B = inFromServer.readDouble();\n        System.out.println(\"Recieved \" + B);\n\n        // Modifies the data to create the number for des key\n        k1 = (Math.pow(B, x))%n;\n        System.out.println(\"DES key seed = \" + k1);\n        byte[] deskeydata = toByteArray(k1);\n\n        // Turns the bytes of the modified number into a DES key spec\n        DESKeySpec deskeyspec = new DESKeySpec(deskeydata);\n\n        // Makes a secret key (DES)\n        SecretKeyFactory keyF = SecretKeyFactory.getInstance(\"DES\");\n        SecretKey keystuff = keyF.generateSecret(deskeyspec);\n        System.out.println(keystuff.toString());\n\n        // Takes in input from the user and turns it into binary\n        BufferedReader inFromUser = new BufferedReader(new InputStreamReader(System.in));\n        System.out.println(\"Enter a message:\");\n\n        String sentence = inFromUser.readLine();\n        byte[] str2 = sentence.getBytes();\n        byte[] encodedMessage = Base64.getEncoder().encode(str2);\n\n        Cipher c = Cipher.getInstance(\"DES/CBC/PKCS5Padding\");\n\n        // Encrypts the user's input with the secret key\n        c.init(Cipher.ENCRYPT_MODE, keystuff, new IvParameterSpec(new byte[8]));\n        byte[] ct2 = c.doFinal(encodedMessage);\n        System.out.println(\"Initted the cipher and moving forward with \" + new String(ct2));\n\n        // Writes the encrypted message to the user\n        outToServer.write(ct2);\n        outToServer.flush();\n\n\n        inFromServer.close();\n        outToServer.close();\n    } catch(Exception e){\n        e.printStackTrace();\n    }\n\n}\n", "idx": 2063}
{"project": "cipher", "commit_id": "Snippet21994605_4423.java", "target": 1, "func": "    @Override\n    public void onClick(View arg0) {\n// TODO Auto-generated method stub\n        FILENAME = filename.getText().toString();\n        PASSWORD = pass.getText().toString();\n\n        // Generate key pair for 1024-bit RSA encryption and decryption\n        Key publicKey = null;\n        Key privateKey = null;\n        try {\n            KeyPairGenerator kpg = KeyPairGenerator.getInstance(\"RSA\");\n            kpg.initialize(1024);\n            KeyPair kp = kpg.genKeyPair();\n            publicKey = kp.getPublic();\n            privateKey = kp.getPrivate();\n        } catch (Exception e) {\n            Log.e(TAG, \"RSA key pair error\");\n        }\n\n        // Encode the original data with RSA private key\n        byte[] encodedBytes = null;\n        try {\n            Cipher c = Cipher.getInstance(\"RSA\");\n            c.init(Cipher.ENCRYPT_MODE, privateKey);\n            encodedBytes = c.doFinal(PASSWORD.getBytes());\n        } catch (Exception e) {\n            Log.e(TAG, \"RSA encryption error\");\n        }\n\n        PASSWORD = Base64.encodeToString(encodedBytes, Base64.DEFAULT);\n\n        try {\n            FileOutputStream fos = openFileOutput(FILENAME,\n                    Context.MODE_PRIVATE);\n            fos.write(PASSWORD.getBytes());\n            fos.close();\n            Toast.makeText(getApplicationContext(),\n                    \"Your Credentials are saved.\", Toast.LENGTH_SHORT).show();\n\n        } catch (FileNotFoundException e) {\n            // TODO Auto-generated catch block\n            e.printStackTrace();\n        } catch (IOException e) {\n            // TODO Auto-generated catch block\n            e.printStackTrace();\n        }\n\n    }\n", "idx": 2564}
{"project": "cipher", "commit_id": "Snippet33686645_15735.java", "target": 1, "func": "      private static Cipher getCipher(int mode) throws Exception {\n      Cipher c = Cipher.getInstance(\"AES/CBC/PKCS5Padding\");\n\n      //a random Init. Vector. just for testing\n      byte[] iv = \"e675f725e675f725\".getBytes(\"UTF-8\");\n\n      c.init(mode, generateKey(), new IvParameterSpec(iv));\n      return c;\n  }\n\n\n  private static String Decrypt(String encrypted) throws Exception {\n\n      byte[] decodedValue = new Base64().decode(encrypted.getBytes(\"UTF-8\")); // new BASE64Decoder().decodeBuffer(encrypted);\n\n      Cipher c = getCipher(Cipher.DECRYPT_MODE);\n      byte[] decValue = c.doFinal(decodedValue);\n\n      return new String(decValue);\n  }\n\n  private static Key generateKey() throws Exception {\n      SecretKeyFactory factory = SecretKeyFactory.getInstance(\"PBKDF2WithHmacSHA1\");\n      char[] password = \"3x5FBNs!\".toCharArray();\n      byte[] salt = \"S@1tS@1t\".getBytes(\"UTF-8\");\n\n      KeySpec spec = new PBEKeySpec(password, salt, 65536, 128);\n      SecretKey tmp = factory.generateSecret(spec);\n      byte[] encoded = tmp.getEncoded();\n      return new SecretKeySpec(encoded, \"AES\");\n  }\n", "idx": 2617}
{"project": "cipher", "commit_id": "Snippet6403043_32113.java", "target": 1, "func": "Button GenKey = null;\nButton encryptString = null;\nButton decryptString = null;\nEditText plainField = null;\nEditText encryptedField = null;\n\n@Override\npublic void onCreate(Bundle savedInstanceState){\n    super.onCreate(savedInstanceState);\n    setContentView(R.layout.main);\n\n    GenKey = (Button) findViewById(R.id.btnGenKey);\n    GenKey.setOnClickListener(new View.OnClickListener() {\n        public void onClick(View view) {\n                generateKey();\n        }\n    });\n\n    encryptString = (Button) findViewById(R.id.btnEncrypt);\n    encryptString.setOnClickListener(new View.OnClickListener() {\n        @Override\n        public void onClick(View v) {\n\n            byte[] encryptedData = null;\n            byte[] dataToEncrypt = null;\n            plainField = (EditText) findViewById (R.id.eTxtPlainTxt);\n            String plainText = plainField.getText().toString();\n                dataToEncrypt = plainText.getBytes(\"UTF-8\");\n                encryptedData = rsaEncrypt(dataToEncrypt);              \n            String encryptedText=null;\n                encryptedText = new String(encryptedData, \"UTF-8\");\n            encryptedField = (EditText)findViewById(R.id.eTxtCiphTxt);\n            encryptedField.setText(encryptedText);\n        }\n    });\n\n    decryptString = (Button) findViewById(R.id.btnDecrypt);\n    decryptString.setOnClickListener(new View.OnClickListener() {\n        @Override\n        public void onClick(View v) {\n            byte[] decryptedData = null;\n            byte[] dataToEncrypt = null;\n            encryptedField = (EditText) findViewById (R.id.eTxtCiphTxt);\n            String cipherText = encryptedField.getText().toString();    \n                dataToEncrypt = cipherText.getBytes(\"UTF-8\");\n                decryptedData = rsaDecrypt(dataToEncrypt);\n\n            String decryptedText = null;\n                decryptedText = new String(decryptedData,\"UTF-8\");\n            plainField = (EditText)findViewById(R.id.eTxtPlainTxt);\n            plainField.setText(decryptedText);\n        }\n    });\n\n}//end of onCreate\n\npublic void generateKey() throws NoSuchAlgorithmException, InvalidKeySpecException, IOException{\n    KeyPairGenerator kpg = KeyPairGenerator.getInstance(\"RSA\");\n    kpg.initialize(512);\n    KeyPair kp = kpg.genKeyPair();\n\n    KeyFactory fact = KeyFactory.getInstance(\"RSA\");\n    RSAPublicKeySpec pub = fact.getKeySpec(kp.getPublic(), RSAPublicKeySpec.class);\n    RSAPrivateKeySpec priv = fact.getKeySpec(kp.getPrivate(), RSAPrivateKeySpec.class);\n\n    saveToFile(\"public.key\", pub.getModulus(),pub.getPublicExponent());\n    saveToFile(\"private.key\", priv.getModulus(),priv.getPrivateExponent());\n    }//end of generateKey\n\npublic void saveToFile(String fileName, BigInteger mod, BigInteger exp) throws IOException {        \n    FileOutputStream fOutStream = openFileOutput(fileName, MODE_PRIVATE);\n    ObjectOutputStream oos = new ObjectOutputStream(new BufferedOutputStream(fOutStream));\n    oos.writeObject(mod);\n    oos.writeObject(exp);\n    oos.flush();\n    oos.close();\n    }//end of saveToFile\n\npublic PublicKey readPubKeyFromFile(String keyFileName) throws StreamCorruptedException, IOException{\n    FileInputStream fInStream = openFileInput(keyFileName);\n    ObjectInputStream oInStream = new ObjectInputStream(new BufferedInputStream(fInStream));\n        BigInteger m = (BigInteger) oInStream.readObject();\n        BigInteger e = (BigInteger) oInStream.readObject();\n        RSAPublicKeySpec keySpec = new RSAPublicKeySpec(m, e);\n        KeyFactory fact = KeyFactory.getInstance(\"RSA\");\n        PublicKey pubKey = fact.generatePublic(keySpec);\n        return pubKey;\n        oInStream.close();\n}//end of readPubKeyFromFile\n\npublic PrivateKey readPrivKeyFromFile(String keyFileName) throws StreamCorruptedException, IOException{\n    FileInputStream fInStream = openFileInput(keyFileName);\n    ObjectInputStream oInStream = new ObjectInputStream(new BufferedInputStream(fInStream));\n        BigInteger m = (BigInteger) oInStream.readObject();\n        BigInteger e = (BigInteger) oInStream.readObject();\n        RSAPrivateKeySpec keySpec = new RSAPrivateKeySpec(m, e);\n        KeyFactory fact = KeyFactory.getInstance(\"RSA\");\n        PrivateKey privKey = fact.generatePrivate(keySpec);\n        return privKey;\n        oInStream.close();\n}//end of readPubKeyFromFile\n\npublic byte[] rsaEncrypt(byte[] data) throws StreamCorruptedException, IOException, NoSuchAlgorithmException, NoSuchPaddingException, InvalidKeyException, IllegalBlockSizeException, BadPaddingException {\n    PublicKey pubKey = readPubKeyFromFile(\"public.key\");\n    Cipher cipher = Cipher.getInstance(\"RSA\");\n    cipher.init(Cipher.ENCRYPT_MODE, pubKey);\n    byte[] cipherData = cipher.doFinal(data);\n    return cipherData;    \n}//end of rsaEncrypt\n\npublic byte[] rsaDecrypt(byte[] data) throws StreamCorruptedException, IOException, NoSuchAlgorithmException, NoSuchPaddingException, InvalidKeyException, IllegalBlockSizeException, BadPaddingException{\n    PrivateKey privKey = readPrivKeyFromFile(\"private.key\");\n    Cipher decipher = Cipher.getInstance(\"RSA\");\n    decipher.init(Cipher.DECRYPT_MODE, privKey);\n    byte[] plainData = decipher.doFinal(data);\n    return plainData;   \n}\n", "idx": 2697}
{"project": "cipher", "commit_id": "Snippet31299113_13434.java", "target": 1, "func": "import java.security.GeneralSecurityException;\nimport java.security.KeyFactory;\nimport java.security.KeyPair;\nimport java.security.KeyPairGenerator;\nimport java.security.PrivateKey;\nimport java.security.PublicKey;\nimport java.security.SecureRandom;\nimport java.security.interfaces.RSAPrivateCrtKey;\nimport java.security.interfaces.RSAPrivateKey;\nimport java.security.interfaces.RSAPublicKey;\nimport java.security.spec.RSAPublicKeySpec;\n\nimport javax.crypto.Cipher;\nimport javax.crypto.KeyGenerator;\nimport javax.crypto.SecretKey;\nimport javax.crypto.spec.IvParameterSpec;\n\nimport org.bouncycastle.asn1.ASN1Encodable;\nimport org.bouncycastle.asn1.ASN1ObjectIdentifier;\nimport org.bouncycastle.asn1.ASN1OctetString;\nimport org.bouncycastle.asn1.DEROctetString;\nimport org.bouncycastle.asn1.nist.NISTObjectIdentifiers;\nimport org.bouncycastle.asn1.pkcs.EncryptedPrivateKeyInfo;\nimport org.bouncycastle.asn1.x509.AlgorithmIdentifier;\nimport org.bouncycastle.pkcs.PKCS8EncryptedPrivateKeyInfo;\n\nfinal class PKCS8\n{\n\n  private static final ASN1ObjectIdentifier AES = ASN1ObjectIdentifier.getInstance(NISTObjectIdentifiers.id_aes128_CBC);\n\n  static RSAPublicKey toPublic(RSAPrivateCrtKey pvt)\n    throws GeneralSecurityException\n  {\n    RSAPublicKeySpec pub = new RSAPublicKeySpec(pvt.getModulus(), pvt.getPublicExponent());\n    KeyFactory f = KeyFactory.getInstance(\"RSA\");\n    return (RSAPublicKey) f.generatePublic(pub);\n  }\n\n  static byte[] encrypt(SecretKey secret, PrivateKey pvt)\n    throws Exception\n  {\n    Cipher enc = Cipher.getInstance(\"AES/CBC/PKCS5Padding\");\n    enc.init(Cipher.WRAP_MODE, secret);\n    ASN1Encodable params = new DEROctetString(enc.getIV());\n    AlgorithmIdentifier algId = new AlgorithmIdentifier(AES, params);\n    byte[] ciphertext = enc.wrap(pvt);\n    return new EncryptedPrivateKeyInfo(algId, ciphertext).getEncoded();\n  }\n\n  static PrivateKey decrypt(SecretKey secret, byte[] pkcs8)\n    throws Exception\n  {\n    EncryptedPrivateKeyInfo info = new PKCS8EncryptedPrivateKeyInfo(pkcs8).toASN1Structure();\n    AlgorithmIdentifier id = info.getEncryptionAlgorithm();\n    byte[] iv = ((ASN1OctetString) id.getParameters()).getOctets();\n    Cipher dec = Cipher.getInstance(\"AES/CBC/PKCS5Padding\");\n    dec.init(Cipher.UNWRAP_MODE, secret, new IvParameterSpec(iv));\n    return (PrivateKey) dec.unwrap(info.getEncryptedData(), \"RSA\", Cipher.PRIVATE_KEY);\n  }\n\n}\n", "idx": 2639}
{"project": "cipher", "commit_id": "Snippet18998124_1881.java", "target": 0, "func": "static void encryptLast64KB(String inputPath, String outputPath)\nthrows IOException, NoSuchAlgorithmException,\nNoSuchPaddingException, InvalidKeyException {\n\n\n    File myFile = new File(inputPath);\n    FileInputStream fis = new FileInputStream(myFile);\n\n    FileOutputStream fos = new FileOutputStream(outputPath);\n    BufferedOutputStream bus = new BufferedOutputStream(fos);\n\n    SecretKeySpec sks = new SecretKeySpec(\"MyDifficultPassw\".getBytes(),\n            \"AES\");\n\n    Cipher cipher = Cipher.getInstance(\"AES\");\n    cipher.init(Cipher.ENCRYPT_MODE, sks);\n\n    int b = 0;\n    byte[] d = new byte[65536];\n\n    int offset = 0;\n\n    byte[] encVal = null;\n\n    while ((b = fis.read(d)) != -1) {\n\n        offset = offset + b;\n        Log.d(TAG, \"Offset: \"+offset);\n        Log.d(TAG, \"b: \"+b);\n        if((offset)>=myFile.length())\n        {\n            Log.d(TAG, \"last 64 Kbytes\");\n\n            try {\n                encVal = cipher.doFinal(d);\n                Log.d(TAG, \"encVal: \"+encVal);\n                bus.write(encVal);\n            } catch (Exception e) {\n                e.printStackTrace();\n            }\n\n        }\n        else\n        {\n            Log.d(TAG, \"rest of the bytes\");\n            bus.write(d);\n        }\n\n\n        bus.flush();\n        bus.close();\n        fis.close();\n    }\n\n\n}\n", "idx": 2174}
{"project": "cipher", "commit_id": "Snippet30096206_12236.java", "target": 0, "func": "String str=message+username;\nbyte[] byte1= str.getBytes(\"UTF8\");\nbyte[] byte2= encrypt(pubk, byte1);\n\npublic byte[] encrypt(PublicKey key, byte[] plaintext)\n{\nCipher cipher = Cipher.getInstance(\"AES\");   \ncipher.init(Cipher.ENCRYPT_MODE, key);  \nreturn cipher.doFinal(plaintext);\n}\n", "idx": 2228}
{"project": "cipher", "commit_id": "Snippet22172588_4544.java", "target": 1, "func": "String PUBLIC_KEY = \"abcdefghijklmnio\";\nString PUBLIC_IV = \"abcdefghijklmnio\";\nbyte[] byteArr = PUBLIC_KEY.getBytes();\nCipher cipher = Cipher.getInstance(\"AES/CBC/NoPadding\");\nfinal SecretKeySpec secretKey = new SecretKeySpec(byteArr, \"AES\");\ncipher.init(Cipher.DECRYPT_MODE, secretKey, new IvParameterSpec(PUBLIC_IV.getBytes()));\n\nbyte[] parsed = Base64.decodeBase64(encrypted.getBytes());\n//byte[] parsed = DatatypeConverter.parseBase64Binary(encrypted); \n\nbyte[] fin = cipher.doFinal(parsed);\nString decryptedString = new String(fin);\n", "idx": 2735}
{"project": "cipher", "commit_id": "Snippet42831339_24912.java", "target": 1, "func": "Cipher asymmetricCipher = null;\nasymmetricCipher = Cipher.getInstance(\"RSA\");\nX509EncodedKeySpec publicKeySpec128 = new X509EncodedKeySpec(key128block);\nX509EncodedKeySpec publicKeySpec74 = new X509EncodedKeySpec(key74block);\n\nKeyFactory keyFactory = KeyFactory.getInstance(\"RSA\");\nKey key = keyFactory.generatePublic(publicKeySpec128);\nasymmetricCipher.init(Cipher.DECRYPT_MODE, key);\n\nbyte[] plainText = asymmetricCipher.doFinal(topBlocksData[0]);\n", "idx": 2531}
{"project": "cipher", "commit_id": "Snippet46589671_28714.java", "target": 0, "func": " try {\n    KeyGenerator  kg = KeyGenerator.getInstance(\"DESede\");\n    SecretKey key = kg.generateKey();\n    Cipher cipher = Cipher.getInstance(\"DESede\");\n    cipher.init(Cipher.ENCRYPT_MODE, key);\n    ObjectOutputStream oos = new ObjectOutputStream(new CipherOutputStream(new FileOutputStream(\"saves/data.ttg\"), cipher));\n    oos.writeObject(\"\" + CurrentMoney);\n    fos = new FileOutputStream(\"saves/key.ttg\");\n    SecretKeyFactory skf = SecretKeyFactory.getInstance(\"DESede\");\n    DESedeKeySpec keyspec = (DESedeKeySpec) skf.getKeySpec(key, DESedeKeySpec.class);\n    fos.write(keyspec.getKey());\n    fos.close();\n    oos.close();\n} catch (NoSuchAlgorithmException e) {\n    e.printStackTrace();\n}\n", "idx": 2205}
{"project": "cipher", "commit_id": "Snippet42788457_24846.java", "target": 1, "func": "cipher = Cipher.getInstance(\"AES/CBC/NoPadding\"); //this may be not decrypt full plaintext.\n", "idx": 2755}
{"project": "cipher", "commit_id": "Snippet27781179_9947.java", "target": 0, "func": "public final String encryptAES(final String plaintext, SecretKey key) {\n        String ciphertext = new String();\n\n        try {\n            Cipher cipher = Cipher.getInstance(\"AES\");\n            cipher.init(Cipher.ENCRYPT_MODE, key);\n            byte[] bytePlaintext = plaintext.getBytes();\n            byte[] byteCiphertext = cipher.doFinal(bytePlaintext);\n            ciphertext = new BASE64Encoder().encode(byteCiphertext);\n\n        } catch (NoSuchAlgorithmException e) {\n            System.out.println(\"NoSuchAlgorithmException: \" + e);\n        } catch (NoSuchPaddingException e) {\n            System.out.println(\"NoSuchPaddingException: \" + e);\n        } catch (InvalidKeyException e) {\n            e.printStackTrace();\n            System.out.println(\"InvalidKeyException: \" + e);\n        } catch (IllegalBlockSizeException e) {\n            System.out.println(\"IllegalBlockSizeException: \" + e);\n        } catch (BadPaddingException e) {\n            System.out.println(\"BadPaddingException: \" + e);\n        }\n        return ciphertext;\n    }\n\npublic final String decryptedPlain(String ciphertext, SecretKey key) {\n        try {\n            Cipher cipher = Cipher.getInstance(\"AES\");\n            cipher.init(Cipher.DECRYPT_MODE, key);\n\n\n            byte [] decodedValue = new Base64().decode(ciphertext.getBytes());\n            plaintext = cipher.doFinal(decodedValue);\n\n        } catch (NoSuchAlgorithmException e) {\n            System.out.println(\"NoSuchAlgorithmException: \" + e);\n        } catch (NoSuchPaddingException e) {\n            System.out.println(\"NoSuchPaddingException: \" + e);\n        } catch (InvalidKeyException e) {\n            System.out.println(\"InvalidKeyException: \" + e);\n        } catch (IllegalBlockSizeException e) {\n            System.out.println(\"IllegalBlockSizeException: \" + e);\n        } catch (BadPaddingException e) {\n            System.out.println(\"BadPaddingException: \" + e);\n        }\n\n        return new String(plaintext);\n    }\n", "idx": 1955}
{"project": "cipher", "commit_id": "Snippet17854613_950.java", "target": 0, "func": "public class Crypto implements java.io.Serializable\n{\n\npublic Crypto(String filename)\n{\n\nCipher cipher = Cipher.getInstance(\"AES/ECB/PKCS5PADDING\");\nSecretKeySpec secretkey = new SecretKeySpec(key(), \"AES\");\ncipher.init(Cipher.ENCRYPT_MODE, secretkey);\nCipherInputStream cipt = new CipherInputStream(new FileInputStream(new File(filename)), cipher)\n\nByteArrayOutputStream baos = new ByteArrayOutputStream();\n\n  ObjectOutputStream obj = null;\n\n           try\n           {\n                obj =   new ObjectOutputStream(baos);\n                obj.writeObject(cipt);\n                byte[] bv = baos.toByteArray();\n                System.out.println(bv);\n\n           }\n           catch(Exception b)\n           {\n           b.printStackTrace();\n           }\n           finally\n           {\n            obj.close();\n            baos.close();\n           }\n      }\n     }\n", "idx": 2139}
{"project": "cipher", "commit_id": "Snippet38344586_20304.java", "target": 1, "func": "try {\n\n\n            // byte[] salt = generateSalt();\n            byte[] salt = saltStr.getBytes();\n           // Log.i(TAG, \"Salt: \" + salt.length + \" \" + HexEncoder.toHex(salt));\n            PBEKeySpec pbeKeySpec = new PBEKeySpec(password.toCharArray(), salt, PBE_ITERATION_COUNT, 128);\n            SecretKeyFactory factory = SecretKeyFactory.getInstance(PBE_ALGORITHM);\n            SecretKey tmp = factory.generateSecret(pbeKeySpec);\n            SecretKey secret = new SecretKeySpec(tmp.getEncoded(), \"AES\");\n            byte[] key = secret.getEncoded();\n            //Log.i(TAG, \"Key: \" + HexEncoder.toHex(key));\n\n            // PBEParameterSpec pbeParamSpec = new PBEParameterSpec(salt, ITERATION_COUNT);\n\n            Cipher encryptionCipher = Cipher.getInstance(CIPHER_ALGORITHM);\n\n            // byte[] encryptionSalt = generateSalt();\n            // Log.i(TAG, \"Encrypted Salt: \" + encryptionSalt.length + \" \" + HexEncoder.toHex(encryptionSalt));\n            // PBEParameterSpec pbeParamSpec = new PBEParameterSpec(encryptionSalt, 1000);\n            // byte[] iv = params.getParameterSpec(IvParameterSpec.class).getIV();\n            Log.i(TAG, encryptionCipher.getParameters() + \" \");\n          // byte[] iv = generateIv();\n           //byte[] iv =\"QmBSbUZMUwld31DPrqyVSA==\".getBytes();\n            IvParameterSpec ivspec = new IvParameterSpec(Arrays.copyOf(iv,16));\n\n            encryptionCipher.init(Cipher.ENCRYPT_MODE, secret, ivspec);\n            byte[] encryptedText = encryptionCipher.doFinal(plainText.getBytes());\n           // Log.i(TAG, \"Encrypted: \" + new String(encryptedText));\n            Log.i(TAG, \"Encrypted: \" + Base64.encodeToString(encryptedText, Base64.DEFAULT));\n\n            Cipher decryptionCipher = Cipher.getInstance(CIPHER_ALGORITHM);\n            decryptionCipher.init(Cipher.DECRYPT_MODE, secret, ivspec);\n            byte[] decryptedText = decryptionCipher.doFinal(encryptedText);\n            Log.i(TAG, \"Decrypted....: \" + new String(decryptedText));\n\n        } catch (Exception e) {\n            e.printStackTrace();\n        }\n", "idx": 2537}
{"project": "cipher", "commit_id": "Snippet29717950_11789.java", "target": 1, "func": "import static java.nio.charset.StandardCharsets.*;\n\nimport java.security.GeneralSecurityException;\nimport java.security.SecureRandom;\n\nimport javax.crypto.BadPaddingException;\nimport javax.crypto.Cipher;\nimport javax.crypto.SecretKey;\nimport javax.crypto.spec.GCMParameterSpec;\nimport javax.crypto.spec.SecretKeySpec;\nimport javax.xml.bind.DatatypeConverter;\n\npublic class SecurityHelperGCM {\n    private static final int NONCE_SIZE = 8;\n    private static final int TAG_SIZE = 12;\n    // make sure that the hexadecimals represent a *truly random* byte array\n    // (e.g. use SecureRandom)\n    private final SecretKey STATIC_SECRET_KEY = new SecretKeySpec(\n            hexDecode(\"66e517bb5fd7df840060aed7e8b58986\"), \"AES\");\n    private Cipher cipher;\n\n    private static byte[] hexDecode(final String hex) {\n        final byte[] data = new byte[hex.length() / 2];\n        for (int i = 0; i < data.length; i++) {\n            data[i] = (byte) Integer.parseInt(hex.substring(i * 2, i * 2 + 2),\n                    16);\n        }\n        return data;\n    }\n\n    public SecurityHelperGCM() {\n        try {\n            this.cipher = Cipher.getInstance(\"AES/GCM/NoPadding\");\n        } catch (final Exception e) {\n            e.printStackTrace();\n        }\n    }\n\n    private static int generateRandomNonce(final byte[] nonceBuffer,\n            final int offset, final int size) {\n        final SecureRandom rng = new SecureRandom();\n        final byte[] nonce = new byte[size];\n        rng.nextBytes(nonce);\n        System.arraycopy(nonce, 0, nonceBuffer, offset, size);\n        clearArray(nonce);\n\n        return offset + size;\n    }\n\n    private static void clearArray(final byte[] nonce) {\n        // clean up...\n        for (int i = 0; i < nonce.length; i++) {\n            nonce[i] = 0;\n        }\n    }\n\n    private static GCMParameterSpec generateGCMParametersFromNonce(\n            final byte[] nonceBuffer, final int offset, final int size,\n            final int blockSize) {\n        final GCMParameterSpec gcmParameters = new GCMParameterSpec(TAG_SIZE\n                * Byte.SIZE, nonceBuffer, offset, size);\n        return gcmParameters;\n    }\n\n    public String encrypt(final String secret) {\n        final byte[] plaintext = secret.getBytes(UTF_8);\n        final byte[] nonceAndCiphertext = new byte[NONCE_SIZE\n                + plaintext.length + TAG_SIZE];\n\n        int offset = generateRandomNonce(nonceAndCiphertext, 0, NONCE_SIZE);\n        final GCMParameterSpec nonceIV = generateGCMParametersFromNonce(\n                nonceAndCiphertext, 0, NONCE_SIZE, this.cipher.getBlockSize());\n\n        try {\n            this.cipher.init(Cipher.ENCRYPT_MODE, this.STATIC_SECRET_KEY,\n                    nonceIV);\n            offset += this.cipher.doFinal(plaintext, 0, plaintext.length,\n                    nonceAndCiphertext, offset);\n            if (offset != nonceAndCiphertext.length) {\n                throw new IllegalStateException(\n                        \"Something wrong during encryption\");\n            }\n            // Java 8 contains java.util.Base64\n            return DatatypeConverter.printBase64Binary(nonceAndCiphertext);\n        } catch (final GeneralSecurityException e) {\n            throw new IllegalStateException(\n                    \"Missing basic functionality from Java runtime\", e);\n        }\n    }\n\n    public String decrypt(final String encrypted) throws BadPaddingException {\n        final byte[] nonceAndCiphertext = DatatypeConverter\n                .parseBase64Binary(encrypted);\n        final GCMParameterSpec nonceIV = generateGCMParametersFromNonce(\n                nonceAndCiphertext, 0, NONCE_SIZE, this.cipher.getBlockSize());\n        try {\n            this.cipher.init(Cipher.DECRYPT_MODE, this.STATIC_SECRET_KEY,\n                    nonceIV);\n            final byte[] plaintext = this.cipher.doFinal(nonceAndCiphertext,\n                    NONCE_SIZE, nonceAndCiphertext.length - NONCE_SIZE);\n            return new String(plaintext, UTF_8);\n        } catch (final BadPaddingException e) {\n            throw e;\n        } catch (final GeneralSecurityException e) {\n            throw new IllegalStateException(\n                    \"Missing basic functionality from Java runtime\", e);\n        }\n    }\n\n    public static void main(final String[] args) {\n        final String secret = \"owlstead\";\n        final SecurityHelperGCM securityHelperGCM = new SecurityHelperGCM();\n        final String ct = securityHelperGCM.encrypt(secret);\n        String pt = null;\n        try {\n            pt = securityHelperGCM.decrypt(ct);\n        } catch (BadPaddingException e) {\n            System.out.println(\"Ciphertext tampered, take action!\");\n        }\n        System.out.println(pt);\n    }\n}\n", "idx": 2664}
{"project": "cipher", "commit_id": "Snippet29531739_11564.java", "target": 1, "func": "import java.io.ByteArrayInputStream;\nimport java.io.File;\nimport java.io.FileInputStream;\nimport java.io.IOException;\nimport java.io.ObjectInputStream;\nimport java.io.Serializable;\nimport java.math.BigInteger;\nimport java.security.KeyFactory;\nimport java.security.KeyPair;\nimport java.security.KeyPairGenerator;\nimport java.security.NoSuchAlgorithmException;\nimport java.security.PrivateKey;\nimport java.security.PublicKey;\nimport java.security.spec.InvalidKeySpecException;\nimport java.security.spec.RSAPublicKeySpec;\nimport java.sql.SQLException;\n\nimport javax.crypto.Cipher;\n\n    public class RSAKeyPack implements Serializable {\n\n      private static final long serialVersionUID = 2L;\n      PublicKey publicKey;\n      PrivateKey privateKey;\n        //KeyPairGenerator keyPairGenerator;\n        transient KeyPairGenerator keyPairGenerator;\n\n        private  void getGenerator() throws NoSuchAlgorithmException {\n           if (keyPairGenerator == null) {\n               keyPairGenerator = KeyPairGenerator.getInstance(\"RSA\");\n               keyPairGenerator.initialize(1024); //1024 used for normal securities\n               KeyPair keyPair = keyPairGenerator.generateKeyPair();  \n               publicKey = keyPair.getPublic();  \n               privateKey = keyPair.getPrivate();\n           }\n\n        }\n        public RSAKeyPack()\n        {\n\n            try {\n                getGenerator();\n            } catch (NoSuchAlgorithmException e) {\n                // TODO Auto-generated catch block\n                e.printStackTrace();\n            }\n            /*try \n            {\n\n                keyPairGenerator = KeyPairGenerator.getInstance(\"RSA\");\n                keyPairGenerator.initialize(2048); //1024 used for normal securities\n                KeyPair keyPair = keyPairGenerator.generateKeyPair();  \n                 publicKey = keyPair.getPublic();  \n                privateKey = keyPair.getPrivate();          \n            } \n            catch (NoSuchAlgorithmException e) \n            {\n                e.printStackTrace();\n            }*/\n        }\n\n        public PublicKey getPublicKey() {\n            return publicKey;\n        }\n\n        public void setPublicKey(PublicKey publicKey) {\n            this.publicKey = publicKey;\n        }\n\n        public PrivateKey getPrivateKey() {\n            return privateKey;\n        }\n\n        public void setPrivateKey(PrivateKey privateKey) {\n            this.privateKey = privateKey;\n        }\n\n\n\n        public   BigInteger  getParamModulus(PublicKey publickey) throws IOException, NoSuchAlgorithmException, InvalidKeySpecException\n        {\n\n                 KeyFactory keyFactory = KeyFactory.getInstance(\"RSA\");  \n                 RSAPublicKeySpec rsaPubKeySpec = keyFactory.getKeySpec(publicKey, RSAPublicKeySpec.class);  \n                 //RSAPrivateKeySpec rsaPrivKeySpec = keyFactory.getKeySpec(privateKey, RSAPrivateKeySpec.class);  \n                 System.out.println(\"PubKey Modulus : \" + rsaPubKeySpec.getModulus());\n\n\n            return rsaPubKeySpec.getModulus();\n           }  \n\n        public   BigInteger  getParamExponent(PublicKey publickey) throws IOException, NoSuchAlgorithmException, InvalidKeySpecException\n        {\n\n                 KeyFactory keyFactory = KeyFactory.getInstance(\"RSA\");  \n                 RSAPublicKeySpec rsaPubKeySpec = keyFactory.getKeySpec(publicKey, RSAPublicKeySpec.class);  \n                 //RSAPrivateKeySpec rsaPrivKeySpec = keyFactory.getKeySpec(privateKey, RSAPrivateKeySpec.class);  \n                 System.out.println(\"PubKey Modulus : \" + rsaPubKeySpec.getPublicExponent());\n\n\n            return rsaPubKeySpec.getPublicExponent();\n           }  \n\n\n         public static PublicKey readPublicKey(BigInteger modulus,BigInteger exponent) throws IOException, NoSuchAlgorithmException, InvalidKeySpecException{  \n\n\n                  //Get Public Key  \n                  RSAPublicKeySpec rsaPublicKeySpec = new RSAPublicKeySpec(modulus, exponent);  \n                  KeyFactory fact = KeyFactory.getInstance(\"RSA\");  \n                  PublicKey publicKey = fact.generatePublic(rsaPublicKeySpec);  \n                  return publicKey;  \n\n\n         }   \n\n\n         public  byte[] encryptData(byte[] data,PublicKey pubKey) throws IOException {  \n\n\n                 byte[] encryptedData = null;  \n                 try {  \n\n                        Cipher cipher = Cipher.getInstance(\"RSA/ECB/NoPadding\");  \n                        cipher.init(Cipher.ENCRYPT_MODE, pubKey);\n\n                        System.out.println(\"data key length after encryption\"+data.length);\n                        encryptedData = cipher.doFinal(data);  \n                        System.out.println(\"data key length after encryption\"+encryptedData.length);\n\n                 } catch (Exception e) {  \n                     System.out.println(\"----------------ENCRYPTION ABANDONED!!!------------\"); \n                        e.printStackTrace();  \n                 }   \n\n\n                 return (encryptedData);  \n             }  \n\n\n         public    byte[] decryptData(byte[] data,PrivateKey privateKey) throws IOException {  \n\n              byte[] descryptedData = null;  \n\n              try {  \n\n               Cipher cipher = Cipher.getInstance(\"RSA/ECB/NoPadding\");\n\n               cipher.init(Cipher.DECRYPT_MODE, privateKey);  \n               descryptedData = cipher.doFinal(data);  \n               System.out.println(\"data key length after decryption     \"+data.length);\n\n              } catch (Exception e) {  \n               e.printStackTrace();  \n              }   \n\n              return descryptedData ;\n\n             }  \n    }\n", "idx": 2573}
{"project": "cipher", "commit_id": "Snippet23744623_6052.java", "target": 1, "func": "Cipher.getInstance(\"AES/CTR/NoPadding\")", "idx": 2590}
{"project": "cipher", "commit_id": "Snippet20871030_3466.java", "target": 0, "func": "  public static byte[] encrypt(byte[] raw, byte[] clear) throws Exception {\n\n    SecretKeySpec skeySpec = new SecretKeySpec(raw, \"AES\");\n    Cipher cipher = Cipher.getInstance(\"AES\");\n    cipher.init(Cipher.ENCRYPT_MODE, skeySpec);\n    byte[] encrypted = cipher.doFinal(clear);\n    return encrypted;\n}\n", "idx": 2217}
{"project": "cipher", "commit_id": "Snippet25844026_8112.java", "target": 0, "func": "import org.bouncycastle.jce.provider.BouncyCastleProvider;\n\nimport javax.crypto.Cipher;\nimport java.security.GeneralSecurityException;\nimport java.security.Provider;\nimport java.security.Security;\n\npublic class JCETest {\npublic static void main( String[] args ) throws GeneralSecurityException\n{\n\n    BouncyCastleProvider bouncyCastleProvider = new BouncyCastleProvider();\n    Security.addProvider(bouncyCastleProvider);\n\n    System.out.println( \"\\nSecurity-Provider:\" );\n    for( Provider prov : Security.getProviders() ) {\n        System.out.println( \"  \" + prov + \": \" + prov.getInfo() );\n    }\n    System.out.println( \"\\nMaxAllowedKeyLength (for '\" + Cipher.getInstance(\"AES\").getProvider() + \"' using current 'JCE Policy Files'):\\n\"\n            + \"  DES        = \" + Cipher.getMaxAllowedKeyLength( \"DES\"        ) + \"\\n\"\n            + \"  Triple DES = \" + Cipher.getMaxAllowedKeyLength( \"Triple DES\" ) + \"\\n\"\n            + \"  AES        = \" + Cipher.getMaxAllowedKeyLength( \"AES\"        ) + \"\\n\"\n            + \"  Blowfish   = \" + Cipher.getMaxAllowedKeyLength( \"Blowfish\"   ) + \"\\n\"\n            + \"  RSA        = \" + Cipher.getMaxAllowedKeyLength( \"RSA\"        ) + \"\\n\" );\n}\n}\n", "idx": 2203}
{"project": "cipher", "commit_id": "Snippet10222284_34544.java", "target": 0, "func": "public class EncryptDecryptFileStreamWithDES {\n\nprivate static Cipher ecipher;\nprivate static Cipher dcipher;\n\n// 8-byte initialization vector\nprivate static byte[] iv = {\n    (byte)0xB2, (byte)0x12, (byte)0xD5, (byte)0xB2,\n    (byte)0x44, (byte)0x21, (byte)0xC3, (byte)0xC3\n};\n\npublic static void call() {\n\n    try {\n\n        SecretKey key = KeyGenerator.getInstance(\"DES\").generateKey();\n\n        AlgorithmParameterSpec paramSpec = new IvParameterSpec(iv);\n\n        ecipher = Cipher.getInstance(\"DES/CBC/PKCS5Padding\");\n        dcipher = Cipher.getInstance(\"DES/CBC/PKCS5Padding\");\n\n        ecipher.init(Cipher.ENCRYPT_MODE, key, paramSpec);\n        dcipher.init(Cipher.DECRYPT_MODE, key, paramSpec);\n\n    //    encrypt(new FileInputStream(\"C:\\\\Users\\\\Admin\\\\Desktop\\\\zipped\\\\4.zip\"), new FileOutputStream(\"C:\\\\Users\\\\Admin\\\\Desktop\\\\zipped\\\\4.dat\"));\n      //  decrypt(new FileInputStream(\"C:\\\\Users\\\\Admin\\\\Desktop\\\\zipped\\\\4.dat\"), new FileOutputStream(\"C:\\\\Users\\\\Admin\\\\Desktop\\\\zipped\\\\4new.zip\"));\n\n    //}\n    //catch (FileNotFoundException e) {\n        //System.out.println(\"File Not Found:\" + e.getMessage());\n        //return;\n    }\n    catch (InvalidAlgorithmParameterException e) {\n        System.out.println(\"Invalid Alogorithm Parameter:\" + e.getMessage());\n        return;\n    }\n    catch (NoSuchAlgorithmException e) {\n        System.out.println(\"No Such Algorithm:\" + e.getMessage());\n        return;\n    }\n    catch (NoSuchPaddingException e) {\n        System.out.println(\"No Such Padding:\" + e.getMessage());\n        return;\n    }\n    catch (InvalidKeyException e) {\n        System.out.println(\"Invalid Key:\" + e.getMessage());\n        return;\n    }\n\n}\n\npublic static void encrypt(InputStream is, OutputStream os) {\n\n    try {\n\n        call();\n\n        byte[] buf = new byte[1024];\n\n        // bytes at this stream are first encoded\n        os = new CipherOutputStream(os, ecipher);\n\n        // read in the clear text and write to out to encrypt\n        int numRead = 0;\n        while ((numRead = is.read(buf)) >= 0) {\n            os.write(buf, 0, numRead);\n        }\n\n        // close all streams\n        os.close();\n\n    }\n    catch (IOException e) {\n        System.out.println(\"I/O Error:\" + e.getMessage());\n    }\n\n}\n\npublic static void decrypt(InputStream is, OutputStream os) {\n\n    try {\n\n        call();\n\n        byte[] buf = new byte[1024];\n\n        // bytes read from stream will be decrypted\n        CipherInputStream cis = new CipherInputStream(is, dcipher);\n\n        // read in the decrypted bytes and write the clear text to out\n        int numRead = 0;\n        while ((numRead = cis.read(buf)) > 0) {\n            os.write(buf, 0, numRead);\n        }\n\n        // close all streams\n        cis.close();\n        is.close();\n        os.close();\n\n    }\n    catch (IOException e) {\n        System.out.println(\"I/O Error:\" + e.getMessage());\n    }\n\n}\n\n}\n", "idx": 2117}
{"project": "cipher", "commit_id": "Snippet27353260_9546.java", "target": 0, "func": "public class Encryptor {\n    private static String inputFilePath = \"D:/1.txt\";\n    public static void main(String[] args) {\n        FileOutputStream fos = null;\n        File file = new File(inputFilePath);\n        String keyString = \"140405PX_0.$88\";\n        String algorithm = \"DESede\";\n        try {\n            FileInputStream fileInputStream = new FileInputStream(file);\n            byte[] fileByteArray = new byte[fileInputStream.available()];\n            fileInputStream.read(fileByteArray);\n            for (byte b : fileByteArray) {\n            System.out.println(b);\n            }\n            SecretKey secretKey = getKey(keyString);\n            Cipher cipher = Cipher.getInstance(algorithm);\n            cipher.init(Cipher.ENCRYPT_MODE, secretKey);\n            ObjectOutputStream objectOutputStream = new ObjectOutputStream\n                    (new CipherOutputStream\n                            (new FileOutputStream\n                                    (\"D:/Secret.file\"), cipher));\n            objectOutputStream.writeObject(fileByteArray);\n            objectOutputStream.close();\n        } catch (Exception e) {\n            e.printStackTrace();\n        }\n    }\n    public static SecretKey getKey(String message) throws Exception {\n        String messageToUpperCase = message.toUpperCase();\n        byte[] digestOfPassword = messageToUpperCase.getBytes();\n        byte[] keyBytes = Arrays.copyOf(digestOfPassword, 24);\n        SecretKey key = new SecretKeySpec(keyBytes, \"DESede\");\n        return key;\n    }\n}\n", "idx": 1953}
{"project": "cipher", "commit_id": "Snippet5445998_31623.java", "target": 0, "func": "byte[] key = getKey();\nCipher cipher = Cipher.getInstance(\"Blowfish\");\nSecretKeySpec keySpec = new SecretKeySpec(key, \"Blowfish\");\ncipher.init(Cipher.DECRYPT_MODE, keySpec);\n", "idx": 2066}
{"project": "cipher", "commit_id": "Snippet41501337_23436.java", "target": 1, "func": "public final class AEScrypt{\n\nprivate static final String TAG = \"AESCrypt\";\n\n//AESCrypt-ObjC uses CBC and PKCS7Padding\nprivate static final String AES_MODE = \"AES/CBC/PKCS7Padding\";\nprivate static final String CHARSET = \"UTF-8\";\n\n//AESCrypt-ObjC uses SHA-256 (and so a 256-bit key)\nprivate static final String HASH_ALGORITHM = \"SHA-256\";\n\n//AESCrypt-ObjC uses blank IV (not the best security, but the aim here is compatibility)\nprivate static final byte[] ivBytes = {0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0};\n//togglable log option (please turn off in live!)\npublic static boolean DEBUG_LOG_ENABLED = false;\n\n\n\nprivate static SecretKeySpec generateKey(final String password) throws NoSuchAlgorithmException, UnsupportedEncodingException {\n    final MessageDigest digest = MessageDigest.getInstance(HASH_ALGORITHM);\n    byte[] bytes = password.getBytes(\"UTF-8\");\n    digest.update(bytes, 0, bytes.length);\n    byte[] key = digest.digest();\n\n    log(\"SHA-256 key \", key);\n\n    SecretKeySpec secretKeySpec = new SecretKeySpec(key, \"AES\");\n    return secretKeySpec;\n}\n\n\npublic static String encrypt(final String password, String message)\n        throws GeneralSecurityException {\n\n    try {\n        final SecretKeySpec key = generateKey(password);\n\n        log(\"message\", message);\n\n        byte[] cipherText = encrypt(key, ivBytes, message.getBytes(CHARSET));\n\n        //NO_WRAP is important as was getting \\n at the end\n        String encoded = Base64.encodeToString(cipherText, Base64.NO_WRAP);\n        log(\"Base64.NO_WRAP\", encoded);\n        return encoded;\n    } catch (UnsupportedEncodingException e) {\n        if (DEBUG_LOG_ENABLED)\n            Log.e(TAG, \"UnsupportedEncodingException \", e);\n        throw new GeneralSecurityException(e);\n    }\n}\n\npublic static byte[] encrypt(final SecretKeySpec key, final byte[] iv, final byte[] message)\n        throws GeneralSecurityException {\n    final Cipher cipher = Cipher.getInstance(AES_MODE);\n    IvParameterSpec ivSpec = new IvParameterSpec(iv);\n    cipher.init(Cipher.ENCRYPT_MODE, key, ivSpec);\n    byte[] cipherText = cipher.doFinal(message);\n\n    log(\"cipherText\", cipherText);\n\n    return cipherText;\n}\n\n\n\npublic static String decrypt(final String password, String base64EncodedCipherText)\n        throws GeneralSecurityException {\n\n    try {\n        final SecretKeySpec key = generateKey(password);\n\n        log(\"base64EncodedCipherText\", base64EncodedCipherText);\n        byte[] decodedCipherText = Base64.decode(base64EncodedCipherText, Base64.NO_WRAP);\n        log(\"decodedCipherText\", decodedCipherText);\n\n        byte[] decryptedBytes = decrypt(key,  ivBytes, decodedCipherText);\n\n        log(\"decryptedBytes\", decryptedBytes);\n        String message = new String(decryptedBytes, CHARSET);\n        log(\"message\", message);\n\n\n        return message;\n    } catch (UnsupportedEncodingException e) {\n        if (DEBUG_LOG_ENABLED)\n            Log.e(TAG, \"UnsupportedEncodingException \", e);\n\n        throw new GeneralSecurityException(e);\n    }\n}\n\n\npublic static byte[] decrypt(final SecretKeySpec key, final byte[] iv, final byte[] decodedCipherText)\n        throws GeneralSecurityException {\n    final Cipher cipher = Cipher.getInstance(AES_MODE);\n    IvParameterSpec ivSpec = new IvParameterSpec(iv);\n    cipher.init(Cipher.DECRYPT_MODE, key, ivSpec);\n    byte[] decryptedBytes = cipher.doFinal(decodedCipherText);\n\n    log(\"decryptedBytes\", decryptedBytes);\n\n    return decryptedBytes;\n}\n\n\nprivate static void log(String what, byte[] bytes) {\n    if (DEBUG_LOG_ENABLED)\n        Log.d(TAG, what + \"[\" + bytes.length + \"] [\" + bytesToHex(bytes) + \"]\");\n}\n\nprivate static void log(String what, String value) {\n    if (DEBUG_LOG_ENABLED)\n        Log.d(TAG, what + \"[\" + value.length() + \"] [\" + value + \"]\");\n}\n\nprivate static String bytesToHex(byte[] bytes) {\n    final char[] hexArray = {'0', '1', '2', '3', '4', '5', '6', '7', '8',\n            '9', 'A', 'B', 'C', 'D', 'E', 'F'};\n    char[] hexChars = new char[bytes.length * 2];\n    int v;\n    for (int j = 0; j < bytes.length; j++) {\n        v = bytes[j] & 0xFF;\n        hexChars[j * 2] = hexArray[v >>> 4];\n        hexChars[j * 2 + 1] = hexArray[v & 0x0F];\n    }\n    return new String(hexChars);\n}\n\nprivate AESCrypt() {\n}\n", "idx": 2582}
{"project": "cipher", "commit_id": "Snippet19924657_2590.java", "target": 0, "func": "  Cipher desCipher;\n  KeyGenerator keygenerator;\n  SecretKey myDesKey; \n  try{\n    keygenerator = KeyGenerator.getInstance(\"DES\");\n    myDesKey = keygenerator.generateKey();\n    byte[] encoded = myDesKey.getEncoded();\n    // convert secret key to string \n   String stringKey =Base64.encodeToString(myDesKey.getEncoded());\n\n    // converting back from  string to secret key. \n    //its returning javax.crypto.spec.SecretKey object but i need com.sun.crypto.provider.DESKey object\n\n   SecretKey originalKey = new SecretKeySpec(stringKey.getBytes(), 0, stringKey.length(), \"DES\"); \n      String text=\"hello how are you \" \n     desCipher = Cipher.getInstance(\"DES/ECB/PKCS5Padding\");\n    desCipher.init(Cipher.ENCRYPT_MODE, myDesKey);\n    byte[] textEncrypted = desCipher.doFinal(text.getBytes());   \n\n    System.out.println(\"text encrypted successfully\");        \n\n    }\n    catch(Exception ex)\n     {\n       ex.printStackTrace();\n     }\n\nis throwing the exception \n", "idx": 2058}
{"project": "cipher", "commit_id": "Snippet22271311_4663.java", "target": 1, "func": "import java.io.UnsupportedEncodingException;\nimport java.security.AlgorithmParameters;\nimport java.security.GeneralSecurityException;\nimport java.security.spec.KeySpec;\nimport java.util.Arrays;\n\nimport javax.crypto.Cipher;\nimport javax.crypto.SecretKey;\nimport javax.crypto.SecretKeyFactory;\nimport javax.crypto.spec.IvParameterSpec;\nimport javax.crypto.spec.PBEKeySpec;\nimport javax.crypto.spec.SecretKeySpec;\n\nimport org.apache.commons.codec.binary.Base64;\nimport org.apache.commons.lang.Validate;\n\npublic class Encryptor\n{\n    private static final String CIPHER_ALOGRITHM = \"AES/CBC/PKCS5Padding\";\n    private static final String KEY_ALOGRITHM = \"PBKDF2WithHmacSHA1\";\n    private static final String KEY_SPEC_ALOGRITHM = \"AES\";\n    private static final String ENCODING = \"UTF-8\";\n\n    public static String decrypt(String password, String encodedCiphertextAndIv) throws GeneralSecurityException,\n        UnsupportedEncodingException\n    {\n        String[] ra = encodedCiphertextAndIv.split(\":\");\n        byte[] ciphertext = Base64.decodeBase64(ra[0]);\n        byte[] iv = Base64.decodeBase64(ra[1]);\n\n        /* Decrypt the message, given derived key and initialization vector. */\n        Cipher cipher = Cipher.getInstance(CIPHER_ALOGRITHM);\n        cipher.init(Cipher.DECRYPT_MODE, getSecret(password), new IvParameterSpec(iv));\n        String plaintext = new String(cipher.doFinal(ciphertext), ENCODING);\n        return plaintext;\n    }\n\n    static SecretKey getSecret(String password) throws GeneralSecurityException\n    {\n        byte[] salt = Arrays.copyOf(password.getBytes(), 8);\n\n        /* Derive the key, given password and salt. */\n        SecretKeyFactory factory = SecretKeyFactory.getInstance(KEY_ALOGRITHM);\n        KeySpec spec = new PBEKeySpec(password.toCharArray(), salt, 1024, 128);\n        SecretKey tmp = factory.generateSecret(spec);\n        SecretKey secret = new SecretKeySpec(tmp.getEncoded(), KEY_SPEC_ALOGRITHM);\n        return secret;\n    }\n\n    public static String encrypt(String password, String plainText) throws GeneralSecurityException,\n        UnsupportedEncodingException\n    {\n        if (plainText == null)\n        {\n            return plainText;\n        }\n        String[] plainTextValues = new String[]\n        {\n            plainText\n        };\n        String[] encryptedValues = encrypt(password, plainTextValues);\n        return encryptedValues[0];\n    }\n\n    public static String[] encrypt(String password, String[] plainTextValues) throws GeneralSecurityException,\n        UnsupportedEncodingException\n    {\n        if (plainTextValues == null || plainTextValues.length == 0)\n        {\n            return new String[] {};\n        }        \n        Validate.notEmpty(password, \"password must not be empty\");\n\n        /* Encrypt the message. */\n        Cipher cipher = Cipher.getInstance(CIPHER_ALOGRITHM);\n        cipher.init(Cipher.ENCRYPT_MODE, getSecret(password));\n        AlgorithmParameters params = cipher.getParameters();\n        byte[] iv = params.getParameterSpec(IvParameterSpec.class).getIV();\n        String encodedIv = new String(Base64.encodeBase64(iv));\n\n        String[] encryptedValues = new String[plainTextValues.length];\n        for (int i = 0; i < plainTextValues.length; i++)\n        {\n            String plainText = plainTextValues[i];\n            if (plainText == null)\n            {\n                encryptedValues[i] = plainText;\n            }\n            else\n            {\n                byte[] ciphertext = cipher.doFinal(plainText.getBytes(ENCODING));\n                String encodedCiphertext = new String(Base64.encodeBase64(ciphertext));\n                encryptedValues[i] = encodedCiphertext + \":\" + encodedIv;\n            }\n        }\n        return encryptedValues;\n    }\n\n    public static void main(String[] args) throws Exception\n    {\n        String password = \"The Secret\";\n        String plainText = \"Hello, World!\";\n\n        String enc = encrypt(password, plainText);\n        System.out.println(enc);\n        System.out.println(decrypt(password, enc));\n    }\n}\n", "idx": 2611}
{"project": "cipher", "commit_id": "Snippet19196728_2038.java", "target": 1, "func": "import java.security.MessageDigest;\nimport java.security.spec.AlgorithmParameterSpec;\n\nimport javax.crypto.Cipher;\nimport javax.crypto.spec.IvParameterSpec;\nimport javax.crypto.spec.SecretKeySpec;\n\nimport android.util.Base64;\n\n/**\n * @author vipin.cb , vipin.cb@experionglobal.com <br>\n *         Sep 27, 2013, 5:18:34 PM <br>\n *         Package:- <b>com.veebow.util</b> <br>\n *         Project:- <b>Veebow</b>\n *         <p>\n */\npublic class AESCrypt {\n\n    private final Cipher cipher;\n    private final SecretKeySpec key;\n    private AlgorithmParameterSpec spec;\n    public static final String SEED_16_CHARACTER = \"U1MjU1M0FDOUZ.Qz\";\n\n    public AESCrypt() throws Exception {\n        // hash password with SHA-256 and crop the output to 128-bit for key\n        MessageDigest digest = MessageDigest.getInstance(\"SHA-256\");\n        digest.update(SEED_16_CHARACTER.getBytes(\"UTF-8\"));\n        byte[] keyBytes = new byte[32];\n        System.arraycopy(digest.digest(), 0, keyBytes, 0, keyBytes.length);\n\n        cipher = Cipher.getInstance(\"AES/CBC/PKCS7Padding\");\n        key = new SecretKeySpec(keyBytes, \"AES\");\n        spec = getIV();\n    }\n\n    public AlgorithmParameterSpec getIV() {\n        byte[] iv = { 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, };\n        IvParameterSpec ivParameterSpec;\n        ivParameterSpec = new IvParameterSpec(iv);\n\n        return ivParameterSpec;\n    }\n\n    public String encrypt(String plainText) throws Exception {\n        cipher.init(Cipher.ENCRYPT_MODE, key, spec);\n        byte[] encrypted = cipher.doFinal(plainText.getBytes(\"UTF-8\"));\n        String encryptedText = new String(Base64.encode(encrypted,\n                Base64.DEFAULT), \"UTF-8\");\n\n        return encryptedText;\n    }\n\n    public String decrypt(String cryptedText) throws Exception {\n        cipher.init(Cipher.DECRYPT_MODE, key, spec);\n        byte[] bytes = Base64.decode(cryptedText, Base64.DEFAULT);\n        byte[] decrypted = cipher.doFinal(bytes);\n        String decryptedText = new String(decrypted, \"UTF-8\");\n\n        return decryptedText;\n    }\n\n}\n", "idx": 2414}
{"project": "cipher", "commit_id": "Snippet27187461_9331.java", "target": 1, "func": "//command for retrieving exponent\nresp = channel.transmit(new CommandAPDU(cmdExp)); \nBigInteger modulus = new BigInteger(resp.getData());\nbyte[] input = { (byte) 0x92, (byte) 0x84, (byte) 0x3B,\n        (byte) 0xD3, (byte) 0x5D, (byte) 0x8A, (byte) 0x6B,\n        (byte) 0x56, (byte) 0xDA, (byte) 0xEA, (byte) 0xE0,\n        (byte) 0x2F, (byte) 0x6D, (byte) 0xAA, (byte) 0x62,\n        (byte) 0x4B, (byte) 0x38, (byte) 0xCE, (byte) 0xD4,\n        (byte) 0x70, (byte) 0xA2, (byte) 0x16, (byte) 0x35,\n        (byte) 0xCC, (byte) 0xEE, (byte) 0xB8, (byte) 0x31,\n        (byte) 0x13, (byte) 0x37, (byte) 0x40, (byte) 0xBE,\n        (byte) 0xA1, (byte) 0xCD, (byte) 0x84, (byte) 0xD9,\n        (byte) 0xF3, (byte) 0xE6, (byte) 0xCE, (byte) 0x26,\n        (byte) 0x0A, (byte) 0xC1, (byte) 0x40, (byte) 0xED,\n        (byte) 0x20, (byte) 0x8F, (byte) 0x3D, (byte) 0x9F,\n        (byte) 0x0D, (byte) 0xE7, (byte) 0x19, (byte) 0xC8,\n        (byte) 0x87, (byte) 0x96, (byte) 0x29, (byte) 0xF2,\n        (byte) 0x63, (byte) 0x34, (byte) 0x6D, (byte) 0x10,\n        (byte) 0xB9, (byte) 0xFB, (byte) 0xB4, (byte) 0x75,\n        (byte) 0xE9 };\n\nRSAPublicKey pubKey = (RSAPublicKey) KeyFactory.getInstance(\"RSA\")\n        .generatePublic(new RSAPublicKeySpec(modulus, exponent));\n\nCipher cipher = null;\n\ncipher = Cipher.getInstance(\"RSA/ECB/PKCS1Padding\");\ncipher.init(Cipher.DECRYPT_MODE, pubKey);\n\nbyte[] cipherText = cipher.doFinal(input);\n", "idx": 2492}
{"project": "cipher", "commit_id": "Snippet39093489_20971.java", "target": 0, "func": "Key key = new SecretKeySpec(keyValue, \"AES\");\nCipher c = Cipher.getInstance(\"AES\");\nc.init(1, key);\nbyte[] encVal = c.doFinal(Data.getBytes());\nencryptedValue = new BASE64Encoder().encode(encVal);\n", "idx": 1969}
{"project": "cipher", "commit_id": "Snippet46258623_28353.java", "target": 1, "func": "static void SO46244541CryptAsURL (String... args) throws Exception {\n    // arguments: data pubkeyfile(der) prvkeyfile(der) flag(if present specify 8859-1 on conversion)\n    String clear = args[0];\n    KeyFactory fact = KeyFactory.getInstance(\"RSA\");\n    Cipher objCipherTunkicloud = Cipher.getInstance(\"RSA/ECB/PKCS1Padding\");\n    // encrypt side\n    objCipherTunkicloud.init(Cipher.ENCRYPT_MODE, fact.generatePublic(new X509EncodedKeySpec(read_file(args[1]))));\n    byte[] arrDecryptedKeyBytes = objCipherTunkicloud.doFinal(clear.getBytes(StandardCharsets.UTF_8));\n    // for correct result must enable flag and specify 8859-1 on ctor\n    String tkn = args.length>3? new String(arrDecryptedKeyBytes,StandardCharsets.ISO_8859_1): new String(arrDecryptedKeyBytes);\n    String output = URLEncoder.encode(tkn, \"ISO-8859-1\");\n    System.out.println (output);\n    // decrypt side\n    String temp = URLDecoder.decode(output, \"ISO-8859-1\");\n    //reused: Cipher objCipherTunkicloud = Cipher.getInstance(\"RSA/ECB/PKCS1Padding\");\n    objCipherTunkicloud.init(Cipher.DECRYPT_MODE, fact.generatePrivate(new PKCS8EncodedKeySpec(read_file(args[2]))));\n    arrDecryptedKeyBytes = objCipherTunkicloud.doFinal(temp.getBytes(StandardCharsets.ISO_8859_1));\n    System.out.println (new String(arrDecryptedKeyBytes));\n}\n\npublic static byte[] read_file (String filename) throws Exception {\n    return Files.readAllBytes(new File(filename).toPath());\n}\n", "idx": 2717}
{"project": "cipher", "commit_id": "Snippet6538485_32176.java", "target": 0, "func": "byte[] key = //... secret sequence of bytes\nbyte[] dataToSend = ...\nCipher c = Cipher.getInstance(\"AES\");\nSecretKeySpec k = new SecretKeySpec(key, \"AES\");\nc.init(Cipher.ENCRYPT_MODE, k);\nbyte[] encryptedData = c.doFinal(dataToSend);\n", "idx": 2232}
{"project": "cipher", "commit_id": "Snippet15430373_38481.java", "target": 0, "func": "    byte[] key = new byte[16];\n    SecretKeySpec skeySpec = new SecretKeySpec(key, \"AES\");\n    Cipher cipher = Cipher.getInstance(\"AES/ECB/NoPadding\");\n    cipher.init(Cipher.ENCRYPT_MODE, skeySpec);\n\n    byte[] data = \"hello world.....\".getBytes();\n    byte[] encrypted = cipher.doFinal(data);\n    System.out.println(\"Encrypted Array : \" + Arrays.toString(encrypted));\n", "idx": 2105}
{"project": "cipher", "commit_id": "Snippet33300707_15360.java", "target": 1, "func": "// add instance of provider class\nSecurity.addProvider(new BouncyCastleProvider());\n\nString name = \"secp256r1\";\n\n// NOTE just \"EC\" also seems to work here\nKeyPairGenerator kpg = KeyPairGenerator.getInstance(\"ECDH\", BouncyCastleProvider.PROVIDER_NAME);\nkpg.initialize(new ECGenParameterSpec(name));\n\n// Key pair to store public and private key\nKeyPair keyPair = kpg.generateKeyPair();\n\nCipher iesCipher = Cipher.getInstance(\"ECIES\", BouncyCastleProvider.PROVIDER_NAME);\niesCipher.init(Cipher.ENCRYPT_MODE, keyPair.getPublic());\n", "idx": 2594}
{"project": "cipher", "commit_id": "Snippet32077760_14141.java", "target": 1, "func": "Cipher.getInstance(\"AES/CBC/NoPadding\")", "idx": 2692}
{"project": "cipher", "commit_id": "Snippet44787048_26884.java", "target": 0, "func": "public static String decrypt(String encryptStr){\n                    String decrypted = null;\n        try {\n\n            while(encryptStr != null){\n                try\n                {\n\n                    String key = \"Bar12345Bar12345\"; // 128 bit key\n                    // Create key and cipher\n                    Key aesKey = new SecretKeySpec(key.getBytes(), \"AES\");\n                    Cipher cipher = Cipher.getInstance(\"AES\");\n                    // encrypt the text\n                    cipher.init(Cipher.ENCRYPT_MODE, aesKey);\n\n                    // for decryption\n                    byte[] bb = new byte[encryptStr.length()];\n                    for (int i=0; i<encryptStr.length(); i++) {\n                        bb[i] = (byte) encryptStr.charAt(i);\n                    }\n\n                    // decrypt the text\n                    cipher.init(Cipher.DECRYPT_MODE, aesKey);\n                    decrypted = new String(cipher.doFinal(bb));\n\n                }\n                catch(Exception e)\n                {\n                    e.printStackTrace();\n                }\n            }\n        } catch (IOException ex) {\n            Logger.getLogger(Snake_H.class.getName()).log(Level.SEVERE, null, ex);\n        }\n        return decrypted;\n    }\n", "idx": 2131}
{"project": "cipher", "commit_id": "Snippet37783936_19778.java", "target": 1, "func": "package com.ucsc.raji;\n\nimport java.io.File;\nimport java.io.FileInputStream;\nimport java.security.Key;\nimport java.security.KeyPair;\nimport java.security.KeyStore;\nimport java.security.MessageDigest;\nimport java.security.NoSuchAlgorithmException;\nimport java.security.PrivateKey;\nimport java.security.PublicKey;\nimport java.security.cert.Certificate;\nimport java.util.Base64;\n\nimport javax.crypto.Cipher;\nimport javax.crypto.NoSuchPaddingException;\n\npublic class DualSignatureSample {\n\n    public static byte[] encrypt(String original, Key privateKey) {\n        if (original != null && privateKey != null) {\n            byte[] bs = original.getBytes();\n            byte[] encData = convert(bs, privateKey, Cipher.ENCRYPT_MODE);\n            return encData;\n        }\n        return null;\n    }\n\n    public static byte[] decrypt(byte[] encrypted, Key publicKey) {\n        if (encrypted != null && publicKey != null) {\n            byte[] decData = convert(encrypted, publicKey, Cipher.DECRYPT_MODE);\n            return decData;\n        }\n        return null;\n    }\n\n    private static byte[] convert(byte[] data, Key key, int mode) {\n        try {\n            //Cipher cipher = Cipher.getInstance(\"RSA\");\n            Cipher cipher = Cipher.getInstance(\"RSA/ECB/PKCS1Padding\");\n\n            cipher.init(mode, key);\n            byte[] newData = cipher.doFinal(data);\n            byte[] datax = org.apache.commons.codec.binary.Base64.encodeBase64(newData);\n            return datax;\n        } catch (Exception e) {\n            e.printStackTrace();\n        }\n        return null;\n    }\n\n    public static KeyPair getPrivateKey() throws Exception {\n        FileInputStream is = new FileInputStream(\"C:\" + File.separator\n                + \"Users\" + File.separator + \"rsatkunam\" + File.separator\n                + \"Documents\" + File.separator + \"Rajeenthini\" + File.separator\n                + \"MCS\" + File.separator + \"keystore.jks\");\n\n        KeyStore keystore = KeyStore.getInstance(KeyStore.getDefaultType());\n        keystore.load(is, \"password\".toCharArray());\n        PublicKey publicKey = null;\n        String alias = \"rajeenthini\";\n\n        Key key = keystore.getKey(alias, \"2015mcs070\".toCharArray());\n        if (key instanceof PrivateKey) {\n            // Get certificate of public key\n            Certificate cert = keystore.getCertificate(alias);\n\n            // Get public key\n            publicKey = cert.getPublicKey();\n\n            // Return a key pair\n\n        }\n        return new KeyPair(publicKey, (PrivateKey) key);\n    }\n\n    public static PublicKey getPublicKey() throws Exception {\n        FileInputStream is = new FileInputStream(\"C:\" + File.separator\n                + \"Users\" + File.separator + \"rsatkunam\" + File.separator\n                + \"Documents\" + File.separator + \"Rajeenthini\" + File.separator\n                + \"MCS\" + File.separator + \"keystore.jks\");\n\n        KeyStore keystore = KeyStore.getInstance(KeyStore.getDefaultType());\n        keystore.load(is, \"password\".toCharArray());\n        PublicKey publicKey = null;\n        String alias = \"rajeenthini\";\n\n        Key key = keystore.getKey(alias, \"password\".toCharArray());\n        // Get certificate of public key\n        Certificate cert = keystore.getCertificate(alias);\n        // Get public key\n        publicKey = cert.getPublicKey();\n        return publicKey;\n    }\n\n    public static String getSha1(String input) throws NoSuchAlgorithmException {\n        MessageDigest mDigest = MessageDigest.getInstance(\"SHA1\");\n        byte[] result = mDigest.digest(input.getBytes());\n        StringBuffer sb = new StringBuffer();\n        for (int i = 0; i < result.length; i++) {\n            sb.append(Integer.toString((result[i] & 0xff) + 0x100, 16).substring(1));\n        }\n\n        return sb.toString();\n    }\n\n    public static byte[] fromHexString(String s) {\n        int len = s.length();\n        byte[] data = new byte[len / 2];\n        for (int i = 0; i < len; i += 2) {\n            data[i / 2] = (byte) ((Character.digit(s.charAt(i), 16) << 4)\n                                 + Character.digit(s.charAt(i+1), 16));\n        }\n        return data;\n    }\n    public static boolean verifyDualByMerchant(String ds, String oi, String hpi, PublicKey pubKey) throws NoSuchAlgorithmException{\n        boolean isVerified = false;\n        // String hOI = hash(oi);\n        // String hoihpi = hoi + hpi;\n\n        // String originalHash = decrypt(ds, pubKey);\n\n        // if (hoihpi.equals(originalHash)) {\n        //  isVerified = true;\n        // }\n        System.out.println(ds.length());\n\n        byte[] ostr = decrypt(ds.getBytes(), pubKey);\n        System.out.println(new String(ostr).toString());\n\n        String xtr = new String(ostr);\n        System.out.println(xtr);\n\n        String x = getSha1(oi);\n        String cx = x + hpi;\n\n        String cxx = getSha1(cx);\n        System.out.println(cxx);\n\n\n        return isVerified;\n    }\n    public static void main(String args[]) {\n        String OI = \"One Laptop Computer\";\n        String PI = \"4465-5342-2344-1009\";\n\n        try {\n            /*System.out.println(\"---------1\"+getPrivateKey().getPrivate());\n            byte[] cipherTxt = encrypt(OI, getPrivateKey().getPrivate());\n            System.out.println(\"---------2\"+cipherTxt.toString());\n\n            System.out.println(\"---------3\"+getPublicKey());\n            byte[] plainTxt = decrypt(cipherTxt, getPublicKey());\n            String s = new String(plainTxt);\n            System.out.println(\"---------4\"+s);*/\n\n            String hashOI = getSha1(OI);\n            System.out.println(\"---------\"+hashOI);\n\n            String hashPI = getSha1(PI);\n            System.out.println(\"---------\"+hashPI);\n\n\n            String concatOIPI = hashOI + hashPI;\n            System.out.println(\"---------\"+concatOIPI);\n\n            String hashconcatOIPI = getSha1(concatOIPI);\n            System.out.println(\"---------\"+hashconcatOIPI);\n\n\n            byte[] dualSignature = encrypt(hashconcatOIPI, getPrivateKey().getPrivate());\n            String s = new String(dualSignature);   \n\n            PublicKey pubKey = getPublicKey();\n            verifyDualByMerchant(s, OI, hashPI, pubKey);\n\n        } catch (Exception e) {\n            // TODO Auto-generated catch block\n            e.printStackTrace();\n        }\n\n    }\n\n}\n", "idx": 2479}
{"project": "cipher", "commit_id": "Snippet24569286_6934.java", "target": 0, "func": "byte data[] = new byte[1024];\n\n            String seed = \"password\";\n\n            byte[] rawKey = getRawKey(seed.getBytes());\n            SecretKeySpec skeySpec = new SecretKeySpec(rawKey, \"AES\");\n            Cipher cipher = Cipher.getInstance(\"AES\");\n            cipher.init(Cipher.ENCRYPT_MODE, skeySpec);\n\n            output = new CipherOutputStream(output, cipher);\n\n\n            long total = 0;\n\n            while ((count = input.read(data)) != -1) {\n                total += count;\n                publishProgress(\"\" + (int) ((total * 100) / lenghtOfFile));\n\n\n                output.write(data, 0, count);\n\n            }\n", "idx": 1954}
{"project": "cipher", "commit_id": "Snippet20053311_2697.java", "target": 0, "func": "private static String seed;\n\n/**\n * Encrypts the text. \n * @param clearText The text you want to encrypt\n * @return Encrypted data if successful, or null if unsucessful\n */\nprotected String encrypt(String clearText) {\n    byte[] encryptedText = null;\n    try {\n        byte[] keyData = seed.getBytes();\n        SecretKey ks = new SecretKeySpec(keyData, \"AES\");\n        Cipher c = Cipher.getInstance(\"AES\");\n        c.init(Cipher.ENCRYPT_MODE, ks);\n        encryptedText = c.doFinal(clearText.getBytes(\"UTF-8\"));\n        return Base64.encodeToString(encryptedText, Base64.DEFAULT);\n    } catch (Exception e) {\n        return null;\n    }\n}\n\n/**\n * Decrypts the text\n * @param encryptedText The text you want to encrypt\n * @return Decrypted data if successful, or null if unsucessful\n */\nprotected String decrypt (String encryptedText) {\n    byte[] clearText = null;\n    try {\n        byte[] keyData = seed.getBytes();\n        SecretKey ks = new SecretKeySpec(keyData, \"AES\");\n        Cipher c = Cipher.getInstance(\"AES\");\n        c.init(Cipher.DECRYPT_MODE, ks);\n        clearText = c.doFinal(Base64.decode(encryptedText, Base64.DEFAULT));\n        return new String(clearText, \"UTF-8\");\n    } catch (Exception e) {\n        return null;\n    }\n}   \n", "idx": 2051}
{"project": "cipher", "commit_id": "Snippet18106542_1138.java", "target": 0, "func": "public void login() {\n        LoginData loginData = this.fragmentBox.getUpdatedLoginData();\n\n        String finishString = new String();\n        try {\n            Cipher cipher = Cipher.getInstance(\"AES\");\n            byte[] output = null;\n\n            SecretKeySpec secretKey = new SecretKeySpec(\n                    Globals.ENCRYPTPW.getBytes(), \"AES\");\n\n            System.out.println(secretKey.getEncoded().toString() +  \"----\" + Globals.ENCRYPTPW);\n            cipher.init(Cipher.ENCRYPT_MODE, secretKey);\n\n            output = cipher.doFinal(loginData.getPassword().getBytes());\n\n            byte[] encryptedUsernameString = Base64.encode(output, 0);\n            finishString = new String(encryptedUsernameString, \"UTF-8\");\n\n        } catch (InvalidKeyException e) {\n            e.getStackTrace();\n            Log.v(\"Fehler im Code\",\"\");\n        } catch(Exception e){}\n\n\n        System.out.println(\"Code: \" + finishString);\n}\n", "idx": 1978}
{"project": "cipher", "commit_id": "Snippet12775575_36442.java", "target": 0, "func": "import java.security.*;\nimport java.security.spec.InvalidKeySpecException;\nimport javax.crypto.*;\nimport javax.crypto.spec.SecretKeySpec;\n\n\nimport sun.misc.*;\n\npublic class AESencrp {\nprivate static final String ALGO = \"AES\";\nprivate static final byte[] keyValue = \n    new byte[] { 'T', 'h', 'e', 'B', 'e', 's', 't','S', 'e', 'c', 'r','e', 't', 'K', 'e', 'y' };\n\npublic static String encrypt(String Data) throws Exception {\n    Key key = generateKey();\n    Cipher c = Cipher.getInstance(ALGO);\n    c.init(Cipher.ENCRYPT_MODE, key);\n    byte[] encVal = c.doFinal(Data.getBytes());\n    String encryptedValue = new BASE64Encoder().encode(encVal);\n    return encryptedValue;\n}\n\npublic static String decrypt(String encryptedData) throws Exception {\n    Key key = generateKey();\n    Cipher c = Cipher.getInstance(ALGO);\n    c.init(Cipher.DECRYPT_MODE, key);\n    byte[] decordedValue = new BASE64Decoder().decodeBuffer(encryptedData);\n    byte[] decValue = c.doFinal(decordedValue);\n    String decryptedValue = new String(decValue);\n    return decryptedValue;\n}\n\nprivate static Key generateKey() throws Exception {\n    Key key = new SecretKeySpec(keyValue, ALGO);\n    return key;\n}\n\n\n\n}\n", "idx": 1964}
{"project": "cipher", "commit_id": "Snippet30035313_12113.java", "target": 0, "func": "    private static String key = \"my8bcode\"; /*Key 8 bytes or 56 bit supported by algo OF*/\n    private static byte[] byteKey = key.getBytes(); \n\n    public static void main(String[] args) throws Exception {\n          String ss = \"yuyuvdzdsfdsfsdsdsdsdsa\";\n          byte[] plainText = ss.getBytes();//Conversion en byte\n\n        try {\n            SecretKeySpec secretKeySpec = new SecretKeySpec(byteKey, \"DES\");\n\n            Cipher cipher = Cipher.getInstance(\"DES/ECB/PKCS5Padding\"); // Request the use of the DES algorithm, using the ECB mode (Electronic CodeBook) and style padding PKCS-5.\n            cipher.init(Cipher.ENCRYPT_MODE, secretKeySpec);\n            byte[] myCipherText = cipher.doFinal(plainText);\n            System.out.println(new String(myCipherText, \"UTF8\"));\n            System.out.println(myCipherText.length);\n\n             System.out.println(\"\\nStart decryption\");\n             cipher.init(Cipher.DECRYPT_MODE, secretKeySpec);\n             byte[] newPlainText = cipher.doFinal(myCipherText);\n             System.out.println(new String(newPlainText, \"UTF8\"));\n        } catch (Exception e) {\n            e.printStackTrace();\n        }\n", "idx": 2130}
{"project": "cipher", "commit_id": "Snippet29688911_11752.java", "target": 0, "func": "byte[] key = (\"Sh\").getBytes(\"UTF-8\");\nMessageDigest sha = MessageDigest.getInstance(\"SHA-1\");\nkey = sha.digest(key);\nkey = Arrays.copyOf(key, 16);\n\nsecretKeySpec = new SecretKeySpec(key, \"AES\");\ncipher = Cipher.getInstance(\"AES\");\n\npublic void dec (String dir)\n{       \n    try{            \n        cipher.init(Cipher.DECRYPT_MODE, secretKeySpec);            \n        String cleartextFile = dir;         \n        FileInputStream fis = new FileInputStream(cleartextFile);                   \n        CipherInputStream cis = new CipherInputStream(fis, cipher);\n        FileOutputStream fos = new FileOutputStream(dir);\n\n        block = new byte[6];\n        while ((i = cis.read(block)) != -1) {\n            fos.write(block, 0, i);\n        }\n        fos.close();        \n    }\n    catch(Exception ex)\n    {\n        Toast.makeText(MainActivity.this, \"Chiper Error\"+ex, Toast.LENGTH_LONG).show();\n    }\n}\n", "idx": 1987}
{"project": "cipher", "commit_id": "Snippet14840165_37946.java", "target": 0, "func": "var = Cipher.getInstance(\"AES\");\n", "idx": 2007}
{"project": "cipher", "commit_id": "Snippet33187543_15258.java", "target": 0, "func": "// To encrypt\nprivate static byte[] encrypt(byte[] raw, byte[] clear) throws Exception {\n    SecretKeySpec skeySpec = new SecretKeySpec(raw, encryptAlgorithm);\n    Cipher cipher = Cipher.getInstance(\"AES\");\n    cipher.init(Cipher.ENCRYPT_MODE, skeySpec);\n    return cipher.doFinal(clear);\n}\n\n// To decrypt\nprivate static byte[] decrypt(byte[] raw, byte[] encrypted) throws Exception {\n    SecretKeySpec skeySpec = new SecretKeySpec(raw, encryptAlgorithm);\n    Cipher cipher = Cipher.getInstance(\"AES\");\n    cipher.init(Cipher.DECRYPT_MODE, skeySpec);\n    return cipher.doFinal(encrypted);\n}\n\npublic static byte[] toByteArray(double value) {\n    byte[] bytes = new byte[8];\n    ByteBuffer.wrap(bytes).putDouble(value);\n    return bytes;\n}\n\npublic static byte[] toByteArray(double[] doubleArray){\n    int times = Double.SIZE / Byte.SIZE;\n    byte[] bytes = new byte[doubleArray.length * times];\n    for(int i=0;i<doubleArray.length;i++){\n        ByteBuffer.wrap(bytes, i*times, times).putDouble(doubleArray[i]);\n    }\n    return bytes;\n}\n\npublic static double[] toDouble(byte[] bytes) {\n    ByteBuffer bb = ByteBuffer.wrap(bytes);\n    DoubleBuffer db = bb.asDoubleBuffer();\n    double[] copy = new double[db.capacity()];\n    db.get(copy);\n    return copy;\n}\n\npublic static Bitmap applyEncryption(Bitmap image, int blockSize) throws Exception {\n    int xPos = 0, yPos = 0, a = 0, b = 0;\n\n    int _w = image.getWidth();\n    int _h = image.getHeight();\n\n    int reconstImage[][] = new int[_w][_h];\n    double dctArrayGray[][] = new double[8][8];\n\n    // It will convert image bitmap pixels to 2-D arrays\n    int[][] imageData = bitmapToArray(image);\n\n    for (int i = 0; i< (_w / blockSize); i++) {\n        xPos = i * blockSize;\n        for (int j = 0; j < (_h / blockSize); j++) {\n            yPos = j * blockSize;\n\n            for (a = 0; a < blockSize; a++) {\n                for (b = 0; b < blockSize; b++) {\n                    dctArrayGray[a][b] = (double) Color.red(imageData[xPos + a][yPos + b]);\n                }\n            }\n\n            DoubleDCT_2D dct = new DoubleDCT_2D(blockSize, blockSize);\n            dct.forward(dctArrayGray, true);\n\n\n\n            // Perform Encryption here....\n            byte[] chiperBytes = encrypt(\"ThisIsASecretKey\".getBytes(), toByteArray(dctArrayGray[0][0]));\n\n            // This is the problem\n            // it will overflow the minimum/maximum DCT values, since there are max/min\n            //     when performing DCT\n\n            // 1. Save the first array in coordinate (0,0)\n            dctArrayGray[0][0] = toDouble(chiperBytes)[0];\n\n            // 2. save the second array in coordinate (7,7)\n            dctArrayGray[7][7] = toDouble(chiperBytes)[1];\n\n            // This is the problem I think, it may have \"bits lost\", after I perform `Color.rgba()` on each block to get pixel values, after below looping. \n            // If I perform `dct.reverse` again, I will not get the same value as the `chiperBytes`\n            // since it will also be decrypted (see the decryption function below this function).\n            dct.inverse(dctArrayGray, true);\n\n            for (a = 0; a < blockSize; a++) {\n                for (b = 0; b < blockSize; b++) {\n                    int red = (int) Math.round(dctArrayGray[a][b]);\n                    reconstImage[xPos+a][yPos + b] = Color.argb(0xFF, red, red, red);\n                }\n            }\n        }\n    }\n\n    // It will convert back the 2-D array to Bitmap image\n    return arrayToBitmap(reconstImage);\n }\n\n\n // Decryption\npublic static Bitmap applyDecryption(Bitmap decryptedImage, int blockSize) throws Exception {\n    int xPos = 0, yPos = 0, a = 0, b = 0;\n\n    int _w = decryptedImage.getWidth();\n    int _h = decryptedImage.getHeight();\n\n    int reconstImage[][] = new int[_w][_h];\n    double dctArrayGray[][] = new double[8][8];\n\n    // It will convert image bitmap pixels to 2-D arrays\n    int[][] imageData = bitmapToArray(decryptedImage);\n\n    for (int i = 0; i< (_w / blockSize); i++) {\n        xPos = i * blockSize;\n        for (int j = 0; j < (_h / blockSize); j++) {\n            yPos = j * blockSize;\n\n            for (a = 0; a < blockSize; a++) {\n                for (b = 0; b < blockSize; b++) {\n                    dctArrayGray[a][b] = (double) Color.red(imageData[xPos + a][yPos + b]);\n                }\n            }\n\n            DoubleDCT_2D dct = new DoubleDCT_2D(blockSize, blockSize);\n            dct.forward(dctArrayGray, true);\n\n\n            // Perform Decryption here....\n\n            // Get back the double values\n            double[] encryptedDoubleValues = new double[2];\n            encryptedDoubleValues[0] = dctArrayGray[0][0];\n            encryptedDoubleValues[1] = dctArrayGray[7][7];\n\n            // I got chiper block not completed EXCEPTION since I got bits lost during saving the encryption\n            // block to image and after converting to RGBA from IDCT (Inverse DCT)\n            byte[] chiperBytes = decrypt(\"ThisIsASecretKey\".getBytes(), toByteArray(encryptedDoubleValues));\n\n            // 1. Save the first array in coordinate (0,0)\n            // This line below suppose to bring back the original value / almost the same with original\n            dctArrayGray[0][0] = toDouble2(chiperBytes);\n\n            // 2. save the second array in coordinate (7,7) and set it to zero\n            // (since AC values are expected to be loss and not necessary needed)\n            dctArrayGray[7][7] = 0;\n\n\n            dct.inverse(dctArrayGray, true);\n\n            for (a = 0; a < blockSize; a++) {\n                for (b = 0; b < blockSize; b++) {\n                    int red = (int) Math.round(dctArrayGray[a][b]);\n                    reconstImage[xPos+a][yPos + b] = Color.argb(0xFF, red, red, red);\n                }\n            }\n        }\n    }\n\n    // It will convert back the 2-D array to Bitmap image\n    return arrayToBitmap(reconstImage);\n}\n", "idx": 2115}
{"project": "cipher", "commit_id": "Snippet10421219_34788.java", "target": 1, "func": "Cipher cipher = Cipher.getInstance(\"RSA\");\nString mod = pbkey.getMod();\nString exp = pbkey.getExp();\n", "idx": 2752}
{"project": "cipher", "commit_id": "Snippet12578244_36353.java", "target": 0, "func": "public class SqlCipherUtil {\n\n    private Cipher ecipher;\n    private Cipher dcipher;\n\n    public String encryptString(String pStrPlainText) {\n\n        try {\n            generateKey();\n            byte[] utf8 = pStrPlainText.getBytes(\"UTF8\");\n            byte[] enc = this.ecipher.doFinal(utf8);\n            return new BASE64Encoder().encode(enc);\n\n        } catch (Exception e) {\n            e.printStackTrace();\n        } \n\n        return null;\n    }\n\n    public String decryptString(String pStrCipherText){\n\n        try {\n            generateKey();\n            byte[] dec = new BASE64Decoder().decodeBuffer(pStrCipherText);\n            byte[] utf8 = this.dcipher.doFinal(dec);\n            return new String(utf8, \"UTF8\");\n\n        } catch (Exception e) {\n            e.printStackTrace();\n        }\n\n        return null;\n    }\n\n    /**\n     * This method is used to generate the encrypted key.\n     */\n    private void generateKey() {\n\n        try {\n            byte[] decodedStr = new BASE64Decoder().decodeBuffer(\"rA/LUdBA/hA=\");\n            SecretKey key = new SecretKeySpec(decodedStr, \"DES\");\n            this.ecipher = Cipher.getInstance(\"DES\");\n            this.dcipher = Cipher.getInstance(\"DES\");\n            this.ecipher.init(1, key);\n            this.dcipher.init(2, key);\n\n        } catch (Exception e) {\n            e.printStackTrace();\n        } \n    }\n}\n", "idx": 2041}
{"project": "cipher", "commit_id": "Snippet3862800_30911.java", "target": 1, "func": "private byte[] aesEncryptedInfo(String info) throws UnsupportedEncodingException, IllegalBlockSizeException, BadPaddingException, InvalidKeyException, NoSuchAlgorithmException, NoSuchPaddingException, InvalidParameterSpecException, InvalidAlgorithmParameterException, NoSuchProviderException {\n    Security.addProvider(new BouncyCastleProvider());\n    SecretKey secret = new SecretKeySpec(CUSTOMLONGSECRETKEY.substring(0, 32).getBytes(), \"AES\");\n    Cipher cipher = Cipher.getInstance(\"AES/CBC/PKCS7Padding\", \"BC\");\n    cipher.init(Cipher.ENCRYPT_MODE, secret, new IvParameterSpec(VECTOR_SECRET_KEY.getBytes()));\n    return cipher.doFinal(info.getBytes(\"UTF-8\"));\n}\n", "idx": 2362}
{"project": "cipher", "commit_id": "Snippet42708450_24747.java", "target": 0, "func": "    private static byte[] seedValue = {\n        0x2d, 0x2a, 0x2d, 0x42, 0x55, 0x49, 0x4c, 0x44, 0x41, 0x43, 0x4f, 0x44, 0x45, 0x2d, 0x2a, 0x2d\n};\nprivate static String ALGORITHM = \"AES\";\nprivate static SecretKeySpec secretKey = new SecretKeySpec(seedValue, \"AES\");\n\n\npublic static String encrypt( String data ) throws Exception {\n    try {\n        Cipher cipher = Cipher.getInstance(\"AES\");\n        cipher.init(Cipher.ENCRYPT_MODE, secretKey);\n        byte[] cipherText = cipher.doFinal(data.getBytes(\"UTF8\"));\n        String encryptedString = new String(Base64.encode(cipherText ,Base64.DEFAULT ) );\n        return encryptedString;\n    } catch (Exception e) {\n        e.printStackTrace();\n    }\n    return null;\n}\n\npublic static String decrypt(String data) throws Exception {\n    try {\n        Cipher cipher = Cipher.getInstance(\"AES\");\n        cipher.init(Cipher.DECRYPT_MODE, secretKey);\n        byte[] cipherText = Base64.decode(data.getBytes(\"UTF8\"), Base64.DEFAULT);\n        String decryptedString = new String(cipher.doFinal(cipherText),\"UTF-8\");\n        return decryptedString;\n    } catch (Exception e) {\n        e.printStackTrace();\n    }\n    return null;\n}\n", "idx": 1985}
{"project": "cipher", "commit_id": "Snippet21931925_4342.java", "target": 0, "func": "/**\n * \n * @param password\n * @return\n * @throws AuthException \n * @throws UnsupportedEncodingException \n */\npublic static String encryptPassword(String password) throws AuthException, UnsupportedEncodingException{\n    byte[] textEncrypted = \"\".getBytes();\n    try{\n\n        DESKeySpec keySpec = new DESKeySpec(Constants.DESkey);\n        SecretKeyFactory keyFactory = SecretKeyFactory.getInstance(\"DES\");\n        SecretKey myDesKey = keyFactory.generateSecret(keySpec);\n\n        Cipher desCipher;\n\n        // Create the cipher \n        desCipher = Cipher.getInstance(\"DES/CBC/PKCS5Padding\");\n\n        AlgorithmParameterSpec alogrithm_specs = new IvParameterSpec(Constants.DESkey);\n\n        // Initialize the cipher for encryption\n        desCipher.init(Cipher.ENCRYPT_MODE, myDesKey, alogrithm_specs);\n\n        //sensitive information\n        byte[] text = password.getBytes(\"UTF-8\");\n\n        // Encrypt the text\n        textEncrypted = desCipher.doFinal(text);\n\n    }catch(NoSuchAlgorithmException e){\n        e.printStackTrace();\n        logger.error(\"[AUTH] Auth Exception...there is something wrong at the encryption phase\\n\" + e.getMessage());\n        throw new AuthException(\"Auth Exception...there is something wrong at the encryption phase\");\n    }catch(NoSuchPaddingException e){\n        e.printStackTrace();\n        logger.error(\"[AUTH] Auth Exception...there is something wrong at the encryption phase\\n\" + e.getMessage());\n        throw new AuthException(\"Auth Exception...there is something wrong at the encryption phase\");\n    }catch(InvalidKeyException e){\n        e.printStackTrace();\n        logger.error(\"[AUTH] Auth Exception...there is something wrong at the encryption phase\\n\" + e.getMessage());\n        throw new AuthException(\"Auth Exception...there is something wrong at the encryption phase\");\n    }catch(IllegalBlockSizeException e){\n        e.printStackTrace();\n        logger.error(\"[AUTH] Auth Exception...there is something wrong at the encryption phase\\n\" + e.getMessage());\n        throw new AuthException(\"Auth Exception...there is something wrong at the encryption phase\");\n    }catch(BadPaddingException e){\n        e.printStackTrace();\n        logger.error(\"[AUTH] Auth Exception...there is something wrong at the encryption phase\\n\" + e.getMessage());\n        throw new AuthException(\"Auth Exception...there is something wrong at the encryption phase\");\n    } catch (InvalidKeySpecException e) {\n        e.printStackTrace();\n        logger.error(\"[AUTH] Auth Exception...there is something wrong at the encryption phase\\n\" + e.getMessage());\n        throw new AuthException(\"Auth Exception...there is something wrong at the encryption phase\");\n    } catch (InvalidAlgorithmParameterException e) {\n        e.printStackTrace();\n        logger.error(\"[AUTH] Auth Exception...there is something wrong at the encryption phase\\n\" + e.getMessage());\n        throw new AuthException(\"Auth Exception...there is something wrong at the encryption phase\");\n    } \n\n    return BaseEncoding.base64().encode(textEncrypted);\n\n}   \n\n/**\n * \n * @param passwordDecrypted\n * @return\n * @throws AuthException \n * @throws UnsupportedEncodingException \n */\n\npublic static String decryptPassword(String passwordToDecrypt) throws AuthException, UnsupportedEncodingException{\n\n    DESKeySpec keySpec;\n    byte[] textDecrypted = \"\".getBytes();\n    try {\n        keySpec = new DESKeySpec(Constants.DESkey);\n\n        SecretKeyFactory keyFactory = SecretKeyFactory.getInstance(\"DES\");\n        SecretKey myDesKey = keyFactory.generateSecret(keySpec);\n\n        Cipher desCipher;\n\n        AlgorithmParameterSpec alogrithm_specs = new IvParameterSpec(Constants.DESkey);\n\n        // Create the cipher \n        //desCipher = Cipher.getInstance(\"DES/ECB/PKCS5Padding\");\n        desCipher = Cipher.getInstance(\"DES/CBC/PKCS5Padding\");\n\n        // Initialize the same cipher for decryption\n        desCipher.init(Cipher.DECRYPT_MODE, myDesKey, alogrithm_specs);\n\n        // Decrypt the text\n        byte[] passwordToDecryptByte = BaseEncoding.base64().decode(passwordToDecrypt);\n\n       textDecrypted = desCipher.doFinal(passwordToDecryptByte);\n\n    } catch (InvalidKeyException e) {\n        e.printStackTrace();\n        logger.error(\"[AUTH] Auth Exception...there is something wrong at the encryption phase\\n\" + e.getMessage());\n        throw new AuthException(\"Auth Exception...there is something wrong at the decryption phase\");\n    } catch (NoSuchAlgorithmException e) {\n        e.printStackTrace();\n        logger.error(\"[AUTH] Auth Exception...there is something wrong at the encryption phase\\n\" + e.getMessage());\n        throw new AuthException(\"Auth Exception...there is something wrong at the decryption phase\");\n    } catch (InvalidKeySpecException e) {\n        e.printStackTrace();\n        logger.error(\"[AUTH] Auth Exception...there is something wrong at the encryption phase\\n\" + e.getMessage());\n        throw new AuthException(\"Auth Exception...there is something wrong at the decryption phase\");\n    } catch (NoSuchPaddingException e) {\n        e.printStackTrace();\n        logger.error(\"[AUTH] Auth Exception...there is something wrong at the encryption phase\\n\" + e.getMessage());\n        throw new AuthException(\"Auth Exception...there is something wrong at the decryption phase\");\n    } catch (IllegalBlockSizeException e) {\n        e.printStackTrace();\n        logger.error(\"[AUTH] Auth Exception...there is something wrong at the encryption phase\\n\" + e.getMessage());\n        throw new AuthException(\"Auth Exception...there is something wrong at the decryption phase\");\n    } catch (BadPaddingException e) {\n        e.printStackTrace();\n        logger.error(\"Auth Exception...there is something wrong at the encryption phase\\n\" + e.getMessage());\n        throw new AuthException(\"Auth Exception...there is something wrong at the decryption phase\");\n    } catch (InvalidAlgorithmParameterException e) {\n        e.printStackTrace();\n        logger.error(\"[AUTH] Auth Exception...there is something wrong at the encryption phase\\n\" + e.getMessage());\n        throw new AuthException(\"Auth Exception...there is something wrong at the decryption phase\");\n    }\n\n    return new String(textDecrypted);\n\n\n}\n\n\npublic static void main(String[] args) throws AuthException, UnsupportedEncodingException{\n    String password = encryptPassword(\"testtest19\");\n\n    System.out.println(password + \" --> \" + \"\\\"\" + decryptPassword(password)+ \"\\\"\");\n\n}\n", "idx": 2234}
{"project": "cipher", "commit_id": "Snippet21039407_3621.java", "target": 0, "func": "public String encryptPadding(String plaintext, byte[] salt) {\n    try {\n        Cipher cipher = Cipher.getInstance(\"DES/CBC/PKCS5Padding\");\n\n        cipher.init(Cipher.ENCRYPT_MODE, SKey);\n\n        byte[] cipherText = cipher.doFinal(PlainText.getBytes(\"UTF-8\"));\n\n        cyphertext = String.format(\"%s%s%s\", toBase64(salt), \"]\",\n                toBase64(cipherText));\n        edit_txt_enc_string.setText(cyphertext);\n        return cyphertext;\n    } catch (GeneralSecurityException e) {\n        throw new RuntimeException(e);\n    } catch (UnsupportedEncodingException e) {\n        throw new RuntimeException(e);\n    }\n}\n\npublic String decryptPadding(String ctext, byte[] salt) {\n    try {\n        Cipher cipher = Cipher.getInstance(\"DES/CBC/PKCS5Padding\");\n\n        IvParameterSpec ivSpec = new IvParameterSpec(ivBytes);\n        cipher.init(Cipher.DECRYPT_MODE, SKey, ivSpec);\n\n        byte[] plaintxt = cipher.doFinal(cyphertext.getBytes(\"UTF-8\"));\n\n        PlainText = String.format(\"%s%s%s\", fromBase64(salt), \"]\",\n                fromBase64(plaintxt));\n        edit_txt_dec_string.setText(PlainText);\n        return PlainText;\n    } catch (GeneralSecurityException e) {\n        throw new RuntimeException(e);\n    } catch (UnsupportedEncodingException e) {\n        throw new RuntimeException(e);\n    }\n}\n", "idx": 2200}
{"project": "cipher", "commit_id": "Snippet13771186_37256.java", "target": 0, "func": "ks = new SecretKeySpec(key, \"AES\");\nciph = Cipher.getInstance(\"AES\");\n", "idx": 2197}
{"project": "cipher", "commit_id": "Snippet19596002_2329.java", "target": 1, "func": "private static byte[] translate(byte[] val, int mode) throws Exception {\n    if (mode != Cipher.ENCRYPT_MODE && mode != Cipher.DECRYPT_MODE)\n        throw new IllegalArgumentException(\n                \"Encryption invalid. Mode should be either Cipher.ENCRYPT_MODE or Cipher.DECRYPT_MODE\");\n    SecretKeySpec skeySpec = new SecretKeySpec(getRawKey(), \"AES\");\n    Cipher cipher = Cipher.getInstance(\"AES/CBC/PKCS5Padding\");\n    IvParameterSpec ivSpec = new IvParameterSpec(generateIv());\n    cipher.init(mode, skeySpec, ivSpec);\n    byte[] encrypted = cipher.doFinal(val);\n    return encrypted;\n}\n", "idx": 2370}
{"project": "cipher", "commit_id": "Snippet39232799_21117.java", "target": 1, "func": "   public byte[] encrypt(byte[] skey, byte[] data){\n      SecretKeySpec skeySpec = new SecretKeySpec(skey, \"AES\");\n      Cipher cipher;\n      byte[] encrypted=null;\n        try {\n            // Get Cipher instance for AES algorithm\n            cipher = Cipher.getInstance(\"AES/CBC/PKCS5Padding\");    \n            // Initialize cipher\n            cipher.init(Cipher.ENCRYPT_MODE, skeySpec);\n            // Encrypt the image byte data\n            encrypted = cipher.doFinal(data);\n        }catch(Exception e){\n            e.printStackTrace();\n        }   \n      return encrypted;\n   }\n", "idx": 2747}
{"project": "cipher", "commit_id": "Snippet12350865_36239.java", "target": 0, "func": "    private static final String ALGORITHM = \"AES\";\n    ....\n    ....\n    Key key = new SecretKeySpec(new String(\"here is your symmetric key\").getBytes(), ALGORITHM);\n    Cipher c = Cipher.getInstance(ALGORITHM);\n    //dencript mode (passes the key)\n    c.init(Cipher.DECRYPT_MODE, key);\n    //Decode base64 to get bytes \n    byte[] encBytes  = new BASE64Decoder().decodeBuffer(encryptedValue);\n    // Decrypt \n    byte[] plainTxtBytes  = c.doFinal(encBytes);\n    // Decode\n    String decryptedValue = new String(plainTxtBytes , \"UTF-8\");\n", "idx": 1992}
{"project": "cipher", "commit_id": "Snippet26180405_8400.java", "target": 1, "func": "public java.security.PrivateKey m_privateKey;\n\npublic byte[] Decrypt(byte[] input)\n{\n    Cipher cipher;\n    byte[] cipherData = null;\n    cipher = Cipher.getInstance(\"RSA\");\n    cipher.init(Cipher.DECRYPT_MODE, m_privateKey);\n    cipherData = cipher.doFinal(input);\n    return cipherData;\n}\n", "idx": 2612}
{"project": "cipher", "commit_id": "Snippet46973733_28964.java", "target": 0, "func": "btn1.setOnClickListener(new View.OnClickListener() {\n            @Override\n            public void onClick(View view) {\n                String plainTextPassword=editText1.getText().toString();\n                String encrypted = \"\";\n                try{\n                    DESKeySpec keySpec = new DESKeySpec(\"qwertykey\".getBytes());\n                    SecretKeyFactory keyFactory = SecretKeyFactory.getInstance(\"DES\");\n                    SecretKey key = keyFactory.generateSecret(keySpec);\n                    byte[] cleartext = plainTextPassword.getBytes();\n\n                    Cipher cipher = Cipher.getInstance(\"DES/CBC/ZeroBytePadding\", \"BC\");; // cipher is not thread safe\n                    cipher.init(Cipher.ENCRYPT_MODE, key);\n                    encrypted = Base64.encodeToString(cipher.doFinal(cleartext),Base64.DEFAULT);\n\n              } catch (NoSuchAlgorithmException e) {\n                    e.printStackTrace();\n                } catch (InvalidKeyException e) {\n                    e.printStackTrace();\n                } catch (NoSuchPaddingException e) {\n                    e.printStackTrace();\n                } catch (BadPaddingException e) {\n                    e.printStackTrace();\n                } catch (InvalidKeySpecException e) {\n                    e.printStackTrace();\n                } catch (IllegalBlockSizeException e) {\n                    e.printStackTrace();\n                } catch (NoSuchProviderException e) {\n                    e.printStackTrace();\n                }\n                textView4.setText(encrypted.toString());\n\n            }});\n", "idx": 2133}
{"project": "cipher", "commit_id": "Snippet15437189_38500.java", "target": 0, "func": "try{\n        //To generate the secret key\n        KeyGenerator keyGen = KeyGenerator.getInstance(\"DES\");\n        sKey = keyGen.generateKey();\n        //Initialize the cipher instance to use DES algorithm, ECB mode,\n        //and PKCS#5 padding scheme.\n        cipherObj = Cipher.getInstance(\"DES/ECB/PKCS5Padding\");\n    }\n    catch(NoSuchAlgorithmException nsae){nsae.printStackTrace();\n\n    }\n    catch(NoSuchPaddingException nspe){nspe.printStackTrace();}\n", "idx": 2233}
{"project": "cipher", "commit_id": "Snippet30432612_12590.java", "target": 0, "func": "class AES{\n\npublic static String encrypt(String seed, String cleartext) throws Exception {\n        byte[] rawKey = getRawKey(seed.getBytes());\n        byte[] result = encrypt(rawKey, cleartext.getBytes());\n        return toHex(result);\n    }\n\n    public static String decrypt(String seed, String encrypted) throws Exception {\n        byte[] rawKey = getRawKey(seed.getBytes());\n        byte[] enc = toByte(encrypted);\n        byte[] result = decrypt(rawKey, enc);\n        return new String(result);\n    }\n  private static byte[] getRawKey(byte[] seed) throws Exception {\n        KeyGenerator kgen = KeyGenerator.getInstance(\"AES\");\n        SecureRandom sr = SecureRandom.getInstance(\"SHA1PRNG\");\n        sr.setSeed(seed);\n        kgen.init(128, sr); // 192 and 256 bits may not be available\n        SecretKey skey = kgen.generateKey();\n        byte[] raw = skey.getEncoded();\n        return raw;\n    }\n\n\n    private static byte[] encrypt(byte[] raw, byte[] clear) throws Exception {\n        SecretKeySpec skeySpec = new SecretKeySpec(raw, \"AES\");\n        Cipher cipher = Cipher.getInstance(\"AES\");\n        cipher.init(Cipher.ENCRYPT_MODE, skeySpec);\n        byte[] encrypted = cipher.doFinal(clear);\n        return encrypted;\n    }\n\n    private static byte[] decrypt(byte[] raw, byte[] encrypted) throws Exception {\n        SecretKeySpec skeySpec = new SecretKeySpec(raw, \"AES\");\n        Cipher cipher = Cipher.getInstance(\"AES\");\n        cipher.init(Cipher.DECRYPT_MODE, skeySpec);\n\n        byte[] decrypted = cipher.doFinal(encrypted);\n        return decrypted;\n    }\n\n    public static String toHex(String txt) {\n        return toHex(txt.getBytes());\n    }\n    public static String fromHex(String hex) {\n        return new String(toByte(hex));\n    }\n\n    public static byte[] toByte(String hexString) {\n        int len = hexString.length()/2;\n        byte[] result = new byte[len];\n        for (int i = 0; i < len; i++)\n            result[i] = Integer.valueOf(hexString.substring(2*i, 2*i+2), 16).byteValue();\n        return result;\n    }\n\n    public static String toHex(byte[] buf) {\n        if (buf == null)\n            return \"\";\n        StringBuffer result = new StringBuffer(2*buf.length);\n        for (int i = 0; i < buf.length; i++) {\n            appendHex(result, buf[i]);\n        }\n        return result.toString();\n    }\n    private final static String HEX = \"0123456789ABCDEF\";\n    private static void appendHex(StringBuffer sb, byte b) {\n        sb.append(HEX.charAt((b>>4)&0x0f)).append(HEX.charAt(b&0x0f));\n    }\n}\n", "idx": 2151}
{"project": "cipher", "commit_id": "Snippet7302986_32676.java", "target": 0, "func": "public String asHex(byte[] buf) {\n    StringBuffer strbuf = new StringBuffer(buf.length * 2);\n    int i;\n    for (i = 0; i < buf.length; i++) {\n        if (((int) buf[i] & 0xff) < 0x10)\n            strbuf.append(\"0\");\n        strbuf.append(Long.toString((int) buf[i] & 0xff, 16));\n    }\n    return strbuf.toString();\n}\n\nprivate SecretKeySpec skeySpec;\nprivate Cipher cipher;\nprivate byte[] encrypted;\n\npublic String encrypt(String str) throws Exception {\n    // Get the KeyGenerator\n    KeyGenerator kgen = KeyGenerator.getInstance(\"AES\");\n    kgen.init(128); // 192 and 256 bits may not be available\n\n    // Generate the secret key specs.\n    SecretKey skey = kgen.generateKey();\n    byte[] raw = skey.getEncoded();\n    skeySpec = new SecretKeySpec(raw, \"AES\");\n\n    // Instantiate the cipher\n    cipher = Cipher.getInstance(\"AES\");\n\n    cipher.init(Cipher.ENCRYPT_MODE, skeySpec);\n\n    encrypted = cipher.doFinal(str.getBytes());\n    return asHex(encrypted);\n}\n\npublic String decrypt(String str) throws Exception {\n    cipher.init(Cipher.DECRYPT_MODE, skeySpec);\n    byte[] original = cipher.doFinal(encrypted);\n    String originalString = new String(original);\n    return originalString;\n}\n", "idx": 2172}
{"project": "cipher", "commit_id": "Snippet20503465_3111.java", "target": 0, "func": "public class testCipher \n{\n    public static final String PROVIDER = \"SunJCE\";\n    private static final String ALGORITHM = \"AES\";\n    private static final String aesKey = \"some long key\";\n    static Cipher ecipher;\n    static Cipher dcipher;\n\n    public static void main(String[] args)  \n    {\n\n    try {\n\n    byte[] buf1 = aesKey.getBytes(\"UTF-8\");\n    MessageDigest sha = MessageDigest.getInstance(\"SHA-256\");\n    buf1 = sha.digest(buf1);\n    buf1 = Arrays.copyOf(buf1, 16);\n    SecretKeySpec keySpec = null;\n    keySpec = new SecretKeySpec(buf1, \"AES\");\n\n    ecipher = Cipher.getInstance(ALGORITHM, PROVIDER);\n    dcipher = Cipher.getInstance(ALGORITHM, PROVIDER);\n\n    ecipher.init(1, keySpec);\n    dcipher.init(2, keySpec, ecipher.getParameters());\n\n    if (args[0].equals(\"encrypt\"))\n    System.out.println(encrypt(args[1]));\n    else if (args[0].equals(\"decrypt\"))\n    System.out.println(decrypt(args[1]));\n    else {\n    System.out.println(\"USAGE: encrypt/decrypt '<string>'\");\n    System.exit(15);\n   }\n\n} catch (Exception e) {\n    System.exit(5);\n} \n\n}\n\npublic static String encrypt(String str) \n{\n    try {\n\n        byte[] utf8 = str.getBytes(\"UTF8\");\n        byte[] enc = ecipher.doFinal(utf8);\n        return new sun.misc.BASE64Encoder().encode(enc);\n\n    } catch (Exception e) {\n        System.exit(7);\n    }\n\n    return null;\n}\n\npublic static String decrypt(String str) \n{\n    try {\n        // Decode base64 to get bytes\n        byte[] dec = new sun.misc.BASE64Decoder().decodeBuffer(str);\n\n        // Decrypt\n        byte[] utf8 = dcipher.doFinal(dec);\n\n        // Decode using utf-8\n        return new String(utf8, \"UTF8\");\n    } catch (Exception e) {\n        System.exit(7);\n    } \n    return null;\n}\n}\n", "idx": 1983}
{"project": "cipher", "commit_id": "Snippet15806145_38796.java", "target": 0, "func": "Cipher cipher = Cipher.getInstance(\"RSA/None/OAEPWithSHA1AndMGF1Padding\", \"BC\");\ncipher.init(Cipher.ENCRYPT_MODE, mPubKey);\nreturn cipher.doFinal(\"Hello World\".getBytes()); // here is the problem\n", "idx": 2012}
{"project": "cipher", "commit_id": "Snippet45276056_27401.java", "target": 0, "func": "try\n{\n\n    FileInputStream encfis = new FileInputStream(Encrypted_File_Path);\n    FileOutputStream decfos = new FileOutputStream(Decrypted_File_Path);\n\n    Cipher decipher = Cipher.getInstance(\"AES\");\n\n    String encode =\"8888888888888888\";\n    byte[] decodedKey = encode.getBytes();\n    SecretKey originalKey = new SecretKeySpec(decodedKey, 0, decodedKey.length, \"AES\");\n\n    decipher.init(Cipher.DECRYPT_MODE, originalKey);\n    CipherOutputStream cos = new CipherOutputStream(decfos,decipher);\n\n    int c;\n    byte[] d1 = new byte[4096 * 2048];\n    while((c = encfis.read(d1)) != -1)\n    {\n        cos.write(d1, 0, c);\n        cos.flush();\n    }\n    cos.close();\n}\ncatch(Exception e)\n{\n    e.printStackTrace();\n}\n", "idx": 1970}
{"project": "cipher", "commit_id": "Snippet23294482_5646.java", "target": 1, "func": "public class Cryption {\nprivate static int KEYLEN_BITS = 256;\nprivate static int ITERATIONS = 128;\n\nstatic private  Log log = LogFactory.getLog(Cryption.class);    \n\nprivate static SecretKeyFactory secretKeyFactory = null;\nprivate static  Map<String, SecretKey> secretKeyMap = new HashMap<String, SecretKey>(); \n\nprivate String password = null;\nprivate SecretKey secretKey = null;\nprivate Cipher cipher = null;\n\nprivate synchronized static SecretKeyFactory createSecretKeyFactory() {\n    try {\n        if(secretKeyFactory == null) {                       \n            secretKeyFactory = SecretKeyFactory.getInstance(\"PBKDF2WithHmacSHA1\");          \n        }       \n    } catch(Exception e) { \n        log.error(\"createSecretKeyFactory\", e);\n    }\n    return secretKeyFactory;\n}\n\nprivate static SecretKey createSecretKey(String password, byte []salt) {\n    SecretKey secretKey = secretKeyMap.get(password);\n    if(secretKey == null) {\n        try {\n            KeySpec spec = new PBEKeySpec(password.toCharArray(), salt, ITERATIONS, KEYLEN_BITS);\n            SecretKey tmpSecretKey = createSecretKeyFactory().generateSecret(spec);\n            secretKey = new SecretKeySpec(tmpSecretKey.getEncoded(), \"AES\");\n            secretKeyMap.put(password, secretKey);\n        } catch(Exception e) { \n            log.error(\"getSecretKey\", e);\n        }\n    }\n    return secretKey;\n}\n\nprivate boolean createCipher(String password, byte []salt, byte[] iv, int mode) {\n    try {\n        this.password = password;\n        secretKey = createSecretKey(password, salt);    \n        cipher = Cipher.getInstance(\"AES/CBC/PKCS5Padding\");\n        if(iv != null) {\n            cipher.init(mode, secretKey, new IvParameterSpec(iv));\n        } else {\n            cipher.init(mode, secretKey);               \n        }\n    } catch(Exception e) { \n        log.error(\"getCipher\", e);\n        return false;\n    }\n    return true;\n}\n\npublic String getPassword() {\n    return password;\n}\n\npublic byte[] getCipherIV() {\n    byte [] iv = null;\n\n    try {       \n        AlgorithmParameters params = cipher.getParameters();\n        iv = params.getParameterSpec(IvParameterSpec.class).getIV();\n    } catch(Exception e) {\n        log.error(\"getCipherIV\", e);\n    }\n    return iv;\n}\n\npublic byte[] execute(byte []in) {\n    byte [] out = null;\n\n    try {       \n        out = cipher.doFinal(in); \n    } catch(Exception e) { \n        log.error(\"execute\", e);\n    }\n    return out;\n}\n\nstatic Cryption create(String password, byte[] salt, byte[] iv, int mode) {\n    Cryption cryption = new Cryption();\n\n    cryption.createCipher(password, salt, iv, mode);\n    return cryption;\n}\n\nstatic void init(Cryption cryption, byte[] iv, int mode) {\n    try {       \n        if(iv != null) {\n            cryption.cipher.init(mode, cryption.secretKey, new IvParameterSpec(iv));\n        } else {\n            cryption.cipher.init(mode, cryption.secretKey);             \n        }\n    } catch(Exception e) { \n        log.error(\"init\", e);\n    }\n}   \n}\n", "idx": 2386}
{"project": "cipher", "commit_id": "Snippet34614268_16579.java", "target": 1, "func": "public static String encode(String password, String text)\n        throws NoPassGivenException, NoTextGivenException {\n    /*if (password.length() == 0 || password == null) {\n        throw new NoPassGivenException(\"Please give Password\");\n    }\n\n    if (text.length() == 0 || text == null) {\n        throw new NoTextGivenException(\"Please give text\");\n    }*/\n\n    try {\n        SecretKeySpec skeySpec = getKey(password);\n        byte[] clearText = text.getBytes(\"UTF8\");\n\n        //IMPORTANT TO GET SAME RESULTS ON iOS and ANDROID\n        final byte[] iv = new byte[16];\n        Arrays.fill(iv, (byte) 0x00);\n        IvParameterSpec ivParameterSpec = new IvParameterSpec(iv);\n\n        //System.out.println(iv);\n        // Cipher is not thread safe\n        Cipher cipher = Cipher.getInstance(\"AES/CBC/PKCS5Padding\");\n        cipher.init(Cipher.ENCRYPT_MODE, skeySpec, ivParameterSpec);\n\n        String encrypedValue = new Base64().encodeAsString(\n                cipher.doFinal(clearText));\n\n        //Log.d(TAG, \"Encrypted: \" + text + \" -> \" + encrypedValue);\n        return encrypedValue;\n\n    } catch (InvalidKeyException e) {\n        e.printStackTrace();\n    } catch (UnsupportedEncodingException e) {\n        e.printStackTrace();\n    } catch (NoSuchAlgorithmException e) {\n        e.printStackTrace();\n    } catch (BadPaddingException e) {\n        e.printStackTrace();\n    } catch (NoSuchPaddingException e) {\n        e.printStackTrace();\n    } catch (IllegalBlockSizeException e) {\n        e.printStackTrace();\n    } catch (InvalidAlgorithmParameterException e) {\n        e.printStackTrace();\n    }\n    return \"\";\n}\npublic static String decode(String password, String text)\n        throws NoPassGivenException, NoTextGivenException {\n\n    /*if (password.length() == 0 || password == null) {\n        throw new NoPassGivenException(\"Please give Password\");\n    }\n\n    if (text.length() == 0 || text == null) {\n        throw new NoTextGivenException(\"Please give text\");\n    }*/\n\n    try {\n        SecretKey key = getKey(password);\n\n        //IMPORTANT TO GET SAME RESULTS ON iOS and ANDROID\n        final byte[] iv = new byte[16];\n        Arrays.fill(iv, (byte) 0x00);\n        IvParameterSpec ivParameterSpec = new IvParameterSpec(iv);\n        //System.out.println(iv);\n        byte[] encrypedPwdBytes = new Base64().decodeBase64(text);\n        // cipher is not thread safe\n        Cipher cipher = Cipher.getInstance(\"AES/CBC/PKCS5Padding\");\n        cipher.init(Cipher.DECRYPT_MODE, key, ivParameterSpec);\n        byte[] decrypedValueBytes = (cipher.doFinal(encrypedPwdBytes));\n\n        String decrypedValue = new String(decrypedValueBytes);\n\n       // BigDecimal bd = new BigDecimal(decrypedValue);\n        //Log.d(TAG, \"Decrypted: \" + text + \" -> \" + decrypedValue);\n       // String data =  Long.toString(bd.longValue());\n        return decrypedValue;\n\n    } catch (InvalidKeyException e) {\n        e.printStackTrace();\n    } catch (UnsupportedEncodingException e) {\n        e.printStackTrace();\n    } catch (NoSuchAlgorithmException e) {\n        e.printStackTrace();\n    } catch (BadPaddingException e) {\n        e.printStackTrace();\n    } catch (NoSuchPaddingException e) {\n        e.printStackTrace();\n    } catch (IllegalBlockSizeException e) {\n        e.printStackTrace();\n    } catch (InvalidAlgorithmParameterException e) {\n        e.printStackTrace();\n    }\n    return \"\";\n}\n", "idx": 2532}
{"project": "cipher", "commit_id": "Snippet29623583_11692.java", "target": 1, "func": "import java.io.UnsupportedEncodingException;\nimport java.security.InvalidAlgorithmParameterException;\nimport java.security.InvalidKeyException;\nimport java.security.NoSuchAlgorithmException;\nimport java.security.spec.InvalidKeySpecException;\nimport java.security.spec.KeySpec;\n\nimport javax.crypto.*;\nimport javax.crypto.spec.IvParameterSpec;\nimport javax.crypto.spec.PBEKeySpec;\nimport javax.crypto.spec.SecretKeySpec;\n\n/**\n * @author alvaro\n */\npublic class Encriptor {\n\n    // Constants -----------------------------------------------------\n\n    private static final String PASS_PHRASE = \"12345678901234\";//says wrong length\n    private static final String SALT_VALUE = \"123456\";\n    private static final int PASSWORD_ITERATIONS = 1;\n    private static final String INIT_VECTOR = \"1234567890123456\";\n    private static final int KEY_SIZE = 128;\n\n    // Attributes ----------------------------------------------------\n\n    // Static --------------------------------------------------------\n\n    // Constructors --------------------------------------------------\n\n    // Public --------------------------------------------------------\n\n    public String encrypt(String text) throws NoSuchAlgorithmException, UnsupportedEncodingException, NoSuchPaddingException, InvalidAlgorithmParameterException, InvalidKeyException, BadPaddingException, IllegalBlockSizeException, InvalidKeySpecException {\n        MessageDigest digest = MessageDigest.getInstance(DIGEST);\n        digest.update(SALT_VALUE.getBytes());\n        byte[] bytes = digest.digest(PASS_PHRASE.getBytes(ENCODING));\n        SecretKey password = new SecretKeySpec(bytes, \"AES\");\n\n        //Initialize objects\n        Cipher cipher = Cipher.getInstance(\"AES/CBC/PKCS5Padding\");\n        byte[] IV = INIT_VECTOR.getBytes();\n        IvParameterSpec ivParamSpec = new IvParameterSpec(IV);\n        cipher.init(Cipher.ENCRYPT_MODE, password, ivParamSpec);\n        byte[] encryptedData = cipher.doFinal(text.getBytes(ENCODING));\n        return new BASE64Encoder().encode(encryptedData).replaceAll(\"\\n\", \"\");\n    }\n\n    // Package protected ---------------------------------------------\n\n    // Protected -----------------------------------------------------\n\n    // Private -------------------------------------------------------\n\n    // Inner classes -------------------------------------------------\n\n}\n", "idx": 2731}
{"project": "cipher", "commit_id": "Snippet27334372_9507.java", "target": 0, "func": "public boolean validateClient(String loggedInKey) throws Exception{\n\n    /* Testing */\n    String randString = this.aI.returnString(); // Client requests a string/ server returns\n    System.out.println(\"This is what the server gave me: \"+randString);\n\n    String encryptionKey = loggedInKey;\n    SecretKeySpec key = new SecretKeySpec(encryptionKey.getBytes(\"UTF-8\"), \"AES\");\n\n    Cipher ecipher = Cipher.getInstance(\"AES\");\n    ecipher.init(Cipher.ENCRYPT_MODE, key);\n\n    SealedObject sealedClientReply = new SealedObject(randString, ecipher); // Client encrypts returned string seals it\n    System.out.println(\"This is what I'm sending back: \"+sealedClientReply);\n    if(this.aI.clientValidate(sealedClientReply, loggedInKey)){\n        System.out.println(\"Client validated!\");\n        return true;\n    }else{\n        return false;\n    }       \n}\n", "idx": 2176}
{"project": "cipher", "commit_id": "Snippet16721406_116.java", "target": 1, "func": "Cipher.getInstance(\"AES/CBC/PKCS5Padding\");\n", "idx": 2551}
{"project": "cipher", "commit_id": "Snippet31949281_14021.java", "target": 1, "func": "package nl.maartenbodewes.stackoverflow;\n\nimport java.io.File;\nimport java.io.FileReader;\nimport java.io.FileWriter;\nimport java.io.IOException;\nimport java.nio.file.Files;\nimport java.security.InvalidKeyException;\nimport java.security.Key;\nimport java.security.KeyFactory;\nimport java.security.KeyPair;\nimport java.security.KeyPairGenerator;\nimport java.security.NoSuchAlgorithmException;\nimport java.security.SecureRandom;\nimport java.security.interfaces.RSAPublicKey;\nimport java.security.spec.InvalidKeySpecException;\nimport java.security.spec.KeySpec;\nimport java.security.spec.X509EncodedKeySpec;\nimport java.util.Base64;\n\nimport javax.crypto.Cipher;\nimport javax.crypto.IllegalBlockSizeException;\nimport javax.crypto.KeyGenerator;\nimport javax.crypto.NoSuchPaddingException;\nimport javax.crypto.SecretKey;\n\nimport org.bouncycastle.util.io.pem.PemObject;\nimport org.bouncycastle.util.io.pem.PemReader;\nimport org.bouncycastle.util.io.pem.PemWriter;\n\npublic class GenerateAndWrapHMACKey {\n\n    public static SecretKey generateHMACKey() throws Exception {\n        final KeyGenerator keyGen;\n        try {\n            keyGen = KeyGenerator.getInstance(\"HmacSHA256\");\n        } catch (NoSuchAlgorithmException e) {\n            throw new RuntimeException(\"HMAC KeyGeneration should be available\");\n        }\n        keyGen.init(128);\n        SecretKey key = keyGen.generateKey();\n        return key;\n    }\n\n    public static void writeToFile(SecretKey key, String filename)\n            throws IOException {\n        // file handling probably should be in a separate class\n        Files.write((new File(filename)).toPath(), key.getEncoded());\n    }\n\n    public static RSAPublicKey readRSAPublicKey(String filename) throws IOException, InvalidKeySpecException {\n        try (PemReader reader = new PemReader(new FileReader(filename))) {\n            PemObject pemObject = reader.readPemObject();\n            KeyFactory kf;\n            try {\n                kf = KeyFactory.getInstance(\"RSA\");\n            } catch (NoSuchAlgorithmException e) {\n                throw new RuntimeException(\"RSA key factory not available\", e);\n            }\n            KeySpec keySpec = new X509EncodedKeySpec(pemObject.getContent());\n            try {\n                return (RSAPublicKey) kf.generatePublic(keySpec);\n            } catch (ClassCastException e) {\n                throw new InvalidKeySpecException(\"That's no RSA key\", e);\n            }\n        }\n    }\n\n    public static byte[] wrapKey(Key key, RSAPublicKey wrappingKey) throws InvalidKeyException, IllegalBlockSizeException {\n        Cipher rsaWrapper;\n        try {\n            rsaWrapper = Cipher.getInstance(\"RSA/ECB/OAEPWithSHA1AndMGF1Padding\");\n            rsaWrapper.init(Cipher.WRAP_MODE, wrappingKey);\n        } catch (NoSuchAlgorithmException | NoSuchPaddingException | InvalidKeyException e) {\n            throw new RuntimeException(\"RSA OAEP should be available for RSA public key\", e);\n        }\n        return rsaWrapper.wrap(key);\n    }\n\n    public static void main(String[] args) throws Exception {\n        // we need an RSA PEM key first I guess :)\n        KeyPairGenerator kpg = KeyPairGenerator.getInstance(\"RSA\");\n        kpg.initialize(1024, new SecureRandom());\n        KeyPair kp = kpg.generateKeyPair();\n        String publicKeyFilename = \"rsa_pub.pem\";\n        try (PemWriter pemWriter = new PemWriter(new FileWriter(publicKeyFilename))) {\n            pemWriter.writeObject(new PemObject(\"PUBLIC KEY\", kp.getPublic().getEncoded()));\n        }\n\n        RSAPublicKey wrappingRSAPublicKey = readRSAPublicKey(publicKeyFilename);\n        SecretKey hmacKey = generateHMACKey();\n        byte[] wrappedKey = wrapKey(hmacKey, wrappingRSAPublicKey);\n        System.out.println(Base64.getEncoder().encodeToString(wrappedKey));\n    }\n}\n", "idx": 2356}
{"project": "cipher", "commit_id": "Snippet23900565_5264.java", "target": 1, "func": "encryptCipher =\n               Cipher.getInstance(\"AES/CTR/PKCS5Padding\")", "idx": 2651}
{"project": "cipher", "commit_id": "Snippet26581748_8725.java", "target": 0, "func": "public class MainActivity extends Activity {\n\nButton button1, button2;\n\nString KEY = \"MyKey\";\nSparseArray<byte[]> array = new SparseArray<byte[]>();\nSparseArray<byte[]> decryptArray = new SparseArray<byte[]>();\n\n@Override\nprotected void onCreate(Bundle savedInstanceState) {\n    super.onCreate(savedInstanceState);\n    setContentView(R.layout.activity_main);\n    button1 = (Button) findViewById(R.id.button1);\n    button1.setOnClickListener(new OnClickListener() {\n\n        @Override\n        public void onClick(View v) {\n           try {\n               new EncryptAsyncTask().execute();\n           } catch (Exception e) {  \n               e.printStackTrace();\n           }\n        }\n    });\n\n    button2 = (Button) findViewById(R.id.button2);\n    button2.setOnClickListener(new OnClickListener() {\n\n        @Override\n        public void onClick(View v) {\n            try {\n                new DecryptAsyncTask().execute();\n            } catch (Exception e) {\n                e.printStackTrace();\n            }\n        }\n    });\n\n\n   public class EncryptAsyncTask extends AsyncTask<String, String, String>{\n\n   ProgressDialog mDialog;\n\n   @Override\n   protected void onPreExecute() {\n        super.onPreExecute();\n        mDialog = ProgressDialog.show(MainActivity.this, \"\", \"Please wait\");\n   }\n\n    @Override\n    protected String doInBackground(String... params) {\n         byte[] incrept = null;\n        try {\n            getImageFile();\n            if(array!=null && array.size()>0){\n                for(int i=0 ; i<array.size() ; i++){\n                    byte[] byteArray = array.get(i);\n                    incrept = encrypt(KEY, byteArray);\n                     FileOutputStream fos = null;\n                        try {\n                            fos = new FileOutputStream(new File(\n                                   Environment.getExternalStorageDirectory()+File.separator\n                                    +\"EncryptedImages\"+File.separator+i+\"_Image.jpg\"));\n                        } catch (FileNotFoundException e) {\n                            e.printStackTrace();\n                        }\n                        try {\n                            fos.write(incrept);\n                        } catch (IOException e1) {\n                            e1.printStackTrace();\n                        }\n                        try {\n                            fos.close();\n                        } catch (IOException e) {\n                            e.printStackTrace();\n                        }\n                }\n            }               \n        } catch (FileNotFoundException e) {\n            e.printStackTrace();\n        } catch (Exception e) {\n            e.printStackTrace();\n        }\n        return null;\n    }\n\n    @Override\n    protected void onPostExecute(String result) {\n        super.onPostExecute(result);\n\n        if(mDialog.isShowing()){\n            mDialog.dismiss();\n        }\n    }\n }\n\n public class DecryptAsyncTask extends AsyncTask<String, String, String>{\n\n   ProgressDialog mDialog;\n\n   @Override\nprotected void onPreExecute() {\nsuper.onPreExecute();\n    mDialog = ProgressDialog.show(MainActivity.this, \"\", \"Please wait\");\n}\n\n    @Override\n    protected String doInBackground(String... params) {\n         byte[] incrept = null;\n        try {\n            getImageFileFromSdCard();\n            if(decryptArray!=null && decryptArray.size()>0){\n                for(int i=0 ; i<decryptArray.size() ; i++){\n                    byte[] byteArray = decryptArray.get(i);\n                    incrept = decrypt(KEY, byteArray);                        \n                     FileOutputStream fos = null;\n                        try {\n                            fos = new FileOutputStream(new File(\n                                   Environment.getExternalStorageDirectory()+File.separator\n                                    +\"DecryptedImages\"+File.separator+i+\"_Image.jpg\"));\n                        } catch (FileNotFoundException e) {\n                            e.printStackTrace();\n                        }\n                        try {\n                            fos.write(incrept);\n                        } catch (IOException e1) {\n                            e1.printStackTrace();\n                        }\n                        try {\n                            fos.close();\n                        } catch (IOException e) {\n                            e.printStackTrace();\n                        }\n                }\n            }               \n        } catch (FileNotFoundException e) {\n            e.printStackTrace();\n        } catch (Exception e) {\n            e.printStackTrace();\n        }\n\n        return null;\n    }\n\n    public byte[]   getImageFile() throws FileNotFoundException\n{\n  byte[] Image_data = null;\n  byte[] arry = null;\n    try {\n        File file = new File(Environment.getExternalStorageDirectory()+File.separator+\"Images\"+File.separator);\n        if(file.exists() && file.isDirectory()){\n            File[] listOfImages = file.listFiles();\n            if(listOfImages.length>0){\n                 for(int i=0; i<listOfImages.length; i++){\n                     byte[] inarry = null;\n                     InputStream is = new BufferedInputStream(new FileInputStream(listOfImages[i]));\n                     int length = is.available();\n                        Image_data = new byte[length];\n\n                        int bytesRead;\n                        ByteArrayOutputStream output = new ByteArrayOutputStream();\n                        while ((bytesRead = is.read(Image_data)) != -1)\n                        {\n                            output.write(Image_data, 0, bytesRead);\n                        }\n                      inarry = output.toByteArray();\n                      array.put(i, inarry);\n                      is.close();\n                 }\n            }\n        }\n    } catch (IOException e) {\n        e.printStackTrace();\n    }\n\nreturn arry;\n}\n\npublic void getImageFileFromSdCard() throws FileNotFoundException\n{\ntry {\n    File file = new            File(Environment.getExternalStorageDirectory()+File.separator+\"EncryptedImages\"+File.separator);\n    if(file.exists() && file.isDirectory()){\n        File[] listOfFiles = file.listFiles();\n        if(listOfFiles.length>0){\n            for(int i=0 ; i<listOfFiles.length ; i++){\n                FileInputStream fileInputStream = new FileInputStream(listOfFiles[i]);\n                byte[] bFile = new byte[(int) listOfFiles[i].length()];\n                fileInputStream.read(bFile);\n                fileInputStream.close();\n                decryptArray.put(i, bFile);\n            }\n        }\n    }\n} catch (IOException e) {\n    e.printStackTrace();\n}\n}\n\npublic  byte[] encrypt(String seed, byte[] cleartext) throws Exception {\n\n    byte[] rawKey = getRawKey(seed.getBytes());\n        byte[] result = encrypt(rawKey, cleartext);\n        return result;\n}\n\npublic  byte[] decrypt(String seed, byte[] encrypted) throws Exception {\n        byte[] rawKey = getRawKey(seed.getBytes());\n        byte[] enc = encrypted;\n        byte[] result = decrypt(rawKey, enc);\n\n        return result;\n}\n\nprivate  byte[] getRawKey(byte[] seed) throws Exception {\n        KeyGenerator kgen = KeyGenerator.getInstance(\"AES\");\n        SecureRandom sr = SecureRandom.getInstance(\"SHA1PRNG\");\n        sr.setSeed(seed);\n    kgen.init(128, sr); \n    SecretKey skey = kgen.generateKey();\n    byte[] raw = skey.getEncoded();\n    return raw;\n} \n\n\nprivate  byte[] encrypt(byte[] raw, byte[] clear) throws Exception {\n    SecretKeySpec skeySpec = new SecretKeySpec(raw, \"AES\");\n        Cipher cipher = Cipher.getInstance(\"AES\");\n    cipher.init(Cipher.ENCRYPT_MODE, skeySpec);\n    byte[] encrypted = cipher.update(clear);\n        return encrypted;\n}\n\nprivate  byte[] decrypt(byte[] raw, byte[] encrypted) throws Exception {\n    SecretKeySpec skeySpec = new SecretKeySpec(raw, \"AES\");\n        Cipher cipher = Cipher.getInstance(\"AES\");\n    cipher.init(Cipher.DECRYPT_MODE, skeySpec);\n    byte[] decrypted = cipher.update(encrypted);\n        return decrypted;\n}\n }\n", "idx": 1966}
{"project": "cipher", "commit_id": "Snippet6054627_31912.java", "target": 1, "func": "private byte[] encRSA(byte[] in, java.security.PublicKey publicKey) {\n    try {\n        Cipher rsaCipher = Cipher.getInstance(\"RSA/NONE/PKCS1Padding\", \"BC\");\n        rsaCipher.init(Cipher.ENCRYPT_MODE, publicKey);\n        rsaCipher.update(in);\n        return rsaCipher.doFinal();\n    } catch (Exception e) {\n        e.printStackTrace();\n    }\n    return null;\n}\n", "idx": 2707}
{"project": "cipher", "commit_id": "Snippet22829354_5227.java", "target": 1, "func": "try (FileInputStream fis = new FileInputStream(sourceFile)) {\n    response = Utils.decryptEnv((byte[]) tempResponse.getObjContents().get(0), fsSecretKey, ivSpec);\n\n    Cipher cipher = Cipher.getInstance(\"AES/CBC/PKCS5Padding\", \"BC\");\n    cipher.init(Cipher.ENCRYPT_MODE, secretKey, ivSpec);\n\n    do {\n        byte[] buf = new byte[4096];\n\n        int n = fis.read(buf); // can throw an IOException\n        else if (n < 0) {\n            System.out.println(\"Read error\");\n            fis.close();\n            return false;\n        }\n\n        byte[] cipherBuf = cipher.doFinal(buf);\n\n        // send through socket blah blah blah\n\n    } while (fis.available() > 0);\n", "idx": 2733}
{"project": "cipher", "commit_id": "Snippet44029620_26094.java", "target": 1, "func": "    public static KeyPair generateKeyPairRSA()  {\n    try {\n        SecureRandom random = SecureRandom.getInstance(\"SHA1PRNG\");\n        KeyPairGenerator keyGen = KeyPairGenerator.getInstance(\"RSA\");\n        keyGen.initialize(1024, random);\n        KeyPair keyPair = keyGen.generateKeyPair();\n        return keyPair;\n    } catch (Exception e) {\n        Log.d(TAG,e.getLocalizedMessage());\n    }\n    return null;\n}\n\n\npublic byte[] RSAEncrypt(final String plain, PublicKey publicKey) throws Exception {\n    Cipher cipher = Cipher.getInstance(ALGO_RSA);\n    cipher.init(Cipher.ENCRYPT_MODE, publicKey);\n    byte[] encryptedBytes = cipher.doFinal(plain.getBytes());\n    return encryptedBytes;\n}\n\npublic static PublicKey loadPublicKey1(String stored) throws Exception{\n    byte[] data = Base64.decode(stored.getBytes());\n    X509EncodedKeySpec spec = new X509EncodedKeySpec(data);\n    KeyFactory fact = KeyFactory.getInstance(ALGO_RSA);\n    return fact.generatePublic(spec);\n}\n", "idx": 2526}
{"project": "cipher", "commit_id": "Snippet38861869_20769.java", "target": 0, "func": "/**\n * \n */\npackage com.ebiznext.utils\n\nimport java.io.Serializable;\nimport java.security.Key;\n\nimport javax.crypto.Cipher;\nimport javax.crypto.spec.SecretKeySpec;\nimport javax.xml.bind.DatatypeConverter\n\nimport sun.misc.BASE64Decoder;\nimport sun.misc.BASE64Encoder;\n\n/**\n * @version $Id $\n *\n */\nclass ByteSerializer\n{\n    def static Object deserialize(String string) throws IOException, ClassNotFoundException\n    {\n        byte[] data = DatatypeConverter.parseBase64Binary(string)\n        ObjectInputStream objectInputStream =\n            new ObjectInputStream(new ByteArrayInputStream(data))\n        Object object = objectInputStream.readObject()\n        objectInputStream.close()\n        return object\n    }\n\n    def static String serialize(Serializable object) throws IOException\n    {\n        ByteArrayOutputStream byteArrayOutputStream = new ByteArrayOutputStream()\n        ObjectOutputStream objectOutputStream = new ObjectOutputStream(byteArrayOutputStream)\n        objectOutputStream.writeObject(object)\n        objectOutputStream.close()\n        return new String(DatatypeConverter.printBase64Binary(byteArrayOutputStream\n            .toByteArray()))\n    }\n\n    def static String toEncryptedString(Serializable object)\n            throws Exception {\n        return encrypt(toString(object));\n    }\n\n    def static Object fromEncryptedString(String encryptedObject)\n            throws Exception {\n        return fromString(decrypt(encryptedObject));\n    }\n\n    private static final String ALGORITHM = \"AES\";\n\n    private static final byte[] keyValue = \"ThisKeyIsVeryPrivateNobodyKnowsAboutItYeah!!\"\n            .substring(0, 32).getBytes();\n\n    def static String encrypt(String valueToEnc) throws Exception {\n\n        Key key = generateKey();\n        Cipher c = Cipher.getInstance(ALGORITHM);\n        c.init(Cipher.ENCRYPT_MODE, key);\n        byte[] encValue = c.doFinal(valueToEnc.getBytes());\n        String encryptedValue = new BASE64Encoder().encode(encValue);\n        return encryptedValue;\n    }\n\n    def static String decrypt(String encryptedValue) throws Exception {\n\n        Key key = generateKey();\n        Cipher c = Cipher.getInstance(ALGORITHM);\n        c.init(Cipher.DECRYPT_MODE, key);\n        byte[] decordedValue = new BASE64Decoder().decodeBuffer(encryptedValue);\n        byte[] decValue = c.doFinal(decordedValue);\n        String decryptedValue = new String(decValue);\n        return decryptedValue;\n    }\n\n    private static Key generateKey() throws Exception {\n        Key key = new SecretKeySpec(keyValue, ALGORITHM);\n        // SecretKeyFactory keyFactory =\n        // SecretKeyFactory.getInstance(ALGORITHM);\n        // key = keyFactory.generateSecret(new DESKeySpec(keyValue));\n        return key;\n    }\n}\n", "idx": 2087}
{"project": "cipher", "commit_id": "Snippet14472683_37742.java", "target": 0, "func": " try{\n\n\n    AlgorithmParameterSpec paramSpec = new IvParameterSpec(IV); \n    Cipher cipher = Cipher.getInstance(\"AES\");\n    SecretKeySpec key = new SecretKeySpec(keyGen, \"AES\");\n    cipher.init(Cipher.DECRYPT_MODE, key, paramSpec); \n    byte[] output =  new BASE64Decoder().decodeBuffer(new String(convertDocToByteArra(\"//Path/somePDF.pdf\")));  \n\n     byte[] decrypted = cipher.doFinal(output);\n\n     convertByteArrayToDoc(decrypted);\n       }catch(Exception e){\n           e.printStackTrace();\n       }\n", "idx": 2175}
{"project": "cipher", "commit_id": "Snippet45083824_27210.java", "target": 1, "func": "Cipher rsaCipher = Cipher.getInstance(\"RSA/None/PKCS1Padding\", \"SC\");\nrsaCipher.init(Cipher.ENCRYPT_MODE, apiPublicKey);\nbyte[] ENCRYPTED_YOUR_STRING = rsaCipher.doFinal(YOUR_STRING);\n", "idx": 2378}
{"project": "cipher", "commit_id": "Snippet14261335_37603.java", "target": 0, "func": "public class SOEncryptDecryptExampleBytes\n{\n    // \"thisIsASecretKey\";\n    private static byte[] key = { 0x74, 0x68, 0x69, 0x73, 0x49, 0x73, 0x41, 0x53, 0x65, 0x63, 0x72, 0x65, 0x74, 0x4b, 0x65, 0x79 };\n\n    private static final String STRING_ENCODING = \"UTF-8\";\n\n    public static void main(String[] args) throws Exception\n    {\n        //*********************************************\n        String x = \"Hello\";\n        System.out.println(\"Plain Text: \" + x);\n        String e = encryptBytesAndBase64Encode(x.getBytes(STRING_ENCODING));\n        System.out.println(\"Encrypted: \" + e);\n        byte[] d = base64decodeAndDecryptBytes(e);\n        System.out.println(\"Decrypted: \" + new String(d, STRING_ENCODING));\n\n        //*********************************************\n        byte b = 124;\n        System.out.println(\"Plain Byte: \" + b);\n        String eb = encryptBytesAndBase64Encode(new byte[] { b });\n        System.out.println(\"Encrypted Byte: \" + eb);\n        byte[] bd = base64decodeAndDecryptBytes(eb);\n        System.out.println(\"Decrypted Byte: \" + bd[0]);\n\n        //*********************************************\n        byte[] bArray = { 23, 42, 55 };\n        System.out.println(\"Plain Byte Array: \" + Arrays.toString(bArray));\n        String eba = encryptBytesAndBase64Encode(bArray);\n        System.out.println(\"Encrypted Byte Array: \" + eba);\n        byte[] deba = base64decodeAndDecryptBytes(eba);\n        System.out.println(\"Decrypted Byte Array: \" + Arrays.toString(deba));\n        //*********************************************\n    }\n\n    /**\n     * Transforms a byte[] into an encrypted byte[] and then uses base64 encodes the encrypted byte[]\n     */\n    public static String encryptBytesAndBase64Encode(byte[] bytes) throws Exception\n    {\n        Cipher cipher = Cipher.getInstance(\"AES/ECB/PKCS5Padding\");\n        SecretKeySpec secretKey = new SecretKeySpec(key, \"AES\");\n        cipher.init(Cipher.ENCRYPT_MODE, secretKey);\n        String encryptedString = Base64.encodeBase64String(cipher.doFinal(bytes));\n        return encryptedString;\n    }\n\n    /**\n     * Base64 decodes a string into a byte[] and then decrypts those bytes into a decrypted byte[]\n     */\n    public static byte[] base64decodeAndDecryptBytes(String base64EncodedEncryptedBytes) throws Exception\n    {\n        Cipher cipher = Cipher.getInstance(\"AES/ECB/PKCS5PADDING\");\n        SecretKeySpec secretKey = new SecretKeySpec(key, \"AES\");\n        cipher.init(Cipher.DECRYPT_MODE, secretKey);\n        byte[] decryptedBytes = cipher.doFinal(Base64.decodeBase64(base64EncodedEncryptedBytes));\n        return decryptedBytes;\n    }\n}\n", "idx": 2026}
{"project": "cipher", "commit_id": "Snippet21945437_4366.java", "target": 1, "func": "File pubKeyFile = new File(keyFileName);\n    DataInputStream inputStream;\n    byte[] signature = null;\n    try {\n        inputStream = new DataInputStream(new FileInputStream(pubKeyFile));\n        byte[] pubKeyBytes = new byte[(int)pubKeyFile.length()];\n        inputStream.readFully(pubKeyBytes);\n        inputStream.close();\n\n        KeyFactory keyFactory = KeyFactory.getInstance(\"RSA\");\n        X509EncodedKeySpec pubSpec = new X509EncodedKeySpec(pubKeyBytes);\n        RSAPublicKey pubKey = (RSAPublicKey) keyFactory.generatePublic(pubSpec);\n\n        Cipher cipher = Cipher.getInstance(\"RSA/ECB/PKCS1Padding\");\n        cipher.init(Cipher.ENCRYPT_MODE, pubKey);\n\n        signature = cipher.doFinal(secretKey.getBytes());\n    } catch (Exception e) {\n        e.printStackTrace();\n    }\n    return signature;\n", "idx": 2750}
{"project": "cipher", "commit_id": "Snippet18528072_1582.java", "target": 1, "func": "Download & Decrypt file from SFTP using JSCH\n\n/**\n * The class to download the files from SFTP server.\n */\npackage com.test.service;\n\nimport java.io.BufferedInputStream;\nimport java.io.BufferedOutputStream;\nimport java.io.ByteArrayInputStream;\nimport java.io.ByteArrayOutputStream;\nimport java.io.FileInputStream;\nimport java.io.FileOutputStream;\nimport java.io.IOException;\nimport java.io.InputStream;\nimport java.io.ObjectInputStream;\nimport java.io.OutputStream;\n\nimport javax.crypto.Cipher;\nimport javax.crypto.CipherInputStream;\nimport javax.crypto.spec.IvParameterSpec;\nimport javax.crypto.spec.SecretKeySpec;\nimport javax.servlet.ServletContext;\n\nimport org.apache.commons.logging.Log;\nimport org.apache.commons.logging.LogFactory;\nimport org.springframework.beans.factory.annotation.Autowired;\nimport org.springframework.beans.factory.annotation.Value;\nimport org.springframework.stereotype.Service;\n\nimport com.jcraft.jsch.Channel;\nimport com.jcraft.jsch.ChannelSftp;\nimport com.jcraft.jsch.JSch;\nimport com.jcraft.jsch.JSchException;\nimport com.jcraft.jsch.Session;\nimport com.jcraft.jsch.SftpException;\n\n/**\n * @author varunvikramsingh@gmail.com\n * \n */\n@Service\npublic class DownloadFileServiceJschImpl implements DownloadFileService {\n    @Value(\"${sftpServer}\")\n    String sftpServer;\n\n    @Value(\"${sftpUsername}\")\n    String sftpUsername;\n\n    @Value(\"${sftpPassword}\")\n    String sftpPassword;\n\n    @Value(\"${sftpPort}\")\n    String sftpPort;\n\n    @Value(\"${decryptPrivateKey}\")\n    String DecryptKeyKey;\n\n    private Log logger = LogFactory.getLog(this.getClass().getName());\n\n    @Override\n    public void downloadFile(String ccoid, String reportType, String url, String filename, OutputStream outStream,\n            byte[] decryptKeyFromSOA) throws SftpException {\n\n            try {\n\n            // SFTP HOST DETAILS\n            String ftpHostSFTP = sftpServer;\n            // SFTP PORT NUMBER\n            String ftpPortSFTP = sftpPort;\n            int parsePort = Integer.parseInt(ftpPortSFTP);\n            // SFTP USER NAME\n            String ftpUserNameSFTP = sftpUsername.trim();\n            // SFTP PASSWORD\n            String ftpPasswordSFTP = sftpPassword;\n            // SFTP REMOTE DIRECTORY\n            String ftpRemoteDirectory = \"/data\";\n\n\n            // First Create a JSch session\n            logger.info(\"Creating session with SFTP.\");\n            // JAVA SECURE CHANNEL API for connecting to the service of via SSH22\n            JSch jsch = new JSch();\n            Session session = null;\n            Channel channel = null;\n            ChannelSftp sftpChannel = null;\n\n            logger.info(\"Trying to Connect to SFTP Server : \"+sftpServer);\n            logger.info(\"SFTP Server userName : \"+sftpUsername);\n            logger.info(\"SFTP Server sftPort: \"+sftpPort);\n            logger.info(\"SFTP Server password: \"+sftpPassword);\n            session = jsch.getSession(ftpUserNameSFTP, ftpHostSFTP, parsePort);\n            //session = jsch.getSession(sftpUsername, sftpServer, sftpPort);\n            session.setConfig(\"StrictHostKeyChecking\", \"no\");\n            session.setPassword(ftpPasswordSFTP);\n            //session.setPassword(sftpPassword);\n            session.connect();\n\n            channel = session.openChannel(\"sftp\");\n            channel.connect();\n            sftpChannel = (ChannelSftp) channel;\n            sftpChannel.cd(\"/\");\n            sftpChannel.cd(\"/data/\");\n\n            logger.info(\"Current Directory for user is : \"+ sftpChannel.pwd());\n            logger.info(\"User is trying to download file :\"+filename);\n\n            String newFileName = filename+\".enc\";\n\n            logger.info(\"Portal added .enc as suffix to filename, fileName now is :\"+newFileName);\n\n            // ==============Decrypt SOA key=================\n            byte[] decryptedSOAKeyArray = decrypt(decryptKeyFromSOA,readSecurityKey());\n            String soaDecryptedKey = new String(decryptedSOAKeyArray);\n\n            logger.info(\"Private Key Received from SOA :\"+soaDecryptedKey);\n\n            logger.info(\"Reading the file from SFTP server\");\n\n            BufferedInputStream bis = new BufferedInputStream(sftpChannel.get(newFileName));  \n            BufferedOutputStream bos = new BufferedOutputStream(outStream);\n\n            logger.info(\"Decrypting the file received from SFTP\");\n\n            // Decrypt the file\n            decrypt(bis, bos, decryptedSOAKeyArray);\n\n            logger.info(\"File Successfully Downloaded\");\n\n            outStream.close();\n            sftpChannel.exit();\n            session.disconnect();\n\n            logger.info(\"All connections successfully closed\");\n\n        }\n        catch (JSchException e) {\n            e.printStackTrace();\n        }\n        catch (SftpException e) {\n            e.printStackTrace();\n        }\n        catch (Exception e) {\n            e.printStackTrace();\n        }\n    }\n\n    @Autowired\n    ServletContext servletContext;\n    private byte[] readSecurityKey() {\n\n        ObjectInputStream in = null;\n        byte[] publicKey = null;\n\n        String path = servletContext.getRealPath(\"/WEB-INF/conf\");\n        String publicKeyfilename = path + \"\\\\PublicKey.txt\";\n\n        logger.info(\"Reading security Key from file :\"+publicKeyfilename);\n\n        try {\n            InputStream is = new FileInputStream(publicKeyfilename);\n            publicKey = getByteArrayFromFile(is);\n        }\n        catch (IOException ioe) {\n            logger.info(\"Exception in reading security key \"+ioe);\n        }\n        finally {\n            if (null != in) {\n                try {\n                    in.close();\n                }\n                catch (IOException e) {\n                    /*\n                     * Eating this exception since it occurred while closing the input stream.\n                     */\n                }\n            }\n\n        } // end of finally\n        return publicKey;\n    }\n\n    public static void invokeDecryptFile(String encFilename,String decFilename,byte[] password){\n        try{\n        BufferedInputStream is = new BufferedInputStream(new FileInputStream(encFilename));\n        BufferedOutputStream decout = new BufferedOutputStream(new FileOutputStream(decFilename));\n        decrypt(is, decout, password);\n        }catch(Exception e){\n            e.printStackTrace();\n        }\n    }\n\n\n    public static byte[] getByteArrayFromFile(InputStream is) {\n        try {\n            ByteArrayOutputStream out = new ByteArrayOutputStream();\n            int buf_size = 1024;\n            byte[] buffer = new byte[buf_size];\n            int len = 0;\n            while (-1 != (len = is.read(buffer, 0, buf_size))) {\n                out.write(buffer, 0, len);\n            }\n            byte[] fileContent = out.toByteArray();\n            is.close();\n            return fileContent;\n        }\n        catch (Exception e) {\n            e.printStackTrace();\n        }\n        return null;\n    }\n\n\n    public static byte[] decrypt(byte[] cipherTextBytes, byte[] password) throws Exception {\n        ByteArrayInputStream bis = new ByteArrayInputStream(cipherTextBytes);\n        ByteArrayOutputStream bos = new ByteArrayOutputStream();\n        decrypt(bis, bos, password);        \n        return bos.toByteArray();\n    }\n\n    public static void decrypt(InputStream in, OutputStream out, byte[] password) throws Exception{\n        final String ALGORITHM = \"AES\";\n        final String transformation=\"AES/CFB8/NoPadding\";\n        final int CACHE_SIZE = 64*1024;\n        final int IV_LENGTH=16;\n        byte[] iv = new byte[IV_LENGTH];\n        in.read(iv);\n\n        Cipher cipher = Cipher.getInstance(transformation); \n        SecretKeySpec keySpec = new SecretKeySpec(password, ALGORITHM);\n        IvParameterSpec ivSpec = new IvParameterSpec(iv);\n        cipher.init(Cipher.DECRYPT_MODE, keySpec, ivSpec);\n\n        in = new CipherInputStream(in, cipher);\n        byte[] buf = new byte[CACHE_SIZE];\n        int numRead = 0;\n        while ((numRead = in.read(buf)) >= 0) {\n            out.write(buf, 0, numRead);\n        }\n        out.close();\n    }\n\n    // @Override\n    // public void downloadFile(InputStream in, OutputStream out) {\n    // try {\n    // int i = 0;\n    // byte[] bytesIn = new byte[1024];\n    //\n    // /*\n    // * Loop through the entire file writing bytes.\n    // */\n    // while ((i = in.read(bytesIn)) >= 0) {\n    // out.write(bytesIn, 0, i);\n    // }\n    //\n    // out.close();\n    // in.close();\n    // }\n    // catch(Exception e) {\n    // e.printStackTrace();\n    // }\n    //\n    // }\n\n\n}\n", "idx": 2459}
{"project": "cipher", "commit_id": "Snippet43433930_25542.java", "target": 1, "func": "//Decrypt\n\nimport java.io.UnsupportedEncodingException;\nimport java.security.InvalidAlgorithmParameterException;\nimport java.security.InvalidKeyException;\nimport java.security.Key;\nimport java.security.KeyFactory;\nimport java.security.KeyPair;\nimport java.security.KeyPairGenerator;\nimport java.security.NoSuchAlgorithmException;\nimport java.security.NoSuchProviderException;\nimport java.security.SecureRandom;\nimport java.security.interfaces.ECPublicKey;\nimport java.security.spec.ECParameterSpec;\nimport java.security.spec.ECPoint;\nimport java.security.spec.ECPublicKeySpec;\nimport java.util.Base64;\nimport java.util.Scanner;\n\nimport javax.crypto.BadPaddingException;\nimport javax.crypto.Cipher;\nimport javax.crypto.IllegalBlockSizeException;\nimport javax.crypto.NoSuchPaddingException;\nimport javax.crypto.SecretKey;\nimport javax.crypto.ShortBufferException;\nimport javax.crypto.spec.IvParameterSpec;\nimport javax.crypto.spec.SecretKeySpec;\n\nimport org.bouncycastle.jce.ECNamedCurveTable;\nimport org.bouncycastle.jce.spec.ECNamedCurveParameterSpec;\n\npublic class Decrypt {\n\n  public static byte[] iv = new SecureRandom().generateSeed(16);\n\n\n  public static void main(String[] args) {\n\n    /*  Scanner scc = new Scanner(System.in);\n        System.out.println(\"Enter IV:\");\n        String ivate = scc.nextLine();\n        byte[] iv = ivate.getBytes();\n    */\n    System.out.println(\"IV=\" + iv);\n\n    Scanner sc = new Scanner(System.in); // object for scanner\n    System.out.println(\"Enter your Cipher:\");\n    String cipherText = sc.nextLine();\n\n    Scanner scanner = new Scanner(System.in); // object for scanner\n\n    System.out.println(\"Enter your Secret Key B:\");\n\n    String encodedKeyB = scanner.nextLine();\n    byte[] decodedKeyB = Base64.getDecoder().decode(encodedKeyB);\n\n    SecretKey secretKeyB = new SecretKeySpec(decodedKeyB, 0, decodedKeyB.length, \"AES\");\n\n    // Initialize two key pairs\n    //  KeyPair keyPairA = generateECKeys();\n    // KeyPair keyPairB = generateECKeys();\n\n    // Create two AES secret keys to encrypt/decrypt the message\n    //SecretKey secretKeyA = generateSharedSecret(keyPairA.getPrivate(),\n    //        keyPairB.getPublic());\n    //SecretKey secretKeyB = generateSharedSecret(keyPairB.getPrivate(),\n    //       keyPairA.getPublic());\n\n    // Encrypt the message using 'secretKeyA'\n    //  String cipherText = encryptString(secretKeyA, plainText);\n    //   System.out.println(\"Encrypted cipher text: \" + cipherText);\n\n    // Decrypt the message using 'secretKeyB'\n    String decryptedPlainText = decryptString(secretKeyB, cipherText);\n    System.out.println(\"Decrypted cipher text: \" + decryptedPlainText);\n    System.out.println(\" cipher text: \" + cipherText);\n    System.out.println(\"Key: \" + secretKeyB);\n  }\n\n  /*  public static KeyPair generateECKeys() {\n        try {\n            ECNamedCurveParameterSpec parameterSpec = ECNamedCurveTable.getParameterSpec(\"brainpoolp256r1\");\n            KeyPairGenerator keyPairGenerator = KeyPairGenerator.getInstance(\n                    \"ECDH\", \"BC\");\n\n            keyPairGenerator.initialize(parameterSpec);\n            KeyPair keyPair = keyPairGenerator.generateKeyPair();\n\n            return keyPair;\n        } catch (NoSuchAlgorithmException | InvalidAlgorithmParameterException\n                | NoSuchProviderException e) {\n            e.printStackTrace();\n            return null;\n        }\n    }\n*/\n  /*    public static SecretKey generateSharedSecret(PrivateKey privateKey,\n              PublicKey publicKey) {\n          try {\n              KeyAgreement keyAgreement = KeyAgreement.getInstance(\"ECDH\", \"BC\");\n              keyAgreement.init(privateKey);\n              keyAgreement.doPhase(publicKey, true);\n\n              SecretKey key = keyAgreement.generateSecret(\"AES\");\n              return key;\n          } catch (InvalidKeyException | NoSuchAlgorithmException\n                  | NoSuchProviderException e) {\n              // TODO Auto-generated catch block\n              e.printStackTrace();\n              return null;\n          }\n      }\n  */\n  /*  public static String encryptString(SecretKey secretkeyB, String plainText) {\n        try {\n            IvParameterSpec ivSpec = new IvParameterSpec(iv);\n            Cipher cipher = Cipher.getInstance(\"AES/GCM/NoPadding\", \"BC\");\n            byte[] plainTextBytes = plainText.getBytes(\"UTF-8\");\n            byte[] cipherText;\n\n            cipher.init(Cipher.ENCRYPT_MODE, key, ivSpec);\n            cipherText = new byte[cipher.getOutputSize(plainTextBytes.length)];\n            int encryptLength = cipher.update(plainTextBytes, 0,\n                    plainTextBytes.length, cipherText, 0);\n            encryptLength += cipher.doFinal(cipherText, encryptLength);\n\n            return bytesToHex(cipherText);\n        } catch (NoSuchAlgorithmException | NoSuchProviderException\n                | NoSuchPaddingException | InvalidKeyException\n                | InvalidAlgorithmParameterException\n                | UnsupportedEncodingException | ShortBufferException\n                | IllegalBlockSizeException | BadPaddingException e) {\n            e.printStackTrace();\n            return null;\n        }\n    }\n*/\n  public static String decryptString(SecretKey secretkeyB, String cipherText) {\n    try {\n      Key decryptionKey = new SecretKeySpec(secretkeyB.getEncoded(),\n        secretkeyB.getAlgorithm());\n      IvParameterSpec ivSpec = new IvParameterSpec(iv);\n      Cipher cipher = Cipher.getInstance(\"AES/GCM/NoPadding\", \"BC\");\n      byte[] cipherTextBytes = hexToBytes(cipherText);\n      byte[] plainText;\n\n\n      cipher.init(Cipher.DECRYPT_MODE, decryptionKey, ivSpec);\n      plainText = new byte[cipher.getOutputSize(cipherTextBytes.length)];\n      int decryptLength = cipher.update(cipherTextBytes, 0,\n        cipherTextBytes.length, plainText, 0);\n      decryptLength = cipher.doFinal(plainText, decryptLength);\n\n      return new String(plainText, \"UTF-8\");\n    } catch (NoSuchAlgorithmException | NoSuchProviderException |\n      NoSuchPaddingException | InvalidKeyException |\n      InvalidAlgorithmParameterException |\n      IllegalBlockSizeException | BadPaddingException |\n      ShortBufferException | UnsupportedEncodingException e) {\n      e.printStackTrace();\n      return null;\n    }\n  }\n\n  public static String bytesToHex(byte[] data, int length) {\n    String digits = \"0123456789ABCDEF\";\n    StringBuffer buffer = new StringBuffer();\n\n    for (int i = 0; i != length; i++) {\n      int v = data[i] & 0xff;\n\n      buffer.append(digits.charAt(v >> 4));\n      buffer.append(digits.charAt(v & 0xf));\n    }\n\n    return buffer.toString();\n  }\n\n  public static String bytesToHex(byte[] data) {\n    return bytesToHex(data, data.length);\n  }\n\n  public static byte[] hexToBytes(String string) {\n    int length = string.length();\n    byte[] data = new byte[length / 2];\n    for (int i = 0; i < length; i += 2) {\n      data[i / 2] = (byte)((Character.digit(string.charAt(i), 16) << 4) + Character\n        .digit(string.charAt(i + 1), 16));\n    }\n    return data;\n  }\n}\n", "idx": 2726}
{"project": "cipher", "commit_id": "Snippet22176759_4573.java", "target": 1, "func": "String PRIVATE_RSA_KEY_PKCS8 = \n    \"-----BEGIN PRIVATE KEY-----\\n\" +\n    \"MDSTofml23d....\\n\" +\n    [...] +\n    \"-----END PRIVATE KEY-----\\n\";\nString key = PRIVATE_RSA_KEY_PKCS8\n    .replace(\"-----BEGIN PRIVATE KEY-----\\n\", \"\")\n    .replace(\"\\n-----END PRIVATE KEY-----\\n\", \"\");\nPKCS8EncodedKeySpec keySpec =\n    new PKCS8EncodedKeySpec(DatatypeConverter.parseBase64Binary(key));\ntry {\n    KeyFactory keyFactory = KeyFactory.getInstance(\"RSA\");\n    PrivateKey privateKey = keyFactory.generatePrivate(keySpec);\n    Cipher cipher = Cipher.getInstance(\"RSA/ECB/OAEPWithSHA1AndMGF1Padding\");\n    cipher.init(Cipher.DECRYPT_MODE, privateKey);\n    byte[] bytes = parseBase64Binary(encryptedNodeIdentifier);\n    byte[] decryptedData = cipher.doFinal(bytes);\n    return new String(decryptedData);\n} catch (GeneralSecurityException e) {\n    return \"\";\n}\n", "idx": 2627}
{"project": "cipher", "commit_id": "Snippet24471512_6795.java", "target": 1, "func": "public static String encryptAES(String key, String source) {\nString encrypted = \"\";\ntry {  \n    SecretKeySpec keySpec = new SecretKeySpec(key.getBytes(), \"AES\");\n    Cipher cipher = Cipher.getInstance(\"AES/CBC/PKCS5Padding\"); \n    IvParameterSpec iv = new IvParameterSpec(new byte[16]);\n    cipher.init(Cipher.ENCRYPT_MODE, keySpec, iv); \n    byte[] bXml = source.getBytes(\"UTF8\");\n    byte[] enc = cipher.doFinal(bXml);\n    encrypted = new sun.misc.BASE64Encoder().encode(enc); \n} catch (Exception e) {  /** removed **/ }\nreturn encrypted;\n}\npublic static String decryptAES(String key, String source) {\nString decrypted = \"\";\ntry {  \n    SecretKeySpec keySpec = new SecretKeySpec(key.getBytes(), \"AES\");\n    Cipher cipher = Cipher.getInstance(\"AES/CBC/PKCS5Padding\");     \n    IvParameterSpec iv = new IvParameterSpec(new byte[16]);\n    cipher.init(Cipher.DECRYPT_MODE, keySpec, iv); \n    byte[] dec = new sun.misc.BASE64Decoder().decodeBuffer(source); \n    byte[] bDecrypted = cipher.doFinal(dec);  /** Error occurs here **/\n    decrypted = new String(bDecrypted, \"UTF8\");     \n} catch (Exception e) {  /** removed **/ }  \nreturn decrypted;\n}\n", "idx": 2411}
{"project": "cipher", "commit_id": "Snippet14582664_37831.java", "target": 0, "func": "    byte[] encodedprivkey = privKey.getEncoded();\n    String MYPBEALG = \"PBEWithSHA1AndDESede\";\n    String password = \"test123\";\n\n    int count = 20;// hash iteration count\n    Random random = new Random();\n    byte[] salt = new byte[8];\n    random.nextBytes(salt);\n\n    PBEParameterSpec pbeParamSpec = new PBEParameterSpec(salt, count);\n    PBEKeySpec pbeKeySpec = new PBEKeySpec(password.toCharArray());\n\n    SecretKeyFactory keyFac = SecretKeyFactory.getInstance(MYPBEALG);\n    SecretKey pbeKey = keyFac.generateSecret(pbeKeySpec);\n\n    Cipher pbeCipher = Cipher.getInstance(MYPBEALG);\n    // Initialize PBE Cipher with key and parameters\n    pbeCipher.init(Cipher.ENCRYPT_MODE, pbeKey, pbeParamSpec);\n\n    // Encrypt the encoded Private Key with the PBE key\n    byte[] ciphertext = pbeCipher.doFinal(encodedprivkey);\n\n\n    // Now construct  PKCS #8 EncryptedPrivateKeyInfo object\n    AlgorithmParameters algparms = AlgorithmParameters.getInstance(MYPBEALG);\n    algparms.init(pbeParamSpec);\n    EncryptedPrivateKeyInfo encinfo = new EncryptedPrivateKeyInfo(algparms, ciphertext);\n\n    FileOutputStream out3 = new FileOutputStream(\"server.key\");\n    out3.write(Base64.encodeBase64(encryptedPkcs8, true));\n    out3.flush();\n    out3.close();\n\n\n    FileOutputStream out3 = new FileOutputStream(\"server.crt\");\n    out3.write(Base64.encodeBase64(chain[0].getEncoded(), true));\n    out3.flush();\n    out3.close();\n", "idx": 2214}
{"project": "cipher", "commit_id": "Snippet42910006_25022.java", "target": 1, "func": "public static byte[] encryptWithAES(byte[] message, Key AESkey, byte[] iv) throws Exception {\nbyte[] decryptedMessage = null;\ntry {\n    Cipher encrypt = Cipher.getInstance(\"AES/CBC/PKCS5Padding\");  // here is the change\n    encrypt.init(Cipher.ENCRYPT_MODE, AESkey,new IvParameterSpec(iv)); // and I add the iv for cbc\n    decryptedMessage = encrypt.doFinal(message);\n} catch (Exception ex) {\n    System.err.println(ex.getMessage());\n    throw ex;\n}\nreturn decryptedMessage;\n}\n", "idx": 2511}
{"project": "cipher", "commit_id": "Snippet31245375_13367.java", "target": 1, "func": "private static final String salt = \"SaltySalt\";\n\nprivate static final int IV_LENGTH = 16;\n\nprivate static byte[] getSaltBytes() throws Exception {\n    return salt.getBytes(\"UTF-8\");\n}\n\nprivate static char[] getMasterPassword() {\n    return \"SuperSecretPassword\".toCharArray();\n}\n\npublic static String encrpytString (String input) throws Exception {\n    SecretKeyFactory factory = SecretKeyFactory.getInstance(\"PBKDF2WithHmacSHA1\");\n    PBEKeySpec spec = new PBEKeySpec(getMasterPassword(), getSaltBytes(), 65536,256);\n    SecretKey secretKey = factory.generateSecret(spec);\n    SecretKeySpec secret = new SecretKeySpec(secretKey.getEncoded(), \"AES\");\n    Cipher cipher = Cipher.getInstance(\"AES/CBC/PKCS5Padding\");\n    cipher.init(Cipher.ENCRYPT_MODE, secret);\n    byte[] ivBytes = cipher.getParameters().getParameterSpec(IvParameterSpec.class).getIV();\n    byte[] encryptedTextBytes = cipher.doFinal(input.getBytes(\"UTF-8\"));\n    byte[] finalByteArray = new byte[ivBytes.length + encryptedTextBytes.length]; \n    System.arraycopy(ivBytes, 0, finalByteArray, 0, ivBytes.length);\n    System.arraycopy(encryptedTextBytes, 0, finalByteArray, ivBytes.length, encryptedTextBytes.length);\n    return DatatypeConverter.printBase64Binary(finalByteArray);        \n}\n\npublic static String decrpytString (String input) throws Exception {\n    if (input.length() <= IV_LENGTH) {\n        throw new Exception(\"The input string is not long enough to contain the initialisation bytes and data.\");\n    }\n    byte[] byteArray = DatatypeConverter.parseBase64Binary(input);\n    byte[] ivBytes = new byte[IV_LENGTH];\n    System.arraycopy(byteArray, 0, ivBytes, 0, 16);\n    byte[] encryptedTextBytes = new byte[byteArray.length - ivBytes.length];\n    System.arraycopy(byteArray, IV_LENGTH, encryptedTextBytes, 0, encryptedTextBytes.length);\n    SecretKeyFactory factory = SecretKeyFactory.getInstance(\"PBKDF2WithHmacSHA1\");\n    PBEKeySpec spec = new PBEKeySpec(getMasterPassword(), getSaltBytes(), 65536, 256);\n    SecretKey secretKey = factory.generateSecret(spec);\n    SecretKeySpec secret = new SecretKeySpec(secretKey.getEncoded(), \"AES\");\n    Cipher cipher = Cipher.getInstance(\"AES/CBC/PKCS5Padding\");\n    cipher.init(Cipher.DECRYPT_MODE, secret, new IvParameterSpec(ivBytes));\n    byte[] decryptedTextBytes = cipher.doFinal(encryptedTextBytes);\n    return new String(decryptedTextBytes);\n}\n", "idx": 2389}
{"project": "cipher", "commit_id": "Snippet31398170_13512.java", "target": 0, "func": "public String encrypt (String str,String key) throws EncryptException {\n\n    try{\n        javax.crypto.spec.SecretKeySpec keyspec = new javax.crypto.spec.SecretKeySpec(key.getBytes(), \"AES\");\n        javax.crypto.Cipher c = javax.crypto.Cipher.getInstance(\"AES\");\n        c.init(javax.crypto.Cipher.ENCRYPT_MODE, keyspec);\n        byte[] src = str.getBytes(\"UTF-8\");\n        byte[] encrypt = c.doFinal(src);\n        return new sun.misc.BASE64Encoder().encode(encrypt).replaceAll(\"\\r|\\n\", \"\");\n    }catch(Exception e){\n        throw new EncryptException(\"Encrypt failed.\",e);\n    }\n}\n", "idx": 1972}
{"project": "cipher", "commit_id": "Snippet5770064_31796.java", "target": 0, "func": "package forums;\n\nimport java.io.*;\nimport java.security.*;\nimport javax.crypto.*;\nimport javax.crypto.spec.*;\n\n/**\n   This program tests the DES cipher. Usage:\n   java DESTest -genkey keyfile\n   java DESTest -encrypt plaintext encrypted keyfile\n   java DESTest -decrypt encrypted decrypted keyfile\n*/\npublic class DESTest\n{\n   private static void usage() {\n      System.err.print(\n          \"This program tests the javax.crypto DES cipher package.\\n\"\n        + \"usage: java DESTest -genkey keyfile\\n\"\n        + \"java DESTest -encrypt plaintext encrypted keyfile\\n\"\n        + \"java DESTest -decrypt encrypted decrypted keyfile\\n\"\n      );\n   }\n\n   public static void main(String[] args) {\n      if ( args.length < 2 || args.length > 4\n        || !args[0].matches(\"-genkey|-encrypt|-decrypt\")\n      ) {\n          usage();\n          return;\n      }\n      try {\n         if (\"-genkey\".equals(args[0])) {\n            KeyGenerator keygen = KeyGenerator.getInstance(\"DES\");\n            SecureRandom random = new SecureRandom();\n            keygen.init(random);\n            SecretKey key = keygen.generateKey();\n            ObjectOutputStream out = new ObjectOutputStream(new FileOutputStream(args[1]));\n            out.writeObject(key);\n            out.close();\n         } else {\n            int mode;\n            if (\"-encrypt\".equals(args[0])) {\n               mode = Cipher.ENCRYPT_MODE;\n            } else { //-decrypt\n               mode = Cipher.DECRYPT_MODE;\n            }\n\n            ObjectInputStream keyIn = new ObjectInputStream(new FileInputStream(args[3]));\n            Key key = (Key) keyIn.readObject();\n            keyIn.close();\n\n            InputStream in = new FileInputStream(args[1]);\n            OutputStream out = new FileOutputStream(args[2]);\n            Cipher cipher = Cipher.getInstance(\"DES\");\n            cipher.init(mode, key);\n\n            crypt(in, out, cipher);\n            in.close();\n            out.close();\n         }\n      } catch (IOException exception) {\n         exception.printStackTrace();\n      } catch (GeneralSecurityException exception) {\n         exception.printStackTrace();\n      } catch (ClassNotFoundException exception) {\n         exception.printStackTrace();\n      }\n   }\n\n   /**\n      Uses a cipher to transform the bytes in an input stream\n      and sends the transformed bytes to an output stream.\n      @param in the input stream\n      @param out the output stream\n      @param cipher the cipher that transforms the bytes\n   */\n   public static void crypt(InputStream in, OutputStream out, Cipher cipher) \n      throws IOException, GeneralSecurityException\n   {\n      int blockSize = cipher.getBlockSize();\n      int outputSize = cipher.getOutputSize(blockSize);\n      byte[] inBytes = new byte[blockSize];\n      byte[] outBytes = new byte[outputSize];\n\n      int inLength = 0;;\n      boolean more = true;\n      while (more) {\n         inLength = in.read(inBytes);\n         if (inLength == blockSize) {\n            int outLength = cipher.update(inBytes, 0, blockSize, outBytes);\n            out.write(outBytes, 0, outLength);\n            System.out.println(outLength);\n         } else {\n            more = false;\n         }\n      }\n      if (inLength > 0) {\n         outBytes = cipher.doFinal(inBytes, 0, inLength);\n      } else {\n         outBytes = cipher.doFinal();\n      }\n      System.out.println(outBytes.length);\n      out.write(outBytes);\n   }\n\n}\n", "idx": 2209}
{"project": "cipher", "commit_id": "Snippet19676675_2412.java", "target": 0, "func": "cipher = Cipher.getInstance(\"AES/ECB/PKCS5Padding\");\n", "idx": 2010}
{"project": "cipher", "commit_id": "Snippet5517191_31672.java", "target": 1, "func": "KeyGenerator kgen = KeyGenerator.getInstance(\"AES\");\n          kgen.init(128);\n          key = kgen.generateKey();\n\n    byte[] ivar = new byte[]\n                      {\n                          0x00, 0x01, 0x02, 0x03, 0x04, 0x05, 0x06, 0x07, 0x08, 0x09,0x0a, 0x0b, 0x0c, 0x0d, 0x0e, 0x0f\n                  };\nAlgorithmParameterSpec params = new IvParameterSpec(ivar );\ndcipher = Cipher.getInstance(\"AES/CBC/PKCS5Padding\");\ndcipher.init(Cipher.DECRYPT_MODE, key, params );\n", "idx": 2440}
{"project": "cipher", "commit_id": "Snippet28798938_10939.java", "target": 1, "func": "    Cipher aes = Cipher.getInstance(\"AES/CBC/PKCS7Padding\");\n\n    SecretKey key = new SecretKeySpec(keyBytes, \"AES\");\n\n    // Initialize the cipher\n    aes.init(Cipher.DECRYPT_MODE, key, new IvParameterSpec(initializationVector));\n\n    guid = new String(aes.doFinal(challengeBytes));\n\n    return guid;\n", "idx": 2738}
{"project": "cipher", "commit_id": "Snippet9038298_33615.java", "target": 0, "func": "    String secretKey = \"abcdefghijklmnopqrstuvwx\";\n\n    byte[] bytes = secretKey.getBytes(\"UTF-8\");\n    SecretKey key = new SecretKeySpec(bytes, \"DESede\");\n\n    Cipher ecipher = Cipher.getInstance(\"DESede\");\n    ecipher.init(Cipher.ENCRYPT_MODE, key);\n\n    String input = \"holahola1\"; \n\n    byte[] utf8 = input.getBytes(\"UTF8\");\n    byte[] enc = ecipher.doFinal(utf8); // Encrypt\n", "idx": 2102}
{"project": "cipher", "commit_id": "Snippet13001960_36634.java", "target": 1, "func": "keyGen.initialize(1024);\nKeyPair keypair = keyGen.genKeyPair();\nPrivateKey privateKey = keypair.getPrivate();\nPublicKey publicKey = keypair.getPublic();\nCipher cipher = Cipher.getInstance(\"RSA\");\ncipher.init(Cipher.ENCRYPT_MODE, publicKey);\nbyte[] cipherData = cipher.doFinal(initkey);\n// Second level of encryption\nKeyPairGenerator keyGen1 = KeyPairGenerator.getInstance(\"RSA\");\nkeyGen1.initialize(1024);\nKeyPair keypair1 = keyGen1.genKeyPair();\nPrivateKey prvKey = keypair1.getPrivate();\nPublicKey pubKey = keypair1.getPublic();\nCipher cipher1 = Cipher.getInstance(\"RSA\");\ncipher1.init(Cipher.ENCRYPT_MODE, pubKey);\nbyte[] cipherData_new = cipher1.doFinal(cipherData);\n", "idx": 2514}
{"project": "cipher", "commit_id": "Snippet12607937_36363.java", "target": 0, "func": "public static String encrypt(String plaintext, String enctoken){\n\n    if(enctoken == null)\n        enctoken = \"sfdjf48mdfdf3054\";\n\n    String encrypted = null; \n\n    byte[] plaintextByte = EncodingUtils.getBytes(plaintext,\"UTF-8\");\n\n    byte[] hash = Connessione.md5(enctoken);\n\n    Log.i(\"ENCRYPT\", \"MD5: \"+Base64.encodeToString(hash, 0));\n\n    try {\n        Cipher cipher = Cipher.getInstance(\"DESEDE/ECB/PKCS5Padding\");\n        SecretKeySpec myKey = new SecretKeySpec(hash,\"DESede\");\n\n        cipher.init(Cipher.ENCRYPT_MODE, myKey); \n\n        try {\n            byte[] encryptedPlainText = cipher.doFinal(plaintextByte);\n\n            encrypted = Base64.encodeToString(encryptedPlainText, 0);\n\n            Log.i(\"ENCRYPT\", \"Pwd encrypted: \"+encrypted);\n\n            return encrypted;\n\n        } catch (IllegalBlockSizeException e) {\n            // TODO Auto-generated catch block\n            e.printStackTrace();\n        } catch (BadPaddingException e) {\n            // TODO Auto-generated catch block\n            e.printStackTrace();\n        }\n\n    } catch (NoSuchAlgorithmException e) {\n        // TODO Auto-generated catch block\n        e.printStackTrace();\n    } catch (NoSuchPaddingException e) {\n        // TODO Auto-generated catch block\n        e.printStackTrace();\n    } catch (InvalidKeyException e) {\n        // TODO Auto-generated catch block\n        e.printStackTrace();\n    }       \n\n    return \"\";\n}\n", "idx": 2138}
{"project": "cipher", "commit_id": "Snippet12730470_36419.java", "target": 1, "func": "package classes;\n\n\nimport java.security.NoSuchAlgorithmException;\n\nimport javax.crypto.Cipher;\nimport javax.crypto.NoSuchPaddingException;\nimport javax.crypto.spec.IvParameterSpec;\nimport javax.crypto.spec.SecretKeySpec;\n\n\npublic class MCrypt {\n\n        private String iv = \"fedcba9876543210\"; \n        private IvParameterSpec ivspec;\n        private SecretKeySpec keyspec;\n        private Cipher cipher;\n\n        private String SecretKey = \"0123456789abcdef\";\n\n        public MCrypt()\n        {\n                ivspec = new IvParameterSpec(iv.getBytes());\n\n                keyspec = new SecretKeySpec(SecretKey.getBytes(), \"AES\");\n\n                try {\n                    cipher = Cipher.getInstance(\"AES/CBC/NoPadding\");\n                } catch (NoSuchAlgorithmException e) {\n                        e.printStackTrace();\n                } catch (NoSuchPaddingException e) {\n                        e.printStackTrace();\n                }\n        }\n\n        public String encrypt(String text) throws Exception\n        {\n                if(text == null || text.length() == 0)\n                        throw new Exception(\"Empty string\");\n\n                byte[] encrypted = null;\n\n                try {\n                        cipher.init(Cipher.ENCRYPT_MODE, keyspec, ivspec);\n\n                        encrypted = cipher.doFinal(padString(text).getBytes());\n                } catch (Exception e)\n                {                       \n                        throw new Exception(\"[encrypt] \" + e.getMessage());\n                }\n\n                return bytesToHex(encrypted);\n        }\n\n        public String decrypt(String code) throws Exception\n        {\n                if(code == null || code.length() == 0)\n                        throw new Exception(\"Empty string\");\n\n                byte[] decrypted = null;\n\n                try {\n                        cipher.init(Cipher.DECRYPT_MODE, keyspec, ivspec);\n\n                        decrypted = cipher.doFinal(hexToBytes(code));\n\n                } catch (Exception e)\n                {\n                       System.out.println(e.toString());\n                }\n\n                return new String(decrypted);\n        }\n\n\n\n        public static String bytesToHex(byte[] data)\n        {\n                if (data==null)\n                {\n                        return null;\n                }\n\n                int len = data.length;\n                String str = \"\";\n                for (int i=0; i<len; i++) {\n                        if ((data[i]&0xFF)<16)\n                                str = str + \"0\" + java.lang.Integer.toHexString(data[i]&0xFF);\n                        else\n                                str = str + java.lang.Integer.toHexString(data[i]&0xFF);\n                }\n                return str;\n        }\n\n\n        public static byte[] hexToBytes(String str) {\n                if (str==null) {\n                        return null;\n                } else if (str.length() < 2) {\n                        return null;\n                } else {\n                        int len = str.length() / 2;\n                        byte[] buffer = new byte[len];\n                        for (int i=0; i<len; i++) {\n                                buffer[i] = (byte) Integer.parseInt(str.substring(i*2,i*2+2),16);\n                        }\n                        return buffer;\n                }\n        }\n\n\n\n        private static String padString(String source)\n        {\n          char paddingChar = ' ';\n          int size = 16;\n          int x = source.length() % size;\n          int padLength = size - x;\n\n          for (int i = 0; i < padLength; i++)\n          {\n                  source += paddingChar;\n          }\n\n          return source;\n        }\n}\n", "idx": 2734}
{"project": "cipher", "commit_id": "Snippet26887779_9018.java", "target": 1, "func": "// *** setup private key\n\nRSAPrivateKeySpec privateRPKS\n= new RSAPrivateKeySpec(new BigInteger(gModulusPlainS, 16), new BigInteger(privateExponentPlainS, 16));\nKeyFactory keyFactoryKF = KeyFactory.getInstance(\"RSA\");\nRSAPrivateKey gPrivateKeyRPK = (RSAPrivateKey) keyFactoryKF.generatePrivate(privateRPKS);\n\n// *** setup cipher\nCipher cipherC = Cipher.getInstance(\"RSA/ECB/PKCS1Padding\");\ncipherC.init(Cipher.DECRYPT_MODE, gPrivateKeyRPK);\n\n// *** decrypt hex-encoded cipherTxS\nbyte[] baCipherText = hexToBin(cipherTxS.getBytes());\nbyte[] baPlainText2 = cipherC.doFinal(baCipherText);\nString decryptedTextS = new String(baPlainText2);\n", "idx": 2435}
{"project": "cipher", "commit_id": "Snippet37430901_19357.java", "target": 1, "func": "public class NodeCrypto {\n\n        private String iv = \"fedcba9876543210\";//Dummy iv (CHANGE IT!)\n        private IvParameterSpec ivspec;\n        private SecretKeySpec keyspec;\n        private Cipher cipher;\n\n        private String SecretKey = \"0123456789abcdef\";//Dummy secretKey (CHANGE IT!)\n\n        public void doKey(String key)\n        {\n                ivspec = new IvParameterSpec(iv.getBytes());\n\n                key = padRight(key,16);\n\n                Log.d(\"hi\",key);\n\n                keyspec = new SecretKeySpec(key.getBytes(), \"AES\");\n\n                try {\n                        cipher = Cipher.getInstance(\"AES/CBC/NoPadding\");\n                } catch (NoSuchAlgorithmException e) {\n                        // TODO Auto-generated catch block\n                        e.printStackTrace();\n                } catch (NoSuchPaddingException e) {\n                        // TODO Auto-generated catch block\n                        e.printStackTrace();\n                }\n        }\n\n        public byte[] encrypt(String text,String key) throws Exception\n        {\n                if(text == null || text.length() == 0)\n                        throw new Exception(\"Empty string\");\n\n                doKey(key);\n\n                byte[] encrypted = null;\n\n                try {\n                        cipher.init(Cipher.ENCRYPT_MODE, keyspec, ivspec);\n\n                        encrypted = cipher.doFinal(padString(text).getBytes());\n                } catch (Exception e)\n                {                       \n                        throw new Exception(\"[encrypt] \" + e.getMessage());\n                }\n\n                return encrypted;\n        }\n\n        public byte[] decrypt(String code,String key) throws Exception\n        {\n                if(code == null || code.length() == 0)\n                        throw new Exception(\"Empty string\");\n\n                byte[] decrypted = null;\n\n                doKey(key);\n\n                try {\n                        cipher.init(Cipher.DECRYPT_MODE, keyspec, ivspec);\n\n                        decrypted = cipher.doFinal(hexToBytes(code));\n                } catch (Exception e)\n                {\n                        throw new Exception(\"[decrypt] \" + e.getMessage());\n                }\n                return decrypted;\n        }\n\n\n\n        public static String bytesToHex(byte[] data)\n        {\n                if (data==null)\n                {\n                        return null;\n                }\n\n                int len = data.length;\n                String str = \"\";\n                for (int i=0; i<len; i++) {\n                        if ((data[i]&0xFF)<16)\n                                str = str + \"0\" + java.lang.Integer.toHexString(data[i]&0xFF);\n                        else\n                                str = str + java.lang.Integer.toHexString(data[i]&0xFF);\n                }\n                return str;\n        }\n\n\n        public static byte[] hexToBytes(String str) {\n                if (str==null) {\n                        return null;\n                } else if (str.length() < 2) {\n                        return null;\n                } else {\n                        int len = str.length() / 2;\n                        byte[] buffer = new byte[len];\n                        for (int i=0; i<len; i++) {\n                                buffer[i] = (byte) Integer.parseInt(str.substring(i*2,i*2+2),16);\n                        }\n                        return buffer;\n                }\n        }\n\n\n\n        private static String padString(String source)\n        {\n          char paddingChar = ' ';\n          int size = 16;\n          int x = source.length() % size;\n          int padLength = size - x;\n\n          for (int i = 0; i < padLength; i++)\n          {\n                  source += paddingChar;\n          }\n\n          return source;\n        }\n\n        public static String padRight(String s, int n) {\n            return String.format(\"%1$-\" + n + \"s\", s);  \n          }\n}\n\n-----------------------------------------------\nfrom your activity or class call encrypt or decrypt method before saving or   retriving from SharedPreference\n", "idx": 2643}
{"project": "cipher", "commit_id": "Snippet47206693_29204.java", "target": 1, "func": " final byte[] symKeyData = DatatypeConverter.parseHexBinary(keyHex);\n final byte[] ivData = ivSalt.getBytes(Charset.forName(\"UTF-8\"));\n final byte[] encryptedMessage = DatatypeConverter.parseBase64Binary(encryptedMessageString);\n final Cipher cipher = javax.crypto.Cipher.getInstance(\"AES/GCM/NoPadding\", \"BC\");\n final SecretKeySpec symKey = new SecretKeySpec(symKeyData, \"AES\");\n final IvParameterSpec iv = new IvParameterSpec(ivData);\n cipher.init(Cipher.DECRYPT_MODE, symKey, iv);\n final byte[] encodedMessage = cipher.doFinal(encryptedMessage);\n final String message = new String(encodedMessage, Charset.forName(\"UTF-8\"));\n", "idx": 2412}
{"project": "cipher", "commit_id": "Snippet12957022_36585.java", "target": 0, "func": "public String encrypt(SecretKey key, String stringIn){\n\n    String outString = \"\";      \n\n    if (stringIn.isEmpty() || stringIn.toUpperCase().equals(\"NULL\")){\n        return \"\";\n    }\n\n\n    try {   \n\n        if (key == null)\n            key = this.key;\n\n        Cipher ecipher = Cipher.getInstance(\"DESede\");\n\n        ecipher.init(Cipher.ENCRYPT_MODE, key);\n\n        byte[] bytes = stringIn.getBytes(\"UTF8\");\n\n        byte[] encVal = ecipher.doFinal(bytes);\n\n        outString = new sun.misc.BASE64Encoder().encode(encVal);\n\n    } catch (UnsupportedEncodingException e) {\n\n        e.printStackTrace();\n\n    } catch (NoSuchAlgorithmException e) {\n\n        e.printStackTrace();\n\n    } catch (NoSuchPaddingException e) {\n\n        e.printStackTrace();\n\n    } catch (InvalidKeyException e) {\n\n        e.printStackTrace();\n\n    } catch (IOException e) {\n\n        e.printStackTrace();\n\n    } finally {\n\n        return outString;\n    }\n\n}\n", "idx": 2086}
{"project": "cipher", "commit_id": "Snippet43267874_25401.java", "target": 1, "func": "String Decrypt(String text, String key) throws Exception {\n    Cipher cipher = Cipher.getInstance(\"AES/CBC/PKCS5Padding\");\n    byte[] keyBytes = Base64.decode(key.getBytes(), Base64.DEFAULT);\n    SecretKeySpec keySpec = new SecretKeySpec(keyBytes, \"AES\");\n    byte[] b = new byte[keySpec.getEncoded().length];\n    System.arraycopy(keySpec.getEncoded(), 0, b, 0, b.length);\n    IvParameterSpec ivSpec = new IvParameterSpec(b);\n    cipher.init(Cipher.DECRYPT_MODE, keySpec, ivSpec);\n    byte[] results = cipher.doFinal(Base64.encode(text.getBytes(\"UTF-8\"), Base64.DEFAULT));\n    String  decoded = new String(cipher.doFinal(results), \"UTF-8\");\n    return decoded;\n}\n", "idx": 2559}
{"project": "cipher", "commit_id": "Snippet22567509_4965.java", "target": 1, "func": " public static String decrypt (String data, String stringKey) throws Exception {\n        JSONObject jsonKey = new JSONObject(stringKey);\n\n        BigInteger n = new BigInteger(Base64.decode(jsonKey.getString(\"n\"), Base64.DEFAULT));\n        BigInteger e = new BigInteger(\"10001\");\n        BigInteger d = new BigInteger(Base64.decode(jsonKey.getString(\"d\"), Base64.DEFAULT));\n        BigInteger p = new BigInteger(Base64.decode(jsonKey.getString(\"p\"), Base64.DEFAULT));\n        BigInteger q = new BigInteger(Base64.decode(jsonKey.getString(\"q\"), Base64.DEFAULT));\n        BigInteger dmp1 = new BigInteger(Base64.decode(jsonKey.getString(\"dmp1\"), Base64.DEFAULT));\n        BigInteger dmq1 = new BigInteger(Base64.decode(jsonKey.getString(\"dmq1\"), Base64.DEFAULT));\n        BigInteger coeff = new BigInteger(Base64.decode(jsonKey.getString(\"coeff\"), Base64.DEFAULT));\n\n\n        KeySpec privateKeySpec = new RSAPrivateCrtKeySpec(n, e, d, p, q, dmp1, dmq1, coeff);\n        KeyFactory keyFactory = KeyFactory.getInstance(\"RSA\");\n        PrivateKey privateKey = keyFactory.generatePrivate(privateKeySpec);\n\n        Cipher cipher = Cipher.getInstance(\"RSA/None/PKCS1Padding\");\n        cipher.init(Cipher.DECRYPT_MODE, privateKey);\n        byte[] dec = cipher.doFinal(data.getBytes());\n        return new String(Base64.decode(dec, Base64.DEFAULT));\n    }\n", "idx": 2748}
{"project": "cipher", "commit_id": "Snippet15882088_38864.java", "target": 1, "func": "byte[] ivdata = new byte[]{0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0};\n IvParameterSpec spec = new IvParameterSpec(ivdata);\n symetricKeyFromCard = new SecretKeySpec(symKeyData, \"AES\");\n\n Cipher cipherAes = Cipher.getInstance(\"AES/CBC/NoPadding\");\n cipherAes.init(Cipher.DECRYPT_MODE, symetricKeyFromCard, spec);\n byte[] decryptedBytes = cipherAes.doFinal(challengeEncrypted);\n", "idx": 2413}
{"project": "cipher", "commit_id": "Snippet22425951_4812.java", "target": 0, "func": "    private static byte[] encrypt(byte[] raw, byte[] clear) throws Exception {\n    SecretKeySpec skeySpec = new SecretKeySpec(raw, \"AES\");\n    Cipher cipher = Cipher.getInstance(\"AES/ECB/PKCS5Padding\");\n    cipher.init(Cipher.ENCRYPT_MODE, skeySpec);\n    byte[] encrypted = cipher.doFinal(clear);\n    return encrypted;\n}\n\n\nprivate static byte[] getRawKey(byte[] seed) throws Exception {\n    KeyGenerator kgen = KeyGenerator.getInstance(\"AES\");\n    SecureRandom sr = new SecureRandom();\n    sr.setSeed(seed);\n    kgen.init(sr); // 192 and 256 bits may not be available\n    SecretKey skey = kgen.generateKey();\n    byte[] raw = skey.getEncoded();\n    return raw;\n}\n\nprivate static byte[] decrypt(byte[] raw, byte[] encrypted) throws Exception {\n    SecretKeySpec skeySpec = new SecretKeySpec(raw, \"AES\");\n    Cipher cipher = Cipher.getInstance(\"AES/ECB/PKCS5Padding\");\n    cipher.init(Cipher.DECRYPT_MODE, skeySpec);\n    byte[] decrypted = cipher.doFinal(encrypted);\n    return decrypted;\n\n}\n", "idx": 2199}
{"project": "cipher", "commit_id": "Snippet6547214_32180.java", "target": 1, "func": "public String encrypt(String text) throws Exception\n{\n    if(text == null || text.length() == 0)\n        throw new Exception(\"Empty string\");\n\n    Cipher cipher;\n    byte[] encrypted = null;\n\n    try {\n        cipher = Cipher.getInstance(\"AES/CBC/NoPadding\");\n        cipher.init(Cipher.ENCRYPT_MODE, keyspec, ivspec);\n\n        encrypted = cipher.doFinal(padString(text).getBytes());\n    } catch (Exception e)\n    {           \n        throw new Exception(\"[encrypt] \" + e.getMessage());\n    }\n\n    return new String( encrypted );\n}\n\npublic String decrypt(String code) throws Exception\n{\n    if(code == null || code.length() == 0)\n        throw new Exception(\"Empty string\");\n\n    Cipher cipher;\n    byte[] decrypted = null;\n\n    try {\n        cipher = Cipher.getInstance(\"AES/CBC/NoPadding\");\n        cipher.init(Cipher.DECRYPT_MODE, keyspec, ivspec);\n        decrypted = cipher.doFinal(hexToBytes(code));\n    } catch (Exception e)\n    {\n        throw new Exception(\"[decrypt] \" + e.getMessage());\n    }\n    return new String( decrypted );\n}\n\n\nprivate static byte[] hexToBytes(String hex) {\n  String HEXINDEX = \"0123456789abcdef\";\n  int l = hex.length() / 2;\n  byte data[] = new byte[l];\n  int j = 0;\n\n  for (int i = 0; i < l; i++) {\n    char c = hex.charAt(j++);\n    int n, b;\n\n    n = HEXINDEX.indexOf(c);\n    b = (n & 0xf) << 4;\n    c = hex.charAt(j++);\n    n = HEXINDEX.indexOf(c);\n    b += (n & 0xf);\n    data[i] = (byte) b;\n  }\n\n  return data;\n}\n\nprivate static String padString(String source)\n{\n  char paddingChar = ' ';\n  int size = 16;\n  int x = source.length() % size;\n  int padLength = size - x;\n\n  for (int i = 0; i < padLength; i++)\n  {\n      source += paddingChar;\n  }\n\n  return source;\n}\n", "idx": 2581}
{"project": "cipher", "commit_id": "Snippet6831033_32383.java", "target": 1, "func": "private static final int IO_BUFFER_SIZE = 4 * 1024;\n@Override\npublic void onCreate(Bundle savedInstanceState){\n    super.onCreate(savedInstanceState);\n    setContentView(R.layout.main);\n\n            try {\n                AssetManager am = this.getAssets();\n                InputStream is = am.open(\"2000_1.jpg_encrypted\"); // get the encrypted image from assets folder\n\n                ByteArrayOutputStream baos = new ByteArrayOutputStream();  \n                byte[] b = new byte[IO_BUFFER_SIZE];  \n                int read;  \n                while ((read = is.read(b)) != -1) {  //convert inputstream to bytearrayoutputstream\n                    baos.write(b, 0, read);\n                }                           \n                //START\n                long start = System.currentTimeMillis()/1000L; // start\n\n                //byte[] keyStart = \"MARTIN_123_MARTIN_123\".getBytes();  // specific key value \n                KeyGenerator kgen = KeyGenerator.getInstance(\"AES/CBC/PKCS5Padding\");   //aes\n                SecureRandom sr = SecureRandom.getInstance(\"SHA1PRNG\");\n                //sr.setSeed(keyStart);\n                kgen.init(128, sr); \n                //SecretKey skey = kgen.generateKey();\n                //byte[] key = skey.getEncoded();    \n\n                byte[] key = \"MARTIN_123_MARTIN_123\".getBytes(\"UTF-8\");\n                byte[] iv = \"1234567890123456\".getBytes(\"UTF-8\");\n                byte[] decryptedData = decrypt(key, iv, b);\n\n\n                //END\n                long end = System.currentTimeMillis()/1000L;    // end\n                Log.d(\"TEST\",\"Time start \"+ String.valueOf(start)); //showing the strat in ms\n                Log.d(\"TEST\",\"Time end \"+ String.valueOf(end));     //showing the end in ms\n\n                Bitmap bitmap = BitmapFactory.decodeByteArray(decryptedData , 0, decryptedData .length);    //decoding bytearrayoutputstream to bitmap\n                //String filepath = Environment.getExternalStorageDirectory()+\"bitmap\";\n                FileOutputStream fos = new FileOutputStream(\"sdcard/DCIM/100ANDRO\");\n                fos.write(decryptedData);\n                fos.close();\n\n                is.close(); // close the inputstream\n                baos.close(); // close the bytearrayoutputstream\n            }\n            catch(Exception e){\n                e.fillInStackTrace();\n            }\n        } \n\n        //decrypt\n        private byte[] decrypt(byte[] raw, byte[] iv, byte[] encrypted) throws Exception {\n      SecretKeySpec skeySpec = new SecretKeySpec(raw, \"AES\");\n      Cipher cipher = Cipher.getInstance(\"AES/CBC/PKCS5Padding\");\n      IvParameterSpec ivspec = new IvParameterSpec(iv);         \n      cipher.init(Cipher.DECRYPT_MODE, skeySpec, ivspec);\n      byte[] decrypted = cipher.doFinal(encrypted);\n\n      return decrypted;\n    }\n", "idx": 2681}
{"project": "cipher", "commit_id": "Snippet27530102_9650.java", "target": 0, "func": "public class StrongAES {\n            public void encrypt_Data(){\n\n        }\n\n    public String decrypt_Data(byte[] cipherText, int ctLength) throws InvalidAlgorithmParameterException{\n\n        Security.addProvider(new org.bouncycastle.jce.provider.BouncyCastleProvider());\n\n        byte[] keyBytes = new byte[] {'T', 'h', 'i', 's', 'I', 's', 'A', 'S', 'e', 'c', 'r', 'e', 't', 'K', 'e', 'y'};\n        SecretKeySpec key = new SecretKeySpec(keyBytes, \"AES\");\n        System.out.println(\"byte length - \"+cipherText.length);\n        Cipher cipher;\n        byte[] plainText = null;\n        try {\n            cipher = Cipher.getInstance(\"AES/ECB/PKCS7Padding\",\"BC\");\n            cipher.init(Cipher.DECRYPT_MODE, key);\n\n            //decrypt\n            plainText = new byte[cipher.getOutputSize(ctLength)];\n            System.out.println(\"cipherText - \"+cipherText+\" ctLength - \"+ctLength+\" plainText - \"+plainText);\n            int ptLength = cipher.update(cipherText, 0, ctLength, plainText,0);\n            System.out.println(\"ptLength - \"+ptLength);\n\n            ptLength += cipher.doFinal(plainText, ptLength);\n\n            return new String(plainText);\n", "idx": 2140}
{"project": "cipher", "commit_id": "Snippet27296571_9469.java", "target": 1, "func": "Cipher cipher = null;\ntry {\n    cipher = Cipher.getInstance(\"RSA/ECB/NoPadding\");\n} catch (NoSuchAlgorithmException e) {\n    cipher = Cipher.getInstance(\"RSA/NONE/NoPadding\");\n}\n", "idx": 2758}
{"project": "cipher", "commit_id": "Snippet27966940_10024.java", "target": 1, "func": "Cipher c = Cipher.getInstance(\"RSA\");\nc.init(Cipher.DECRYPT_MODE,_clientPrivateKey);\nbyte [] r = c..doFinal(encrypted);\n", "idx": 2667}
{"project": "cipher", "commit_id": "Snippet43467590_25578.java", "target": 0, "func": "    mVideoView.requestFocus();\n    mVideoView.setOnCompletionListener(new MediaPlayer.OnCompletionListener() {\n\n        @Override\n        public void onCompletion(MediaPlayer mp) {\n            finish();\n        }\n    });\n\n    try{\n        byte k[] = \"SomeKey\".getBytes();\n        SecretKeySpec skey = new SecretKeySpec(k,\"DES\");\n        Cipher cipher = Cipher.getInstance(\"DES/ECB/NoPadding\");\n        cipher.init(Cipher.DECRYPT_MODE, skey);\n\n        Licensing.allow(this);\n        mServer = new LocalSingleHttpServer();\n\n        mServer.setCipher(cipher);\n        mServer.start();\n\n        String serverPath = mServer.getURL(path);\n        mVideoView.setVideoPath(serverPath);\n        mVideoView.setMediaController(new MediaController(this));\n        mVideoView.start();\n\n    }catch(Exception e){\n        Toast.makeText(this,e.getMessage()+\" sometext\",Toast.LENGTH_LONG).show();\n        Log.e(\"e.getMessage()\",e.getMessage());\n        e.printStackTrace();\n    }\n\n    mVideoView.setMediaController(null);\n", "idx": 2171}
{"project": "cipher", "commit_id": "Snippet22299371_4699.java", "target": 1, "func": "private void stripHeaders(){\n\n    public_key = public_key.replace(\"-----BEGIN PUBLIC KEY-----\", \"\");\n    public_key = public_key.replace(\"-----END PUBLIC KEY-----\", \"\");\n\n}\n\npublic byte[] encryptWithPublicKey(String encrypt) throws Exception {\n    byte[] message = encrypt.getBytes(\"UTF-8\");\n    stripHeaders(); \n    PublicKey apiPublicKey= getRSAPublicKeyFromString(); \n    Cipher rsaCipher = Cipher.getInstance(\"RSA/None/PKCS1Padding\", \"SC\");\n    rsaCipher.init(Cipher.ENCRYPT_MODE, apiPublicKey); \n    return rsaCipher.doFinal(message);\n}\n\nprivate PublicKey getRSAPublicKeyFromString() throws Exception{\n    KeyFactory keyFactory = KeyFactory.getInstance(\"RSA\", \"SC\"); \n    byte[] publicKeyBytes = Base64.decode(public_key.getBytes(\"UTF-8\"), Base64.DEFAULT); \n    X509EncodedKeySpec x509KeySpec = new X509EncodedKeySpec(publicKeyBytes); \n    return keyFactory.generatePublic(x509KeySpec);\n}\n", "idx": 2718}
{"project": "cipher", "commit_id": "Snippet16240013_39195.java", "target": 1, "func": "try {\n\n        String encryptionKey = \"1234567890123456\";\n        String plaintext = \"1234567890123456\";\n\n        System.out.println(\"key:   \" + encryptionKey);\n        System.out.println(\"plain:   \" + plaintext);\n        byte[] a = aes.encrypt(plaintext, encryptionKey);\n        String b = new String(a);\n        byte[] c = b.getBytes();\n\n        String decrypted = new String(aes.decrypt(c, encryptionKey));\n\n        System.out.println(\"decrypt: \" + decrypted);\n\n    } catch (Exception e) {\n      e.printStackTrace();\n    } \n}\n\n\npublic byte[] encrypt(String plainText, String encryptionKey) throws Exception {\n    Cipher cipher = Cipher.getInstance(\"AES/CBC/NoPadding\");\n    SecretKeySpec key = new SecretKeySpec(encryptionKey.getBytes(), \"AES\");\n    cipher.init(Cipher.ENCRYPT_MODE, key,new IvParameterSpec(IV.getBytes()));\n    return cipher.doFinal(plainText.getBytes());\n}\n", "idx": 2446}
{"project": "cipher", "commit_id": "Snippet46992584_28995.java", "target": 1, "func": "        byte[] keyPass = pass.getBytes(\"ASCII\");\n        byte[] aesIV = new byte[16];\n        byte[] Decryptdata = Base64.decode(encodedString, Base64.NO_WRAP);\n        System.arraycopy(Decryptdata, 0, aesIV, 0, 16);\n        byte[] data = new byte[Decryptdata.length - 16];\n        System.arraycopy(Decryptdata, 16, data, 0, dataToDecrypt.length - 16);\n        Key aesKey = new SecretKeySpec(keyPass, \"AES\");\n        IvParameterSpec ivSpec = new IvParameterSpec(aesIV);\n        Cipher cipher = Cipher.getInstance(\"AES/CBC/PKCS7Padding\");\n        cipher.init(Cipher.DECRYPT_MODE, aesKey, ivSpec);\n        Text = new String(cipher.doFinal(data), \"UTF-8\");\n", "idx": 2365}
{"project": "cipher", "commit_id": "Snippet32162887_14264.java", "target": 1, "func": "      String key = \"HkJHBKJBvffdbv\";\n      String IV= \"qjfghftrsbdghzir\";\n      String theMessageToCifer =\"your message\";\n\n      SecretKeySpec secretKeySpec = new SecretKeySpec(key.getBytes(), \"AES\");\n\n      IvParameterSpec ivSpec = new IvParameterSpec(IV.getBytes());\n      try{\n\n      //specify your mode\n      Cipher cipher = Cipher.getInstance(\"AES/CTR/NoPadding\");\n      cipher.init(Cipher.ENCRYPT_MODE, secretKeySpec,ivSpec);\n\n      encrypted = cipher.doFinal(theMessageToCifer.getBytes());\n\n      bytesEncoded = Base64.encode(encrypted);\n      System.out.println(\" base64 code \" +bytesEncoded);\n      System.out.println(\"encrypted string: \" +encrypted);\n      // decryption\n      cipher.init(Cipher.DECRYPT_MODE, secretKeySpec,ivSpec);\n      byte[] original = cipher.doFinal(encrypted);\n      String originalString = new String(original);\n      System.out.println(\"Original string: \" + originalString );\n      }catch (Exception e){\n         e.printStackTrace();\n      }   \n", "idx": 2467}
{"project": "cipher", "commit_id": "Snippet21496467_3987.java", "target": 0, "func": "import java.security.SecureRandom;\nimport javax.crypto.Cipher;\nimport javax.crypto.KeyGenerator;\nimport javax.crypto.SecretKey;\nimport javax.crypto.spec.SecretKeySpec;\nimport android.util.Base64;\n\npublic class EncodeDecodeAES {\n\n    private final static String HEX = \"0123456789ABCDEF\";\n    private final static String key = \"encryptionKey\"\n    private final static int JELLY_BEAN_4_2 = 17;\n\n    private final static byte[] key = { 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0 };\n\n    public static String encrypt(String cleartext) throws Exception {\n        return encrypt(key,cleartext);\n    }\n\n    public static String decrypt(String cleartext) throws Exception {\n        return decrypt(key,cleartext);\n    }\n\n    public static String encrypt(String seed, String cleartext) throws Exception {\n\n        byte[] rawKey = getRawKey(seed.getBytes());\n        byte[] result = encrypt(rawKey, cleartext.getBytes());\n        String fromHex = toHex(result);\n        String base64 = new String(Base64.encodeToString(fromHex.getBytes(), 0));\n        return base64;\n    }     \n\n    public static String decrypt(String seed, String encrypted) throws Exception {\n\n        byte[] seedByte = seed.getBytes();\n        System.arraycopy(seedByte, 0, key, 0, ((seedByte.length < 16) ? seedByte.length : 16));\n        String base64 = new String(Base64.decode(encrypted, 0));\n        byte[] rawKey = getRawKey(seedByte);\n        byte[] enc = toByte(base64);\n        byte[] result = decrypt(rawKey, enc);\n        return new String(result);\n    }\n\n    public static byte[] encryptBytes(String seed, byte[] cleartext) throws Exception {\n\n        byte[] rawKey = getRawKey(seed.getBytes());\n        byte[] result = encrypt(rawKey, cleartext);\n        return result;\n    }\n\n\n    public static byte[] decryptBytes(String seed, byte[] encrypted) throws Exception {\n\n        byte[] rawKey = getRawKey(seed.getBytes());\n        byte[] result = decrypt(rawKey, encrypted);\n        return result;\n\n    }\n\n    private static byte[] getRawKey(byte[] seed) throws Exception {\n\n        KeyGenerator kgen = KeyGenerator.getInstance(\"AES\"); // , \"SC\");\n        SecureRandom sr = null;\n        if (android.os.Build.VERSION.SDK_INT >= JELLY_BEAN_4_2) {\n         sr = SecureRandom.getInstance(\"SHA1PRNG\", \"Crypto\");\n        } else {\n         sr = SecureRandom.getInstance(\"SHA1PRNG\");\n        }\n        sr.setSeed(seed);\n        try {\n         kgen.init(256, sr);\n         // kgen.init(128, sr);\n        } catch (Exception e) {\n         // Log.w(LOG, \"This device doesn't suppor 256bits, trying 192bits.\");\n         try {\n          kgen.init(192, sr);\n         } catch (Exception e1) {\n          // Log.w(LOG, \"This device doesn't suppor 192bits, trying 128bits.\");\n          kgen.init(128, sr);\n         }\n       }\n        SecretKey skey = kgen.generateKey();\n        byte[] raw = skey.getEncoded();\n        return raw;\n    }\n    private static byte[] encrypt(byte[] raw, byte[] clear) throws Exception {\n\n        SecretKeySpec skeySpec = new SecretKeySpec(raw, \"AES\");\n        Cipher cipher = Cipher.getInstance(\"AES\"); // /ECB/PKCS7Padding\", \"SC\");\n        cipher.init(Cipher.ENCRYPT_MODE, skeySpec);\n        byte[] encrypted = cipher.doFinal(clear);\n        return encrypted;\n    }\n\n    private static byte[] decrypt(byte[] raw, byte[] encrypted) throws Exception {\n\n        SecretKeySpec skeySpec = new SecretKeySpec(raw, \"AES\");\n        Cipher cipher = Cipher.getInstance(\"AES\"); // /ECB/PKCS7Padding\", \"SC\");\n        cipher.init(Cipher.DECRYPT_MODE, skeySpec);\n        byte[] decrypted = cipher.doFinal(encrypted);\n        return decrypted;\n    }\n\n    public static String toHex(String txt) {\n        return toHex(txt.getBytes());\n    }\n\n    public static String fromHex(String hex) {\n\n        return new String(toByte(hex));\n    }\n\n\n    public static byte[] toByte(String hexString) {\n\n        int len = hexString.length() / 2;\n        byte[] result = new byte[len];\n        for (int i = 0; i < len; i++)\n            result[i] = Integer.valueOf(hexString.substring(2 * i, 2 * i + 2), 16).byteValue();\n        return result;\n    }\n\n\n    public static String toHex(byte[] buf) {\n\n        if (buf == null)\n            return \"\";\n        StringBuffer result = new StringBuffer(2 * buf.length);\n        for (int i = 0; i < buf.length; i++) {\n            appendHex(result, buf[i]);\n        }\n        return result.toString();\n    }\n\n    private static void appendHex(StringBuffer sb, byte b) {\n        sb.append(HEX.charAt((b >> 4) & 0x0f)).append(HEX.charAt(b & 0x0f));\n    }\n\n}\n", "idx": 2062}
{"project": "cipher", "commit_id": "Snippet24841795_7165.java", "target": 0, "func": "public static byte[] encrypt(String passphrase, byte[] data) throws Exception {\n\n    // Hash the ASCII-encoded passphrase with md5\n\n    byte[] keyData = passphrase.getBytes(Charset.forName(\"US-ASCII\"));\n    MessageDigest md = MessageDigest.getInstance(\"MD5\");\n    byte [] md5HashOfKey = md.digest(keyData);\n\n    // Need to use bouncycastle (spongycastle on Android) to get RC2\n\n    Security.addProvider(new BouncyCastleProvider());\n\n    Cipher rc2 = Cipher.getInstance(\"RC2/CBC/PKCS5PADDING\");\n\n    // Create an RC2 40-bit key from the 1st 5 bytes of the hash.\n\n    SecretKeySpec rc2KeySpec = new SecretKeySpec(md5HashOfKey, 0, 5, \"RC2\");\n    rc2.init(Cipher.ENCRYPT_MODE, rc2KeySpec);\n\n    byte [] cipher = rc2.doFinal(data);\n\n    return cipher;\n}\n", "idx": 2107}
{"project": "cipher", "commit_id": "Snippet20142612_2807.java", "target": 1, "func": "import java.io.BufferedOutputStream;\nimport java.io.FileOutputStream;\nimport java.io.IOException;\nimport java.io.ObjectOutputStream;\nimport java.io.UnsupportedEncodingException;\nimport java.math.BigInteger;\nimport java.security.InvalidKeyException;\nimport java.security.KeyFactory;\nimport java.security.KeyPair;\nimport java.security.KeyPairGenerator;\nimport java.security.NoSuchAlgorithmException;\nimport java.security.PublicKey;\nimport java.security.spec.InvalidKeySpecException;\nimport java.security.spec.RSAPrivateKeySpec;\nimport java.security.spec.RSAPublicKeySpec;\nimport java.util.logging.Level;\nimport java.util.logging.Logger;\nimport javax.crypto.BadPaddingException;\nimport javax.crypto.Cipher;\nimport javax.crypto.IllegalBlockSizeException;\nimport javax.crypto.NoSuchPaddingException;\n\nimport android.os.Environment;\n\n/**\n *\n * @author Test01\n */\npublic class Encryptor extends RSABase {\n\n    private KeyPair pair;\n    private String text;\n    public Encryptor(String text) {\n        this.text=text;\n        try {\n            KeyPairGenerator kpg=KeyPairGenerator.getInstance(\"RSA\");\n            kpg.initialize(1024);\n            pair=kpg.generateKeyPair();\n            KeyFactory fact=KeyFactory.getInstance(\"RSA\");\n            RSAPublicKeySpec pub=fact.getKeySpec(pair.getPublic(), RSAPublicKeySpec.class);\n            RSAPrivateKeySpec priv=fact.getKeySpec(pair.getPrivate(), RSAPrivateKeySpec.class);\n            saveKeyToFile(Environment.getExternalStorageDirectory()+\"/public.key\", pub.getModulus(), pub.getPublicExponent());\n            saveKeyToFile(Environment.getExternalStorageDirectory()+\"/private.key\", priv.getModulus(), priv.getPrivateExponent());\n        } catch (NoSuchAlgorithmException ex) {\n            Logger.getLogger(Encryptor.class.getName()).log(Level.SEVERE, null, ex);\n        } catch (InvalidKeySpecException ex) {\n            Logger.getLogger(Encryptor.class.getName()).log(Level.SEVERE, null, ex);\n        }\n    }\n    private void saveKeyToFile(String filename, BigInteger mod, BigInteger exp){\n        ObjectOutputStream fileOut=null;\n        try {\n            fileOut = new ObjectOutputStream(new BufferedOutputStream(new FileOutputStream(filename)));\n            fileOut.writeObject(mod);\n            fileOut.writeObject(exp);\n        } catch (IOException ex) {\n            Logger.getLogger(Encryptor.class.getName()).log(Level.SEVERE, null, ex);\n        }finally{\n            try {\n                fileOut.close();\n            } catch (IOException ex) {\n                Logger.getLogger(Encryptor.class.getName()).log(Level.SEVERE, null, ex);\n            }\n        }\n    }\n    public String encrypt(){\n        byte[] encrypted=null;\n        try {\n            byte[] encryptable=text.getBytes(\"UTF-8\");\n            PublicKey key=pair.getPublic();\n            Cipher cipher=Cipher.getInstance(\"RSA\");\n            cipher.init(Cipher.ENCRYPT_MODE, key);\n            encrypted=cipher.doFinal(encryptable);\n        } catch (UnsupportedEncodingException ex) {\n            Logger.getLogger(Encryptor.class.getName()).log(Level.SEVERE, null, ex);\n        } catch (NoSuchAlgorithmException ex) {\n            Logger.getLogger(Encryptor.class.getName()).log(Level.SEVERE, null, ex);\n        } catch (NoSuchPaddingException ex) {\n            Logger.getLogger(Encryptor.class.getName()).log(Level.SEVERE, null, ex);\n        } catch (InvalidKeyException ex) {\n            Logger.getLogger(Encryptor.class.getName()).log(Level.SEVERE, null, ex);\n        } catch (IllegalBlockSizeException ex) {\n            Logger.getLogger(Encryptor.class.getName()).log(Level.SEVERE, null, ex);\n        } catch (BadPaddingException ex) {\n            Logger.getLogger(Encryptor.class.getName()).log(Level.SEVERE, null, ex);\n        }\n        return toHexString(encrypted);\n    }\n}\n", "idx": 2739}
{"project": "cipher", "commit_id": "Snippet44743501_26831.java", "target": 0, "func": "public class AESHelper {\n\npublic static String encrypt(String seed, String cleartext) throws Exception {\n    byte[] rawKey = getRawKey(seed.getBytes());\n    byte[] result = encrypt(rawKey, cleartext.getBytes());\n    return toHex(result);\n}\n\npublic static String decrypt(String seed, String encrypted) throws Exception {\n    byte[] rawKey = getRawKey(seed.getBytes());\n    byte[] enc = toByte(encrypted);\n    byte[] result = decrypt(rawKey, enc);\n    return new String(result);\n}\n\nprivate static byte[] getRawKey(byte[] seed) throws Exception {\n    KeyGenerator kgen = KeyGenerator.getInstance(\"AES\");\n    SecureRandom sr = SecureRandom.getInstance(\"SHA1PRNG\",\"Crypto\");\n    sr.setSeed(seed);\n    kgen.init(128, sr); // 192 and 256 bits may not be available\n    SecretKey skey = kgen.generateKey();\n    byte[] raw = skey.getEncoded();\n    return raw;\n}\n\n\nprivate static byte[] encrypt(byte[] raw, byte[] clear) throws Exception {\n    SecretKeySpec skeySpec = new SecretKeySpec(raw, \"AES\");\n    Cipher cipher = Cipher.getInstance(\"AES\");\n    cipher.init(Cipher.ENCRYPT_MODE, skeySpec);\n    byte[] encrypted = cipher.doFinal(clear);\n    return encrypted;\n}\n\nprivate static byte[] decrypt(byte[] raw, byte[] encrypted) throws Exception {\n    SecretKeySpec skeySpec = new SecretKeySpec(raw, \"AES\");\n    Cipher cipher = Cipher.getInstance(\"AES\");\n    cipher.init(Cipher.DECRYPT_MODE, skeySpec);\n    byte[] decrypted = cipher.doFinal(encrypted);\n    return decrypted;\n}\n\npublic static String toHex(String txt) {\n    return toHex(txt.getBytes());\n}\npublic static String fromHex(String hex) {\n    return new String(toByte(hex));\n}\n\npublic static byte[] toByte(String hexString) {\n    int len = hexString.length()/2;\n    byte[] result = new byte[len];\n    for (int i = 0; i < len; i++)\n        result[i] = Integer.valueOf(hexString.substring(2*i, 2*i+2), 16).byteValue();\n    return result;\n}\n\npublic static String toHex(byte[] buf) {\n    if (buf == null)\n        return \"\";\n    StringBuffer result = new StringBuffer(2*buf.length);\n    for (int i = 0; i < buf.length; i++) {\n        appendHex(result, buf[i]);\n    }\n    return result.toString();\n}\nprivate final static String HEX = \"0123456789ABCDEF\";\nprivate static void appendHex(StringBuffer sb, byte b) {\n    sb.append(HEX.charAt((b>>4)&0x0f)).append(HEX.charAt(b&0x0f));\n}\n", "idx": 2122}
{"project": "cipher", "commit_id": "Snippet41562408_23480.java", "target": 1, "func": "public static byte[] decrypt(byte[] key, byte[] initVector, byte[] encryptedValue) {\n\n    try {\n\n        IvParameterSpec iv = new IvParameterSpec(initVector);\n        SecretKeySpec skeySpec = new SecretKeySpec(key, \"AES\");\n\n        Cipher cipher = Cipher.getInstance(\"AES/CBC/NOPADDING\");\n        cipher.init(Cipher.DECRYPT_MODE, skeySpec, iv);\n\n        byte[] original = cipher.doFinal(encryptedValue);\n\n        return original;\n    } catch (Exception ex) {\n        Logger.getLogger(MainGUI.class.getName()).log(Level.SEVERE, null, ex);\n    }\n\n    return null;\n}\n...\nbyte[] encpryted = Base64.getDecoder().decode(rd.readLine());\nbyte[] iv = Base64.getDecoder().decode(rd.readLine());\nbyte[] key = Base64.getDecoder().decode(rd.readLine());\n\nbyte[] output = decrypt(key, iv, encpryted);\n", "idx": 2444}
{"project": "cipher", "commit_id": "Snippet21155095_3714.java", "target": 1, "func": "public static byte[] encrypt(String value) {\n        byte[] encrypted = null;\n        try {\n\n            byte[] raw = new byte[]{'T', 'h', 'i', 's', 'I', 's', 'A', 'S', 'e', 'c', 'r', 'e', 't', 'K', 'e', 'y'};\n            Key skeySpec = new SecretKeySpec(raw, \"AES\");\n            Cipher cipher = Cipher.getInstance(\"AES/CBC/PKCS5Padding\");\n            byte[] iv = new byte[cipher.getBlockSize()];\n\n            IvParameterSpec ivParams = new IvParameterSpec(iv);\n            cipher.init(Cipher.ENCRYPT_MODE, skeySpec,ivParams);\n            encrypted  = cipher.doFinal(value.getBytes());\n            System.out.println(\"encrypted string:\" + encrypted.length);\n\n        } catch (Exception ex) {\n            ex.printStackTrace();\n        }\n        return encrypted;\n    }\n\n    public static  byte[]  decrypt(byte[] encrypted) {\n         byte[] original = null;\n         Cipher cipher = null;\n        try {\n            byte[] raw = new byte[]{'T', 'h', 'i', 's', 'I', 's', 'A', 'S', 'e', 'c', 'r', 'e', 't', 'K', 'e', 'y'};\n            Key key = new SecretKeySpec(raw, \"AES\");\n            cipher = Cipher.getInstance(\"AES/CBC/PKCS5Padding\");\n            //the block size (in bytes), or 0 if the underlying algorithm is not a block cipher\n            byte[] ivByte = new byte[cipher.getBlockSize()];\n            //This class specifies an initialization vector (IV). Examples which use\n            //IVs are ciphers in feedback mode, e.g., DES in CBC mode and RSA ciphers with OAEP encoding operation.\n            IvParameterSpec ivParamsSpec = new IvParameterSpec(ivByte);\n            cipher.init(Cipher.DECRYPT_MODE, key, ivParamsSpec);\n            original= cipher.doFinal(encrypted);\n        } catch (Exception ex) {\n            ex.printStackTrace();\n        }\n        return original;\n    }  \n", "idx": 2616}
{"project": "cipher", "commit_id": "Snippet20043095_2686.java", "target": 1, "func": "private static byte[] unwrapKey(byte[] toUnwrap, String key) throws Exception {\n    byte[] decoded = Base64.decode(toUnwrap);\n    if (decoded == null || decoded.length <= 16) {\n        throw new RuntimeException(\"Bad input data.\");\n    }\n    byte[] salt = new byte[16];\n    byte[] wrappedKey = new byte[decoded.length - 16];\n    System.arraycopy(decoded, 0, salt, 0, 16);\n    System.arraycopy(decoded, 16, wrappedKey, 0, decoded.length - 16);\n    PBEKeySpec pbeKeySpec = new PBEKeySpec(key.toCharArray());\n    SecretKey wrapperKey = SecretKeyFactory.getInstance(\"PBEWITHSHA256AND256BITAES-CBC-BC\").generateSecret(pbeKeySpec);\n    PBEParameterSpec parameterSpec = new PBEParameterSpec(salt, 10);\n    Cipher decCipher = Cipher.getInstance(\"AES/GCM/NoPadding\", bcProvider);\n    decCipher.init(Cipher.UNWRAP_MODE, wrapperKey, parameterSpec);\n    return decCipher.unwrap(wrappedKey, \"AES\", Cipher.SECRET_KEY).getEncoded();\n}\n", "idx": 2550}
{"project": "cipher", "commit_id": "Snippet34349335_16324.java", "target": 0, "func": "private static final String ALGO = \"AES\";\nprivate static final byte[] keyValue = new byte[] { 'o', 'n', 'e', 'n','e', 't', 'e','d', 'o', 'c', 'e', 'i', 'r', 's', 'r', 'p' };\n    public static String decrypt(String encryptedData){\n        String decryptedValue = null;\n        try{\n        Key key = generateKey();\n        Cipher c = Cipher.getInstance(ALGO);\n        c.init(Cipher.DECRYPT_MODE, key);\n        byte[] decordedValue = new BASE64Decoder().decodeBuffer(encryptedData);\n        byte[] decValue = c.doFinal(decordedValue);\n        decryptedValue = new String(decValue);\n    }catch(Exception e){\n        //LOGGER.error(\"In TD:\" + e);\n        //Teneno_StartupService.loadForConnectionFailed();\n    }\n    return decryptedValue;\n}\nprivate static Key generateKey(){\n    Key key = new SecretKeySpec(keyValue, ALGO);\n    return key;\n}\n", "idx": 2201}
{"project": "cipher", "commit_id": "Snippet34692737_16692.java", "target": 0, "func": "import java.security.InvalidAlgorithmParameterException;\nimport java.security.InvalidKeyException;\nimport java.security.NoSuchAlgorithmException;\nimport javax.crypto.BadPaddingException;\nimport javax.crypto.Cipher;\nimport javax.crypto.IllegalBlockSizeException;\nimport javax.crypto.NoSuchPaddingException;\nimport javax.crypto.spec.IvParameterSpec;\nimport javax.crypto.spec.SecretKeySpec;\n\npublic class Security {\n    private static byte[] IV_64 = new byte[] { 0, 0, 0, 0, 0, 0, 0, 0 };\n    private static byte[] KEY_64 = new byte[] { 7, 1, 7, 7, 5, 5, 4, 7 };\n\n    private static String KEY_TYPE = \"DES\";\n    private static String ALGORITHM = \"DES/CBC/PKCS5Padding\";\n\n    public static String GetString(byte[] value) {\n        StringBuilder builder = new StringBuilder();\n        for (byte i : value) {\n            builder.append(String.format(\"%02X\", i & 0xff));\n        }\n        return builder.toString();\n    }\n\n    public static byte[] GetByte(String value) {\n        StringBuilder builder = new StringBuilder();\n        for (char i : value.toCharArray()) {\n            builder.append(String.format(\"%02X\", i & 0xff));\n        }\n        return String.valueOf(builder).getBytes();\n    }\n\n    public static byte[] Encrypt(byte[] value) {\n        try {\n            Cipher cipher = Cipher.getInstance(ALGORITHM);\n            cipher.init(Cipher.ENCRYPT_MODE, new SecretKeySpec(KEY_64, KEY_TYPE), new IvParameterSpec(IV_64));\n            return cipher.doFinal(value);\n        } catch (InvalidKeyException e) {\n            e.printStackTrace();\n        } catch (InvalidAlgorithmParameterException e) {\n            e.printStackTrace();\n        } catch (NoSuchAlgorithmException e) {\n            e.printStackTrace();\n        } catch (NoSuchPaddingException e) {\n            e.printStackTrace();\n        } catch (BadPaddingException e) {\n            e.printStackTrace();\n        } catch (IllegalBlockSizeException e) {\n            e.printStackTrace();\n        }\n        return null;\n    }\n\n    public static byte[] Decrypt(byte[] value) {\n        try {\n            Cipher cipher = Cipher.getInstance(ALGORITHM);\n            cipher.init(Cipher.DECRYPT_MODE, new SecretKeySpec(KEY_64, KEY_TYPE), new IvParameterSpec(IV_64));\n            return cipher.doFinal(value);\n        } catch (InvalidKeyException e) {\n            e.printStackTrace();\n        } catch (InvalidAlgorithmParameterException e) {\n            e.printStackTrace();\n        } catch (NoSuchAlgorithmException e) {\n            e.printStackTrace();\n        } catch (NoSuchPaddingException e) {\n            e.printStackTrace();\n        } catch (BadPaddingException e) {\n            e.printStackTrace();\n        } catch (IllegalBlockSizeException e) {\n            e.printStackTrace();\n        }\n        return null;\n    }\n}\n", "idx": 1971}
{"project": "cipher", "commit_id": "Snippet31515636_13661.java", "target": 0, "func": "public class Anything\n{\n    private static final String ALGO = \"AES\";\n    //generate 128bit key\n    private static final String keyStr = \"Z8LSq0wWwB5v+6YJzurcP463H3F12iZh74fDj4S74oUH4EONkiKb2FmiWUbtFh97GG/c/lbDE47mvw6j94yXxKHOpoqu6zpLKMKPcOoSppcVWb2q34qENBJkudXUh4MWcreondLmLL2UyydtFKuU9Sa5VgY/CzGaVGJABK2ZR94=\";\n\n    private static Key generateKey() throws Exception {\n        byte[] keyValue = keyStr.getBytes(\"UTF-8\");\n        MessageDigest sha = MessageDigest.getInstance(\"SHA-1\");\n        keyValue = sha.digest(keyValue);\n        keyValue = Arrays.copyOf(keyValue, 16); // use only first 128 bit       \n        Key key = new SecretKeySpec(keyValue, ALGO);\n        return key;\n    }\n\n    public static String encrypt(String Data) throws Exception {\n            Key key = generateKey();\n            Cipher c = Cipher.getInstance(ALGO);\n            c.init(Cipher.ENCRYPT_MODE, key);\n            byte[] encVal = c.doFinal(Data.getBytes());\n            String encryptedValue = DatatypeConverter.printBase64Binary(encVal);\n            return encryptedValue;\n    }\n\n    public static String decrypt(String encryptedData) throws Exception {\n        Key key = generateKey();\n        Cipher c = Cipher.getInstance(ALGO);\n        c.init(Cipher.DECRYPT_MODE, key);       \n        byte[] decordedValue = DatatypeConverter.parseBase64Binary(encryptedData);\n        byte[] decValue = c.doFinal(decordedValue);\n        String decryptedValue = new String(decValue);\n        return decryptedValue;\n    }\n}\n", "idx": 2189}
{"project": "cipher", "commit_id": "Snippet31601344_13727.java", "target": 0, "func": "package xuggler;\n\nimport com.xuggle.mediatool.IMediaReader;\nimport com.xuggle.mediatool.IMediaWriter;\nimport com.xuggle.mediatool.MediaListenerAdapter;\nimport com.xuggle.mediatool.ToolFactory;\nimport com.xuggle.mediatool.event.IVideoPictureEvent;\nimport com.xuggle.xuggler.Global;\nimport com.xuggle.xuggler.ICodec;\n\nimport java.awt.Graphics2D;\nimport java.awt.Point;\nimport java.awt.Transparency;\nimport java.awt.image.BufferedImage;\nimport java.awt.image.ColorModel;\nimport java.awt.image.ComponentColorModel;\nimport java.awt.image.DataBuffer;\nimport java.awt.image.DataBufferByte;\nimport java.awt.image.Raster;\nimport java.awt.image.WritableRaster;\n\nimport java.io.File;\n\nimport java.security.InvalidKeyException;\nimport java.security.NoSuchAlgorithmException;\nimport java.security.SecureRandom;\n\nimport java.util.concurrent.TimeUnit;\nimport java.util.logging.Level;\nimport java.util.logging.Logger;\n\nimport javax.crypto.BadPaddingException;\nimport javax.crypto.Cipher;\nimport javax.crypto.IllegalBlockSizeException;\nimport javax.crypto.KeyGenerator;\nimport javax.crypto.NoSuchPaddingException;\nimport javax.crypto.SecretKey;\n\nimport javax.imageio.ImageIO;\n\n\npublic class DecodeAndCaptureFrames extends MediaListenerAdapter\n{\n\n // The number of seconds between frames.\n      public static final double SECONDS_BETWEEN_FRAMES = 5;\n\n  //The number of micro-seconds between frames.\n  public static final long MICRO_SECONDS_BETWEEN_FRAMES =(long)      (Global.DEFAULT_PTS_PER_SECOND * SECONDS_BETWEEN_FRAMES);\n\n  // Time of last frame write\n  private static long mLastPtsWrite = Global.NO_PTS;\n\nprivate static final double FRAME_RATE = 50;\n\nprivate static final int SECONDS_TO_RUN_FOR = 20;\n\nprivate static final String outputFilename = \"D:\\\\K.mp4\";\n\npublic static IMediaWriter writer = ToolFactory.makeWriter(outputFilename);\n//receive BufferedImage and returns its byte data\n    public static byte[] get_byte_data(BufferedImage image) {\n    WritableRaster raster = image.getRaster();\n    DataBufferByte buffer = (DataBufferByte) raster.getDataBuffer();\n    return buffer.getData();\n}\n\n\n//create new_img with the attributes of image\npublic static BufferedImage user_space(BufferedImage image) {\n    //create new_img with the attributes of image\n    BufferedImage new_img = new BufferedImage(image.getWidth(), image.getHeight(), BufferedImage.TYPE_3BYTE_BGR);\n    Graphics2D graphics = new_img.createGraphics();\n    graphics.drawRenderedImage(image, null);\n    graphics.dispose(); //release all allocated memory for this image\n    return new_img;\n}\n\npublic static BufferedImage toImage(byte[] imagebytes, int width, int height) {\n    DataBuffer buffer = new DataBufferByte(imagebytes, imagebytes.length);\n    WritableRaster raster = Raster.createInterleavedRaster(buffer, width, height,\n       3 * width, 3, new int[]{2, 1, 0}, (Point) null);\n\n    ColorModel cm = new ComponentColorModel(ColorModel.getRGBdefault().getColorSpace(), \n            false, true, Transparency.OPAQUE, DataBuffer.TYPE_BYTE);\n    return new BufferedImage(cm, raster, true, null);\n}\n\npublic static byte[] encrypt(byte[] orgnlbytes, String key) throws NoSuchPaddingException, IllegalBlockSizeException, BadPaddingException {\n    byte[] encbytes = null;\n    try {\n        Cipher cipher = Cipher.getInstance(\"AES\");\n        KeyGenerator keyGen = KeyGenerator.getInstance(\"AES\");\n        SecureRandom random = SecureRandom.getInstance(\"SHA1PRNG\");\n        // cryptograph. secure random\n        random.setSeed(key.getBytes());\n\n        keyGen.init(128, random);\n        // for example\n        SecretKey secretKey = keyGen.generateKey();\n        try {\n            cipher.init(Cipher.ENCRYPT_MODE, secretKey);\n        } catch (InvalidKeyException ex) {\n            Logger.getLogger(DecodeAndCaptureFrames.class.getName()).log(Level.SEVERE, null, ex);\n        }\n        encbytes = cipher.doFinal(orgnlbytes);\n    }\n    catch (NoSuchAlgorithmException ex) {\n        Logger.getLogger(DecodeAndCaptureFrames.class.getName()).log(Level.SEVERE, null, ex);\n    }        catch (NoSuchPaddingException ex)\n    {\n        System.out.print(\"can not encrypt buffer\");\n    }\n\n    return encbytes;\n}\n\n\n  /**\n   * The video stream index, used to ensure we display frames from one\n   * and only one video stream from the media container.\n   */\n\n  private int mVideoStreamIndex = -1;\n\n  /**\n   * Takes a media container (file) as the first argument, opens it and\n   *  writes some of it's video frames to PNG image files in the\n   *  temporary directory.\n   *\n   * @param args must contain one string which represents a filename\n   */\n\n  public static void main(String[] args)\n  {\n    // create a new mr. decode and capture frames\n\n\n    DecodeAndCaptureFrames decodeAndCaptureFrames;\n    decodeAndCaptureFrames = new DecodeAndCaptureFrames(\"D:\\\\K.mp4\");\n  } \n\n  /** Construct a DecodeAndCaptureFrames which reads and captures\n   * frames from a video file.\n   *\n   * @param filename the name of the media file to read\n   */\n\n\n  //makes reader to the file and read the data of it\n  public DecodeAndCaptureFrames(String filename)\n  {\n    // create a media reader for processing video\n\n   IMediaReader reader = ToolFactory.makeReader(filename);\n\n// stipulate that we want BufferedImages created in BGR 24bit color space\nreader.setBufferedImageTypeToGenerate(BufferedImage.TYPE_3BYTE_BGR);\n\n\n// note that DecodeAndCaptureFrames is derived from\n// MediaReader.ListenerAdapter and thus may be added as a listener\n// to the MediaReader. DecodeAndCaptureFrames implements\n// onVideoPicture().\n\nreader.addListener(this);\n\n// read out the contents of the media file, note that nothing else\n// happens here.  action happens in the onVideoPicture() method\n// which is called when complete video pictures are extracted from\n// the media source\n\nwhile (reader.readPacket() == null)\n  do {} while(false);\n  }\n\n /**\n   * Called after a video frame has been decoded from a media stream.\n   * Optionally a BufferedImage version of the frame may be passed\n   * if the calling {@link IMediaReader} instance was configured to\n   * create BufferedImages.\n   *\n   * This method blocks, so return quickly.\n   */\n\n  public void onVideoPicture(IVideoPictureEvent event)\n  {\n    try\n    {\n      // if the stream index does not match the selected stream index,\n      // then have a closer look\n\n  if (event.getStreamIndex() != mVideoStreamIndex)\n  {\n    // if the selected video stream id is not yet set, go ahead an\n    // select this lucky video stream\n\n    if (-1 == mVideoStreamIndex)\n      mVideoStreamIndex = event.getStreamIndex();\n\n    // otherwise return, no need to show frames from this video stream\n\n    else\n      return;\n  }\n\n  // if uninitialized, backdate mLastPtsWrite so we get the very\n  // first frame\n\n  if (mLastPtsWrite == Global.NO_PTS)\n    mLastPtsWrite = event.getTimeStamp() - MICRO_SECONDS_BETWEEN_FRAMES;\n\n  // if it's time to write the next frame\n\n  if (event.getTimeStamp() - mLastPtsWrite >= MICRO_SECONDS_BETWEEN_FRAMES)\n  {\n    // Make a temporary file name\n\n   // File file = File.createTempFile(\"frame\", \".jpeg\");\n\n    // write out PNG\n\n//        ImageIO.write(event.getImage(), \"png\", file);\n\n    BufferedImage orgnlimage = event.getImage();\n        orgnlimage = user_space(orgnlimage);\n        byte[] orgnlimagebytes = get_byte_data(orgnlimage);\n        byte[] encryptedbytes = encrypt(orgnlimagebytes, \"abc\");\n        BufferedImage encryptedimage = toImage(encryptedbytes, orgnlimage.getWidth(), orgnlimage.getHeight());\n\n\n        ImageIO.write(encryptedimage, \"png\", File.createTempFile(\"frame\", \".png\"));\n//         indicate file written\n\n    double seconds = ((double)event.getTimeStamp())\n      / Global.DEFAULT_PTS_PER_SECOND;\n//        System.out.printf(\"at elapsed time of %6.3f seconds wrote: %s\\n\",seconds, file);\n\n    // update last write time\n\n    mLastPtsWrite += MICRO_SECONDS_BETWEEN_FRAMES;\n  }\n}\ncatch (Exception e)\n{\n  e.printStackTrace();\n}\n  }\n\n}\n", "idx": 2179}
{"project": "cipher", "commit_id": "Snippet13556295_37101.java", "target": 1, "func": "String test =\"test\";\nbyte[] testbytes = test.getBytes();\nCipher cipher = Cipher.getInstance(\"RSA\");\ncipher.init(Cipher.ENCRYPT_MODE, publicKey);\nbyte[] cipherData = cipher.doFinal(testbytes);\nString s = new String(cipherData);\nLog.d(\"testbytes after encryption\",s);\n", "idx": 2620}
{"project": "cipher", "commit_id": "Snippet7024907_32530.java", "target": 1, "func": "package com.custom.lazylist;\n\nimport java.io.File;\nimport java.io.IOException;\nimport java.io.InputStream;\nimport java.net.HttpURLConnection;\nimport java.net.URL;\nimport java.util.HashMap;\nimport java.util.Stack;\nimport javax.crypto.Cipher;\nimport javax.crypto.CipherInputStream;\nimport javax.crypto.spec.IvParameterSpec;\nimport javax.crypto.spec.SecretKeySpec;\nimport com.fedorvlasov.lazylist.R;\nimport android.app.Activity;\nimport android.content.Context;\nimport android.content.res.AssetManager;\nimport android.graphics.Bitmap;\nimport android.graphics.BitmapFactory;\nimport android.util.Log;\nimport android.widget.ImageView;\n\npublic class ImageLoader extends Activity {\n\n    //the simplest in-memory cache implementation. This should be replaced with something like SoftReference or BitmapOptions.inPurgeable(since 1.6)\n    private HashMap<String, Bitmap> cache=new HashMap<String, Bitmap>();\n\n    private File cacheDir;\n\n    public ImageLoader(Context context){\n        //Make the background thead low priority. This way it will not affect the UI performance\n        photoLoaderThread.setPriority(Thread.NORM_PRIORITY-1);\n\n        //Find the dir to save cached images\n        if (android.os.Environment.getExternalStorageState().equals(android.os.Environment.MEDIA_MOUNTED))\n            cacheDir=new File(android.os.Environment.getExternalStorageDirectory(),\"LazyList\");\n        else\n            cacheDir=context.getCacheDir();\n        if(!cacheDir.exists())\n            cacheDir.mkdirs();\n    }\n\n    final int stub_id=R.drawable.stub;\n    public void DisplayImage(String url, Activity activity, ImageView imageView)\n    {\n        if(cache.containsKey(url))\n            imageView.setImageBitmap(cache.get(url));\n        else\n        {\n            queuePhoto(url, activity, imageView);\n            imageView.setImageResource(stub_id);\n        }    \n    }\n\n    private void queuePhoto(String url, Activity activity, ImageView imageView)\n    {\n        //This ImageView may be used for other images before. So there may be some old tasks in the queue. We need to discard them. \n        photosQueue.Clean(imageView);\n        PhotoToLoad p=new PhotoToLoad(url, imageView);\n        synchronized(photosQueue.photosToLoad){\n            photosQueue.photosToLoad.push(p);\n            photosQueue.photosToLoad.notifyAll();\n        }\n\n        //start thread if it's not started yet\n        if(photoLoaderThread.getState()==Thread.State.NEW)\n            photoLoaderThread.start();\n    }\n\n\n    //MY METHOD\nprivate Bitmap getBitmap(String src) {\n    Bitmap myBitmap = null;\n        //Decryption\n        try {\n        Cipher cipher = Cipher.getInstance(\"AES/CBC/NoPadding\");\n        SecretKeySpec keySpec = new SecretKeySpec(\"01234567890abcde\".getBytes(), \"AES\");\n        IvParameterSpec ivSpec = new IvParameterSpec(\"fedcba9876543210\".getBytes());\n        cipher.init(Cipher.DECRYPT_MODE, keySpec, ivSpec);\n\n        AssetManager is = this.getAssets();        \n        InputStream input = is.open(src); //open file in asset manager\n        CipherInputStream cis = new CipherInputStream(input, cipher);\n\n        myBitmap = BitmapFactory.decodeStream(cis);\n\n        }\n        catch(Exception e){\n            e.printStackTrace();\n            Log.v(\"ERROR\",\"Error : \"+e);\n        }\n\n\n        return myBitmap;\n    }\n\n\n\n    //Task for the queue\n    private class PhotoToLoad\n    {\n        public String url;\n        public ImageView imageView;\n        public PhotoToLoad(String u, ImageView i){\n            url=u; \n            imageView=i;\n        }\n    }\n\n    PhotosQueue photosQueue=new PhotosQueue();\n\n    public void stopThread()\n    {\n        photoLoaderThread.interrupt();\n    }\n\n    //stores list of photos to download\n    class PhotosQueue\n    {\n        private Stack<PhotoToLoad> photosToLoad=new Stack<PhotoToLoad>();\n\n        //removes all instances of this ImageView\n        public void Clean(ImageView image)\n        {\n            for(int j=0 ;j<photosToLoad.size();){\n                if(photosToLoad.get(j).imageView==image)\n                    photosToLoad.remove(j);\n                else\n                    ++j;\n            }\n        }\n    }\n\n    class PhotosLoader extends Thread {\n        public void run() {\n            try {\n                while(true)\n                {\n                    //thread waits until there are any images to load in the queue\n                    if(photosQueue.photosToLoad.size()==0)\n                        synchronized(photosQueue.photosToLoad){\n                            photosQueue.photosToLoad.wait();\n                        }\n                    if(photosQueue.photosToLoad.size()!=0)\n                    {\n                        PhotoToLoad photoToLoad;\n                        synchronized(photosQueue.photosToLoad){\n                            photoToLoad=photosQueue.photosToLoad.pop();\n                        }\n                        Bitmap bmp=getBitmap(photoToLoad.url);\n                        cache.put(photoToLoad.url, bmp);\n                        Object tag=photoToLoad.imageView.getTag();\n                        if(tag!=null && ((String)tag).equals(photoToLoad.url)){\n                            BitmapDisplayer bd=new BitmapDisplayer(bmp, photoToLoad.imageView);\n                            Activity a=(Activity)photoToLoad.imageView.getContext();\n                            a.runOnUiThread(bd);\n                        }\n                    }\n                    if(Thread.interrupted())\n                        break;\n                }\n            } catch (InterruptedException e) {\n                //allow thread to exit\n            }\n        }\n    }\n\n    PhotosLoader photoLoaderThread=new PhotosLoader();\n\n    //Used to display bitmap in the UI thread\n    class BitmapDisplayer implements Runnable\n    {\n        Bitmap bitmap;\n        ImageView imageView;\n        public BitmapDisplayer(Bitmap b, ImageView i){bitmap=b;imageView=i;}\n        public void run()\n        {\n            if(bitmap!=null)\n                imageView.setImageBitmap(bitmap);\n            else\n                imageView.setImageResource(stub_id);\n        }\n    }\n\n    public void clearCache() {\n        //clear memory cache\n        cache.clear();\n\n        //clear SD cache\n        File[] files=cacheDir.listFiles();\n        for(File f:files)\n            f.delete();\n    }  \n\n}\n", "idx": 2649}
{"project": "cipher", "commit_id": "Snippet3711754_30839.java", "target": 1, "func": "import java.io.FileOutputStream;\nimport java.io.InputStreamReader;\nimport java.io.ObjectOutputStream;\nimport javax.crypto.Cipher;\nimport javax.crypto.spec.IvParameterSpec;\nimport javax.crypto.spec.SecretKeySpec;\nimport org.bouncycastle.jce.provider.BouncyCastleProvider;\n\npublic class AesFileIo {\n\n    private static final String AES_ALGORITHM = \"AES/CTR/NoPadding\";\n    private static final String PROVIDER = BouncyCastleProvider.PROVIDER_NAME;\n    private static final byte[] AES_KEY_128 = { // Hard coded for now\n        78, -90, 42, 70, -5, 20, -114, 103,\n        -99, -25, 76, 95, -85, 94, 57, 54};\n    private static final byte[] IV = { // Hard coded for now\n        -85, -67, -5, 88, 28, 49, 49, 85,\n        114, 83, -40, 119, -65, 91, 76, 108};\n    private static final SecretKeySpec secretKeySpec =\n            new SecretKeySpec(AES_KEY_128, \"AES\");\n    private static final IvParameterSpec ivSpec = new IvParameterSpec(IV);\n\n    public void AesFileIo() {\n        Security.addProvider(new org.bouncycastle.jce.provider\n                .BouncyCastleProvider());\n    }\n\n    public void writeFile(String fileName, String theFile) {\n        try {\n            Cipher cipher = Cipher.getInstance(AES_ALGORITHM, PROVIDER);\n            cipher.init(Cipher.ENCRYPT_MODE, secretKeySpec, ivSpec);\n            byte[] encrypted = cipher.doFinal(theFile.getBytes());\n            ObjectOutputStream os = new ObjectOutputStream(\n                new FileOutputStream(fileName));\n            os.write(encrypted);\n            os.flush();\n            os.close();\n        } catch (Exception e) {\n            StackTraceElement se = new Exception().getStackTrace()[0];\n            System.err.println(se.getFileName() + \" \" + se.getLineNumber()\n                    + \" \" + e);\n        }\n    }\n}\n", "idx": 2626}
{"project": "cipher", "commit_id": "Snippet32785560_14875.java", "target": 0, "func": "public String encrypt(String a,int x) {\n\n\n     String ret=\"\";\n  try {\n\n     String text = a;\n\n     String key = \"Bar12345Bar12345\"; // 128 bit key\n     // Create key and cipher\n     Key aesKey = new SecretKeySpec(key.getBytes(), \"AES\");\n\n     Cipher cipher = Cipher.getInstance(\"AES\");\n     // encrypt the text\nif(x==0)//x==0 means i want to encrypt\n{\n         cipher.init(Cipher.ENCRYPT_MODE, aesKey);\n         byte[] encrypted = cipher.doFinal(text.getBytes());\n         ret =new String(encrypted);\n}\nelse//if not 0 i want to decrypt\n{\n        // decrypt the text\n\n    byte[] encrypted = text.getBytes(Charset.forName(\"UTF-8\"));\n         cipher.init(Cipher.DECRYPT_MODE, aesKey);\n         String decrypted = new String(cipher.doFinal(encrypted));\n         ret=decrypted;\n}\n  }catch(Exception e) {\n     e.printStackTrace();\n  }\n  return ret;\n}\n", "idx": 2180}
{"project": "cipher", "commit_id": "Snippet34433376_16429.java", "target": 0, "func": "cipher = Cipher.getInstance(\"DES/ECB/PKCS5Padding\");\n", "idx": 2242}
{"project": "cipher", "commit_id": "Snippet13897008_37342.java", "target": 1, "func": "Key privateKey = keyStore.getKey(\"youralias\", \"password\".toCharArray());\nPublicKey publicKey = keyStore.getCertificate(\"youralias\").getPublicKey();\n\nKeyGenerator keyGen = KeyGenerator.getInstance(\"AES\");\nKey secKey = keyGen.generateKey();\n\nCipher keyCipher = Cipher.getInstance(\"RSA\");\nkeyCipher.init(Cipher.ENCRYPT_MODE, privateKey);\nbyte[] encryptedKey = keyCipher.doFinal(secKey.getEncoded());\n\n// Write & Read to/from file!\n\nCipher decryptCipher = Cipher.getInstance(\"RSA\");\ndecryptCipher.init(Cipher.DECRYPT_MODE, publicKey);\nbyte[] decryptedKey = decryptCipher.doFinal(encryptedKey);\n\nboolean equals = Arrays.equals(secKey.getEncoded(), new SecretKeySpec(decryptedKey, \"AES\").getEncoded());\nSystem.out.println(equals?\"Successfull!\":\"Failed!\");\n", "idx": 2638}
{"project": "cipher", "commit_id": "Snippet28389630_10555.java", "target": 0, "func": "public static void main(String[] args) {\n    Scanner input = new Scanner(System.in);\n    try\n    {\n\n        //Prompt for String\n        System.out.print(\"Enter a sentence:\");\n        String in = input.next();\n\n        //Generate Key for encryption/decryption\n        KeyGenerator keygenerator = KeyGenerator.getInstance(\"DES\");\n        SecretKey myDesKey = keygenerator.generateKey();\n        Cipher desCipher;\n        desCipher = Cipher.getInstance(\"DES\");\n        desCipher.init(Cipher.ENCRYPT_MODE, myDesKey);\n\n        //Cast the input into bytes \n        byte[] text = in.getBytes();\n        System.out.println(\"\" + new String(text));\n        // Encrypt the text\n        byte[] textEncrypted = desCipher.doFinal(text);\n        System.out.println(\"File Encryted : \" + textEncrypted);\n        // Initialize the same cipher for decryption\n        desCipher.init(Cipher.DECRYPT_MODE, myDesKey);\n        // Decrypt the text\n        byte[] textDecrypted = desCipher.doFinal(textEncrypted);\n        System.out.println(\"File Decryted : \" +  new String(textDecrypted));\n\n    }catch(NoSuchAlgorithmException e)\n    {\n        e.printStackTrace();\n    }catch(NoSuchPaddingException e)\n    {\n        e.printStackTrace();\n    }catch(InvalidKeyException e)\n    {\n        e.printStackTrace();\n    }catch(IllegalBlockSizeException e)\n    {\n        e.printStackTrace();\n    }catch(BadPaddingException e)\n    {\n        e.printStackTrace();\n    } \n\n}\n", "idx": 2119}
{"project": "cipher", "commit_id": "Snippet14845785_37937.java", "target": 1, "func": "Cipher cipher = Cipher.getInstance(\"AES/CBC/NoPadding\");\nint blockSize = cipher.getBlockSize();\n\nbyte[] inputBytes = data.getBytes();\nint byteLength = inputBytes.length;\nif (byteLength % blockSize != 0) {\n    byteLength = byteLength + (blockSize - (byteLength % blockSize));\n}\n\nbyte[] paddedBytes = new byte[byteLength];\n\nSystem.arraycopy(inputBytes, 0, paddedBytes, 0, inputBytes.length);\n\ncipher.init(Cipher.ENCRYPT_MODE, newKey, ivSpec);\nbyte[] results = cipher.doFinal(paddedBytes);\n", "idx": 2493}
{"project": "cipher", "commit_id": "Snippet35689554_17522.java", "target": 1, "func": "Cipher.getInstance(\"RSA/ECB/PKCS1Padding\");", "idx": 2416}
{"project": "cipher", "commit_id": "Snippet29607500_11678.java", "target": 0, "func": "//Starting decryption\ntry{\n    byte[] key = c_key.getBytes(\"ISO-8859-1\");\n    key = Arrays.copyOf(key, 16); // use only first 128 bit\n    //System.out.println(Arrays.toString(key));\n    SecretKeySpec SecKey = new SecretKeySpec(key, \"AES\");\n    Cipher AesCipher = Cipher.getInstance(\"AES\");\n    AesCipher.init(Cipher.DECRYPT_MODE, SecKey);\n\n    BufferedReader breader = new BufferedReader(new FileReader(\"download/enc_\"+file));\n    String line;\n    boolean bool = false;\n    File f = new File(file);\n    bool = f.createNewFile();\n    if(bool==false){\n        f.delete();\n        bool = f.createNewFile();\n    }\n    PrintWriter out = new PrintWriter(new BufferedWriter(new FileWriter(file, true)));\n    while ((line = breader.readLine()) != null){\n         byte[] cipher=null;\n         byte[] plain=null;\n\n         cipher=line.getBytes(\"ISO-8859-1\");\n         plain=AesCipher.doFinal(cipher);\n\n         out.println(new String(plain,\"ISO-8859-1\"));\n    }\n    out.close();\n    return 1;\n}\ncatch(Exception dcf){\n    System.out.println(\"Message:\"+dcf.getMessage());\n    dcf.printStackTrace();\n    return 0;\n}\n", "idx": 2064}
{"project": "cipher", "commit_id": "Snippet22815227_5198.java", "target": 1, "func": "public static final int SALT_LENGTH = 20;\npublic static final int PBE_ITERATION_COUNT = 200; //1024;\n\nprivate static final String PBE_ALGORITHM = \"PBEWithSHA256And256BitAES-CBC-BC\";\n\n//algoritmo / modo / relleno \nprivate static final String CIPHER_ALGORITHM = \"AES/CBC/PKCS5Padding\";\n\nbyte[] iv = \"1234567890asdfgh\".getBytes();\n\nbyte[] salt = \"o6806642kbM7c5\".getBytes();\n\n@SuppressLint(\"TrulyRandom\")\npublic byte[] encrypt(String password, String cleartext) {\n\n    byte[] encryptedText = null;\n\n    try {\n\n\n        PBEKeySpec pbeKeySpec = new PBEKeySpec(password.toCharArray(), salt, PBE_ITERATION_COUNT, 256);\n\n        //Factoria para crear la SecretKey, debemos indicar el Algoritmo\n        SecretKeyFactory factory = SecretKeyFactory.getInstance(PBE_ALGORITHM);\n\n        SecretKey tmp = factory.generateSecret(pbeKeySpec);\n\n        //Creamos una llave;\n        SecretKey secret = new SecretKeySpec(tmp.getEncoded(), \"AES\");\n\n        //Obtenemos la llave, solo informativo\n        byte[] key = secret.getEncoded();\n\n        //La clase Cipher, se usa para cifrar mediante algoritmos de  clave sim\u00e9trica\n        Cipher encryptionCipher = Cipher.getInstance(CIPHER_ALGORITHM);   \n\n        //byte[] iv = generateIv();\n\n        IvParameterSpec ivspec = new IvParameterSpec(iv);\n\n        //Accion, SecretKey, parameter specification for an initialization vector\n        encryptionCipher.init(Cipher.ENCRYPT_MODE, secret, ivspec);\n\n        //Realizamos el cifrado\n        encryptedText = encryptionCipher.doFinal(cleartext.getBytes());\n\n    } catch (Exception e) {\n        e.printStackTrace();\n    }\n\n    return encryptedText;\n}\n\npublic String decrypt(String password, byte[] encryptedText) {\n\n    String cleartext = \"\";\n\n    try {\n\n        PBEKeySpec pbeKeySpec = new PBEKeySpec(password.toCharArray(), salt, PBE_ITERATION_COUNT, 256);\n\n        //Factoria para crear la SecretKey, debemos indicar el Algoritmo\n        SecretKeyFactory factory = SecretKeyFactory.getInstance(PBE_ALGORITHM);\n\n        SecretKey tmp = factory.generateSecret(pbeKeySpec);\n\n        //Creamos una llave;\n        SecretKey secret = new SecretKeySpec(tmp.getEncoded(), \"AES\");\n\n        //Obtenemos la llave, solo informativo\n        byte[] key = secret.getEncoded();\n\n        //La clase Cipher, se usa para cifrar mediante algoritmos de  clave sim\u00e9trica\n        Cipher decryptionCipher = Cipher.getInstance(CIPHER_ALGORITHM);\n\n        //byte[] iv = generateIv();\n\n        IvParameterSpec ivspec = new IvParameterSpec(iv);\n\n        //Accion, SecretKey, parameter specification for an initialization vector\n        decryptionCipher.init(Cipher.DECRYPT_MODE, secret, ivspec);\n\n        //Realizamos el descifrado\n        byte[] decryptedText = decryptionCipher.doFinal(encryptedText);\n\n        cleartext =  new String(decryptedText); \n\n    } catch (Exception e) {\n        e.printStackTrace();\n    }\n\n    return cleartext;\n}      \n", "idx": 2682}
{"project": "cipher", "commit_id": "Snippet8632617_33391.java", "target": 0, "func": "Cipher c = Cipher.getInstance(\"Blowfish\", \"SC\");\n", "idx": 2040}
{"project": "cipher", "commit_id": "Snippet28230350_10464.java", "target": 1, "func": "public class Cryptor {\nprivate static Cryptor _instance = null;\nprivate static Object mutex = new Object();\nString symKeyString;\nSecretKey symKey;\nString keyString;\nCipher cipher;\nString plainText;\nString cipherText;\nbyte[] plainByte;\nSecretKey originalKey;\nSecretKey key;\nKeyGenerator keyGen;\nbyte[] cipherByte;\n\nprivate Cryptor() {\n    try {\n        cipher = Cipher.getInstance(\"AES/CBC/PKCS5Padding\");\n    } catch (Exception e) {\n        e.printStackTrace();\n    }\n}\n\npublic static Cryptor getInstance() {\n    if (_instance == null) {\n        synchronized (mutex) {\n            if (_instance == null)\n                _instance = new Cryptor();\n        }\n    }\n    return _instance;\n\n}\n\npublic String generateSymmetricKey() {\n\n    try {\n        keyGen = KeyGenerator.getInstance(\"AES\");\n        symKey = keyGen.generateKey();\n    } catch (NoSuchAlgorithmException e) {\n        e.printStackTrace();\n    }\n\n    symKeyString = convertKeyToString(symKey);\n    return symKeyString;\n}\n\n\npublic String symEncrypt(String keyStr, String plainTextInput) {\n\n    key = convertStringToKey(keyStr);\n\n    try {\n        cipher.init(Cipher.ENCRYPT_MODE, key);\n\n\n        cipherByte = cipher.doFinal(plainTextInput.getBytes());\n\n    } catch (Exception e) {\n        e.printStackTrace();\n    }\n    cipherText = Base64.encodeToString(cipherByte, Base64.DEFAULT);\n    return cipherText;\n}\n\n\npublic String symDecrypt(String keyStr, String cipherText) {\n    key = convertStringToKey(keyStr);\n\n    try {\n        cipher.init(Cipher.DECRYPT_MODE, key);\n\n        plainByte = cipher.doFinal(cipherText.getBytes()); //here is where the exception is thrown!\n\n    } catch (Exception e) {\n        e.printStackTrace();\n    }\n\n    plainText = Base64.encodeToString(plainByte, Base64.DEFAULT);\n    return plainText;\n}\n\n\nprivate String convertKeyToString(SecretKey key) {\n\n\n    keyString = Base64.encodeToString(key.getEncoded(), Base64.DEFAULT);\n\n    return keyString;\n}\n\nprivate SecretKey convertStringToKey(String keyStr) {\n    byte[] decodedKey = Base64.decode(keyStr, Base64.DEFAULT);\n    originalKey = new SecretKeySpec(decodedKey, 0, decodedKey.length, \"AES\");\n    return originalKey;\n}\n}\n", "idx": 2455}
{"project": "cipher", "commit_id": "Snippet32156462_14252.java", "target": 0, "func": "Cipher.getInstance(\"AES\")", "idx": 1976}
{"project": "cipher", "commit_id": "Snippet22687135_5101.java", "target": 1, "func": "cipher = Cipher.getInstance(\"RSA/ECB/PKCS1Padding\");\n", "idx": 2571}
{"project": "cipher", "commit_id": "Snippet18700095_1663.java", "target": 0, "func": "   public String decrypt(){\n       String keyStr = \"password\";\n       String msg = \"KGFL1GG5VLQ=\";\n       String erg = \"\";\n       try{\n\n\n       KeySpec ks = new DESKeySpec(keyStr.getBytes(\"UTF-8\"));\n       SecretKey key = SecretKeyFactory.getInstance(\"DES\").generateSecret(ks);\n       IvParameterSpec iv = new IvParameterSpec(Hex.decodeHex(\"1234567890ABCDEF\".toCharArray()));\n       Cipher cipher = Cipher.getInstance(\"DES/ECB/PKCS5Padding\");\n       cipher.init(Cipher.DECRYPT_MODE, key, iv);\n\n       byte[] decoded = cipher.doFinal(Base64.decodeBase64(msg));\n       erg = new String(decoded);\n       } catch (Exception e){\n           erg = \"error\";\n       }\n       return erg;\n\n   }\n", "idx": 2076}
{"project": "cipher", "commit_id": "Snippet41517225_23445.java", "target": 0, "func": "@Test\npublic void testCipherGetInstanceShouldDefaultToECB() throws Exception {\n    // Arrange\n    final String PLAINTEXT = \"This is a plaintext message.\"\n    final SecretKey key = new SecretKeySpec(Hex.decodeHex(\"0123456789ABCDEFFEDCBA9876543210\" as char[]), \"AES\")\n\n    Cipher unspecified = Cipher.getInstance(\"AES\")\n    final Cipher EXPECTED_CIPHER = Cipher.getInstance(\"AES/ECB/PKCS5Padding\")\n\n    unspecified.init(Cipher.ENCRYPT_MODE, key)\n    EXPECTED_CIPHER.init(Cipher.DECRYPT_MODE, key)\n\n    // Act\n    byte[] cipherBytes = unspecified.doFinal(PLAINTEXT.getBytes(StandardCharsets.UTF_8))\n    logger.info(\"Cipher text: ${Hex.encodeHexString(cipherBytes)}\")\n\n    // Assert\n    byte[] recoveredBytes = EXPECTED_CIPHER.doFinal(cipherBytes)\n    String recovered = new String(recoveredBytes, StandardCharsets.UTF_8)\n    assert recovered == PLAINTEXT\n}\n", "idx": 2147}
{"project": "cipher", "commit_id": "Snippet18435227_1495.java", "target": 0, "func": ">>> from javax.crypto import Cipher\n>>> Cipher.getMaxAllowedKeyLength(\"AES\")\n128\n>>> from java.lang import Class\n>>> c = Class.forName(\"javax.crypto.JceSecurity\")\n>>> isRestricted = c.getDeclaredField(\"isRestricted\")\n>>> isRestricted.setAccessible(True)\n>>> isRestricted.set(None, False)\n>>> isRestricted.get(None)\nFalse\n>>> Cipher.getMaxAllowedKeyLength(\"AES\")\n128\n>>> from javax.crypto import KeyGenerator\n>>> kge = KeyGenerator.getInstance(\"AES\")\n>>> kge.init(256)\n>>> aesKey = kgen.generateKey()\n>>> c2 = Cipher.getInstance(\"AES\")\n>>> c2.init(Cipher.ENCRYPT_MODE, aesKey)\n>>> c2.doFinal(\"test\")\narray('b', [-81, 99, -61, -51, 93, -42, -68, -28, 107, 59, -109, -98, -25, 127, 37, 23])\n", "idx": 2002}
{"project": "cipher", "commit_id": "Snippet24340760_6545.java", "target": 1, "func": "Cipher cipher = Cipher.getInstance(\"RSA/ECB/PKCS1Padding\");\n", "idx": 2489}
{"project": "cipher", "commit_id": "Snippet21084777_3681.java", "target": 1, "func": "public static String encrypt(String source, String publicKey)\n            throws Exception {\n    Key key = getPublicKey(publicKey);\n    Cipher cipher = Cipher.getInstance(\"RSA/ECB/PKCS1Padding\");\n    cipher.init(Cipher.ENCRYPT_MODE, key);\n    byte[] b = source.getBytes();\n    byte[] b1 = cipher.doFinal(b);\n    return new String(Base64.encodeBase64(b1), \"UTF-8\");\n}\n", "idx": 2727}
{"project": "cipher", "commit_id": "Snippet29626232_11701.java", "target": 1, "func": "private static final String ZERO_PADDING_KEY = \"32_length_String\";\nprivate static final String IV = \"32_length_String\";\nprivate static final String CIPHER_ALGORITHM = \"AES/CBC/ZeroBytePadding\";\n\npublic static String encryptAESURL(String url) {\n    try {\n\n        byte[] key = ZERO_PADDING_KEY.getBytes(\"UTF-8\");\n\n        SecretKeySpec sks = new SecretKeySpec(key, \"AES\");\n\n        byte[] iv = Arrays.copyOf(IV.getBytes(\"UTF-8\"), 16);\n\n        IvParameterSpec ivspec = new IvParameterSpec(iv);\n\n        Cipher cipher = Cipher.getInstance(CIPHER_ALGORITHM);\n\n        // encryption pass\n        cipher.init(Cipher.ENCRYPT_MODE, sks, ivspec);\n\n        byte[] encryptedText = cipher.doFinal(url.getBytes(\"UTF-8\"));\n\n        String resul = bytesToHex(encryptedText);\n        url = resul;\n        return resul;\n\n    } catch (Exception e) {\n        Log.e(\"ENCRYPT ERROR\", e.getMessage());\n        e.printStackTrace();\n        //  throw new CryptoException(\"Unable to decrypt\", e);\n\n    }\n    return url;\n\n    final protected static char[] hexArray = \"0123456789ABCDEF\".toCharArray();\n\n    public static String bytesToHex(byte[] bytes) {\n        char[] hexChars = new char[bytes.length * 2];\n        for (int j = 0; j < bytes.length; j++) {\n            int v = bytes[j] & 0xFF;\n            hexChars[j * 2] = hexArray[v >>> 4];\n            hexChars[j * 2 + 1] = hexArray[v & 0x0F];\n        }\n        return new String(hexChars);\n    }\n", "idx": 2690}
{"project": "cipher", "commit_id": "Snippet26346248_8487.java", "target": 1, "func": "public final String modulusString =\"..............\";\npublic final String publicExponentString = \"AQAB\";\n\n/* Encryption */\nbyte[] modulebytes = Base64.decode(modulusString);\nbyte[] exponentbytes = Base64.decode(publicExponentString);\nBigInteger module = new BigInteger(1,modulebytes);\nBigInteger publicexponent = new BigInteger(1,exponentbytes);\nRSAPublicKeySpec rsaPubKey = new RSAPublicKeySpec(module, publicexponent);\nKeyFactory fact = KeyFactory.getInstance(\"RSA\");\nPublicKey pubKey = fact.generatePublic(rsaPubKey);\n\nCipher cipher = Cipher.getInstance(\"RSA/ECB/PKCS1Padding\");\ncipher.init(Cipher.ENCRYPT_MODE, pubKey);\n\nbyte[] plainBytes = EncryptionValue.getBytes(\"UTF-8\");\nbyte[] cipherData = cipher.doFinal( plainBytes );\nString encryptedString = Base64.encode(cipherData);\n\nreturn encryptedString;\n\n/* Decryption */\nbyte[] modulebytes = Base64.decode(modulusString);\nbyte[] exponentbytes = Base64.decode(publicExponentString);\n\nBigInteger modulus = new BigInteger(1, modulebytes );\nBigInteger exponent = new BigInteger(1, exponentbytes);\n\nRSAPrivateKeySpec rsaPrivKey = new RSAPrivateKeySpec(modulus, exponent);\nKeyFactory fact = KeyFactory.getInstance(\"RSA\");\nPrivateKey privKey = fact.generatePrivate(rsaPrivKey);\n\nCipher cipher = Cipher.getInstance(\"RSA/ECB/PKCS1Padding\");\ncipher.init(Cipher.DECRYPT_MODE, privKey);\n\nbyte[] base64String = Base64.decode(DecryptionValue);\nbyte[] plainBytes = new String(base64String).getBytes(\"UTF-8\");\nplainBytes = cipher.update(plainBytes);\nbyte[] values = cipher.doFinal(plainBytes);\n\nreturn new String(values, \"UTF-8\");\n", "idx": 2430}
{"project": "cipher", "commit_id": "Snippet23861877_6160.java", "target": 0, "func": "String dataEncrypted = new String();\ntry {\n    Cipher aesCipher = Cipher.getInstance(\"AES\");\n    byte[] raw = hexToBytes(key);\n    SecretKeySpec skeySpec = new SecretKeySpec(raw, \"AES\");\n    aesCipher.init(Cipher.ENCRYPT_MODE, skeySpec);\n    byte[] byteDataToEncrypt = data.getBytes();\n    byte[] byteCipherText = aesCipher.doFinal(byteDataToEncrypt);\n    dataEncrypted = new BASE64Encoder().encode(byteCipherText);\n    return dataEncrypted;\n} catch (Exception ex) {\n    //log.d(ex.getMessage());\n}\n", "idx": 2043}
{"project": "cipher", "commit_id": "Snippet41243646_23204.java", "target": 1, "func": "private void exampleMethod(){\n    String messageString = \"This actually works in Java AND Android!\";\n\n    String serverPubKey = \"MIIBIjANBgkqhkiG9w0BAQEFAAOCAQ8AMIIBCgKCAQEAjS7T3WJ+VLucnUP5WYryeg+hhOjZZl5VxwvJAgo4GrXaXdernTPtmXnOSUlbhd928QRCip7D3rLwJNvGIwhPa6coA+YQnj+aHQC02AvCJP/9jpeNmm5MASZfYFXrdmOrMhAPpDZ4rUk1mqtvpwBkYmW3VbMtG336wT1bAIKPHCZuI2n6glupJvs8gK0NuIoAPRlxiQmQD7NCcRx1Et4JmqOMIRC+HqdGv9GGqC/0PB0Fv6LXi8GdzJQPMdoRLR0rvVykNeIzmcimejoIVjI78XUZeB1hF7p55h6W4C4Xm/PrnzKuXw4lBVehZtRhyIvNO62G/eNEZ3tup1/m+vkzHQIDAQAB\";\n\n    String encryptedMessageString = getUrlEncodedCipherText(messageString, serverPubKey, Base64.NO_WRAP);\n    System.out.println(\"encryptedMessageString: \" + encryptedMessageString);\n    /**\n     * This works! Ciphertext always comes out different, as expected, and decodes successfully when fed into Java application.\n     */\n}\n\npublic static String getUrlEncodedCipherText(String plainText, String pubKey, int base64Type){\n    try {\n        final PublicKey publicKey = loadPublicKey(pubKey, base64Type);\n        final byte[] cipherBytes = encrypt(plainText, publicKey);\n        String cipherText = base64Encode(cipherBytes, base64Type);\n        String urlEncodedCipherText = urlEncode(cipherText);\n        return urlEncodedCipherText;\n    }\n    catch (Exception e){\n        e.printStackTrace();\n        return null;\n    }\n}\n\npublic static final String ALGORITHM = \"RSA\";\npublic static final String CIPHER_ALGORITHM = \"RSA/ECB/PKCS1Padding\";\n\npublic static PublicKey loadPublicKey(String stored, int base64Type) throws GeneralSecurityException {\n    String pubKey = stored.replace(BEGIN_PUBLIC_KEY, \"\");\n    pubKey = pubKey.replace(END_PUBLIC_KEY, \"\");\n\n    byte[] data = Base64.decode(pubKey, base64Type);\n    X509EncodedKeySpec spec = new X509EncodedKeySpec(data);\n    KeyFactory fact = KeyFactory.getInstance(ALGORITHM);\n    PublicKey pub = fact.generatePublic(spec);\n    return pub;\n}\n\npublic static byte[] encrypt(String text, PublicKey key) {\n    byte[] cipherText = null;\n    try {\n        Cipher cipher = Cipher.getInstance(CIPHER_ALGORITHM);\n        cipher.init(Cipher.ENCRYPT_MODE, key);\n        cipherText = cipher.doFinal(text.getBytes());\n    }\n    catch (Exception e) {\n        e.printStackTrace();\n    }\n    return cipherText;\n}\n\npublic static String base64Encode(byte[] cipherBytes, int base64Type){\n    byte[] base64Cipher = Base64.encode(cipherBytes, base64Type);\n    return new String(base64Cipher);\n}\n\npublic static String urlEncode(String text){\n    return text.replace(\"+\", \"-\").replace(\"/\", \"_\").replace(\"=\", \",\");\n}\n", "idx": 2641}
{"project": "cipher", "commit_id": "Snippet18906161_1824.java", "target": 0, "func": "        SecretKeyFactory factory = SecretKeyFactory.getInstance(\"PBEWithMD5AndTripleDES\");\n        SecretKey key = factory.generateSecret(keySpec);\n\n        // instead of key.getAlgorithm(). For compatibility with JDK 1.5\n        String newAlgorithm = \"PBEWithMD5AndDES\"; // the same value as in JDK 1.5\n\n        ecipher = Cipher.getInstance(newAlgorithm);\n", "idx": 1940}
{"project": "cipher", "commit_id": "Snippet28934850_11014.java", "target": 1, "func": "public static byte[] encrypt(PublicKey pk, byte[] data) throws Exception {\n    try {\n        Cipher cipher = Cipher.getInstance(\"RSA\", new org.bouncycastle.jce.provider.BouncyCastleProvider());\n        cipher.init(Cipher.ENCRYPT_MODE, pk);\n        int blockSize = cipher.getBlockSize();\n        int outputSize = cipher.getOutputSize(data.length);\n        int leavedSize = data.length % blockSize;\n        int blocksSize = leavedSize != 0 ? data.length / blockSize + 1 : data.length / blockSize;\n        byte[] raw = new byte[outputSize * blocksSize];\n        int i = 0;\n\n        while (data.length - i * blockSize > 0) {\n            if (data.length - i * blockSize > blockSize) {\n                cipher.doFinal(data, i * blockSize, blockSize, raw, i * outputSize);\n            } else {\n                cipher.doFinal(data, i * blockSize, data.length - i * blockSize, raw, i * outputSize);\n            }\n            i++;\n        }\n\n        return raw;\n    } catch (Exception e) {\n        throw new Exception(e.getMessage());\n    }\n}\n", "idx": 2569}
{"project": "cipher", "commit_id": "Snippet908714_29805.java", "target": 1, "func": "public static byte[] encrypt(String toEncrypt) throws Exception{\n    try{\n        String plaintext = toEncrypt;\n        String key = \"01234567890abcde\";\n        String iv = \"fedcba9876543210\";\n\n        SecretKeySpec keyspec = new SecretKeySpec(key.getBytes(), \"AES\");\n        IvParameterSpec ivspec = new IvParameterSpec(iv.getBytes());\n\n        Cipher cipher = Cipher.getInstance(\"AES/CBC/NoPadding\");\n        cipher.init(Cipher.ENCRYPT_MODE,keyspec,ivspec);\n        byte[] encrypted = cipher.doFinal(toEncrypt.getBytes());\n\n        return encrypted;\n    } catch(Exception e){\n        return null;            // Always must return something\n    }\n}\n", "idx": 2536}
{"project": "cipher", "commit_id": "Snippet37824933_19841.java", "target": 1, "func": "Cipher ciphertest = null;\nciphertest = Cipher.getInstance(\"RSA/ECB/OAEPWithSHA-256AndMGF1Padding\");\nciphertest.init(Cipher.ENCRYPT_MODE, publicKey);\nbyte[] encryptedBytes = null;\nencryptedBytes = ciphertest.doFinal(Bytes_to_encrypt);\n", "idx": 2602}
{"project": "cipher", "commit_id": "Snippet34121787_16151.java", "target": 1, "func": "    SecretKeySpec keySpec = new SecretKeySpec(decryptedKeySpec, \"AES\");\n    Cipher decoder = Cipher.getInstance(\"AES/CBC/PKCS5PADDING\");\n    decoder.init(Cipher.DECRYPT_MODE, keyspec);\n    byte[] original = descipher.doFinal(message);\n", "idx": 2366}
{"project": "cipher", "commit_id": "Snippet7883684_32986.java", "target": 1, "func": "public boolean licenseValid() throws IOException, InvalidKeyException, NoSuchAlgorithmException, NoSuchPaddingException, IllegalBlockSizeException, BadPaddingException{\n    java.io.File file = new java.io.File(Environment.getExternalStorageDirectory().toString() ,\n            \"/folder/file.lic\");\n    byte[] fileBArray = new byte[(int)file.length()];\n    FileInputStream fis = new FileInputStream(file);\n\n    // Read in the bytes\n    int offset = 0;\n    int numRead = 0;\n    while (offset < fileBArray.length\n           && (numRead=fis.read(fileBArray, offset, fileBArray.length-offset)) >= 0) {\n        offset += numRead;\n    }\n\n    // Ensure all the bytes have been read in\n    if (offset < fileBArray.length) {\n        throw new IOException(\"Could not completely read file \"+file.getName());\n    }\n\n    fis.close();\n\n    // Decrypt the ciphertext using the public key\nPublicKey pubKey = readKeyFromFile();\nCipher cipher = Cipher.getInstance(\"RSA\");\ncipher.init(Cipher.DECRYPT_MODE, pubKey);\nbyte[] newPlainText = cipher.doFinal(fileBArray);\n\n    // THE FOLLOWING TOAST PRINTS MANY <?> AND THAN THE DECRYPTED MESSAGE. THE TOTAL NUMBER OF CHARACTERS IS 255, EVEN IF I CHANGE ENCRYPTED TEXT!\ntoast(String.valueOf(cipher.doFinal(fileBArray).length));\n\n    if (new String(newPlainText, \"utf-8\").compareTo(\"Hello World!\") == 0)\n        return true;\n    else\n        return false;\n}\n\nPublicKey readKeyFromFile() throws IOException {\n    Resources myResources = getResources();\n    //public key filename \"pub.lic\"\n    InputStream is = myResources.openRawResource(R.raw.pub);\nObjectInputStream oin =\n    new ObjectInputStream(new BufferedInputStream(is));\n\ntry {\n        BigInteger m = (BigInteger) oin.readObject();\n        BigInteger e = (BigInteger) oin.readObject();\n        RSAPublicKeySpec keySpec = new RSAPublicKeySpec(m, e);\n    KeyFactory fact = KeyFactory.getInstance(\"RSA\");\n    PublicKey pubKey = fact.generatePublic(keySpec);\n    return pubKey;\n  } catch (Exception e) {\n    throw new RuntimeException(\"Spurious serialisation error\", e);\n  } finally {\n    oin.close();\n   }\n}\n", "idx": 2371}
{"project": "cipher", "commit_id": "Snippet20900108_3487.java", "target": 0, "func": "Cipher cipher = Cipher.getInstance(\"PBEWithMD5AndDES\");\n", "idx": 2193}
{"project": "cipher", "commit_id": "Snippet38796839_20719.java", "target": 1, "func": "public byte[] encrypt(byte[] origin)\n    {\n        String key = \"testkey\";\n        SecretKeySpec sks = new SecretKeySpec(convertAESKey(key), \"AES\");\n        Cipher cipher = Cipher.getInstance(\"AES/CBC/PKCS5Padding\");\n        byte[] iv = new byte[16];\n        cipher.init(Cipher.ENCRYPT_MODE, sks, new IvParameterSpec(iv));\n        return cipher.doFinal(origin);\n    }\n\nprivate byte[] convertAESKey(String key)\n   {\n        byte[] keyBytes;\n        keyBytes = key.getBytes(\"UTF-8\");\n        byte[] keyBytes16 = new byte[16];\n        System.arraycopy(keyBytes, 0, keyBytes16, 0,\n                Math.min(keyBytes.length, 16));\n        return keyBytes16;\n    }\n}\n", "idx": 2477}
{"project": "cipher", "commit_id": "Snippet42044614_24019.java", "target": 0, "func": "Cipher cipher = Cipher.getInstance(\"DESede\");\nbyte[] bytes = cipher.doFinal(value.getBytes());\nString decrypted = new String(bytes);[code]\n", "idx": 1965}
{"project": "cipher", "commit_id": "Snippet11503157_35406.java", "target": 1, "func": "Cipher cipher = Cipher.getInstance(\"AES/CBC/PKCS5Padding\");\ncipher.init(Cipher.DECRYPT_MODE, encriptionKey,new IvParameterSpec(iv));\n", "idx": 2652}
{"project": "cipher", "commit_id": "Snippet37819550_19826.java", "target": 0, "func": "public static void encrypt(SecretKey secretKey, String filePath){\n    try {\n        // Here you read the cleartext.\n        FileInputStream fis = new FileInputStream(filePath);\n        // This stream write the encrypted text. This stream will be wrapped by another stream.\n        FileOutputStream fos = new FileOutputStream(filePath);\n\n        // Create cipher\n        Cipher cipher = Cipher.getInstance(\"AES\");\n        cipher.init(Cipher.ENCRYPT_MODE, secretKey);\n        // Wrap the output stream\n        CipherOutputStream cos = new CipherOutputStream(fos, cipher);\n\n        // Write bytes\n        int b;\n        byte[] d = new byte[8];\n        while ((b = fis.read(d)) != -1) {\n            cos.write(d, 0, b);\n        }\n\n        // Flush and close streams.\n        cos.flush();\n        cos.close();\n        fis.close();\n\n    }catch(IOException e){\n        e.printStackTrace();\n    }catch (NoSuchAlgorithmException e){\n        e.printStackTrace();\n    }catch(NoSuchPaddingException e){\n        e.printStackTrace();\n    }catch(InvalidKeyException e){\n        e.printStackTrace();\n    }\n}\n", "idx": 2204}
{"project": "cipher", "commit_id": "Snippet39484455_21393.java", "target": 1, "func": "    String strDataToEncrypt = new String();\n    String strCipherText = new String();\n    String strDecryptedText = new String();\n\n    try {\n        KeyGenerator keyGen = KeyGenerator.getInstance(\"AES\");\n        keyGen.init(128);\n        SecretKey secretKey = keyGen.generateKey();\n\n        final int AES_KEYLENGTH = 128;  \n        byte[] iv = new byte[AES_KEYLENGTH / 8];    \n        SecureRandom prng = new SecureRandom();\n        prng.nextBytes(iv);\n\n        Cipher aesCipherForEncryption = Cipher.getInstance(\"AES/CBC/PKCS7PADDING\");\n\n        aesCipherForEncryption.init(Cipher.ENCRYPT_MODE, secretKey, new IvParameterSpec(iv));\n\n        strDataToEncrypt = \"Hello World of Encryption using AES \";\n        byte[] byteDataToEncrypt = strDataToEncrypt.getBytes();\n        byte[] byteCipherText = aesCipherForEncryption.doFinal(byteDataToEncrypt);\n\n        strCipherText = new BASE64Encoder().encode(byteCipherText);\n        System.out.println(\"Cipher Text generated using AES is \" + strCipherText);\n\n\n        Cipher aesCipherForDecryption = Cipher.getInstance(\"AES/CBC/PKCS7PADDING\"); \n\n        aesCipherForDecryption.init(Cipher.DECRYPT_MODE, secretKey, new IvParameterSpec(iv));\n        byte[] byteDecryptedText = aesCipherForDecryption.doFinal(byteCipherText);\n        strDecryptedText = new String(byteDecryptedText);\n\n        System.out.println(\" Decrypted Text message is \" + strDecryptedText);\n\n    } catch (NoSuchAlgorithmException noSuchAlgo) {\n        System.out.println(\" No Such Algorithm exists \" + noSuchAlgo);\n    } catch (NoSuchPaddingException noSuchPad) {\n        System.out.println(\" No Such Padding exists \" + noSuchPad);\n    } catch (InvalidKeyException invalidKey) {\n        System.out.println(\" Invalid Key \" + invalidKey);\n    } catch (BadPaddingException badPadding) {\n        System.out.println(\" Bad Padding \" + badPadding);\n    } catch (IllegalBlockSizeException illegalBlockSize) {\n        System.out.println(\" Illegal Block Size \" + illegalBlockSize);\n    } catch (InvalidAlgorithmParameterException invalidParam) {\n        System.out.println(\" Invalid Parameter \" + invalidParam);\n    }\n", "idx": 2645}
{"project": "cipher", "commit_id": "Snippet43890793_26015.java", "target": 1, "func": "cipher = Cipher.getInstance(\"AES/CBC/PKCS5Padding\");\n", "idx": 2504}
{"project": "cipher", "commit_id": "Snippet5118375_31468.java", "target": 0, "func": "private static byte[] getPasswordMessageDigest(String password) throws NoSuchAlgorithmException {\n    MessageDigest messageDigest = MessageDigest.getInstance(\"SHA-512\");\n    byte[] passwordMessageDigest = messageDigest.digest(password.getBytes());\n\n    return passwordMessageDigest;\n}\n\npublic static SecretKey createSecretKey(String password) throws NoSuchAlgorithmException, InvalidKeySpecException {\n    byte[] passwordMessageDigest = getPasswordMessageDigest(password);\n\n    SecureRandom secureRandom = SecureRandom.getInstance(\"SHA1PRNG\");\n    secureRandom.setSeed(passwordMessageDigest);\n\n    KeyGenerator keyGenerator = KeyGenerator.getInstance(\"AES\");\n    keyGenerator.init(128, secureRandom);\n\n    SecretKey secretKey = keyGenerator.generateKey();\n\n    return secretKey;\n}\n\npublic static byte[] encrypt(String password, byte[] plainText) throws NoSuchAlgorithmException, NoSuchPaddingException, InvalidKeySpecException, InvalidKeyException, IllegalBlockSizeException, BadPaddingException {\n    Cipher cipher = Cipher.getInstance(\"AES\");\n\n    SecretKey secretKey = createSecretKey(password);\n\n    cipher.init(Cipher.ENCRYPT_MODE, secretKey);\n\n    byte[] cipherText = cipher.doFinal(plainText);\n\n    return cipherText;\n}\n\npublic static byte[] decrypt(String password, byte[] cipherText) throws NoSuchAlgorithmException, NoSuchPaddingException, InvalidKeySpecException, InvalidKeyException, IllegalBlockSizeException, BadPaddingException {\n    Cipher cipher = Cipher.getInstance(\"AES\");\n\n    SecretKey secretKey = createSecretKey(password);\n\n    cipher.init(Cipher.DECRYPT_MODE, secretKey);\n\n    byte[] plainText = cipher.doFinal(cipherText);\n\n    return plainText;\n}\n", "idx": 1931}
{"project": "cipher", "commit_id": "Snippet11346813_35481.java", "target": 1, "func": " //what does this actually do?\n Cipher cipher = Cipher.getInstance(\"AES/CTR/NoPadding\", \"BC\");\n", "idx": 2596}
{"project": "cipher", "commit_id": "Snippet30849594_12991.java", "target": 1, "func": "public byte[] rsaEncrypt(byte[] data) {\n\n    byte[] cipherData;\n\n    try {\n\n        RSAPublicKeySpec keySpec = new RSAPublicKeySpec(pubMod, pubExp);\n        KeyFactory fact = KeyFactory.getInstance(\"RSA\");\n        PublicKey pubKey = fact.generatePublic(keySpec);\n\n        Cipher cipher = Cipher.getInstance(\"RSA/ECB/OAEPWithSHA-256AndMGF1Padding\");\n        cipher.init(Cipher.ENCRYPT_MODE, pubKey);\n        cipherData = cipher.doFinal(data);\n        return cipherData;\n\n    } catch (NoSuchAlgorithmException | IllegalBlockSizeException | InvalidKeyException | InvalidKeySpecException | NoSuchPaddingException | BadPaddingException e) {\n        e.printStackTrace();\n    }\n\n    return null;\n}\n", "idx": 2671}
{"project": "cipher", "commit_id": "Snippet41007639_22919.java", "target": 1, "func": "package com.hs.works;\n\nimport org.apache.commons.codec.binary.Base64;\nimport org.eclipse.jetty.http.HttpStatus;\n\nimport javax.servlet.ServletException;\nimport javax.servlet.http.HttpServlet;\nimport javax.servlet.http.HttpServletRequest;\nimport javax.servlet.http.HttpServletResponse;\nimport java.io.IOException;\nimport java.security.interfaces.RSAPublicKey;\nimport java.security.spec.X509EncodedKeySpec;\nimport java.security.KeyFactory;\n\nimport javax.crypto.Cipher;\n\npublic class CryptServlet extends HttpServlet {\n\n    byte[] encrypt(byte[] pubKey, String text) {\n        try {\n            X509EncodedKeySpec keySpec = new X509EncodedKeySpec(pubKey);\n            KeyFactory keyFactory = KeyFactory.getInstance(\"RSA\");\n            RSAPublicKey k = (RSAPublicKey) keyFactory.generatePublic(keySpec);\n            final Cipher cipher = Cipher.getInstance(\"RSA\");\n            cipher.init(Cipher.ENCRYPT_MODE, k);\n            return cipher.doFinal(text.getBytes());\n        } catch (Exception e) {\n            e.printStackTrace();\n        }\n        return null;\n    }\n\n    @Override\n    protected void doPost(HttpServletRequest req, HttpServletResponse resp) throws ServletException, IOException {\n        String key = req.getParameter(\"key\");\n        byte[] decoded_bytes = Base64.decodeBase64(key.getBytes());\n        byte[] encoded = encrypt(decoded_bytes, \"SECRET_TEXT\");\n        resp.setStatus(HttpStatus.OK_200);\n        resp.getWriter().write(new String(Base64.encodeBase64(encoded)));\n    }\n}\n", "idx": 2684}
{"project": "cipher", "commit_id": "Snippet29756654_11828.java", "target": 0, "func": "   import java.io.*;\n   import java.net.*;\n   import java.security.*;\n   import javax.crypto.*;\n   import javax.crypto.spec.*;\n   import java.util.*;\n\n class RealSocketTest {\n public static void main(String[] args) throws NoSuchAlgorithmException, NoSuchPaddingException, InvalidKeyException, IllegalBlockSizeException, BadPaddingException {\n\n    String str = \"\";\n    String str2 = \"\";\n    DataOutputStream out;\n    DataInputStream in;\n\n    try {\n        Socket t = new Socket(\"127.0.0.1\", 9003);\n        in = new DataInputStream(t.getInputStream());\n        out = new DataOutputStream(t.getOutputStream());\n        BufferedReader br = new BufferedReader(new InputStreamReader(System.in));\n\n        boolean more = true;\n        System.out.println(in.readUTF());\n\n        while (more) {\n            str = in.readUTF();\n            System.out.print(str);\n            str2 = br.readLine();\n            out.writeUTF(str2);\n            out.flush();\n            str = in.readUTF();\n\n            System.out.println(\"Encrypted Info: \" + str);\n\n            try {\n\n                String key1 = \"1234567812345678\";\n                byte[] key2 = key1.getBytes();\n                SecretKeySpec secret = new SecretKeySpec(key2, \"AES\");\n                Cipher cipher = Cipher.getInstance(\"AES\");\n                cipher.init(Cipher.DECRYPT_MODE, secret);\n                byte[] decrypted = cipher.doFinal(str.getBytes());\n                System.out.println(\"Decrypted Info: \" + new String(decrypted));\n            } catch (BadPaddingException e) {\n                System.out.println(\"Wrong Key!\");\n            } catch (InvalidKeyException f) {\n                System.out.println(\"Invalid Key!\");\n            }\n        }\n    } catch (IOException e) {\n        System.out.println(\"Error\");\n    }\n  }\n}\n", "idx": 1922}
{"project": "cipher", "commit_id": "Snippet14631582_37856.java", "target": 0, "func": "public class AES_Encryption  {\npublic static void main(String[] args) throws Exception {\n    String str = new Scanner(new File(\"plainText.txt\")).useDelimiter(\"\\\\t\").next();\n    FileOutputStream fstream = new FileOutputStream(\"cipherText.txt\");\n    BufferedOutputStream out = new BufferedOutputStream(fstream);\n    FileOutputStream fstream2 = new FileOutputStream(\"decrpytedText.txt\");\n    BufferedOutputStream out2 = new BufferedOutputStream(fstream2);\n    System.out.println(\"INPUT String:\\n\" + str);\n\n\n    KeyGenerator keyGen = KeyGenerator.getInstance(\"AES\");\n    keyGen.init(128);\n    Key key = keyGen.generateKey();\n    Cipher cipher = Cipher.getInstance(\"AES/ECB/PKCS5Padding\");\n    cipher.init(Cipher.ENCRYPT_MODE, key);\n    byte[] cipherText = cipher.doFinal(str.getBytes());\n    System.out.println(\"ENCRYPTED String:\\n\"+new String(cipherText, \"UTF8\") );\n    out.write(cipherText);\n    out.flush();\n    out.close();\n\n\n    //String cipherT = new Scanner(new File(\"cipherText.txt\")).nextLine();\n    BufferedInputStream bfin = new BufferedInputStream(new FileInputStream(new File(\"cipherText.txt\")));//To read the file in Binary Mode.\n    cipher.init(Cipher.DECRYPT_MODE, key);\n    int BUFFERSIZE = 1024;\n    byte[] readBytes = new byte[BUFFERSIZE];\n    byte[] data = null;\n    int totalRead = -1;\n    while( (totalRead = bfin.read(readBytes))!=-1)\n    {\n        byte[] temp = new byte[(data == null ? totalRead : data.length)];\n        System.arraycopy((data==null ? readBytes : data),0,temp,0, temp.length); \n        data = new byte[(data == null ? 0 : data.length) + totalRead];\n        System.arraycopy(temp, 0, data, 0, temp.length);\n        System.arraycopy(readBytes, 0, data, data.length - temp.length, totalRead);\n    }\n    if (data!=null)\n    {\n        byte[] newPlainText = cipher.doFinal(data);\n        out2.write(newPlainText);\n        out2.flush();\n        System.out.println(\"DECRYPTED String:\\n\"+new String(newPlainText,\"UTF8\"));\n    }\n    else\n    {\n        System.out.println(\"No Data Found\");\n    }\n    //String dt = new String(newPlainText, \"UTF8\");\n    out2.close();\n}\n}\n", "idx": 2088}
{"project": "cipher", "commit_id": "Snippet45786921_27866.java", "target": 0, "func": "private static final char[] BASE58_CHARS = \"123456789ABCDEFGHJKLMNPQRSTUVWXYZabcdefghijkmnopqrstuvwxyz\".toCharArray();\nprivate static final int LENGTH = BASE58_CHARS.length;\nprivate static final BigInteger LENGTH_BI = BigInteger.valueOf(LENGTH);\n\n// TODO: CHANGE THE KEY TO SOMETHING RANDOM!\nprivate static final byte[] KEY = new byte {1,2,3,4,5,6,7,8,1,2,3,4,5,6,7,8,1,2,3,4,5,6,7,8};\n\npublic static String genSlug(long priimaryKeyId) {\n    ByteBuffer bb = ByteBuffer.allocate(8);\n    bb.putLong(priimaryKeyId);\n\n    Cipher cipher = Cipher.getInstance(\"DESede/ECB/NoPadding\");\n    cipher.init(Cipher.ENCRYPT_MODE, new SecretKeySpec(KEY, \"DESede\"));\n    byte[] encrypted = cipher.doFinal(bb.array());\n    BigInteger bi = new BigInteger(1, encrypted);\n\n    char[] buffer = new char[20];\n    int index = 0;\n    do {\n        BigInteger i = bi.mod(LENGTH_BI);\n        buffer[index++] = BASE58_CHARS[i.intValue()];\n        bi = bi.divide(LENGTH_BI);\n    } while (bi.compareTo(BigInteger.ZERO) == 1);\n    return new String(buffer, 0, index);\n}\n", "idx": 2000}
{"project": "cipher", "commit_id": "Snippet42899442_25026.java", "target": 1, "func": "import java.security._\nimport java.security.spec.X509EncodedKeySpec\nimport javax.crypto._\nimport org.apache.commons.codec.binary.Base64\nimport scala.io.Source\nimport org.apache.spark.SparkConf\nimport org.apache.spark.SparkContext\nimport java.util.logging.Logger\n\nobject RSA {\n   def bytes2hex(bytes: Array[Byte]): String = {\n    val hex = new StringBuilder()\n    for (i <- 0 to bytes.length - 1) {\n      val b = bytes(i)\n      var negative = false\n      if (b < 0) {\n        negative = true\n      }\n      val inte = Math.abs(b)\n      val temp = Integer.toHexString(inte & 0xFF)\n      if (temp.length() == 1) {\n        hex.append(\"0\")\n      }\n      // hex.append(temp.toLowerCase())\n      hex.append(temp)\n    }\n    hex.toString\n  }\n\n\n\ndef decodePublicKey(encodedKey: String):Option[PublicKey] = { \n    this.decodePublicKey(\n      (new Base64()).decode(encodedKey)\n    )   \n  }\ndef decodePublicKey(encodedKey: Array[Byte]): Option[PublicKey]= { \n    scala.util.control.Exception.allCatch.opt {\n      val spec = new X509EncodedKeySpec(encodedKey)\n      val factory = KeyFactory.getInstance(\"RSA\")\n      factory.generatePublic(spec)\n    }   \n  }\n\ndef encrypt(file: String,key:PublicKey): Array[Byte] = { \n\nval cipher = Cipher.getInstance(\"RSA\")\n\ncipher.init(Cipher.ENCRYPT_MODE, key)\n\nval text = Source.fromFile(file)\n\nval list=text.toList\n\nval blocks=list.grouped(501)\n\nval iter=blocks.formatted()\n\n\nval words=iter.getBytes\n\ncipher.doFinal(words)\n}\n\ndef main(args:Array[String]):Unit={\nval publicKey=decodePublicKey(\"--4096bits RSA public keys--\")\n\nval cipher = encrypt(\"E:\\\\plaintext.txt\",publicKey.get)\n\nprintln(\"Cipher is \"+  bytes2hex(cipher))\n\n}\n  }`\n", "idx": 2460}
{"project": "cipher", "commit_id": "Snippet44281488_26329.java", "target": 1, "func": "import java.io.UnsupportedEncodingException;\nimport java.security.SecureRandom;\n\nimport javax.crypto.Cipher;\nimport javax.crypto.SecretKey;\nimport javax.crypto.SecretKeyFactory;\nimport javax.crypto.spec.IvParameterSpec;\nimport javax.crypto.spec.PBEKeySpec;\nimport javax.crypto.spec.SecretKeySpec;\nimport org.apache.commons.codec.binary.Base64;\n\npublic class AESDecryption {\nprivate static String key = \"1234567890123456\";\nprivate static String encryptedStr = \"0aZdRxsIqSpFtuszNr73na/J9JuMLNB0J6T2f2FrV0sUlMmbW4prbZMmXGnLU4W6CDlb5F1lb8js\\r\\nRHw6tfyZd5ZL//ZUlozE916wvP+zd+uUfjpk2Bl9o2uAu+1bsNoAVdtP5m5fbnkjxf9yLRzREVVO\\r\\nIwYQOxNI/CeX2dzF/Uc=\";\nprivate static String padding = \"AES/CBC/PKCS5Padding\";\nprivate static int iterationCount = 65536;\nprivate static int keyLength = 128;\nprivate static String secretKeyAlg = \"PBEWithHmacSHA1AndAES_128\";\n\npublic static void main(String[] args) throws Exception {\n    String finalStrDec = null;\n    SecretKeyFactory factory = SecretKeyFactory.getInstance(secretKeyAlg);\n    PBEKeySpec spec = new PBEKeySpec(key.toCharArray(), generateSalt(), iterationCount, keyLength);\n    SecretKey secretKey = factory.generateSecret(spec);\n    SecretKeySpec secretKeySpec = new SecretKeySpec(secretKey.getEncoded(), \"AES\");\n\n    IvParameterSpec ivSpec = new IvParameterSpec(new byte[16]);\n    Cipher cipherDec = Cipher.getInstance(padding);\n    cipherDec.init(Cipher.DECRYPT_MODE, secretKeySpec, ivSpec);\n    byte[] original = cipherDec.doFinal(Base64.decodeBase64(encryptedStr));\n    finalStrDec = new String(original);\n    System.out.println(finalStrDec);\n}\n\npublic static byte[] generateSalt() throws UnsupportedEncodingException {\n    SecureRandom random = new SecureRandom();\n    byte bytes[] = new byte[20];\n    random.nextBytes(bytes);\n    String salt = new String(bytes);\n    return salt.getBytes(\"UTF-8\");\n}\n}\n", "idx": 2655}
{"project": "cipher", "commit_id": "Snippet5615643_31683.java", "target": 1, "func": "    //httpOutput is the HTTPUrlConnection request stream\n    Cipher rsaCipher = Cipher.getInstance(\"RSA/ECB/PKCS1Padding\");\n    rsaCipher.init(Cipher.ENCRYPT_MODE, certificate);\n    CipherOutputStream cipherOutput = new CipherOutputStream(httpOutput, rsaCipher);\n\n    BufferedOutputStream bufferedOutput = new BufferedOutputStream(cipherOutput);\n    ObjectOutputStream objectOutput = new ObjectOutputStream(bufferedOutput );\n", "idx": 2521}
{"project": "cipher", "commit_id": "Snippet37761653_19769.java", "target": 1, "func": "public class Cryptor {\n        private IvParameterSpec ivspec;\n        private SecretKeySpec keyspec;\n        private Cipher cipher;\n\n        public Cryptor(byte[] key_par,byte[] iv_par)\n        {\n            keyspec = new SecretKeySpec(key_par, \"AES\");\n            ivspec = new IvParameterSpec(iv_par);\n            try {\n                cipher = Cipher.getInstance(\"AES/CBC/ZeroPadding\");\n            } catch (NoSuchAlgorithmException e) {\n                e.printStackTrace();\n            } catch (NoSuchPaddingException e) {\n                e.printStackTrace();\n            }\n        }\n        public byte[] encrypt(byte[] input) throws Exception\n        {\n            if(text == null || text.length() == 0)\n                throw new Exception(\"Empty input\");\n            byte[] encrypted = null;\n            try {\n                cipher.init(Cipher.ENCRYPT_MODE, keyspec, ivspec);\n                encrypted = cipher.doFinal(input);\n            } catch (Exception e)\n            {\n                throw new Exception(\"[encrypt] \" + e.getMessage());\n            }\n            return encrypted;\n        }\n        public byte[] decrypt(String code) throws Exception\n        {\n            if(code == null || code.length() == 0)\n                throw new Exception(\"Empty string\");\n            byte[] decrypted = null;\n            try {\n                cipher.init(Cipher.DECRYPT_MODE, keyspec, ivspec);\n                decrypted = cipher.doFinal(hexToBytes(code));\n            } catch (Exception e)\n            {\n                throw new Exception(\"[decrypt] \" + e.getMessage());\n            }\n            return decrypted;\n        }\n        public static String bytesToHex(byte[] data)\n        {\n            if (data==null)\n            {\n                return null;\n            }\n            int len = data.length;\n            String str = \"\";\n            for (int i=0; i<len; i++) {\n                if ((data[i]&0xFF)<16)\n                    str = str + \"0\" + java.lang.Integer.toHexString(data[i]&0xFF);\n                else\n                    str = str + java.lang.Integer.toHexString(data[i]&0xFF);\n            }\n            return str;\n        }\n        public static byte[] hexToBytes(String str) {\n            if (str==null) {\n                return null;\n            } else if (str.length() < 2) {\n                return null;\n            } else {\n                int len = str.length() / 2;\n                byte[] buffer = new byte[len];\n                for (int i=0; i<len; i++) {\n                    buffer[i] = (byte) Integer.parseInt(str.substring(i*2,i*2+2),16);\n                }\n                return buffer;\n            }\n        }\n}\n", "idx": 2603}
{"project": "cipher", "commit_id": "Snippet16192140_39150.java", "target": 0, "func": "Cipher aes = Cipher.getInstance(\"AES/ECB/PKCS5Padding\");\naes.init(Cipher.DECRYPT_MODE, generateKey());\nbyte[] ciphertext = aes.doFinal(rawPassword.getBytes());\n", "idx": 1934}
{"project": "cipher", "commit_id": "Snippet20196658_2871.java", "target": 1, "func": "String SecretKey = \"0123456789abcdef\";\nString iv = \"fedcba9876543210\";\n\nIvParameterSpec ivspec = new IvParameterSpec(iv.getBytes());\nSecretKeySpec keyspec = new SecretKeySpec(SecretKey.getBytes(), \"AES\");\nCipher cipher = Cipher.getInstance(\"AES/CBC/PKCS5Padding\");\n\n//Initialize the cipher\ncipher.init(Cipher.ENCRYPT_MODE, keyspec, ivspec); \n\nString message = \"What's up?\";\nbyte[] encrypted = cipher.doFinal(message.getBytes());\n\n//Send the data\noutputStream.write(encrypted);\n", "idx": 2540}
{"project": "cipher", "commit_id": "Snippet29476038_11482.java", "target": 1, "func": "import android.os.Bundle;\nimport android.support.v7.app.ActionBarActivity;\nimport android.util.Base64;\nimport android.view.Menu;\nimport android.view.MenuItem;\nimport android.widget.TextView;\nimport org.bouncycastle.jce.provider.BouncyCastleProvider;\nimport java.security.InvalidAlgorithmParameterException;\nimport java.security.InvalidKeyException;\nimport java.security.KeyPair;\nimport java.security.KeyPairGenerator;\nimport java.security.NoSuchAlgorithmException;\nimport java.security.NoSuchProviderException;\nimport java.security.PrivateKey;\nimport java.security.PublicKey;\nimport java.security.Security;\nimport java.security.spec.ECGenParameterSpec;\n\nimport javax.crypto.BadPaddingException;\nimport javax.crypto.Cipher;\nimport javax.crypto.IllegalBlockSizeException;\nimport javax.crypto.NoSuchPaddingException;\n\npublic class ECC_page extends ActionBarActivity {\n\n    @Override\n    protected void onCreate(Bundle savedInstanceState) {\n        super.onCreate(savedInstanceState);\n        setContentView(R.layout.activity_ecc_page);\n\n        Security.addProvider(new BouncyCastleProvider());\n\n        KeyPairGenerator kpg = null;\n        try {\n            kpg = KeyPairGenerator.getInstance(\"ECIES\", \"BC\");\n        } catch (NoSuchAlgorithmException | NoSuchProviderException e) {\n            e.printStackTrace();\n        }\n        ECGenParameterSpec brainpoolP160R1 = new ECGenParameterSpec(\"brainpoolP160R1\");\n\n        try {\n            assert kpg != null;\n            kpg.initialize(brainpoolP160R1); //I am getting the error here\n        } catch (InvalidAlgorithmParameterException ignored) {\n\n\n        }\n\n        KeyPair kp = kpg.generateKeyPair();\n\n        PublicKey publicKey = kp.getPublic();\n        PrivateKey privateKey = kp.getPrivate();\n\n        byte[] PublicKey = publicKey.getEncoded();\n        byte[] PrivateKey = privateKey.getEncoded();\n\n        Cipher c = null;\n        try {\n            c = Cipher.getInstance(\"ECIESWithAES/DHAES/NoPadding\", \"BC\");\n        } catch (NoSuchAlgorithmException | NoSuchPaddingException | NoSuchProviderException e) {\n            e.printStackTrace();\n        }\n\n        try {\n            c.init(Cipher.ENCRYPT_MODE, publicKey);\n        } catch (InvalidKeyException e) {\n            e.printStackTrace();\n        }\n\n        byte[] cipher = new byte[0];\n        try {\n            cipher = c.doFinal(\"This is the message\".getBytes());\n        } catch (IllegalBlockSizeException | BadPaddingException e) {\n            e.printStackTrace();\n        }\n        TextView eccencoded = (TextView) findViewById(R.id.eccencoded);\n        eccencoded.setText(\"[ENCODED]:\\n\" +\n                Base64.encodeToString(cipher, Base64.DEFAULT) + \"\\n\");\n\n\n        try {\n            c.init(Cipher.DECRYPT_MODE, privateKey); \n        } catch (InvalidKeyException e) {\n            e.printStackTrace();\n        }\n\n       byte[] plaintext = new byte[0];\n        try {\n            plaintext = c.doFinal(cipher);\n        } catch (IllegalBlockSizeException | BadPaddingException e) {\n            e.printStackTrace();\n        }\n        TextView eccdecoded = (TextView) findViewById(R.id.eccdecoded);\n        eccdecoded.setText(\"[DECODED]:\\n\" +\n                Base64.encodeToString(plaintext, Base64.DEFAULT) + \"\\n\");\n\n\n    }\n\n}\n", "idx": 2538}
{"project": "cipher", "commit_id": "Snippet43188874_25322.java", "target": 1, "func": "private static final String KEY_TRANSFORMATION_ALGORITHM_SYM = \"AES/CBC/NoPadding\";\n\n@NonNull\nstatic String encryptMessage(@NonNull String plainMessage,\n                             @NonNull SharedPreferences storage,\n                             @Nullable Key aesKey,\n                             @NonNull String charset) {\n    if (aesKey == null) {\n        throw new RuntimeException(\"AES key is null\", null);\n    }\n    try {\n        // Cipher can not be re-used on Android\n        Cipher cipher = Cipher.getInstance(KEY_TRANSFORMATION_ALGORITHM_SYM);\n        cipher.init(Cipher.ENCRYPT_MODE, aesKey, new IvParameterSpec(getIV(storage, cipher, charset)));\n        byte[] charsetEncryptedData = cipher.doFinal(plainMessage.getBytes(charset));\n        return Base64.encodeToString(charsetEncryptedData, Base64.NO_WRAP);\n\n    } catch (NoSuchAlgorithmException | InvalidKeyException | NoSuchPaddingException | InvalidAlgorithmParameterException | BadPaddingException | IllegalBlockSizeException | UnsupportedEncodingException e) {\n        throw new RuntimeException(e.getMessage(), e);\n    }\n}\n\n@NonNull\nstatic String decryptMessage(@NonNull String encryptedMessage,\n                             @NonNull SharedPreferences storage,\n                             @Nullable Key aesKey,\n                             @NonNull String charset) {\n    if (aesKey == null) {\n        throw new RuntimeException(\"AES key is null\", null);\n    }\n    try {\n        //Cipher can not be re-used on Android\n        Cipher cipher = Cipher.getInstance(KEY_TRANSFORMATION_ALGORITHM_SYM);\n        cipher.init(Cipher.DECRYPT_MODE, aesKey, new IvParameterSpec(getIV(storage, cipher, charset)));\n\n        byte[] decryptedData = Base64.decode(encryptedMessage.getBytes(charset), Base64.NO_WRAP);\n        byte[] charsetEncryptedData = cipher.doFinal(decryptedData);\n        return new String(charsetEncryptedData, charset);\n\n    } catch (NoSuchAlgorithmException | InvalidKeyException | InvalidAlgorithmParameterException | BadPaddingException | NoSuchPaddingException | IllegalBlockSizeException | UnsupportedEncodingException e) {\n        throw new RuntimeException(e.getMessage(), e);\n    }\n}\n", "idx": 2691}
{"project": "cipher", "commit_id": "Snippet25587557_7910.java", "target": 0, "func": "import java.security.NoSuchAlgorithmException;\nimport javax.crypto.BadPaddingException;\nimport javax.crypto.Cipher;\nimport javax.crypto.IllegalBlockSizeException;\nimport javax.crypto.KeyGenerator;\nimport javax.crypto.NoSuchPaddingException;\nimport javax.crypto.SecretKey;\nimport javax.crypto.spec.SecretKeySpec;\nimport javax.management.openmbean.InvalidKeyException;\nimport javax.xml.bind.DatatypeConverter;\n\npublic class Test11 {\n\n    public static String brutToHexa(byte[] t) {\n        StringBuilder sb = new StringBuilder(t.length * 2);\n        for (int i = 0; i < t.length; i++) {\n\n            int v = t[i] & 0xff;\n            if (v < 16) {\n\n                sb.append('0');\n\n            }\n\n            sb.append(Integer.toHexString(v));//.append(\"-\");\n\n        }\n\n        return sb.toString();\n    }\n\n    public static byte[] hexStringToByteArray(String s) {\n        int len = s.length();\n        byte[] data = new byte[len / 2];\n        for (int i = 0; i < len; i += 2) {\n            data[i / 2] = (byte) ((Character.digit(s.charAt(i), 16) << 4)\n                            + Character.digit(s.charAt(i + 1), 16));\n        }\n        return data;\n    }\n\n    public static byte[] encrypter(final String message, SecretKey cle)\n                    throws NoSuchAlgorithmException, NoSuchPaddingException,\n                    InvalidKeyException, IllegalBlockSizeException, BadPaddingException, java.security.InvalidKeyException {\n        Cipher cipher = Cipher.getInstance(\"AES\");\n        cipher.init(Cipher.ENCRYPT_MODE, cle);\n        byte[] donnees = message.getBytes();\n\n        return cipher.doFinal(donnees);\n    }\n\n    public static String decrypter(final byte[] donnees, SecretKey cle)\n                    throws NoSuchAlgorithmException, NoSuchPaddingException,\n                    InvalidKeyException, IllegalBlockSizeException, BadPaddingException, java.security.InvalidKeyException {\n        Cipher cipher = Cipher.getInstance(\"AES\");\n        cipher.init(Cipher.DECRYPT_MODE, cle);\n\n        return new String(cipher.doFinal(donnees));\n    }\n\n    public static void main(String[] args) throws java.security.InvalidKeyException {\n\n        final String message = \"Java is the best\";\n\n        KeyGenerator keyGen;\n        try {\n            keyGen = KeyGenerator.getInstance(\"AES\");\n            SecretKey cle = keyGen.generateKey();\n\n            String hexKey = brutToHexa(cle.getEncoded());\n\n            byte[] enc = encrypter(message, cle);\n            System.out.print(\"encrypted text : \");\n            System.out.println(DatatypeConverter.printBase64Binary(enc));\n\n            String dec = decrypter(enc, cle);\n            System.out.println(\"decrypted text : \" + dec);\n\n            decryptWith(hexKey, brutToHexa(enc));\n\n        } catch (NoSuchAlgorithmException | NoSuchPaddingException | InvalidKeyException |\n                        IllegalBlockSizeException | BadPaddingException e) {\n            e.printStackTrace();\n        }\n    }\n\n    public static void decryptWith(String hexKey, String hexMessage) throws java.security.InvalidKeyException {\n        try {\n\n            byte[] byteKey = hexStringToByteArray(hexKey);\n            SecretKey secretKey = new SecretKeySpec(byteKey, \"AES\");\n\n            byte[] message = hexStringToByteArray(hexMessage);\n\n            Cipher cipher = Cipher.getInstance(\"AES\");\n            cipher.init(Cipher.DECRYPT_MODE, secretKey);\n            String dec = new String(cipher.doFinal(message));\n            System.out.println(\"texte decrypte : \" + dec);\n\n        } catch (NoSuchAlgorithmException | NoSuchPaddingException | InvalidKeyException | IllegalBlockSizeException | BadPaddingException e) {\n            e.printStackTrace();\n        }\n    }\n}\n", "idx": 1991}
{"project": "cipher", "commit_id": "Snippet20877251_3469.java", "target": 0, "func": "public static boolean exportDB(int wellnessDayId) {\n    Serializer serializer = new Persister();\n    WellnessDay backToXMLWellnesday = ExportDbToXml.buildXmlDataModel(wellnessDayId);\n    if (backToXMLWellnesday == null) {\n        return false;\n    }\n    StringWriter sw = new StringWriter();\n    FileOutputStream fos = null;\n    FileOutputStream fosbackup = null;\n    try {\n        serializer.write(backToXMLWellnesday, sw);\n        DesHelper des = new DesHelper(\"12345678\");\n        byte[] decryptedBytes = sw.toString().getBytes();\n\n        //Calculating the size that the array should be (ie multiples of 8)\n        Double len = Math.ceil(((double) decryptedBytes.length) / EIGHT) * EIGHT;\n        byte[] decryptedBytesPadded = new byte[len.intValue()];\n\n        //Initializing to whitespace character\n        byte whiteSpaceBytevalue = 32;\n        for (int k=0; k< decryptedBytesPadded.length; k++){\n            decryptedBytesPadded[k]= whiteSpaceBytevalue;\n        }\n\n        //Copying the array into the byte array that is the correct length (ie multiples of 8)\n        System.arraycopy(decryptedBytes, 0, decryptedBytesPadded, 0, Math.min(decryptedBytes.length, len.intValue()));\n\n        byte[] encryptedBytes = des.encrypt(decryptedBytesPadded);\n        String filename = \"Export.blb\";\n        File sdCard = Environment.getExternalStorageDirectory();\n        File dir = new File(sdCard.getAbsolutePath() + \"/export\");\n        dir.mkdirs();\n\n        File file = new File(dir, filename);\n        file.createNewFile();\n        fos = new FileOutputStream(file);\n\n        for (int p = 0; p < encryptedBytes.length; p++) {\n            fos.write(encryptedBytes[p]);\n        }\n\n        Format formatter;\n        Date date = Calendar.getInstance().getTime();\n        formatter = new SimpleDateFormat(\"dd-MM-yyyy HH-mm-ss\");\n        String dateFormatted = formatter.format(date);\n        //Create Backup file in /Wellnessdays/archive\n         File dirBackup = new File(sdCard.getAbsolutePath() + \"/archive\");\n        dirBackup.mkdirs();\n        File filebackup = new File(dirBackup, dateFormatted + \" - \" + filename);\n        filebackup.createNewFile();\n        fosbackup = new FileOutputStream(filebackup);\n        for (int p = 0; p < encryptedBytes.length; p++) {\n            fosbackup.write(encryptedBytes[p]);\n        }\n\n\n    } catch (FileNotFoundException e) {\n        Log.e(TAG, e.getMessage());\n        return false;\n    } catch (IOException e) {\n        Log.e(TAG, e.getMessage());\n        return false;\n    } catch (GeneralSecurityException e) {\n        Log.e(TAG, e.getMessage());\n        return false;\n    } catch (Exception e) {\n        Log.e(TAG, e.getMessage());\n        return false;\n    } finally {\n        if (fos != null) {\n            try {\n                fos.close();\n            } catch (IOException e) {\n                Log.e(\"DatabaseExportToXML\", e.getMessage());\n            }\n        }\n        if (fosbackup!=null){\n            try {\n                fosbackup.close();\n            } catch (IOException e) {\n                Log.e(\"DatabaseExportToXML\", e.getMessage());\n            }\n        }\n    }\n    return true;\n}\n\npublic class DesHelper {\n\npublic static int MAX_KEY_LENGTH = DESKeySpec.DES_KEY_LEN;\n//private static String ENCRYPTION_ALGORITHM = \"DES/CBC/PKCS5Padding\";\nprivate static String ENCRYPTION_ALGORITHM = \"DES/ECB/NoPadding\";\nprivate static String ENCRYPTION_KEY_TYPE = \"DES\";\n\nprivate final SecretKeySpec keySpec;\n\npublic DesHelper(String passphrase) {\n    byte[] key;\n    try {\n        key = passphrase.getBytes(\"UTF8\");\n    } catch (UnsupportedEncodingException e) {\n        throw new IllegalArgumentException(e);\n    }\n    //The key is always 8 bytes, no need to pad the key\n    keySpec = new SecretKeySpec(key, ENCRYPTION_KEY_TYPE);\n}\n\nprivate byte[] padKeyToLength(byte[] key, int len) {\n    byte[] newKey = new byte[len];\n    System.arraycopy(key, 0, newKey, 0, Math.min(key.length, len));\n    return newKey;\n}\n\npublic byte[] encrypt(byte[] unencrypted) throws GeneralSecurityException {\n    return doCipher(unencrypted, Cipher.ENCRYPT_MODE);\n}\n\npublic byte[] decrypt(byte[] encrypted) throws GeneralSecurityException {\n    return doCipher(encrypted, Cipher.DECRYPT_MODE);\n}\n\nprivate byte[] doCipher(byte[] original, int mode) throws GeneralSecurityException {\n    Cipher cipher = Cipher.getInstance(ENCRYPTION_ALGORITHM);\n    cipher.init(mode, keySpec);\n    return cipher.doFinal(original);\n}\n\n}\n", "idx": 2101}
{"project": "cipher", "commit_id": "Snippet26941518_9063.java", "target": 1, "func": "public class AESDemo {\n\n\n    private static final String password = \"test\";\n    private static String salt;\n    private static int pswdIterations = 65536;\n    private static int keySize = 256;\n    private byte[] ivBytes;\n\n    public String encrypt(String plainText) throws Exception {\n\n        //get salt\n        salt = generateSalt();\n        byte[] saltBytes = salt.getBytes(\"UTF-8\");\n\n        // Derive the key\n        SecretKeyFactory factory = SecretKeyFactory.getInstance(\"PBKDF2WithHmacSHA1\");\n        PBEKeySpec spec = new PBEKeySpec(\n                password.toCharArray(),\n                saltBytes,\n                //null,\n                pswdIterations,\n                keySize\n        );\n\n        SecretKey secretKey = factory.generateSecret(spec);\n        SecretKeySpec secret = new SecretKeySpec(secretKey.getEncoded(), \"AES\");\n\n        //encrypt the message\n        Cipher cipher = Cipher.getInstance(\"AES/CBC/PKCS5Padding\");\n        cipher.init(Cipher.ENCRYPT_MODE, secret);\n        AlgorithmParameters params = cipher.getParameters();\n        ivBytes = params.getParameterSpec(IvParameterSpec.class).getIV();\n        byte[] encryptedTextBytes = cipher.doFinal(plainText.getBytes(\"UTF-8\"));\n        //return new Base64().encodeAsString(encryptedTextBytes);\n        return  Base64.encodeToString(encryptedTextBytes, Base64.DEFAULT);\n    }\n\n    @SuppressWarnings(\"static-access\")\n    public String decrypt(String encryptedText) throws Exception {\n\n        byte[] saltBytes = salt.getBytes(\"UTF-8\");\n        //byte[] encryptedTextBytes = new Base64().decodeBase64(encryptedText);\n        byte[] encryptedTextBytes= Base64.decode(encryptedText, Base64.DEFAULT);\n\n        // Derive the key\n        SecretKeyFactory factory = SecretKeyFactory.getInstance(\"PBKDF2WithHmacSHA1\");\n        PBEKeySpec spec = new PBEKeySpec(\n                password.toCharArray(),\n                saltBytes,\n                pswdIterations,\n                keySize\n        );\n\n        SecretKey secretKey = factory.generateSecret(spec);\n        SecretKeySpec secret = new SecretKeySpec(secretKey.getEncoded(), \"AES\");\n\n        // Decrypt the message\n        Cipher cipher = Cipher.getInstance(\"AES/CBC/PKCS5Padding\");\n        cipher.init(Cipher.DECRYPT_MODE, secret, new IvParameterSpec(ivBytes));\n\n\n        byte[] decryptedTextBytes = null;\n        try {\n            decryptedTextBytes = cipher.doFinal(encryptedTextBytes);\n        } catch (IllegalBlockSizeException e) {\n            e.printStackTrace();\n        } catch (BadPaddingException e) {\n            e.printStackTrace();\n        }\n\n        return new String(decryptedTextBytes);\n    }\n\n    public String generateSalt() {\n        SecureRandom random = new SecureRandom();\n        byte bytes[] = new byte[20];\n        String ss = \"\";\n        random.nextBytes(bytes);\n        String s = new String(bytes);\n        return \"sare\";\n    }\n}\n", "idx": 2736}
{"project": "cipher", "commit_id": "Snippet42548963_24595.java", "target": 0, "func": "String keyAlg = \"AES\";\nString cipherAlg = \"AES/ECB/PKCS5Padding\";\nbyte[] data = new byte[]{14,23,3,45,62};\nbyte[] pswdBytes = new byte[]{1,2,3,4,6};\nMessageDigest digest = MessageDigest.getInstance(\"MD5\");\nbyte[] hash = digest.digest(pswdBytes);\n\n\nKey key = new SecretKeySpec(hash , keyAlg);\nCipher cipher = Cipher.getInstance(cipherAlg);\ncipher.init(Cipher.ENCRYPT_MODE, key);\nbyte[] encVal = cipher.doFinal(data);\n", "idx": 2252}
{"project": "cipher", "commit_id": "Snippet7883954_32987.java", "target": 1, "func": "Cipher.getInstance(\"RSA\")", "idx": 2657}
{"project": "cipher", "commit_id": "Snippet42505829_24536.java", "target": 0, "func": "private static byte[] encodeFile(byte[] yourKey, byte[] fileData)\n        throws Exception {\n    byte[] encrypted = null;\n    SecretKeySpec skeySpec = new SecretKeySpec(yourKey, 0, yourKey.length, \"AES\");\n    Cipher cipher = Cipher.getInstance(\"AES/ECB/PKCS7PADDING\");\n    cipher.init(Cipher.ENCRYPT_MODE, skeySpec);\n    encrypted = cipher.doFinal(fileData);\n    return encrypted;\n}\n\nprivate static byte[] generateKey() throws NoSuchAlgorithmException {\n    byte[] keyStart = \"This is my key\".getBytes();\n    String id = \"dummypass\";\n    int iterationCount = 1000;\n    int saltLength = 32;\n    int keyLength = 128;\n    SecureRandom random = new SecureRandom();\n    byte[] salt = Arrays.copyOf(keyStart,saltLength);\n    random.nextBytes(salt);\n    KeySpec keySpec = new PBEKeySpec(id.toCharArray(), salt,\n            iterationCount, keyLength);\n    SecretKeyFactory keyFactory = SecretKeyFactory\n            .getInstance(\"PBKDF2WithHmacSHA1\");\n    byte[] keyBytes = new byte[0];\n    try {\n        keyBytes = keyFactory.generateSecret(keySpec).getEncoded();\n    } catch (InvalidKeySpecException e) {\n        e.printStackTrace();\n    }\n    SecretKey key = new SecretKeySpec(keyBytes, \"AES\");\n    return key.getEncoded();\n}\n\nprivate static byte[] decodeFile(byte[] yourKey, byte[] encryptedData)\n        throws Exception {\n    SecretKeySpec skeySpec = new SecretKeySpec(yourKey, 0, yourKey.length,\n            \"AES\");\n    Cipher cipher = Cipher.getInstance(\"AES/ECB/PKCS7PADDING\");\n    cipher.init(Cipher.DECRYPT_MODE, skeySpec);\n    byte[] decrypted = cipher.doFinal(encryptedData);\n    return decrypted;\n}\n\npublic static void Encrypt(byte[] bytesToEncrypt, File target) {\n    try {\n        BufferedOutputStream bos = new BufferedOutputStream(\n                new FileOutputStream(target));\n        byte[] key = generateKey();\n        byte[] encryptedBytes = encodeFile(key, bytesToEncrypt);\n        bos.write(encryptedBytes);\n        bos.flush();\n        bos.close();\n    } catch (FileNotFoundException e) {\n        e.printStackTrace();\n    } catch (IOException e) {\n        e.printStackTrace();\n    } catch (Exception e) {\n        e.printStackTrace();\n    }\n}\npublic static  byte[] DecryptFile(byte[] bytesToDecrypt) {\n    byte[] decodedData = new byte[0];\n    try {\n        byte[] key = generateKey();\n        decodedData = decodeFile(key, bytesToDecrypt);\n    } catch (Exception e) {\n        e.printStackTrace();\n    }\n    return decodedData;\n}\n", "idx": 1998}
{"project": "cipher", "commit_id": "Snippet30861393_13015.java", "target": 0, "func": "package tutorial;\n\nimport org.apache.thrift.TByteArrayOutputStream;\nimport org.apache.thrift.transport.TMemoryInputTransport;\nimport org.apache.thrift.transport.TTransport;\nimport org.apache.thrift.transport.TTransportException;\nimport org.apache.thrift.transport.TTransportFactory;\n\nimport javax.crypto.Cipher;\nimport java.security.Key;\n/**\n * TEncryptedFramedTransport is a buffered TTransport. It encrypts fully read message\n * with the \"AES/ECB/PKCS5Padding\" symmetric algorithm and send it, preceeding with a 4-byte frame size.\n */\npublic class TEncryptedFramedTransport extends TTransport {\n    public static final String ALGORITHM = \"AES/ECB/PKCS5Padding\";\n\n    private Cipher encryptingCipher;\n    private Cipher decryptingCipher;\n\n    protected static final int DEFAULT_MAX_LENGTH = 0x7FFFFFFF;\n\n    private int maxLength_;\n\n    private TTransport transport_ = null;\n\n    private final TByteArrayOutputStream writeBuffer_ = new TByteArrayOutputStream(1024);\n    private TMemoryInputTransport readBuffer_ = new TMemoryInputTransport(new byte[0]);\n\n    public static class Factory extends TTransportFactory {\n        private int maxLength_;\n        private Key secretKey_;\n\n        public Factory(Key secretKey) {\n            this(secretKey, DEFAULT_MAX_LENGTH);\n        }\n\n        public Factory(Key secretKey, int maxLength) {\n            maxLength_ = maxLength;\n            secretKey_ = secretKey;\n        }\n\n        @Override\n        public TTransport getTransport(TTransport base) {\n            return new TEncryptedFramedTransport(base, secretKey_, maxLength_);\n        }\n    }\n\n    /**\n     * Constructor wraps around another tranpsort\n     */\n    public TEncryptedFramedTransport(TTransport transport, Key secretKey, int maxLength) {\n        transport_ = transport;\n        maxLength_ = maxLength;\n\n        try {\n            encryptingCipher = Cipher.getInstance(ALGORITHM);\n            encryptingCipher.init(Cipher.ENCRYPT_MODE, secretKey);\n\n            decryptingCipher = Cipher.getInstance(ALGORITHM);\n            decryptingCipher.init(Cipher.DECRYPT_MODE, secretKey);\n        } catch (Exception e) {\n            throw new RuntimeException(\"Unable to initialize ciphers.\");\n        }\n    }\n\n    public TEncryptedFramedTransport(TTransport transport, Key secretKey) {\n        this(transport, secretKey, DEFAULT_MAX_LENGTH);\n    }\n\n    public void open() throws TTransportException {\n        transport_.open();\n    }\n\n    public boolean isOpen() {\n        return transport_.isOpen();\n    }\n\n    public void close() {\n        transport_.close();\n    }\n\n    public int read(byte[] buf, int off, int len) throws TTransportException {\n        if (readBuffer_ != null) {\n            int got = readBuffer_.read(buf, off, len);\n            if (got > 0) {\n                return got;\n            }\n        }\n\n        // Read another frame of data\n        readFrame();\n\n        return readBuffer_.read(buf, off, len);\n    }\n\n    @Override\n    public byte[] getBuffer() {\n        return readBuffer_.getBuffer();\n    }\n\n    @Override\n    public int getBufferPosition() {\n        return readBuffer_.getBufferPosition();\n    }\n\n    @Override\n    public int getBytesRemainingInBuffer() {\n        return readBuffer_.getBytesRemainingInBuffer();\n    }\n\n    @Override\n    public void consumeBuffer(int len) {\n        readBuffer_.consumeBuffer(len);\n    }\n\n    private final byte[] i32buf = new byte[4];\n\n    private void readFrame() throws TTransportException {\n        transport_.readAll(i32buf, 0, 4);\n        int size = decodeFrameSize(i32buf);\n\n        if (size < 0) {\n            throw new TTransportException(\"Read a negative frame size (\" + size + \")!\");\n        }\n\n        if (size > maxLength_) {\n            throw new TTransportException(\"Frame size (\" + size + \") larger than max length (\" + maxLength_ + \")!\");\n        }\n\n        byte[] buff = new byte[size];\n        transport_.readAll(buff, 0, size);\n\n        try {\n            buff = decryptingCipher.doFinal(buff);\n        } catch (Exception e) {\n            throw new TTransportException(0, e);\n        }\n\n        readBuffer_.reset(buff);\n    }\n\n    public void write(byte[] buf, int off, int len) throws TTransportException {\n        writeBuffer_.write(buf, off, len);\n    }\n\n    @Override\n    public void flush() throws TTransportException {\n        byte[] buf = writeBuffer_.get();\n        int len = writeBuffer_.len();\n        writeBuffer_.reset();\n\n        try {\n            buf = encryptingCipher.doFinal(buf, 0, len);\n        } catch (Exception e) {\n            throw new TTransportException(0, e);\n        }\n\n        encodeFrameSize(buf.length, i32buf);\n        transport_.write(i32buf, 0, 4);\n        transport_.write(buf);\n        transport_.flush();\n    }\n\n    public static void encodeFrameSize(final int frameSize, final byte[] buf) {\n        buf[0] = (byte) (0xff & (frameSize >> 24));\n        buf[1] = (byte) (0xff & (frameSize >> 16));\n        buf[2] = (byte) (0xff & (frameSize >> 8));\n        buf[3] = (byte) (0xff & (frameSize));\n    }\n\n    public static int decodeFrameSize(final byte[] buf) {\n        return\n                ((buf[0] & 0xff) << 24) |\n                        ((buf[1] & 0xff) << 16) |\n                        ((buf[2] & 0xff) << 8) |\n                        ((buf[3] & 0xff));\n    }\n}\n", "idx": 2124}
{"project": "cipher", "commit_id": "Snippet17497426_675.java", "target": 1, "func": "StringBuilder texto1 = new StringBuilder(\"LALALLA\");\nbyte[] x = texto1.toString().getBytes();\ntry {\n  Cipher cifrado = Cipher.getInstance(\"RSA/ECB/PKCS1Padding\");\n  cifrado.init(Cipher.ENCRYPT_MODE, key1.getPublic());\n  x = cifrado.doFinal(x);\n  String texto;\n  texto = new String(x, \"UTF-8\");\n  JOptionPane.showInputDialog(publicKey.toString());\n  String teste = \"\";\n  for (int i = 0; i < x.length; i++) {\n    teste += x[i];\n  }\n  jTextPane1.setText(teste);\n  //cifrado.init(Cipher.DECRYPT_MODE, privatekey);\n  byte[] y;\n  // x= texto.getBytes();\n  //y = cifrado.doFinal(texto.getBytes());\n  //texto = new String(y,\"UTF-8\");\n  jTextPane2.setText(x.toString());\n} ...\n", "idx": 2401}
{"project": "cipher", "commit_id": "Snippet24968466_7298.java", "target": 0, "func": "import javax.crypto.Cipher;\nimport javax.crypto.spec.SecretKeySpec;\n\npublic class Test {\n\n    private byte[] encrypted;\n\n    private String encryptedtext;\n    private String decrypted;\n\n\n\n    public String Encrypt (String pInput) {\n\n\n      try {\n\n         String Input = pInput;\n         String key = \"Bar12345Bar12345Bar12345Bar12345\"; \n\n         // Erstelle key and cipher\n         SecretKeySpec aesKey = new SecretKeySpec(key.getBytes(), \"AES\");\n         Cipher cipher = Cipher.getInstance(\"AES\");\n\n         // Verschl\u00fcsselung\n         cipher.init(Cipher.ENCRYPT_MODE, aesKey);\n         byte[] encrypted = cipher.doFinal(Input.getBytes());\n         encryptedtext = new String(encrypted);\n         System.err.println(\"encrypted:\" + encryptedtext);\n\n\n      }catch(Exception e) {\n         e.printStackTrace();\n      }\n\n        return encrypted;\n    }\n\n\n\n    public String Decrypt (String pInput) {\n\n\n       try {\n\n           String Input = pInput; \n\n           String key = \"Bar12345Bar12345Bar12345Bar12345\"; \n\n           // Erstelle key and cipher\n           SecretKeySpec aesKey = new SecretKeySpec(key.getBytes(), \"AES\");\n           Cipher cipher = Cipher.getInstance(\"AES\");\n\n           // Entschl\u00fcsselung\n           cipher.init(Cipher.DECRYPT_MODE, aesKey);\n           decrypted = new String(cipher.doFinal(encryptedtext)); // HERE IS THE PROBLEM IT WANT BYTE BUT I WANT TO ENCRYPT FROM A STRING\n           System.err.println(\"decrypted: \" + decrypted);\n\n        }catch(Exception e) {\n           e.printStackTrace();\n        }\n        return pInput;\n      }\n\n}\n", "idx": 1937}
{"project": "cipher", "commit_id": "Snippet37368710_19262.java", "target": 1, "func": "public static String encryptAES(String data, String secretKey) {\n    try {\n        byte[] secretKeys = Hashing.sha1().hashString(secretKey, Charsets.UTF_8)\n                .toString().substring(0, 16)\n                .getBytes(Charsets.UTF_8);\n\n        final SecretKey secret = new SecretKeySpec(secretKeys, \"AES\");\n\n        final Cipher cipher = Cipher.getInstance(\"AES/CBC/PKCS5Padding\");\n        cipher.init(Cipher.ENCRYPT_MODE, secret);\n\n        final AlgorithmParameters params = cipher.getParameters();\n\n        final byte[] iv = params.getParameterSpec(IvParameterSpec.class).getIV();\n        final byte[] cipherText = cipher.doFinal(data.getBytes(Charsets.UTF_8));\n\n        return DatatypeConverter.printHexBinary(iv) + DatatypeConverter.printHexBinary(cipherText);\n    } catch (Exception e) {\n        throw Throwables.propagate(e);\n    }\n}\n\n\npublic static String decryptAES(String data, String secretKey) {\n    try {\n        byte[] secretKeys = Hashing.sha1().hashString(secretKey, Charsets.UTF_8)\n                .toString().substring(0, 16)\n                .getBytes(Charsets.UTF_8);\n\n        // grab first 16 bytes - that's the IV\n        String hexedIv = data.substring(0, 32);\n\n        // grab everything else - that's the cipher-text (encrypted message)\n        String hexedCipherText = data.substring(32);\n\n        byte[] iv = DatatypeConverter.parseHexBinary(hexedIv);\n        byte[] cipherText = DatatypeConverter.parseHexBinary(hexedCipherText);\n\n        final Cipher cipher = Cipher.getInstance(\"AES/CBC/PKCS5Padding\");\n\n        cipher.init(Cipher.DECRYPT_MODE, new SecretKeySpec(secretKeys, \"AES\"), new IvParameterSpec(iv));\n\n        return new String(cipher.doFinal(cipherText), Charsets.UTF_8);\n    } catch (BadPaddingException e) {\n        throw new IllegalArgumentException(\"Secret key is invalid\");\n    }catch (Exception e) {\n        throw Throwables.propagate(e);\n    }\n}\n", "idx": 2433}
{"project": "cipher", "commit_id": "Snippet22185728_4576.java", "target": 0, "func": "String f=\"A000000000000000\";\nFileInputStream fis = new FileInputStream(\"C:\\\\Users\\\\original.txt\");\nbyte[] bytes = DatatypeConverter.parseHexBinary(f);\nSecretKey key = new SecretKeySpec(bytes, 0, bytes.length, \"DES\");\n\nString strDataToEncrypt = new String();\nString strCipherText = new String();\nString strDecryptedText = new String();\n\n    try{\n\n    Cipher desCipher = Cipher.getInstance(\"DES/CBC/PKCS5Padding\");\n    desCipher.init(Cipher.ENCRYPT_MODE,key);\n\n            //read from file and transform to String\n            try{\n            builder = new StringBuilder();\n            int ch;\n            while((ch = fis.read()) != -1){\n            builder.append((char)ch);\n            }\n            }catch (IOException e){\n\n            }\n\n    byte[] byteDataToEncrypt = builder.toString().getBytes();\n    byte[] byteCipherText = desCipher.doFinal(byteDataToEncrypt); \n    strCipherText = new BASE64Encoder().encode(byteCipherText);\n\n    System.out.println(strCipherText);\n", "idx": 2093}
{"project": "cipher", "commit_id": "Snippet28049791_10205.java", "target": 1, "func": "byte[] message = new byte[] { (byte) 0xbe, (byte) 0xef, (byte) 0xef };\nCipher cipher = Cipher.getInstance(\"RSA\");\n\nKeyFactory keyFactory = KeyFactory.getInstance(\"RSA\");\n\nString mod = \"B390F7412F2554387597814A25BC11BFFD95DB2D1456F1B66CDF52BCC1D20C7FF24F3CCE7B2D66E143213F64247454782A377C79C74477A28AF6C317BE68BC6E8FF001D375F9363B5A7161C2DFBC2ED0850697A54421552C6288996AC61AF5A9F7DE218ABBC75A145F891266615EB81D11A22B7260F7608083B373BA4BC0756B\";\nString exp = \"010001\";\n\nRSAPublicKeySpec pubKeySpec = new RSAPublicKeySpec(new BigInteger(Hex.fromString(mod)), new BigInteger(Hex.fromString(exp)));\nRSAPublicKey pubKey = (RSAPublicKey) keyFactory.generatePublic(pubKeySpec);\n\ncipher.init(Cipher.ENCRYPT_MODE, pubKey);\n\nbyte[] cipherText = cipher.doFinal(message);\nSystem.out.println(\"cipher: \" + new String(cipherText));\n", "idx": 2471}
{"project": "cipher", "commit_id": "Snippet30772674_12952.java", "target": 0, "func": " public String encrypt(String textToEncrypt) {\n    String encryptedpassword = null;\n    try {\n        Security.addProvider(new org.bouncycastle.jce.provider.BouncyCastleProvider());\n        password1 = textToEncrypt.getBytes();\n        SecretKeySpec key = new SecretKeySpec(keyBytes, \"DES\");\n        IvParameterSpec ivSpec = new IvParameterSpec(ivBytes);\n        cipherpass = Cipher.getInstance(\"DES/CTR/NoPadding\", \"BC\");\n        cipherpass.init(Cipher.ENCRYPT_MODE, key, ivSpec);\n        cipherTextPassword = new byte[cipherpass.getOutputSize(password1.length)];\n        passLength = cipherpass.update(password1, 0, password1.length, cipherTextPassword, 0);\n        passLength += cipherpass.doFinal(cipherTextPassword, passLength);\n        encryptedpassword = new String(cipherTextPassword);\n    } catch (NoSuchAlgorithmException | NoSuchProviderException | NoSuchPaddingException | InvalidKeyException | InvalidAlgorithmParameterException | ShortBufferException | IllegalBlockSizeException | BadPaddingException ex) {\n\n    }\n    return encryptedpassword;\n}\n byte[] password1;\nbyte[] emailpass1;\nbyte[] keyBytes = \"12345678\".getBytes();\nbyte[] ivBytes = \"input123\".getBytes();\nSecretKeySpec key = new SecretKeySpec(keyBytes, \"DES\");\nIvParameterSpec ivSpec = new IvParameterSpec(ivBytes);\nCipher cipherEmailpass, cipherpass;\nbyte[] cipherTextPassword;\nbyte[] cipherEmailTextPassword;\nint passLength, emailpassLength;\n", "idx": 2104}
{"project": "cipher", "commit_id": "Snippet20260097_2900.java", "target": 1, "func": "public static byte[] iv = new SecureRandom().generateSeed(16);\n\npublic static void main(String[] args) {\n    String plainText = \"Look mah, I'm a message!\";\n    System.out.println(\"Original plaintext message: \" + plainText);\n\n    // Initialize two key pairs\n    KeyPair keyPairA = generateECKeys();\n    KeyPair keyPairB = generateECKeys();\n\n    // Create two AES secret keys to encrypt/decrypt the message\n    SecretKey secretKeyA = generateSharedSecret(keyPairA.getPrivate(),\n            keyPairB.getPublic());\n    System.out.println(bytesToHex(secretKeyA.getEncoded()));\n    SecretKey secretKeyB = generateSharedSecret(keyPairB.getPrivate(),\n            keyPairA.getPublic());\n    System.out.println(bytesToHex(secretKeyB.getEncoded()));\n\n    // Encrypt the message using 'secretKeyA'\n    String cipherText = encryptString(secretKeyA, plainText);\n    System.out.println(\"Encrypted cipher text: \" + cipherText);\n\n    // Decrypt the message using 'secretKeyB'\n    String decryptedPlainText = decryptString(secretKeyB, cipherText);\n    System.out.println(\"Decrypted cipher text: \" + decryptedPlainText);\n}\n\npublic static KeyPair generateECKeys() {\n    try {\n        ECNamedCurveParameterSpec parameterSpec = ECNamedCurveTable.getParameterSpec(\"secp521r1\");\n        KeyPairGenerator keyPairGenerator = KeyPairGenerator.getInstance(\n                \"ECDH\", \"BC\");\n\n        keyPairGenerator.initialize(parameterSpec);\n\n        KeyPair keyPair = keyPairGenerator.generateKeyPair();\n        System.out.println(\"Private key length: \"\n                + keyPair.getPrivate().getEncoded().length);\n        System.out.println(\"Public key length: \"\n                + keyPair.getPublic().getEncoded().length);\n        return keyPair;\n    } catch (NoSuchAlgorithmException | InvalidAlgorithmParameterException\n            | NoSuchProviderException e) {\n        e.printStackTrace();\n        return null;\n    }\n}\n\npublic static SecretKey generateSharedSecret(PrivateKey privateKey,\n        PublicKey publicKey) {\n    try {\n        KeyAgreement keyAgreement = KeyAgreement.getInstance(\"ECDH\", \"BC\");\n        keyAgreement.init(privateKey);\n        keyAgreement.doPhase(publicKey, true);\n\n        SecretKey key = keyAgreement.generateSecret(\"AES\");\n        System.out.println(\"Shared key length: \" + key.getEncoded().length);\n        return key;\n    } catch (InvalidKeyException | NoSuchAlgorithmException\n            | NoSuchProviderException e) {\n        // TODO Auto-generated catch block\n        e.printStackTrace();\n        return null;\n    }\n}\n\npublic static String encryptString(SecretKey key, String plainText) {\n    try {\n        IvParameterSpec ivSpec = new IvParameterSpec(iv);\n        Cipher cipher = Cipher.getInstance(\"AES/GCM/NoPadding\", \"BC\");\n        byte[] plainTextBytes = plainText.getBytes(\"UTF-8\");\n        byte[] cipherText;\n\n        cipher.init(Cipher.ENCRYPT_MODE, key, ivSpec);\n        cipherText = new byte[cipher.getOutputSize(plainTextBytes.length)];\n        int encryptLength = cipher.update(plainTextBytes, 0,\n                plainTextBytes.length, cipherText, 0);\n        encryptLength += cipher.doFinal(cipherText, encryptLength);\n\n        return bytesToHex(cipherText);\n    } catch (NoSuchAlgorithmException | NoSuchProviderException\n            | NoSuchPaddingException | InvalidKeyException\n            | InvalidAlgorithmParameterException\n            | UnsupportedEncodingException | ShortBufferException\n            | IllegalBlockSizeException | BadPaddingException e) {\n        e.printStackTrace();\n        return null;\n    }\n}\n\npublic static String decryptString(SecretKey key, String cipherText) {\n    try {\n        Key decryptionKey = new SecretKeySpec(key.getEncoded(),\n                key.getAlgorithm());\n        IvParameterSpec ivSpec = new IvParameterSpec(iv);\n        Cipher cipher = Cipher.getInstance(\"AES/GCM/NoPadding\", \"BC\");\n        byte[] cipherTextBytes = hexToBytes(cipherText);\n        byte[] plainText;\n\n        cipher.init(Cipher.DECRYPT_MODE, decryptionKey, ivSpec);\n        plainText = new byte[cipher.getOutputSize(cipherTextBytes.length)];\n        int decryptLength = cipher.update(cipherTextBytes, 0,\n                cipherTextBytes.length, plainText, 0);\n        decryptLength += cipher.doFinal(plainText, decryptLength);\n\n        return new String(plainText, \"UTF-8\");\n    } catch (NoSuchAlgorithmException | NoSuchProviderException\n            | NoSuchPaddingException | InvalidKeyException\n            | InvalidAlgorithmParameterException\n            | IllegalBlockSizeException | BadPaddingException\n            | ShortBufferException | UnsupportedEncodingException e) {\n        e.printStackTrace();\n        return null;\n    }\n}\n\npublic static String bytesToHex(byte[] data, int length) {\n    String digits = \"0123456789ABCDEF\";\n    StringBuffer buffer = new StringBuffer();\n\n    for (int i = 0; i != length; i++) {\n        int v = data[i] & 0xff;\n\n        buffer.append(digits.charAt(v >> 4));\n        buffer.append(digits.charAt(v & 0xf));\n    }\n\n    return buffer.toString();\n}\n\npublic static String bytesToHex(byte[] data) {\n    return bytesToHex(data, data.length);\n}\n\npublic static byte[] hexToBytes(String string) {\n    int length = string.length();\n    byte[] data = new byte[length / 2];\n    for (int i = 0; i < length; i += 2) {\n        data[i / 2] = (byte) ((Character.digit(string.charAt(i), 16) << 4) + Character\n                .digit(string.charAt(i + 1), 16));\n    }\n    return data;\n}\n", "idx": 2703}
{"project": "cipher", "commit_id": "Snippet27879803_10038.java", "target": 1, "func": "ByteArrayOutputStream blob = new ByteArrayOutputStream();\nDataOutputStream dataBlob = new DataOutputStream(blob);\n\n// Get the salt\nSecureRandom random = new SecureRandom();\nbyte[] salt = new byte[saltLength];\nrandom.nextBytes(salt);\n\ndataBlob.writeShort(saltLength);\ndataBlob.write(salt);\n\n// Secret key\nSecretKey secretKey = getSecretKey(seed, salt);\n\n// Get Cipher instance for AES with Padding algorithm PKCS5\nCipher cipher = Cipher.getInstance(\"AES/CBC/PKCS5Padding\");\n\n// Initialization vector, as CBC requires IV\nbyte[] iv = new byte[cipher.getBlockSize()];\nrandom.nextBytes(iv);\n\ndataBlob.write(iv.length);\ndataBlob.write(iv);\n\n// Algorithm spec for IV\nIvParameterSpec ivParams = new IvParameterSpec(iv);\n\ncipher.init(Cipher.ENCRYPT_MODE, secretKey, ivParams);\n\n// Encrypt the text\nbyte[] encryptedTextInBytes = cipher.doFinal(textToBeEncrypted\n        .getBytes(StandardCharsets.UTF_8));\n\ndataBlob.writeInt(encryptedTextInBytes.length);\ndataBlob.write(encryptedTextInBytes);\n\n\n// out of scope: add HMAC protection over current contents of blob here\n// (or while writing it to dataBlob, also update a HMAC) \n\n// Base64Encoder encode;\nreturn Base64Encoder.encode(blob.toByteArray());\n", "idx": 2715}
{"project": "cipher", "commit_id": "Snippet4673158_31257.java", "target": 0, "func": "import java.io.ByteArrayOutputStream;\nimport java.text.SimpleDateFormat;\nimport java.util.StringTokenizer;\n\nimport javax.crypto.Cipher;\nimport javax.crypto.SecretKey;\nimport javax.crypto.spec.IvParameterSpec;\nimport javax.crypto.spec.SecretKeySpec;\n\n\n// TODO: Auto-generated Javadoc\n\n/**\n * The Class SymmetricEncryption.\n */\n\npublic class SymmetricEncryption {\n\n    public static void main(String args[]) {\n\n        String signatureKey = \"185-188-32-81-185-2-188-103-248-127-38-173-109-200-56-32-81-47-234-4-191-157-26-247\";\n        String serverTime = \"2011-01-12 18:48:43.000\";\n        String encryptedSignatureKey = \"240-230-243-218-251-103-145-3-156-109-41-25-127-185-149-150-36-96-176-154-83-24-20-89\";\n\n        SymmetricEncryption sE = new SymmetricEncryption();\n        String result1 = sE.genericencrypt(serverTime, signatureKey);\n\n        System.out.println(result1);\n    }\n\n    /**\n     * The d format.\n     */\n    public final SimpleDateFormat dFormat = new SimpleDateFormat(\"yyyy-MM-dd HH:mm:ss\");\n\n    /**\n     * The ivbytes.\n     */\n    public byte[] ivbytes = new byte[]{(byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x00};\n\n    /**\n     * The iv.\n     */\n    public IvParameterSpec iv = new IvParameterSpec(ivbytes);\n\n    /**\n     * Genericencrypt.\n     *\n     * @param source    the source\n     * @param keyString the key string\n     * @return the string\n     */\n    public String genericencrypt(String source, String keyString) {\n        try {\n\n            // Generate key\n            SecretKey key = getKey(keyString);\n\n            // Create the cipher\n            Cipher desCipher = Cipher.getInstance(\"DESede/CBC/PKCS5Padding\");\n\n            // Initialize the cipher for encryption\n            desCipher.init(Cipher.ENCRYPT_MODE, key, iv);\n\n            // Our cleartext as bytes\n            byte[] cleartext = source.getBytes();\n\n            System.out.println(\"Server Time ASCII \" + new String(cleartext));\n\n            // Encrypt the cleartext\n            byte[] ciphertext = desCipher.doFinal(cleartext);\n\n            System.out.println(\"ciphertext ASCII \" + new String(ciphertext));\n\n            // Return a String representation of the cipher text\n            return getString(ciphertext);\n\n        } catch (Exception e) {\n            e.printStackTrace();\n        }\n        return null;\n    }\n\n    /**\n     * Gets the key.\n     *\n     * @param keyString the key string\n     * @return the key\n     */\n    private SecretKey getKey(String keyString) {\n        try {\n            byte[] bytes = getBytes(keyString);\n            return new SecretKeySpec(bytes, \"DESede\");\n        } catch (Exception e) {\n            e.printStackTrace();\n        }\n        return null;\n    }\n\n    /**\n     * Gets the string.\n     *\n     * @param bytes the bytes\n     * @return the string\n     */\n    public String getString(byte[] bytes) {\n        StringBuffer sb = new StringBuffer();\n        for (int i = 0; i < bytes.length; i++) {\n            byte b = bytes[i];\n            sb.append((int) (0x00FF & b));\n            if (i + 1 < bytes.length) {\n                sb.append(\"-\");\n            }\n        }\n        return sb.toString();\n    }\n\n    /**\n     * Gets the bytes.\n     *\n     * @param str the str\n     * @return the bytes\n     */\n    public byte[] getBytes(String str) {\n        ByteArrayOutputStream bos = new ByteArrayOutputStream();\n        StringTokenizer st = new StringTokenizer(str, \"-\", false);\n        while (st.hasMoreTokens()) {\n            int i = Integer.parseInt(st.nextToken());\n            bos.write((byte) i);\n        }\n        return bos.toByteArray();\n    }\n}\n", "idx": 1968}
{"project": "cipher", "commit_id": "Snippet38114974_20094.java", "target": 1, "func": "Cipher cipherb = Cipher.getInstance(\"RSA/NONE/NoPadding\");\ncipherb.init(Cipher.DECRYPT_MODE, publicKey);\ndecrypted = cipherb.doFinal(text.getBytes());\n", "idx": 2510}
{"project": "cipher", "commit_id": "Snippet25260570_7626.java", "target": 1, "func": "Cipher decrypt = Cipher.getInstance(\"AES/CBC/PKCS5Padding\");\n                decrypt.init(Cipher.DECRYPT_MODE, hashedKey,iv);\n        byte[] decryptedMsg = decrypt.doFinal(encryptedMsg);\n", "idx": 2381}
{"project": "cipher", "commit_id": "Snippet23821923_6129.java", "target": 0, "func": "import java.security.spec.AlgorithmParameterSpec;\nimport java.security.spec.KeySpec;\n\nimport javax.crypto.Cipher;\nimport javax.crypto.SecretKey;\nimport javax.crypto.SecretKeyFactory;\nimport javax.crypto.spec.PBEKeySpec;\nimport javax.crypto.spec.PBEParameterSpec;\n\nimport org.apache.commons.codec.binary.Base64;\n\npublic class Main\n{\n\n    private static class DesEncrypter\n    {\n        /** algorithm used for encrpytion and decryption */\n        private static final String ALGORITHM = \"PBEWithMD5AndDES\";\n\n        /** 8-byte Salt. */\n        private static final byte[] SALT = { <You salt> };\n\n        /** Iteration count. */\n        private static final int ITERATION_COUNT = 19;\n\n        /** Stores parameter specification. */\n        private static final AlgorithmParameterSpec PARAM_SPEC = new PBEParameterSpec(\n            SALT, ITERATION_COUNT);\n\n        /** Key specification. */\n        private final KeySpec keySpec;\n\n        /** Secret key. */\n        private final SecretKey key;\n\n        public DesEncrypter(final String passPhrase)\n        {\n            // Create the key\n            keySpec = new PBEKeySpec(passPhrase.toCharArray(), SALT, ITERATION_COUNT);\n            try\n            {\n                key = SecretKeyFactory.getInstance(ALGORITHM).generateSecret(keySpec);\n            }\n            catch (final Exception ex)\n            {\n                throw new RuntimeException(\"Could not create DesEncrypter: \" + ex.getMessage(), ex);\n            }\n        }\n\n        public final String encrypt(final String message)\n        {\n            try\n            {\n                // Create cipher instance\n                final Cipher cipher = Cipher.getInstance(ALGORITHM);\n                // Initialize cipher\n                cipher.init(Cipher.ENCRYPT_MODE, key, PARAM_SPEC);\n                // Encode string\n                final byte[] enc = cipher.doFinal(message.getBytes(\"UTF8\"));\n                // Encode bytes to base64 to get a string\n                return Base64.encodeBase64String(enc);\n            }\n            catch (final Exception ex)\n            {\n                throw new RuntimeException(\"Error encrypting message.\", ex);\n            }\n        }\n    }\n\n    public static void main(final String[] args)\n    {\n        if (args.length == 2)\n        {\n            System.out.println(\"!!\" + new DesEncrypter(args[0]).encrypt(args[1]));\n        }\n    }\n}\n", "idx": 2161}
{"project": "cipher", "commit_id": "Snippet38369043_20324.java", "target": 0, "func": "public final class Encryption {\n    private static final String CHIPHER_TRANSFORMATION = \"AES/ECB/PKCS5Padding\";\n    private static final String GENERATE_KEY__ALGORITHM = \"PBKDF2WithHmacSHA1\";\n    private static final String GENERATE_KEY_ALGORITHM = \"AES\";\n    public static final int CRYPTO_TYPE_ENCRYPT = 0;\n    public static final int CRYPTO_TYPE_DECRYPT = 1;\n\n    public static String crypto(String inString, int type, String hashKey, String salt, String charset) {\n        Cipher cipher = null;\n        try {\n            cipher = Cipher.getInstance(CHIPHER_TRANSFORMATION);\n            byte[] inputByte = inString.getBytes(charset);\n            switch (type) {\n                case CRYPTO_TYPE_DECRYPT:\n                    cipher.init(Cipher.DECRYPT_MODE, initKey(hashKey, salt));\n                    return new String(cipher.doFinal(Base64.decode(inputByte, Base64.DEFAULT)));\n                case CRYPTO_TYPE_ENCRYPT:\n                    cipher.init(Cipher.ENCRYPT_MODE, initKey(hashKey, salt));\n                    return new String(Base64.encode(cipher.doFinal(inputByte), Base64.DEFAULT));\n            }\n        } catch (NoSuchAlgorithmException e) {\n            e.printStackTrace();\n        } catch (NoSuchPaddingException e) {\n            e.printStackTrace();\n        } catch (UnsupportedEncodingException e) {\n            e.printStackTrace();\n        } catch (IllegalBlockSizeException e) {\n            e.printStackTrace();\n        } catch (BadPaddingException e) {\n            e.printStackTrace();\n        } catch (InvalidKeyException e) {\n            e.printStackTrace();\n        }\n\n        return null;\n    }\n\n    private static SecretKey getSecretKey(char[] password, byte[] salt) throws NoSuchAlgorithmException, InvalidKeySpecException {\n        SecretKeyFactory factory = SecretKeyFactory.getInstance(GENERATE_KEY__ALGORITHM);\n        KeySpec spec = new PBEKeySpec(password, salt, 1024, 128);\n        SecretKey tmp = factory.generateSecret(spec);\n        return (new SecretKeySpec(tmp.getEncoded(), GENERATE_KEY_ALGORITHM));\n    }\n\n    private static SecretKey initKey(String hashKey, String salt) {\n        try {\n            return getSecretKey(hashKey.toCharArray(), salt.getBytes());\n        } catch (NoSuchAlgorithmException e) {\n            e.printStackTrace();\n        } catch (InvalidKeySpecException e) {\n            e.printStackTrace();\n        }\n        return null;\n    }\n}\n", "idx": 1942}
{"project": "cipher", "commit_id": "Snippet26874410_9015.java", "target": 0, "func": "import java.io.File;\nimport java.io.FileInputStream;\nimport java.io.FileOutputStream;\nimport java.io.ObjectInputStream;\nimport java.io.ObjectOutputStream;\nimport java.security.Key;\nimport java.security.KeyFactory;\nimport java.security.KeyPair;\nimport java.security.KeyPairGenerator;\nimport java.security.PrivateKey;\nimport java.security.SecureRandom;\nimport java.security.Signature;\nimport java.security.spec.EncodedKeySpec;\nimport java.security.spec.PKCS8EncodedKeySpec;\nimport java.util.Arrays;\n\nimport javax.crypto.Cipher;\nimport javax.crypto.spec.SecretKeySpec;\n\nimport codec.Hex;\n\npublic class Pgm {\n    public static void main(String[] args) {\n        try {\n            KeyPairGenerator dsa = KeyPairGenerator.getInstance(\"DSA\");\n            SecureRandom random = new SecureRandom();\n            dsa.initialize(1024, random);\n            KeyPair keypair = dsa.generateKeyPair();\n            PrivateKey privateKey = (PrivateKey) keypair.getPrivate();\n            byte[] key = Hex.decode(\"000102030405060708090A0B0C0D0E0F\");\n            Key aesKey = new SecretKeySpec(key, \"AES\");\n            Cipher cipher = Cipher.getInstance(\"AES\");\n            String currentDir = System.getProperty(\"user.dir\");\n            // encrypt the text\n            cipher.init(Cipher.ENCRYPT_MODE, aesKey);\n            byte[] abc = privateKey.getEncoded();\n\n            byte[] encrypted = cipher.doFinal(abc);\n            // System.out.println(\"len=\"+encrypted.length());\n            File dir = new File(currentDir);\n            File private_file = new File(dir, \"privatekey.txt\");\n            if (!private_file.exists()) {\n                private_file.createNewFile();\n            }\n            FileOutputStream fileos = new FileOutputStream(private_file);\n            ObjectOutputStream objectos = new ObjectOutputStream(fileos);\n            objectos.writeObject(encrypted);\n            objectos.close();\n            fileos.close();\n\n            File file_private = new File(dir, \"privatekey.txt\");\n            FileInputStream fileo = new FileInputStream(file_private);\n            ObjectInputStream objos = new ObjectInputStream(fileo);\n            Object obj = objos.readObject();\n            byte[] encrypted1 = (byte[]) obj;\n            cipher.init(Cipher.DECRYPT_MODE, aesKey);\n            byte[] decrypted = cipher.doFinal(encrypted1);\n            if (Arrays.equals(decrypted, abc))\n                System.out.println(\"true\");\n            else\n                System.out.println(\"false\");\n            Signature tosign = Signature.getInstance(\"DSA\");\n\n            KeyFactory generator = KeyFactory.getInstance(\"DSA\");\n            EncodedKeySpec privateKeySpec = new PKCS8EncodedKeySpec(decrypted);\n            PrivateKey privatekey1 = generator.generatePrivate(privateKeySpec);\n            tosign.initSign(privatekey1);\n\n        } catch (Exception e) {\n            System.out.println(\"failed\");\n            e.printStackTrace();\n        }\n    }\n}\n", "idx": 2054}
{"project": "cipher", "commit_id": "Snippet33223926_15291.java", "target": 1, "func": "public String decrypt(byte[] cipherText) throws Exception {\n\n    String psk = \"0123456789012345\";\n    String iv = \"0123456789012345\";\n    try {\n        String encryptionKey = psk;\n        final Cipher cipher = Cipher.getInstance(\"AES/CBC/PKCS5Padding\", \"SunJCE\");\n        final SecretKeySpec key = new SecretKeySpec(encryptionKey.getBytes(UTF8), \"AES\");\n        cipher.init(Cipher.DECRYPT_MODE, key, new IvParameterSpec(iv.getBytes(UTF8)));\n        return new String(cipher.doFinal(cipherText), UTF8);\n    } catch (BadPaddingException | IllegalBlockSizeException | UnsupportedEncodingException | InvalidAlgorithmParameterException | InvalidKeyException | NoSuchAlgorithmException | NoSuchPaddingException | NoSuchProviderException ex) {\n        LOG.log(Level.SEVERE, ex.getMessage(), ex);\n        throw new Exception(ex.getMessage());\n    }\n}\n", "idx": 2587}
{"project": "cipher", "commit_id": "Snippet45505854_27582.java", "target": 1, "func": "String key = client.getPublicKey(nonce).getRSAEncryptionKey().toString();\nkey = key.replace(\"-----BEGIN RSA PUBLIC KEY-----\\n\", \"\");\nkey = key.replace(\"-----END RSA PUBLIC KEY-----\", \"\");\nbyte[] keyBytes = Base64.getDecoder().decode(key); //bytes of key\nCipher cipher_RSA;\n        try {\n            cipher_RSA = Cipher.getInstance(\"RSA\");\n            X509EncodedKeySpec spec = new X509EncodedKeySpec(keyBytes);\n            KeyFactory keyFactory = KeyFactory.getInstance(\"RSA\");\n            PublicKey pk = keyFactory.generatePublic( spec);\n\n            cipher_RSA.init(Cipher.ENCRYPT_MODE, pk); \n            return cipher_RSA.doFinal(message);\n        }catch(Exception e){}\n", "idx": 2441}
{"project": "cipher", "commit_id": "Snippet46549160_28688.java", "target": 1, "func": "//encrypt\ntry {\n        Cipher c = Cipher.getInstance(\"ECIES\",BouncyCastleProvider.PROVIDER_NAME);\n        c.init(Cipher.ENCRYPT_MODE,publicKey);\n        encodeBytes = c.doFinal(origin.getBytes());           \n        //encrypt = Base64.getEncoder().encodeToString(encodeBytes);\n        encrypt = bytesToHex(encodeBytes);\n\n        System.out.println(encrypt);\n\n\n    } catch (Exception e) {\n        e.printStackTrace();\n    }\n    //decrypt\n    try\n    {\n        //abc = Base64.getDecoder().decode(encrypt);\n        abc = hexStringToByteArray(encrypt);\n        Cipher c = Cipher.getInstance(\"ECIES\",\"BC\");\n        c.init(Cipher.DECRYPT_MODE,privateKey);\n        decodeBytes = c.doFinal(abc);\n        String deCrypt = new String(decodeBytes,\"UTF-8\");\n\n        System.out.println(\"Decrypt:\"+ deCrypt +\"\\n\");\n    }\n    catch (Exception ex)\n    {\n        ex.printStackTrace();\n    }\npublic static String bytesToHex(byte[] bytes) \n{\n    char[] hexChars = new char[bytes.length * 2];\n    for ( int j = 0; j < bytes.length; j++ ) \n    {\n        int v = bytes[j] & 0xFF;\n        hexChars[j * 2] = hexArray[v >>> 4];\n        hexChars[j * 2 + 1] = hexArray[v & 0x0F];\n    }\n    return new String(hexChars);\n}\npublic static byte[] hexStringToByteArray(String s) {\n    int len = s.length();\n    byte[] data = new byte[len / 2];\n    for (int i = 0; i < len; i += 2) {\n        data[i / 2] = (byte) ((Character.digit(s.charAt(i), 16) << 4)\n                             + Character.digit(s.charAt(i+1), 16));\n    }\n    return data;\n}\n", "idx": 2613}
{"project": "cipher", "commit_id": "Snippet8763597_33482.java", "target": 1, "func": "try\n{\n    FileInputStream in = new FileInputStream(\"test.aes\");\n    DataInputStream dataIn = new DataInputStream(in);\n\n    // stream key and message\n    byte[] rawKey = new byte[16];\n    dataIn.read(rawKey);\n    byte encryptedMessageLen = dataIn.readByte();\n    byte[] encryptedMessage = new byte[encryptedMessageLen];\n    dataIn.read(encryptedMessage);\n\n    // use CBC/PKCS5PADDING, with 0 IV -- default for Microsoft Base Cryptographic Provider\n    SecretKeySpec sessionKey = new SecretKeySpec(rawKey, \"AES\");\n    Cipher cipher = Cipher.getInstance(\"AES/CBC/PKCS5PADDING\");\n    cipher.init(Cipher.DECRYPT_MODE, sessionKey, new IvParameterSpec(new byte[16]));\n\n    cipher.doFinal(encryptedMessage);\n}\ncatch (Exception e) {\n  e.printStackTrace();\n}\n", "idx": 2622}
{"project": "cipher", "commit_id": "Snippet41136368_23083.java", "target": 1, "func": "public static byte[] readFileBytes(String filename) throws IOException\n{\n    Path path = Paths.get(filename);\n    return Files.readAllBytes(path);        \n}\n  public static PublicKey readPublicKey(String filename) throws     IOException,NoSuchAlgorithmException,InvalidKeySpecException\n{\n    X509EncodedKeySpec publicSpec = new X509EncodedKeySpec(readFileBytes(filename));\n    KeyFactory keyFactory = KeyFactory.getInstance(\"RSA\");\n\n\n    return keyFactory.generatePublic(publicSpec);\n}\npublic static PrivateKey readPrivateKey(String filename) throws IOException,NoSuchAlgorithmException,InvalidKeySpecException\n{\n    PKCS8EncodedKeySpec keySpec = new PKCS8EncodedKeySpec(readFileBytes(filename));\n    KeyFactory keyFactory = KeyFactory.getInstance(\"RSA\");\n    return keyFactory.generatePrivate(keySpec);\n}\npublic static byte[] encrypt(PublicKey key,byte[] plaintext) throws NoSuchAlgorithmException,NoSuchPaddingException,InvalidKeySpecException,IllegalBlockSizeException,BadPaddingException, InvalidKeyException\n{\n    Cipher cipher = Cipher.getInstance(\"RSA/ECB/OAEPWithSHA1AndMGF1Padding\");\n    cipher.init(Cipher.ENCRYPT_MODE,key);\n    return cipher.doFinal(plaintext);\n}\npublic static byte[] decrypt(PrivateKey key,byte[] ciphertext)throws NoSuchAlgorithmException,NoSuchPaddingException, InvalidKeyException, IllegalBlockSizeException, BadPaddingException\n{\n    Cipher cipher = Cipher.getInstance(\"RSA/ECB/OAEPWithSHA1AndMGF1Padding\");\n    cipher.init(Cipher.DECRYPT_MODE,key);\n    return cipher.doFinal(ciphertext);\n\n}\n", "idx": 2647}
{"project": "cipher", "commit_id": "Snippet32087235_14147.java", "target": 0, "func": "<%\n//variable declaration for encrypt and decrypt\nbyte [] input ;\nbyte [] keyBytes = \"12345678\".getBytes();\nbyte [] ivBytes =\"input123\".getBytes();\n\nSecretKeySpec key = new SecretKeySpec(keyBytes,\"DES\");\nIvParameterSpec ivSpec = new IvParameterSpec(ivBytes);\nCipher cipher;\nbyte[] cipherText;\nint ctLength=0;\n\nClass.forName(\"com.mysql.jdbc.Driver\");\nconn = DriverManager.getConnection(CONN_STRING, USERNAME, PASSWORD);\n\nif(request.getParameter(\"submit\")!=null){\n    String cuser=request.getParameter(\"currentusername\"); \n    String user = request.getParameter(\"username\");\n    String pwd = request.getParameter(\"password\");\n    String cpwd = request.getParameter(\"confirmpassword\");\n\n    Security.addProvider(new org.bouncycastle.jce.provider.BouncyCastleProvider());\n      input = pwd.getBytes();\n      key = new SecretKeySpec(keyBytes, \"DES\");\n      ivSpec = new IvParameterSpec(ivBytes);\n      cipher = Cipher.getInstance(\"DES/CTR/NoPadding\",\"BC\");\n\n      cipher.init(Cipher.ENCRYPT_MODE, key, ivSpec);\n      cipherText = new byte[cipher.getOutputSize(input.length)];\n\n      ctLength+=cipher.update(input, 0, input.length, cipherText, 0);\n\n      ctLength+= cipher.doFinal(cipherText, ctLength);\n      String enpwd = new String(cipherText);\n\n\n     String sql2 = \"update webadmin set username=? ,password=? where username='\"+cuser+\"' \";\n\n     if((cuser!=null &&cuser.length()>0) \n        && (user!=null &&user.length()>0)  \n        && (pwd!=null && pwd.length()>0)\n        && cpwd!=null && cpwd.length()>0) {\n\n         if((pwd.equals(cpwd))){\n           pst =conn.prepareStatement(sql2);\n           pst.setString(1, user);\n           pst.setString(2, enpwd);\n\n            pst.executeUpdate();\n%>\n <script language=\"JavaScript\">\n     alert(\"Sucessfully Updated\");\n </script>\n <%\n         }else{\n             %>\n           <script language=\"JavaScript\">\n            alert(\"Passwords are not matching try again\");\n            </script>\n           <%\n\n     }\n    }\n  }\n}\n\n%> \n", "idx": 2239}
{"project": "cipher", "commit_id": "Snippet25587090_7898.java", "target": 0, "func": "import java.security.InvalidKeyException;\nimport java.security.NoSuchAlgorithmException;\nimport javax.crypto.*;\nimport javax.crypto.spec.SecretKeySpec;\n\npublic class DecryptCipherAES {\n\n    public static void main(String[] args) {\n        try {\n            byte[] key = (\"dfaa3b49adbc546d4437107b6a666cb1\").getBytes();\n            SecretKey secretKey = new SecretKeySpec(key, \"AES\");\n\n            String base64String = \"iwEjj0Gahfzgq4BWrdY9odNX9PqvHgppz9YZ3mddQq8=\";\n            byte[] enc = org.apache.commons.codec.binary.Base64.decodeBase64(base64String.getBytes());\n\n            Cipher cipher = Cipher.getInstance(\"AES\");\n            cipher.init(Cipher.DECRYPT_MODE, secretKey);\n            String dec = new String(cipher.doFinal(enc));\n            System.out.println(\"texte decrypte : \" + dec);\n\n        } catch (NoSuchAlgorithmException | NoSuchPaddingException | InvalidKeyException | IllegalBlockSizeException | BadPaddingException e) {\n            e.printStackTrace();\n        }\n    }\n}\n", "idx": 2003}
{"project": "cipher", "commit_id": "Snippet32827989_14916.java", "target": 1, "func": "File encryptedFile = getFileTodecrypt();\n    byte[] salt = new byte[] { 1, 2, 3, 4, 5, 6, 7, 8 };\n    SecretKeyFactory factory =     SecretKeyFactory.getInstance(\"PBKDF2WithHmacSHA1\");\n    KeySpec spec = new PBEKeySpec(PASSWORD.toCharArray(), salt, 1000, 256);\n    SecretKey tmp = factory.generateSecret(spec);\n    SecretKey secret = new SecretKeySpec(tmp.getEncoded(), \"AES\");\n\n    /* Encrypt the message. */\n    Cipher cipher = Cipher.getInstance(\"AES/CBC/PKCS5Padding\");\n    cipher.init(Cipher.ENCRYPT_MODE, secret);\n\n    AlgorithmParameters params = cipher.getParameters();\n    byte[] iv = params.getParameterSpec(IvParameterSpec.class).getIV();\n\n    File fileToDecrypt = getFileTodecrypt(); // this gets my file\n    InputStream inputStream = FileUtils.openInputStream(fileToDecrypt);\n    byte[] bytesToBeDecrypted = IOUtils.toByteArray(inputStream);\n\n    // file bytes does not work\n    //byte[] ciphertext = cipher.doFinal(bytesToBeDecrypted);\n    // file to string does not work\n    //byte[] ciphertext = cipher.doFinal(encryptedString.getBytes(\"UTF-8\"));\n    // this works, but does not take c# code into account at all\n    byte[] ciphertext = cipher.doFinal(\"hello\".getBytes(\"UTF-8\"));\n\n    IvParameterSpec iv2 = new IvParameterSpec(iv);\n\n    //decrypt\n    cipher.init(Cipher.DECRYPT_MODE, secret, new IvParameterSpec(iv));\n    String plaintext = new String(cipher.doFinal(ciphertext), \"UTF-8\");\n    System.out.println(plaintext);\n\n}\n\nprivate String convertFileToString(File encryptedFile) throws IOException {\n    String fileString = FileUtils.readFileToString(encryptedFile, \"UTF-8\");\n    return fileString;\n\n}\n", "idx": 2572}
{"project": "cipher", "commit_id": "Snippet8643731_33400.java", "target": 1, "func": "File bufferFile = new File(ids.get(position));\n        FileInputStream fis   = new FileInputStream(bufferFile);\n\n        Cipher cipher = Cipher.getInstance(\"AES/CBC/NoPadding\");\n        SecretKeySpec keySpec = new SecretKeySpec(\"01234567890abcde\".getBytes(), \"AES\");\n        IvParameterSpec ivSpec = new IvParameterSpec(\"fedcba9876543210\".getBytes());\n        cipher.init(Cipher.DECRYPT_MODE, keySpec, ivSpec);\n        CipherInputStream cis = new CipherInputStream(fis, cipher);\n\n\n        Options options = new BitmapFactory.Options();\n        options.inJustDecodeBounds = true;\n\n        BitmapFactory.decodeStream(cis, null, options);\n\n        Boolean scaleByHeight = Math.abs(options.outHeight - Cards.height) >= Math.abs(options.outWidth - Cards.width);\n\n        if(options.outHeight * options.outWidth * 2 >= 200*200*2){\n               // Load, scaling to smallest power of 2 that'll get it <= desired dimensions\n              double sampleSize = scaleByHeight\n                    ? options.outHeight / Cards.height\n                    : options.outWidth / Cards.width;\n              options.inSampleSize = \n                    (int)Math.pow(2d, Math.floor(\n                    Math.log(sampleSize)/Math.log(2d)));\n           }\n\n              // Do the actual decoding\n              options.inJustDecodeBounds = false;\n\n              //cis.close();\n              cis = new CipherInputStream(fis, cipher);\n              Bitmap img = BitmapFactory.decodeStream(cis, null, options);\n              cis.close();\n\n\n       ((ImageView) convertView.findViewById(R.id.imgView)).setImageBitmap(img);\n\n        fis.close();\n\n\n        Runtime.getRuntime().gc();\n", "idx": 2452}
{"project": "cipher", "commit_id": "Snippet28295930_10505.java", "target": 1, "func": "static byte[] IV = {  0x00, 0x01, 0x02, 0x03, 0x04, 0x05, 0x06, 0x07, 0x08, 0x09, 0x0a, 0x0b, 0x0c, 0x0d, 0x0e, 0x0f };\n\nstatic String plaintext = \"00010101010102020202020303030303\"; \n\nstatic byte[] encryptionKey = {0x41, 0x41, 0x41, 0x41, 0x41, 0x41, 0x41, 0x41, 0x41,\n    0x41, 0x41, 0x41, 0x41, 0x41, 0x41, 0x41  };\n\npublic static void main(String[] args) {\n    try {\n\n        System.out.println(\"==Java==\");\n        System.out.println(\"plain:   \" + plaintext);\n\n        byte[] cipher = encrypt(plaintext, encryptionKey);\n\n        System.out.print(\"cipher:  \");\n        for (int i = 0; i < cipher.length; i++) {\n            // System.out.print(new Integer(cipher[i]) + \" \");\n            byte b = cipher[i];\n            System.out.print(String.format(\"%02x\", b & 0xFF) + \" \");\n\n        }\n\n        String decrypted = decrypt(cipher, encryptionKey);\n\n        System.out.println(\"decrypt: \" + decrypted);\n\n    } catch (Exception e) {\n        e.printStackTrace();\n    }\n}\n\npublic static byte[] encrypt(String plainText, byte[] encryptionKey)\n        throws Exception {\n    Cipher cipher = Cipher.getInstance(\"AES/CBC/NoPadding\");\n    SecretKeySpec key = new SecretKeySpec(encryptionKey, \"AES\");\n    cipher.init(Cipher.ENCRYPT_MODE, key, new IvParameterSpec(IV));\n    return cipher.doFinal(plainText.getBytes(\"UTF-8\"));\n}\n\npublic static String decrypt(byte[] cipherText, byte[] encryptionKey)\n        throws Exception {\n    Cipher cipher = Cipher.getInstance(\"AES/CBC/NoPadding\");\n    SecretKeySpec key = new SecretKeySpec(encryptionKey, \"AES\");\n    cipher.init(Cipher.DECRYPT_MODE, key, new IvParameterSpec(IV));\n    return new String(cipher.doFinal(cipherText), \"UTF-8\");\n}\n", "idx": 2490}
{"project": "cipher", "commit_id": "Snippet13896007_37338.java", "target": 1, "func": "KeyPairGenerator kpg = KeyPairGenerator.getInstance(\"RSA\");\nkpg.initialize(1024);\nKeyPair kp = kpg.genKeyPair();\nPrivateKey privateKey = kp.getPrivate();\nCipher keyCipher = Cipher.getInstance(\"RSA\");\nkeyCipher.init(Cipher.ENCRYPT_MODE, privateKey);\nbyte[] encryptedKey = keyCipher.doFinal(secKey.getEncoded());\nFileOutputStream keyStream = new FileOutputStream(\"key.txt\");\nkeyStream.write(encryptedKey);\nkeyStream.close();\n", "idx": 2635}
{"project": "cipher", "commit_id": "Snippet39401521_21309.java", "target": 1, "func": "String Encrypt(String text, byte[] keyBytes) throws Exception {\n    Cipher cipher = Cipher.getInstance(\"AES/CFB/PKCS5Padding\");\n    SecretKeySpec keySpec = new SecretKeySpec(keyBytes, \"AES\");\n    IvParameterSpec ivSpec = new IvParameterSpec(\"AAAAAAAAAAAAAAAA\".getBytes(\"UTF-8\"));\n    cipher.init(Cipher.ENCRYPT_MODE, keySpec, ivSpec);\n\n    byte[] results = cipher.doFinal(text.getBytes(\"UTF-8\"));\n    return Base64.encodeToString(results, Base64.URL_SAFE);\n}\n", "idx": 2585}
{"project": "cipher", "commit_id": "Snippet13713991_37217.java", "target": 1, "func": "import java.io.UnsupportedEncodingException;\nimport java.security.KeyFactory;\nimport java.security.KeyPair;\nimport java.security.KeyPairGenerator;\nimport java.security.PrivateKey;\nimport java.security.PublicKey;\nimport java.security.SecureRandom;\nimport java.security.Security;\n\nimport javax.crypto.BadPaddingException;\nimport javax.crypto.Cipher;\nimport javax.crypto.IllegalBlockSizeException;\n\nimport android.app.Activity;\nimport android.os.Bundle;\nimport android.util.Base64;\nimport android.util.Log;\nimport de.flexiprovider.common.ies.IESParameterSpec;\nimport de.flexiprovider.core.FlexiCoreProvider;\nimport de.flexiprovider.ec.FlexiECProvider;\nimport de.flexiprovider.ec.parameters.CurveParams;\nimport de.flexiprovider.ec.parameters.CurveRegistry.BrainpoolP384r1;\nimport de.flexiprovider.pki.PKCS8EncodedKeySpec;\nimport de.flexiprovider.pki.X509EncodedKeySpec;\n\npublic class MainActivity extends Activity {\n\nprivate static PublicKey PublicKey;\nprivate static PrivateKey PrivateKey;\nprivate static String PubKey;\nprivate static String PrvKey;\nprivate static String message = \"Hello World\";\nprivate static String encryptedMessage;\nprivate static String decryptedMessage;\n\nprivate final static String TAG = \"ERROR: \";\n\n@Override\nprotected void onCreate(Bundle savedInstanceState) {\n    super.onCreate(savedInstanceState);\n    setContentView(R.layout.activity_main);\n\n    try {\n        Security.addProvider(new FlexiCoreProvider());\n        Security.addProvider(new FlexiECProvider());\n\n        // instantiate the elliptic curve key pair generator\n        KeyPairGenerator kpg = KeyPairGenerator.getInstance(\"ECIES\", \"FlexiEC\");\n\n        // choose the curve\n        CurveParams ecParams = new BrainpoolP384r1();\n\n        // Initialize the key pair generator\n        kpg.initialize(ecParams, new SecureRandom());\n        KeyPair keyPair = kpg.generateKeyPair();\n\n        // generate the public key\n        PublicKey = keyPair.getPublic();\n\n        // generate private key\n        PrivateKey = keyPair.getPrivate();\n    }\n    catch (Exception e) {\n        Log.e(TAG, e.toString());\n    }\n\n    // I'm converting keys to strings here as the public keys will be stored on a server\n    // database and the private keys will be stored in the application preferences file\n    // this private key storage is maybe not optimum, but at this point I just want to\n    // simulate a messaging encryption/decryption process for testing purposes\n\n    // convert public key to a string\n    PubKey = Base64.encodeToString(PublicKey.getEncoded(), Base64.DEFAULT);\n    Log.d(\"PubKey: \", PubKey);\n\n    // convert private key to a string\n    PrvKey = Base64.encodeToString(PrivateKey.getEncoded(), Base64.DEFAULT);\n    Log.d(\"PrvKey: \", PrvKey);\n\n    // encrypt the message with the public key\n    encryptedMessage = encryptMessage(PubKey, message);\n\n    // report if the public key has not been regenerated correctly\n    if (encryptedMessage == null) {\n        Log.d(\"PUBLIC_KEY_REGENERATE_ERROR: \", encryptedMessage);\n    }\n\n    // decrypt the message with the private key\n    decryptedMessage = decryptMessage(PrvKey, encryptedMessage);\n\n    // report if the private key has not been regenerated correctly\n    if (encryptedMessage == null) {\n        Log.d(\"PRIVATE_KEY_REGENERATE_ERROR: \", decryptedMessage);\n    }\n}\n\n// encrypt function\npublic static String encryptMessage(String publicKey, String message) {\n\n    KeyFactory keyFactory = null;\n    PublicKey pubkey = null;\n    Cipher cipher = null;\n\n    byte[] PLAINTEXT_MESSAGE = message.getBytes();\n    Log.d(\"PLAINTEXT_MESSAGE: \", message);\n\n    Security.addProvider(new FlexiCoreProvider());\n    Security.addProvider(new FlexiECProvider());\n\n    // Base64 decode the publicKey string into a byte array\n    byte[] decodedPublicKey = Base64.decode(publicKey, Base64.DEFAULT);\n\n    try {\n        // instantiate a X509EncodedKeySpec\n        X509EncodedKeySpec X509spec = new X509EncodedKeySpec(decodedPublicKey);\n\n        keyFactory = KeyFactory.getInstance(\"ECIES\", \"FlexiEC\");\n\n        // re-generate the public key\n        pubkey = keyFactory.generatePublic(X509spec);\n\n        // sanity check, return null on inequality\n        if (!pubkey.equals(PublicKey)) {\n            return null;\n        }\n\n        cipher = Cipher.getInstance(\"ECIES\", \"FlexiEC\");\n        IESParameterSpec IESspec = new IESParameterSpec(\"AES256_CBC\", \"HmacSHA512\", null, null);\n        cipher.init(Cipher.ENCRYPT_MODE, pubkey, IESspec);\n    }\n    catch (Exception e) {\n        Log.e(TAG, e.toString());\n    }\n\n    // encrypt the message\n    byte[] encryptedData = null;\n\n    try {\n        encryptedData = cipher.doFinal(PLAINTEXT_MESSAGE);\n    }\n    catch (IllegalBlockSizeException e) {\n        Log.e(TAG, e.toString());\n    }\n    catch (BadPaddingException e) {\n        Log.e(TAG, e.toString());\n    }\n\n    String encryptedMessage = null;\n\n    try {\n        encryptedMessage = new String(encryptedData, \"UTF-8\");\n    }\n    catch (UnsupportedEncodingException e) {\n        Log.e(TAG, e.toString());\n    }\n    Log.d(\"encryptedMessage: \", encryptedMessage);\n    return encryptedMessage;\n}\n\n// decrypt function\npublic static String decryptMessage(String privateKey, String message) {\n\n    KeyFactory keyFactory = null;\n    PrivateKey prvkey = null;\n    Cipher cipher = null;\n\n    byte[] ENCRYPTED_MESSAGE = message.getBytes();\n    Log.d(\"ENCRYPTED_MESSAGE: \", message);\n\n    Security.addProvider(new FlexiCoreProvider());\n    Security.addProvider(new FlexiECProvider());\n\n    try {\n        // Base64 decode the privateKey string into a byte array\n        byte[] decodedPrivateKey = Base64.decode(privateKey, Base64.DEFAULT);\n\n        // instantiate a PKCS8EncodedKeySpec\n        PKCS8EncodedKeySpec PKCS8spec = new PKCS8EncodedKeySpec(decodedPrivateKey);\n\n        keyFactory = KeyFactory.getInstance(\"ECIES\", \"FlexiEC\");\n\n        // re-generate the private key\n        prvkey = keyFactory.generatePrivate(PKCS8spec);\n\n        // sanity check, return null on inequality\n        if (!prvkey.equals(PrivateKey)) {\n            return null;\n        }\n\n        cipher = Cipher.getInstance(\"ECIES\", \"FlexiEC\");\n        IESParameterSpec IESspec = new IESParameterSpec(\"AES256_CBC\", \"HmacSHA512\", null, null);\n        cipher.init(Cipher.DECRYPT_MODE, prvkey, IESspec);\n    }\n    catch (Exception e) {\n        Log.e(TAG, e.toString());\n    }\n\n    // decrypt the message\n    byte[] decryptedData = null;\n\n    try {\n        decryptedData = cipher.doFinal(ENCRYPTED_MESSAGE);\n\n        // ERROR THROWN HERE! ..............................\n        // de.flexiprovider.api.exceptions.BadPaddingException: invalid ciphertext\n    }\n    catch (IllegalBlockSizeException e) {\n        Log.e(TAG, e.toString());\n    }\n    catch (BadPaddingException e) {\n        Log.e(TAG, e.toString());\n    }\n\n    String decryptedMessage = null;\n\n    try {\n        decryptedMessage = new String(decryptedData, \"UTF-8\");\n    }\n    catch (UnsupportedEncodingException e) {\n        Log.e(TAG, e.toString());\n    }\n    Log.d(\"decryptedMessage: \", decryptedMessage);\n    return decryptedMessage;\n}\n", "idx": 2599}
{"project": "cipher", "commit_id": "Snippet20087963_2727.java", "target": 0, "func": "static void decrypt() throws IOException, NoSuchAlgorithmException, NoSuchPaddingException, InvalidKeyException {\n    FileInputStream fis = new FileInputStream(\"data/encrypted\");\n\n    FileOutputStream fos = new FileOutputStream(\"data/decrypted\");\n    SecretKeySpec sks = new SecretKeySpec(\"MyDifficultPassw\".getBytes(), \"AES\");\n    Cipher cipher = Cipher.getInstance(\"AES\");\n    cipher.init(Cipher.DECRYPT_MODE, sks);\n    CipherInputStream cis = new CipherInputStream(fis, cipher);\n    int b;\n    byte[] d = new byte[8];\n    while((b = cis.read(d)) != -1) {\n        fos.write(d, 0, b);\n    }\n    fos.flush();\n    fos.close();\n    cis.close();\n}\n", "idx": 2084}
{"project": "cipher", "commit_id": "Snippet3870784_30916.java", "target": 1, "func": "private byte[] aesEncryptedInfo(String info) throws UnsupportedEncodingException, IllegalBlockSizeException, BadPaddingException, InvalidKeyException, NoSuchAlgorithmException, NoSuchPaddingException, InvalidParameterSpecException, InvalidAlgorithmParameterException, NoSuchProviderException {\n    Security.addProvider(new BouncyCastleProvider());\n    SecretKey secret = new SecretKeySpec(CUSTOMLONGSECRETKEY.substring(0, 32).getBytes(), \"AES\");\n    Cipher cipher = Cipher.getInstance(\"AES/CBC/PKCS7Padding\", \"BC\");\n    cipher.init(Cipher.ENCRYPT_MODE, secret, new IvParameterSpec(VECTOR_SECRET_KEY.getBytes()));\n    return cipher.doFinal(info.getBytes(\"UTF-8\"));\n}\n", "idx": 2545}
{"project": "cipher", "commit_id": "Snippet38407929_20358.java", "target": 0, "func": "Cipher cipher = Cipher.getInstance(\"blowfish\");\n", "idx": 1950}
{"project": "cipher", "commit_id": "Snippet31070753_13240.java", "target": 1, "func": "c = Cipher.getInstance(\"RSA/ECB/NoPadding\");\nc.init(Cipher.ENCRYPT_MODE, pubKeyNew);\nencodeFile = c.doFinal(b);\n", "idx": 2429}
{"project": "cipher", "commit_id": "Snippet42738641_24771.java", "target": 0, "func": "    try {\n        String english = \"Rastapopoulos\";\n        String chinese = \"\u6843\u8349\u5939\u82a5\u4eba\u8549\u82a5\u7389\u82a5\u82b1\u8377\u5b50\u8863\u5170\u82a5\u82b1\";\n        String transformationKey = \"asdewqayxswedcvf\";\n        Key aesKey = new SecretKeySpec(transformationKey.getBytes(\"UTF-8\"), \"AES\");\n        Cipher cipher = Cipher.getInstance(\"AES\");\n        cipher.init(Cipher.ENCRYPT_MODE, aesKey);\n\n        byte[] encrypted1 = cipher.doFinal(english.getBytes(\"UTF-8\"));\n        String encoded1 = Base64.encodeBase64String(encrypted1);\n\n        byte[] encrypted2 = cipher.doFinal(chinese.getBytes(\"UTF-8\"));\n        String encoded2 = Base64.encodeBase64String(encrypted2);\n\n        System.out.println(\"Original length: \" + english.length() + \"\\tEncrypted length: \" + encoded1.length() + \"\\t\" + encoded1);\n        System.out.println(\"Original length: \" + chinese.length() + \"\\tEncrypted length: \" + encoded2.length() + \"\\t\" + encoded2);\n    } catch (Exception e) {\n        e.printStackTrace();\n    }\n", "idx": 1990}
{"project": "cipher", "commit_id": "Snippet23101320_5462.java", "target": 0, "func": "Cipher.getInstance(\"AES/ECB/PKCS5Padding\")", "idx": 2037}
{"project": "cipher", "commit_id": "Snippet8102794_33085.java", "target": 1, "func": "import java.security.PublicKey; \nimport java.security.Security; \nimport javax.crypto.Cipher; \n\npublic class DecyrptTest { \n    public static void main (String[] args) throws Exception { \n        Security.addProvider(new org.bouncycastle.jce.provider.BouncyCastleProvider()); \n        //msg is some secret msg ,i have deleted. \n        String msg = \"\"; \n        byte[] signedMsgBytes = SHA1.sign(msg); \n        String signedMessageOther=StringTools.bytesToHex(signedMsgBytes); \n        System.out.println(\"signedMessageOther: \"+signedMessageOther); \n\n        String ct=\"1386cfed01490b9026903722324f80f8a56cc38169b46e15154ce9e7168ff589282855002e195a0c1a96d5fe540a7fa97b01ae24f365f39302e0c1186ee9308d6b94526741f7093dc2678c713bb2b1a8a6942decb35b16725353da523417cb835cea903485b19b63c2c444c8bc6c865ea78c749f10ca70b266f6078192f5c76c\"; \n\n        Cipher cipher = Cipher.getInstance(\"RSA\", \"BC\"); \n        PublicKey pubKey = KeyUtil.getPubKeyFromFile(\"res/key.pub\"); \n        System.out.println(\"Algorithm: \"+pubKey.getAlgorithm()); \n        System.out.println(\"Format: \"+pubKey.getFormat()); \n        System.out.println(\"Key Length: \"+pubKey.getEncoded().length); \n\n        cipher.init(Cipher.DECRYPT_MODE, pubKey); \n        byte[] ctBytes=StringTools.hexStringToByteArray(ct); \n        System.out.println(ctBytes.length); \n        byte[] cipherText2 = cipher.doFinal(ctBytes); \n        System.out.println(\"cipher: \" + StringTools.bytesToHex(cipherText2)); \n    } \n}\n", "idx": 2631}
{"project": "cipher", "commit_id": "Snippet35195011_17122.java", "target": 0, "func": "private static synchronized Cipher getAesCipher() throws NoSuchAlgorithmException, NoSuchPaddingException{\n    if (_aesCipher == null) {\n        _aesCipher = Cipher.getInstance(\"AES\");\n    }\n\n    return _aesCipher;\n}\n", "idx": 2120}
{"project": "cipher", "commit_id": "Snippet2638967_30363.java", "target": 1, "func": "package so.example;\n\nimport java.security.*;\nimport javax.crypto.Cipher;\nimport javax.crypto.spec.IvParameterSpec;\nimport javax.crypto.spec.SecretKeySpec;\nimport org.apache.commons.codec.binary.*;\n\npublic class SO_AES192 {\n\nprivate static final String _AES = \"AES\";\nprivate static final String _AES_CBC_PKCS5Padding = \"AES/CBC/PKCS5Padding\";\nprivate static final String KEY_VALUE = \"a-24byte-key-string-here\";\nprivate static final String SALT_VALUE = \"16byte-salt-here\";\nprivate static final int ITERATIONS = 1;\n\nprivate static IvParameterSpec ivParameterSpec;\n\npublic static String encryptHex(String value) throws Exception {\n    Key key = generateKey();\n\n    Cipher c = Cipher.getInstance(_AES_CBC_PKCS5Padding);\n    ivParameterSpec = new IvParameterSpec(SALT_VALUE.getBytes());\n    c.init(Cipher.ENCRYPT_MODE, key, ivParameterSpec);\n\n    String valueToEncrypt = null;\n    String eValue = value;\n    for (int i = 0; i < ITERATIONS; i++) {\n//            valueToEncrypt = SALT_VALUE + eValue; // pre-pend salt - Length > sample length\n        valueToEncrypt =  eValue;     // don't pre-pend salt  Length = sample length\n        byte[] encValue = c.doFinal(valueToEncrypt.getBytes());\n        eValue =  Hex.encodeHexString(encValue);\n    }\n    return eValue;\n}\n\npublic static String decryptHex(String value) throws Exception {\n    Key key = generateKey();\n\n    Cipher c = Cipher.getInstance(_AES_CBC_PKCS5Padding);\n    ivParameterSpec = new IvParameterSpec(SALT_VALUE.getBytes());\n    c.init(Cipher.DECRYPT_MODE, key, ivParameterSpec);\n\n    String dValue = null;\n    char[] valueToDecrypt = value.toCharArray();\n    for (int i = 0; i < ITERATIONS; i++) {\n        byte[] decordedValue = Hex.decodeHex(valueToDecrypt);\n        byte[] decValue = c.doFinal(decordedValue);\n//            dValue = new String(decValue).substring(SALT_VALUE.length()); // when salt is pre-pended\n        dValue = new String(decValue);   // when salt is not pre-pended\n        valueToDecrypt = dValue.toCharArray();\n    }\n    return dValue;\n}\n\nprivate static Key generateKey() throws Exception {\n    // Key key = new SecretKeySpec(KEY_VALUE.getBytes(), _AES); // this was wrong\n    Key key = new SecretKeySpec(new BASE64Decoder().decodeBuffer(keyValueString), _AES); // had to un-Base64 the 'known' 24-byte key.\n    return key;\n}\n\n}\n", "idx": 2737}
{"project": "cipher", "commit_id": "Snippet46023797_27892.java", "target": 1, "func": "def decode(input:String, key:String) = {\n    val cipher = Cipher.getInstance(\"AES/CFB/NoPadding\")\n    val blockSize = cipher.getBlockSize()\n    val keyBytes = key.getBytes()\n    val inputArr = Base64.getUrlDecoder().decode(input)\n    val skSpec = new SecretKeySpec(keyBytes, \"AES\")\n    val iv = new IvParameterSpec(inputArr.slice(0, blockSize).toArray)\n    val dataToDecrypt = inputArr.slice(blockSize, inputArr.size)\n    cipher.init(Cipher.DECRYPT_MODE, skSpec, iv)\n    new String(cipher.doFinal(dataToDecrypt.toArray))\n}\n\ndef main(args: Array[String]) {\n    print(decode(\"c1bpFhxn74yzHQs-vgLcW6E5yL8zJfgceEQgYl0=\", \"0123456789abcdef\"));\n}\n", "idx": 2606}
{"project": "cipher", "commit_id": "Snippet23792993_6099.java", "target": 1, "func": "package com.infovale.cripto;\n\nimport java.io.UnsupportedEncodingException;\nimport java.math.BigInteger;\nimport java.security.InvalidKeyException;\nimport java.security.KeyPair;\nimport java.security.KeyPairGenerator;\nimport java.security.NoSuchAlgorithmException;\nimport java.security.PrivateKey;\nimport java.security.PublicKey;\nimport java.util.Arrays;\n\nimport javax.crypto.BadPaddingException;\nimport javax.crypto.Cipher;\nimport javax.crypto.IllegalBlockSizeException;\nimport javax.crypto.NoSuchPaddingException;\n\npublic class RSA {\n\nKeyPairGenerator kpg;\nKeyPair kp;\nPublicKey publicKey;\nPrivateKey privateKey;\nbyte[] encryptedBytes, decryptedBytes;\nCipher cipher, cipher1;\nString encrypted, decrypted;\n\npublic String Encrypt (String plain) throws NoSuchAlgorithmException, NoSuchPaddingException, InvalidKeyException, IllegalBlockSizeException, BadPaddingException \n{\n    kpg = KeyPairGenerator.getInstance(\"RSA\");\n    kpg.initialize(1024);\n    kp = kpg.genKeyPair();\n    publicKey = kp.getPublic();\n    privateKey = kp.getPrivate();\n\n    cipher = Cipher.getInstance(\"RSA\");\n    cipher.init(Cipher.ENCRYPT_MODE, publicKey);\n    encryptedBytes = cipher.doFinal(plain.getBytes());\n\n    encrypted = bytesToString(encryptedBytes);\n    return encrypted;\n\n}\n\npublic String Decrypt (String result) throws NoSuchAlgorithmException, NoSuchPaddingException, InvalidKeyException, IllegalBlockSizeException, BadPaddingException \n{           \n\n    cipher1=Cipher.getInstance(\"RSA\");\n    cipher1.init(Cipher.DECRYPT_MODE, privateKey);\n    decryptedBytes = cipher1.doFinal(stringToBytes(result));\n    decrypted = new String(decryptedBytes);\n    return decrypted;\n\n}\n\npublic  String bytesToString(byte[] b) {\n    byte[] b2 = new byte[b.length + 1];\n    b2[0] = 1;\n    System.arraycopy(b, 0, b2, 1, b.length);\n    return new BigInteger(b2).toString(36);\n}\n\npublic  byte[] stringToBytes(String s) {\n    byte[] b2 = new BigInteger(s, 36).toByteArray();\n    return Arrays.copyOfRange(b2, 1, b2.length);\n}\n}\n", "idx": 2458}
{"project": "cipher", "commit_id": "Snippet21891215_4316.java", "target": 1, "func": "private final String characterEncoding = \"UTF-8\";\nprivate final String cipherTransformation = \"AES/CBC/PKCS5Padding\";\nprivate final String aesEncryptionAlgorithm = \"AES\";\n\npublic  byte[] decrypt(byte[] cipherText, byte[] key, byte [] initialVector) throws NoSuchAlgorithmException, NoSuchPaddingException, InvalidKeyException, InvalidAlgorithmParameterException, IllegalBlockSizeException, BadPaddingException\n{\n    Cipher cipher = Cipher.getInstance(cipherTransformation);\n    SecretKeySpec secretKeySpecy = new SecretKeySpec(key, aesEncryptionAlgorithm);\n    IvParameterSpec ivParameterSpec = new IvParameterSpec(initialVector);\n    cipher.init(Cipher.DECRYPT_MODE, secretKeySpecy, ivParameterSpec);\n    cipherText = cipher.doFinal(cipherText);\n    return cipherText;\n}\n\npublic byte[] encrypt(byte[] plainText, byte[] key, byte [] initialVector) throws NoSuchAlgorithmException, NoSuchPaddingException, InvalidKeyException, InvalidAlgorithmParameterException, IllegalBlockSizeException, BadPaddingException\n{\n    Cipher cipher = Cipher.getInstance(cipherTransformation);\n    SecretKeySpec secretKeySpec = new SecretKeySpec(key, aesEncryptionAlgorithm);\n    IvParameterSpec ivParameterSpec = new IvParameterSpec(initialVector);\n    cipher.init(Cipher.ENCRYPT_MODE, secretKeySpec, ivParameterSpec);\n    plainText = cipher.doFinal(plainText);\n    return plainText;\n}\n\nprivate byte[] getKeyBytes(String key) throws UnsupportedEncodingException{\n    byte[] keyBytes= new byte[16];\n    byte[] parameterKeyBytes= key.getBytes(characterEncoding);\n    System.arraycopy(parameterKeyBytes, 0, keyBytes, 0, Math.min(parameterKeyBytes.length, keyBytes.length));\n    return keyBytes;\n}\n\n\npublic String encrypt(String plainText, String key) throws UnsupportedEncodingException, InvalidKeyException, NoSuchAlgorithmException, NoSuchPaddingException, InvalidAlgorithmParameterException, IllegalBlockSizeException, BadPaddingException{\n    byte[] plainTextbytes = plainText.getBytes(characterEncoding);\n    byte[] keyBytes = getKeyBytes(key);\n    return Base64.encodeToString(encrypt(plainTextbytes,keyBytes, keyBytes), Base64.DEFAULT);\n}\n\n\npublic String decrypt(String encryptedText, String key) throws KeyException, GeneralSecurityException, GeneralSecurityException, InvalidAlgorithmParameterException, IllegalBlockSizeException, BadPaddingException, IOException{\n    byte[] cipheredBytes = Base64.decode(encryptedText, Base64.DEFAULT);\n    byte[] keyBytes = getKeyBytes(key);\n    return new String(decrypt(cipheredBytes, keyBytes, keyBytes), characterEncoding);\n}\n", "idx": 2377}
{"project": "cipher", "commit_id": "Snippet44746907_26833.java", "target": 1, "func": "import java.security.InvalidKeyException;\nimport java.security.Key;\nimport java.security.KeyPair;\nimport java.security.KeyPairGenerator;\nimport java.security.NoSuchAlgorithmException;\nimport java.security.PrivateKey;\nimport java.security.PublicKey;\nimport java.security.Signature;\nimport java.security.SignatureException;\nimport javax.crypto.Cipher;\nimport javax.crypto.spec.IvParameterSpec;\nimport javax.crypto.spec.SecretKeySpec;\nimport org.apache.commons.codec.binary.Base64;\n\npublic class Lc {\n    public static PublicKey pub;\n      public static PrivateKey pri;\n      public byte[] by;\n      public String dot;\n      public Lc() {\n          Object localObject = \"RSA\";\n          try\n          {\n            localObject = KeyPairGenerator.getInstance((String)localObject);\n            KeyPair localKeyPair = ((KeyPairGenerator)localObject).generateKeyPair();\n            localObject = localKeyPair.getPublic();\n            pub = (PublicKey)localObject;\n            localObject = localKeyPair.getPrivate();\n            pri = (PrivateKey)localObject;\n          }\n          catch (NoSuchAlgorithmException localNoSuchAlgorithmException)\n          {\n            localNoSuchAlgorithmException.printStackTrace();\n          }\n    }\n      public static String upperDot(String paramString)\n      {\n        Object localObject = \"RSA/ECB/PKCS1Padding\";\n        try\n        {\n          Cipher localCipher = Cipher.getInstance((String)localObject);\n          localObject = pub;\n          int i = 1;\n          localCipher.init(i, (Key)localObject);\n          localObject = paramString.getBytes();\n          byte[] arrayOfByte1 = localCipher.doFinal((byte[])localObject);\n          byte[] arrayOfByte2 = Base64.encodeBase64(arrayOfByte1);\n          localObject = new String(arrayOfByte2);\n          return (String)localObject;\n        }\n        catch (Exception localException)\n        {\n          System.out.print(localException);\n        }\n        return null;\n      }\n}\n", "idx": 2648}
{"project": "cipher", "commit_id": "Snippet17407909_627.java", "target": 0, "func": "public static byte[] tripleDes(final byte[] original, final int mode, final SecretKeySpec keySpec, final byte[] ivSpec) throws GeneralSecurityException {\n    final Cipher cipher = Cipher.getInstance(\"DESede/CBC/NoPadding\");\n    final IvParameterSpec iv = new IvParameterSpec(ivSpec);\n    cipher.init(mode, keySpec, iv);\n    return cipher.doFinal(original);\n}\n", "idx": 2191}
{"project": "cipher", "commit_id": "Snippet7642871_32825.java", "target": 1, "func": "Cipher c = Cipher.getInstance(\"AES/CTR/NoPadding\");\nSecretKeySpec keySpec = new SecretKeySpec(aeskey, \"AES\");\nIvParameterSpec ivSpec = new IvParameterSpec(iv);\n\nc.init(Cipher.ENCRYPT_MODE, keySpec, ivSpec);\n\nCipherOutputStream cipher_out = new CipherOutputStream(output, c);\n\ntry {\n    while (true) {\n        cipher_out.write(input.readByte());\n    }\n} catch (EOFException e) {\n}\n\nbyte curIV[] = c.getIV();\n", "idx": 2500}
{"project": "cipher", "commit_id": "Snippet28504150_10666.java", "target": 0, "func": "import java.security.Key;\n\nimport javax.crypto.Cipher; import javax.crypto.spec.SecretKeySpec;\nimport javax.persistence.AttributeConverter;\n\nimport org.postgresql.util.Base64; \nimport org.springframework.beans.factory.annotation.Value; \nimport org.springframework.context.annotation.Bean; \nimport org.springframework.context.support.PropertySourcesPlaceholderConfigurer;\nimport org.springframework.stereotype.Component;\n\n@javax.persistence.Converter \n@Component \npublic class EntityEncryptionConverter implements AttributeConverter<String, String> {\n\n    @Value(\"${general.key}\")\n    private String keyCode;\n\n    private static final String ALGORITHM = \"AES/ECB/PKCS5Padding\";\n    private static final byte[] KEY = \"395DEADE4D23DD92\".getBytes();\n\n    public String convertToDatabaseColumn(String ccNumber) {\n        System.out.print(keyCode);\n        // do some encryption\n        Key key = new SecretKeySpec(KEY, \"AES\");\n        try {\n            Cipher c = Cipher.getInstance(ALGORITHM);\n            c.init(Cipher.ENCRYPT_MODE, key);\n            return Base64.encodeBytes(c.doFinal(ccNumber.getBytes()));\n        } catch (Exception e) {\n            throw new RuntimeException(e);\n        }\n    }\n\n    public String convertToEntityAttribute(String dbData) {\n        // do some decryption\n        Key key = new SecretKeySpec(KEY, \"AES\");\n        try {\n            Cipher c = Cipher.getInstance(ALGORITHM);\n            c.init(Cipher.DECRYPT_MODE, key);\n            return new String(c.doFinal(Base64.decode(dbData)));\n        } catch (Exception e) {\n            throw new RuntimeException(e);\n        }\n    }\n}\n", "idx": 1997}
{"project": "cipher", "commit_id": "Snippet13784098_37276.java", "target": 1, "func": "byte[] iv = new byte[] { 0x0, 0x1, 0x2, 0x3, 0x4, 0x5, 0x6, 0x7, 0x8, 0x9, 0xA, 0xB, 0xC, 0xD, 0xE, 0xF }; \nIvParameterSpec ivSpec = new IvParameterSpec(iv);\n\nSecretKeySpec skeySpec = new SecretKeySpec(raw, \"AES\");\nCipher cipher = Cipher.getInstance(\"AES/CFB/NoPadding\");\ncipher.init(Cipher.ENCRYPT_MODE, skeySpec, ivSpec);\n", "idx": 2475}
{"project": "cipher", "commit_id": "Snippet41220754_23181.java", "target": 1, "func": "public class RSAcipher {\n\nprivate static final String TAG = \"RSA Cipher\";\n\nprivate SharedPreferences keyDat=null;\nprivate SharedPreferences.Editor keyEdit=null;\nprivate String\n        pubKeyStr=null,\n        priKeyStr=null;\nprivate Key\n        publicKey=null,\n        privateKey=null;\n\nprivate static Context ct=null;\nprivate static RSAcipher savedInstance=null;\n\npublic static RSAcipher getInstance(Context context) {\n    ct = context;\n    if(savedInstance==null){\n        savedInstance = new RSAcipher();\n    }\n    return savedInstance;\n}\n\nprivate RSAcipher() {\n    keyDat = PreferenceManager.getDefaultSharedPreferences(ct);\n    keyEdit = keyDat.edit();\n    pubKeyStr = keyDat.getString(\"spPubKeyTag\",null);\n    priKeyStr = keyDat.getString(\"spPriKeyTag\",null);\n    if(pubKeyStr==null && priKeyStr==null){\n        generateKeys();\n    }\n}\n\nprivate void generateKeys(){\n    try{\n        KeyPairGenerator kpg = KeyPairGenerator.getInstance(\"RSA\", \"BC\");\n        kpg.initialize(1024, new SecureRandom());\n        KeyPair keyPair = kpg.genKeyPair();\n        publicKey = keyPair.getPublic();\n        privateKey = keyPair.getPrivate();\n\n        byte[] pubByte = publicKey.getEncoded();\n        pubKeyStr = new String(Base64.encodeToString(pubByte,Base64.DEFAULT));\n        byte[] priByte = privateKey.getEncoded();\n        priKeyStr = new String(Base64.encodeToString(priByte,Base64.DEFAULT));\n\n        keyEdit.putString(\"spPubKeyTag\",pubKeyStr);\n        keyEdit.putString(\"spPriKeyTag\",priKeyStr);\n        keyEdit.commit();\n    } catch (Exception e){\n        Log.e(TAG,\"key generation error\");\n    }\n}\n\nprivate Key getPubKey(){\n    String pubKeyStr = keyDat.getString(\"spPubKeyTag\", \"\");\n    byte[] sigBytes = Base64.decode(pubKeyStr, Base64.DEFAULT);\n    X509EncodedKeySpec x509KeySpec = new X509EncodedKeySpec(sigBytes);\n    KeyFactory keyFact = null;\n    try {\n        keyFact = KeyFactory.getInstance(\"RSA\", \"BC\");\n    } catch (NoSuchAlgorithmException e) {\n        e.printStackTrace();\n    } catch (NoSuchProviderException e) {\n        e.printStackTrace();\n    }\n    try {\n        return  keyFact.generatePublic(x509KeySpec);\n    } catch (InvalidKeySpecException e) {\n        e.printStackTrace();\n    }\n    return null;\n}\n\nprivate  Key getPriKey(){\n    String privKeyStr = keyDat.getString(\"spPriKeyTag\", \"\");\n    byte[] sigBytes = Base64.decode(privKeyStr, Base64.DEFAULT);\n    X509EncodedKeySpec x509KeySpec = new X509EncodedKeySpec(sigBytes);\n    KeyFactory keyFact = null;\n    try {\n        keyFact = KeyFactory.getInstance(\"RSA\", \"BC\");\n    } catch (NoSuchAlgorithmException e) {\n        e.printStackTrace();\n    } catch (NoSuchProviderException e) {\n        e.printStackTrace();\n    }\n    try {\n        return  keyFact.generatePrivate(x509KeySpec);\n    } catch (InvalidKeySpecException e) {\n        e.printStackTrace();\n    }\n    return null;\n}\n\npublic String getEncoded(String str){\n    if(publicKey==null){\n        publicKey = getPubKey();\n    }\n    String enstr = new String();\n    byte[] encodedBytes = null;\n    try{\n        Cipher c = Cipher.getInstance(\"RSA\", \"BC\");\n        c.init(Cipher.ENCRYPT_MODE,publicKey);\n        encodedBytes = c.doFinal(str.getBytes());\n    } catch (Exception e){\n        Log.e(TAG, \"RSA Encryption error\");\n    }\n    enstr = Base64.encodeToString(encodedBytes,Base64.DEFAULT);\n    return enstr;\n}\n\npublic  String getDecoded(String str){\n    if(privateKey==null){\n        privateKey = getPriKey();\n    }\n    String destr = new String();\n    byte[] encodedBytes = Base64.decode(str,Base64.DEFAULT);\n    byte[] decodedBytes = null;\n    try{\n        Cipher c = Cipher.getInstance(\"RSA\", \"BC\");\n        c.init(Cipher.DECRYPT_MODE,privateKey);\n        decodedBytes = c.doFinal(encodedBytes);\n    }catch(Exception e){\n        Toast.makeText(ct, e.toString(), Toast.LENGTH_LONG).show();\n    }\n    try{destr = new String(decodedBytes);}catch (Exception e){}\n    return destr;\n}}\n", "idx": 2369}
{"project": "cipher", "commit_id": "Snippet31771658_13842.java", "target": 1, "func": "Cipher cipher = Cipher.getInstance(\"RSA/ECB/NoPadding\");\ncipher.init(Cipher.ENCRYPT_MODE,publicServerKey);\nbyte[] parametersCipher = cipher.doFinal(parameters.getBytes(\"UTF-8\"));\nString encoded=new String(Base64.encode(parametersCipher, Base64.URL_SAFE)); //URL_SAFE from Android Documentation + as - and / as _\nString parametersencrypted=\"data=\"+encoded;\n", "idx": 2486}
{"project": "cipher", "commit_id": "Snippet13263210_36813.java", "target": 1, "func": "package cartoon;\n\nimport javax.crypto.Cipher;\nimport javax.crypto.spec.IvParameterSpec;\nimport javax.crypto.spec.SecretKeySpec;\n\npublic class MCrypt {\n\nprivate String iv = \"0123456789abcdef\";// iv \nprivate IvParameterSpec ivspec;\nprivate SecretKeySpec keyspec;\nprivate Cipher cipher;\nprivate String SecretKey = \"fedcba9876543210\";// secretKey \n\npublic MCrypt() {\n    ivspec = new IvParameterSpec(iv.getBytes(), 0, iv.getBytes().length);\n\n    keyspec = new SecretKeySpec(SecretKey.getBytes(), 0, iv.getBytes().length, \"AES\");\n\n}\n\nString Decrypt(String text) throws Exception {\n    cipher = Cipher.getInstance(\"AES/CBC/PKCS5Padding\");\n\n    cipher.init(Cipher.DECRYPT_MODE, keyspec, ivspec);\n    byte[] results = null;\n    int results1 = cipher.doFinal(Base64.decode(text), 0, Base64.decode(text).length, results, 0);\n    System.out.println(\"String resultssssssssssssss \" + results1);\n    return new String(results, \"UTF-8\");\n}\n\nString Encrypt(String text)\n        throws Exception {\n    cipher = Cipher.getInstance(\"AES/CBC/PKCS5Padding\");\n\n    System.out.println(\"String input : \" + text);\n\n    cipher.init(Cipher.ENCRYPT_MODE, keyspec, ivspec);\n    byte[] results = null;\n    int results1 = cipher.doFinal(text.getBytes(), 0, text.getBytes().length, results, 0);\n    return Base64.encode(results);\n}\n}\n", "idx": 2637}
{"project": "cipher", "commit_id": "Snippet15346056_38404.java", "target": 1, "func": "public class Encrypter {\n\n    private Cipher cipher; //The encryption cipher object\npublic static final String ALGORITHM = \"Blowfish\"; //Encryption Algorithm\n\n    /**\n     * Constructor\n     */\n    public Encrypter()\n    {       \n        try {\n            initlizeCipher();\n        } catch (Throwable e) {     \n            ServerSettings.LOG.logError(e);\n            e.printStackTrace();\n\n        }\n    }\n\n    /**\n     * Initialize the Cipher object\n     * @throws NoSuchAlgorithmException\n     * @throws NoSuchPaddingException\n     */\n    private void initlizeCipher() throws NoSuchAlgorithmException, NoSuchPaddingException\n    {       \n        cipher = Cipher.getInstance(ServerSettings.ALGORITHM);\n    }\n\n    /**\n     * Encrypt a String\n     * @param string String to encrypt\n     * @return an encrypted String\n     * @throws InvalidKeyException\n     * @throws IllegalBlockSizeException\n     * @throws BadPaddingException\n     * @throws UnsupportedEncodingException\n     */\n    public synchronized String encrypt(String string) throws InvalidKeyException, IllegalBlockSizeException, BadPaddingException, UnsupportedEncodingException\n    {\n        cipher.init(Cipher.ENCRYPT_MODE, ServerSettings.SECRECT_KEY_SPEC);\n        byte[] stringBytes = string.getBytes(\"UTF-8\");\n        byte[] encryptedBytes = cipher.doFinal(stringBytes);\n        return Base64.encodeBytes(encryptedBytes);      \n    }\n\n    /**\n     * Decrypt a String\n     * @param string String to decrypt\n     * @return a decrypted String\n     * @throws InvalidKeyException\n     * @throws IllegalBlockSizeException\n     * @throws BadPaddingException\n     * @throws IOException\n     */\n    public synchronized String decrypt(String string) throws InvalidKeyException, IllegalBlockSizeException, BadPaddingException, IOException\n    {       \n        cipher.init(Cipher.DECRYPT_MODE, ServerSettings.SECRECT_KEY_SPEC);\n        byte[] decryptedBytes = Base64.decode(string.getBytes());       \n        byte[] encryptedBytes = cipher.doFinal(decryptedBytes);\n        return new String(encryptedBytes,\"UTF-8\");\n    }   \n}\n", "idx": 2470}
{"project": "cipher", "commit_id": "Snippet34604515_16574.java", "target": 1, "func": "File secKey = new File(ROOT_PATH+\"pkcs8_key.key\");\nbyte[] privateKeyB = readByte(secKey);\nPKCS8EncodedKeySpec privateSpec = new PKCS8EncodedKeySpec(privateKeyB);\n\nKeyFactory privateFactory = KeyFactory.getInstance(\"ec\",provider);\nPrivateKey privateKey = privateFactory.generatePrivate(privateSpec);\nCipher privateCipher = Cipher.getInstance(\"ECIES/NONE/Nopadding\", provider);\nprivateCipher.init(Cipher.DECRYPT_MODE, privateKey);\nbyte[] encryptedFromFile = readByte(new File(ROOT_PATH+\"test/real/testout.dat\"));\nbyte[] decrypted = privateCipher.doFinal(encryptedFromFile);\n\nFileUtils.writeByteArrayToFile(new File(ROOT_PATH+\"test/real/testout_de.txt\"), decrypted);`\n", "idx": 2512}
{"project": "cipher", "commit_id": "Snippet40912549_22824.java", "target": 0, "func": " String text16 = \"6F4B1B252A5F0C3F2992E1A65E56E5B8\";\n    String secret16 = \"c4dcc3c6ce0acaec4327b6098260b0be\";\n\n    SecretKeySpec sks = new SecretKeySpec(secret16.getBytes(),\"AES\");\n    Cipher c = Cipher.getInstance(\"AES\");\n\n    c.init(Cipher.ENCRYPT_MODE, sks);\n    c.update(text16.getBytes());\n    byte[] ciphertext = c.doFinal();\n    Log.d(\"resultdebug\",new String(Hex.encode(ciphertext), \"ASCII\"));\n", "idx": 2216}
{"project": "cipher", "commit_id": "Snippet25579941_7891.java", "target": 0, "func": "package dataBases;\n\n\npublic class BackupHelper {\n\npublic static int SECURITY_NONE = 1 ;\npublic static int SECURITY_ENCRYPTED = 2 ;\n\npublic static void backup(Context context, int securityMode) {\n\n    File backup = new File(Environment.getExternalStorageDirectory()+ \n            \"/\" + \"KarAmad\" + \"/\" + \"backup\");\n    backup.mkdirs();\n\n    List<File> src = new ArrayList<File>();\n    List<File> dst = new ArrayList<File>();\n\n\n    try {\n        src.add( new File(new PrimaryInformationDataBase(context).getDirectory()) );\n        dst.add( new File(backup.getPath() + \"/\" + \"PI\") );\n\n        src.add( new File(new TransactionDataBase(context).getDirectory()) );\n        dst.add( new File(backup.getPath() + \"/\" + \"T\") );\n\n        src.add( new File(new NoteDataBase(context).getDirectory()) );\n        dst.add( new File(backup.getPath() + \"/\" + \"N\") );\n\n        src.add( new File(new PictureDataBase(context).getDirectory()) );\n        dst.add( new File(backup.getPath() + \"/\" + \"P\") );\n\n        for(int i = 0 ; i < src.size() ; i ++) {\n            dst.get(i).createNewFile();\n            if(securityMode == SECURITY_ENCRYPTED)\n                BackupHelper.encrypt(src.get(i), dst.get(i));\n            else\n                LeftFragment.copy(src.get(i), dst.get(i));\n        }\n\n        Toast.makeText(context, \"\u067e\u0634\u062a\u06cc\u0628\u0627\u0646 \u06af\u06cc\u0631\u06cc \u0627\u0646\u062c\u0627\u0645 \u0634\u062f\", Toast.LENGTH_SHORT).show();\n\n    } catch (Exception e) {\n\n        Toast.makeText(context, \"\u067e\u0634\u062a\u06cc\u0628\u0627\u0646 \u06af\u06cc\u0631\u06cc \u0627\u0646\u062c\u0627\u0645 \u0646\u0634\u062f!\", Toast.LENGTH_SHORT).show();\n        e.printStackTrace();\n\n    }\n}\n\npublic static void restore(Context context, int securityMode) {\n\n    NoteDataBase dummyNoteDataBase = new NoteDataBase(context);\n    String temp = dummyNoteDataBase.getDirectory();\n    String dataBasesPath = temp.substring(0, temp.lastIndexOf(\"/\"));\n\n    File source = new File(Environment.getExternalStorageDirectory()+ \n            \"/\" + \"KarAmad\" + \"/\" + \"backup\");\n\n    List<File> src = new ArrayList<File>();\n    List<File> dst = new ArrayList<File>();\n\n    try {\n        src.add( new File(source.getPath() + \"/\" + \"PI\") );\n        dst.add( new File(dataBasesPath + \"/\" + \"PrimaryInformation\") );\n\n        src.add( new File(source.getPath() + \"/\" + \"T\") );\n        dst.add( new File(dataBasesPath + \"/\" + \"Transaction\") );\n\n        src.add( new File(source.getPath() + \"/\" + \"N\") );\n        dst.add( new File(dataBasesPath + \"/\" + \"Note\") );\n\n        src.add( new File(source.getPath() + \"/\" + \"P\") );\n        dst.add( new File(dataBasesPath + \"/\" + \"Picture\") );\n\n        for(int i = 0 ; i < src.size() ; i++) {\n\n            dst.get(i).createNewFile();\n\n            if(securityMode == SECURITY_ENCRYPTED)\n                BackupHelper.decrypt(src.get(i), dst.get(i));\n            else\n                LeftFragment.copy(src.get(i), dst.get(i));\n        }\n\n\n\n        Toast.makeText(context, \"\u0628\u0627\u0632\u06cc\u0627\u0628\u06cc \u0641\u0627\u06cc\u0644 \u067e\u0634\u062a\u06cc\u0628\u0627\u0646 \u0627\u0646\u062c\u0627\u0645 \u0634\u062f\", Toast.LENGTH_SHORT).show();\n\n    } catch (Exception e) {\n\n        Toast.makeText(context, \"\u0628\u0627\u0632\u06cc\u0627\u0628\u06cc \u0641\u0627\u06cc\u0644 \u067e\u0634\u062a\u06cc\u0628\u0627\u0646 \u0627\u0646\u062c\u0627\u0645 \u0646\u0634\u062f!\", Toast.LENGTH_SHORT).show();\n        e.printStackTrace();\n\n    }\n}\n\npublic static void encrypt(File src, File dst) throws IOException,\n    NoSuchAlgorithmException, NoSuchPaddingException, InvalidKeyException {\n\n    FileInputStream inputStream = new FileInputStream(src);\n    FileOutputStream outputStream = new FileOutputStream(dst);\n\n    SecretKeySpec keySpec = new SecretKeySpec(\"1393032613930326\".getBytes(), \"AES\");\n\n    Cipher cipher = Cipher.getInstance(\"AES\");\n    cipher.init(Cipher.ENCRYPT_MODE, keySpec);\n\n    CipherOutputStream cipherOutputStream = \n            new CipherOutputStream(outputStream, cipher);\n\n    int b;\n    byte[] d = new byte[8];\n    while((b = inputStream.read(d)) > 0) {\n        cipherOutputStream.write(d, 0, b);\n    }\n\n    cipherOutputStream.flush();\n    cipherOutputStream.close();\n    inputStream.close();\n}\n\n\npublic static void decrypt(File src, File dst) throws IOException,\nNoSuchAlgorithmException, NoSuchPaddingException, InvalidKeyException {\n\n    FileInputStream inputStream = new FileInputStream(src);\n    FileOutputStream outputStream = new FileOutputStream(dst);\n\n    SecretKeySpec keySpec = new SecretKeySpec(\"1393032613930326\".getBytes(), \"AES\");\n\n    Cipher cipher = Cipher.getInstance(\"AES\");\n    cipher.init(Cipher.DECRYPT_MODE, keySpec);\n\n    CipherInputStream cipherOutputStream = \n            new CipherInputStream(inputStream, cipher);\n\n    int b;\n    byte[] d = new byte[8];\n    while((b = inputStream.read(d)) > 0) {\n        outputStream.write(d, 0, b);\n    }\n\n    outputStream.flush();\n    outputStream.close();\n    cipherOutputStream.close();\n\n}\n}\n", "idx": 2182}
{"project": "cipher", "commit_id": "Snippet10500512_34842.java", "target": 0, "func": "public static void main(String[] args) throws Exception {\n\n\n\n        String key=\"this is key\";\n\n        String message=\"This is just an example\";\n\n           KeyGenerator kgen = KeyGenerator.getInstance(\"AES\");\n\n           kgen.init(128, new SecureRandom(Base64.decodeBase64(key)));\n\n           // Generate the secret key specs.\n           SecretKey skey = kgen.generateKey();\n\n           byte[] raw = skey.getEncoded();\n\n           SecretKeySpec skeySpec = new SecretKeySpec(raw, \"AES\");\n\n           Cipher cipher = Cipher.getInstance(\"AES\");\n\n           cipher.init(Cipher.ENCRYPT_MODE, skeySpec);\n\n           byte[] encrypted= cipher.doFinal(Base64.decodeBase64(message));\n\n           String encryptedString=Base64.encodeBase64String(encrypted);\n\n           cipher.init(Cipher.DECRYPT_MODE, skeySpec);\n\n           byte[] original =\n             cipher.doFinal(Base64.decodeBase64(encryptedString));\n\n           System.out.println(Base64.encodeBase64String(original));\n\n\n    }\n", "idx": 2118}
{"project": "cipher", "commit_id": "Snippet33795543_15839.java", "target": 1, "func": " @SuppressWarnings(\"static-access\")\npublic String decrypt(String encryptedText) throws Exception {\n\n    byte[] saltBytes = salt.getBytes(\"UTF-8\");\n    byte[] encryptedTextBytes = new Base64().decodeBase64(encryptedText);\n\n    // Derive the key\n    SecretKeyFactory factory =     SecretKeyFactory.getInstance(\"PBKDF2WithHmacSHA1\");\n    PBEKeySpec spec = new PBEKeySpec(\n            password.toCharArray(), \n            saltBytes, \n            pswdIterations, \n            keySize\n            );\n\n    SecretKey secretKey = factory.generateSecret(spec);\n    SecretKeySpec secret = new SecretKeySpec(secretKey.getEncoded(), \"AES\");\n\n    // Decrypt the message\n    Cipher cipher = Cipher.getInstance(\"AES/CBC/PKCS5Padding\");\n    cipher.init(Cipher.DECRYPT_MODE, secret, new IvParameterSpec(ivBytes));\n\n\n    byte[] decryptedTextBytes = null;\n    try {\n        decryptedTextBytes = cipher.doFinal(encryptedTextBytes);\n    } catch (IllegalBlockSizeException e) {\n        e.printStackTrace();\n    } catch (BadPaddingException e) {\n        e.printStackTrace();\n    }\n\n    return new String(decryptedTextBytes);\n  }\n", "idx": 2496}
{"project": "cipher", "commit_id": "Snippet39064616_20950.java", "target": 1, "func": "SecretKey secret = new SecretKeySpec(aesKey, \"AES\");\nCipher cipher = Cipher.getInstance(\"AES/CBC/PKCS5Padding\");\ncipher.init(Cipher.ENCRYPT_MODE, secret);\n// everything else as before\n", "idx": 2716}
{"project": "cipher", "commit_id": "Snippet11762184_35760.java", "target": 0, "func": "import java.security.*;\nimport javax.crypto.Cipher; \nimport javax.crypto.spec.SecretKeySpec;\nimport sun.misc.*;\n\npublic class Encryption {\nprivate static final String ALGORITHM = \"AES\";\nprivate static final byte[] keyValue = \n    new byte[] { '1', '2', '3', '4', '5', '6', '7', '8', '9', 'A', 'B', 'C', 'D', 'E', 'F', 'G' };\n\npublic static String encrypt(String valueToEnc) throws Exception {\n    Key key = generateKey();\n    Cipher c = Cipher.getInstance(ALGORITHM);\n    c.init(Cipher.ENCRYPT_MODE, key);\n    byte[] encValue = c.doFinal(valueToEnc.getBytes());\n    String encryptedValue = new BASE64Encoder().encode(encValue);\n    return encryptedValue;\n}\n\nprivate static Key generateKey() throws Exception {\n    Key key = new SecretKeySpec(keyValue, ALGORITHM);\n    return key;\n}\n\nprivate static String decrypt(String encryptedValue) throws Exception {\n    Key key = generateKey();\n    Cipher c = Cipher.getInstance(ALGORITHM);\n    c.init(Cipher.DECRYPT_MODE, key);\n    byte[] decordedValue = new BASE64Decoder().decodeBuffer(encryptedValue);\n    byte[] decValue = c.doFinal(decordedValue);\n    String decryptedValue = new String(decValue);\n    return decryptedValue;\n}\n}\n", "idx": 2215}
{"project": "cipher", "commit_id": "Snippet3866457_30915.java", "target": 1, "func": "public class AesFileIo {\n    private static final String EOL = \"\\n\";\n    private static final String AES_ALGORITHM = \"AES/CTR/NoPadding\";\n    private static final SecretKeySpec secretKeySpec =\n            new SecretKeySpec(AES_KEY_128, \"AES\");\n    private static final IvParameterSpec ivSpec = new IvParameterSpec(IV);\n\n    public void AesFileIo() {\n        Security.addProvider(new org.bouncycastle.jce.provider\n                .BouncyCastleProvider());\n    }\n\n    public String readFile(String fileName) {\n        StringBuilder stringBuilder = new StringBuilder();\n        try {\n            ObjectInputStream is = new ObjectInputStream(\n                new FileInputStream(fileName));\n            Cipher cipher = Cipher.getInstance(AES_ALGORITHM);\n            cipher.init(Cipher.DECRYPT_MODE, secretKeySpec, ivSpec);\n            CipherInputStream cis = new CipherInputStream(is, cipher);\n            InputStreamReader isr = new InputStreamReader(cis);\n            BufferedReader reader = new BufferedReader(isr);\n            String line;\n            while ((line = reader.readLine()) != null) {\n                stringBuilder.append(line).append(EOL);\n            }\n            is.close();\n        } catch (java.io.FileNotFoundException e) {\n            System.out.println(\"FileNotFoundException: probably OK\");\n        } catch (Exception e) {\n            e.printStackTrace();\n        }\n        return stringBuilder.toString();\n    }\n\n    public void writeFile(String fileName, String theFile) {\n        try {\n            Cipher cipher = Cipher.getInstance(AES_ALGORITHM);\n            cipher.init(Cipher.ENCRYPT_MODE, secretKeySpec, ivSpec);\n            byte[] encrypted = cipher.doFinal(theFile.getBytes());\n            ObjectOutputStream os = new ObjectOutputStream(\n                new FileOutputStream(fileName));\n            os.write(encrypted);\n            os.flush();\n            os.close();\n        } catch (Exception e) {\n            e.printStackTrace();\n        }\n    }\n}\n", "idx": 2498}
{"project": "cipher", "commit_id": "Snippet46284402_28389.java", "target": 1, "func": " ///Gen Key\n ECNamedCurveParameterSpec spec = ECNamedCurveTable.getParameterSpec(\"prime256v1\");\n            try {\n                KeyPairGenerator g = KeyPairGenerator.getInstance(\"ECDSA\",\"SC\");\n                g.initialize(spec, new SecureRandom());\n                KeyPair keyPair = g.generateKeyPair();\n                privateKey = keyPair.getPrivate();\n                publicKey = keyPair.getPublic();\n                Toast.makeText(MainActivity.this, \"GEN KEY SUCCESS!!\", Toast.LENGTH_SHORT).show();\n\n            } catch (Exception e) {\n                e.printStackTrace();\n            }\n/////Encrypt\nString origin = txtOrigin.getText().toString();\n            try {\n                Cipher c = Cipher.getInstance(\"ECIES\",\"SC\");\n                c.init(Cipher.ENCRYPT_MODE,publicKey);\n                encodeBytes = c.doFinal(origin.getBytes());\n                txtEncrypt.setText(Base64.encodeToString(encodeBytes,Base64.DEFAULT));\n                Toast.makeText(MainActivity.this, \"ENCRYPT SUCCESS!!\", Toast.LENGTH_SHORT).show();\n            } catch (Exception e) {\n                e.printStackTrace();\n            }\n ////Decrypt\n byte[] decodeBytes = null;\n            try\n            {\n                Cipher c = Cipher.getInstance(\"ECIES\",\"SC\");\n                c.init(Cipher.DECRYPT_MODE,privateKey);\n                decodeBytes = c.doFinal(encodeBytes);\n                String deCrypt = new String(decodeBytes,\"UTF-8\");\n                txtDecrypt.setText(deCrypt);\n                Toast.makeText(MainActivity.this, \"DECRYPT SUCCESS!!\", Toast.LENGTH_SHORT).show();\n            }\n            catch (Exception ex)\n            {\n                ex.printStackTrace();\n            }\n", "idx": 2732}
{"project": "cipher", "commit_id": "Snippet33005676_15032.java", "target": 0, "func": "import java.io.FileInputStream;\nimport java.io.FileOutputStream;\nimport java.io.IOException;\nimport java.io.InputStream;\nimport java.io.OutputStream;\nimport javax.crypto.Cipher;\nimport javax.crypto.CipherInputStream;\nimport javax.crypto.CipherOutputStream;\nimport javax.crypto.SecretKey;\nimport javax.crypto.SecretKeyFactory;\nimport javax.crypto.spec.DESKeySpec;\n\npublic class Program {\n\n    public static void main(String[] args) {\n\n        try {\n            String key = \"secret1234\";// This is the key\n\n            FileInputStream fis = new FileInputStream(\"text.txt\");//text.txt is a text file with a short message                                        \n            FileOutputStream fos = new FileOutputStream(\"encryptedText.txt\");\n            encrypt(key, fis, fos);\n\n            FileInputStream fis2 = new FileInputStream(\"encryptedText.txt\");\n            FileOutputStream fos2 = new FileOutputStream(\"decryptedText.txt\");\n            decrypt(key, fis2, fos2);\n\n        } catch (Throwable e) {\n            e.printStackTrace();\n        }\n\n    }\n\n    public static void encrypt(String key, InputStream is, OutputStream os) throws Throwable {\n        encryptOrDecrypt(key, Cipher.ENCRYPT_MODE, is, os);\n    }\n\n    public static void decrypt(String key, InputStream is, OutputStream os) throws Throwable {\n        encryptOrDecrypt(key, Cipher.DECRYPT_MODE, is, os);\n    }\n\n    public static void encryptOrDecrypt(String key, int mode, InputStream is, OutputStream os) throws Throwable {\n\n        DESKeySpec dks = new DESKeySpec(key.getBytes());\n        SecretKeyFactory skf = SecretKeyFactory.getInstance(\"DES\");\n        SecretKey desKey = skf.generateSecret(dks);\n        Cipher cipher = Cipher.getInstance(\"DES\");\n\n        if (mode == Cipher.ENCRYPT_MODE) {\n            cipher.init(Cipher.ENCRYPT_MODE, desKey);\n            CipherInputStream cis = new CipherInputStream(is, cipher);\n            doCopy(cis, os);\n        } else if (mode == Cipher.DECRYPT_MODE) {\n            cipher.init(Cipher.DECRYPT_MODE, desKey);\n            CipherOutputStream cos = new CipherOutputStream(os, cipher);\n            doCopy(is, cos);\n        }\n    }\n\n    public static void doCopy(InputStream is, OutputStream os) throws IOException {\n        byte[] bytes = new byte[64];\n        int numBytes;\n        while ((numBytes = is.read(bytes)) != -1) {\n            os.write(bytes, 0, numBytes);\n        }\n            os.flush();\n            os.close();\n            is.close();\n    }\n\n}\n", "idx": 2106}
{"project": "cipher", "commit_id": "Snippet39486787_21399.java", "target": 1, "func": "import android.util.Base64;\n\nimport java.io.IOException;\nimport java.io.UnsupportedEncodingException;\nimport java.security.GeneralSecurityException;\nimport java.security.InvalidAlgorithmParameterException;\nimport java.security.InvalidKeyException;\nimport java.security.KeyException;\nimport java.security.NoSuchAlgorithmException;\n\nimport javax.crypto.BadPaddingException;\nimport javax.crypto.Cipher;\nimport javax.crypto.IllegalBlockSizeException;\nimport javax.crypto.NoSuchPaddingException;\nimport javax.crypto.spec.IvParameterSpec;\nimport javax.crypto.spec.SecretKeySpec;\n\n/**\n * Created by aurelian.rosca.\n */\npublic class EncryptionProvider2 {\n    private final String characterEncoding = \"UTF-8\";\n    private final String cipherTransformation = \"AES/CBC/PKCS5Padding\";\n    private final String aesEncryptionAlgorithm = \"AES\";\n\n    public  byte[] decrypt(byte[] cipherText, byte[] key, byte [] initialVector) throws NoSuchAlgorithmException, NoSuchPaddingException, InvalidKeyException, InvalidAlgorithmParameterException, IllegalBlockSizeException, BadPaddingException\n    {\n        Cipher cipher = Cipher.getInstance(cipherTransformation);\n        SecretKeySpec secretKeySpecy = new SecretKeySpec(key, aesEncryptionAlgorithm);\n        IvParameterSpec ivParameterSpec = new IvParameterSpec(initialVector);\n        cipher.init(Cipher.DECRYPT_MODE, secretKeySpecy, ivParameterSpec);\n        cipherText = cipher.doFinal(cipherText);\n        return cipherText;\n    }\n\n    public byte[] encrypt(byte[] plainText, byte[] key, byte [] initialVector) throws NoSuchAlgorithmException, NoSuchPaddingException, InvalidKeyException, InvalidAlgorithmParameterException, IllegalBlockSizeException, BadPaddingException\n    {\n        Cipher cipher = Cipher.getInstance(cipherTransformation);\n        SecretKeySpec secretKeySpec = new SecretKeySpec(key, aesEncryptionAlgorithm);\n        IvParameterSpec ivParameterSpec = new IvParameterSpec(initialVector);\n        cipher.init(Cipher.ENCRYPT_MODE, secretKeySpec, ivParameterSpec);\n        plainText = cipher.doFinal(plainText);\n        return plainText;\n    }\n\n    private byte[] getKeyBytes(String key) throws UnsupportedEncodingException {\n        byte[] keyBytes= new byte[16];\n        byte[] parameterKeyBytes= key.getBytes(characterEncoding);\n        System.arraycopy(parameterKeyBytes, 0, keyBytes, 0, Math.min(parameterKeyBytes.length, keyBytes.length));\n        return keyBytes;\n    }\n\n\n    public String encrypt(String plainText, String key) throws UnsupportedEncodingException, InvalidKeyException, NoSuchAlgorithmException, NoSuchPaddingException, InvalidAlgorithmParameterException, IllegalBlockSizeException, BadPaddingException{\n        byte[] plainTextbytes = plainText.getBytes(characterEncoding);\n        byte[] keyBytes = getKeyBytes(key);\n        return Base64.encodeToString(encrypt(plainTextbytes,keyBytes, keyBytes), Base64.NO_WRAP);\n    }\n\n\n    public String decrypt(String encryptedText, String key) throws KeyException, GeneralSecurityException, GeneralSecurityException, InvalidAlgorithmParameterException, IllegalBlockSizeException, BadPaddingException, IOException {\n        byte[] cipheredBytes = Base64.decode(encryptedText, Base64.NO_WRAP);\n        byte[] keyBytes = getKeyBytes(key);\n        return new String(decrypt(cipheredBytes, keyBytes, keyBytes), characterEncoding);\n    }\n}\n", "idx": 2383}
{"project": "cipher", "commit_id": "Snippet28976404_11050.java", "target": 1, "func": "KeyGenerator kgen = KeyGenerator.getInstance(\"AES\");\nkgen.init(128);\nSecretKey skAESPayloadKey = kgen.generateKey();\nbyte[] raw = skAESPayloadKey.getEncoded();\n\nSecretKeySpec skeySpec = new SecretKeySpec(raw, \"AES\");\nCipher cipher = Cipher.getInstance(\"AES/CBC/PKCS5Padding\");\ncipher.init(Cipher.ENCRYPT_MODE, skeySpec, ips);\nbyte[] baEncSerialNbr = cipher.doFinal(baSerialNbr);\n", "idx": 2607}
{"project": "cipher", "commit_id": "Snippet23886913_6188.java", "target": 0, "func": "import java.security.Key;\n\nimport javax.crypto.Cipher;\nimport javax.crypto.spec.SecretKeySpec;\n\nimport sun.misc.BASE64Decoder;\nimport sun.misc.BASE64Encoder;\n\npublic class Decrypt256bit {\n\nprivate static Key key;\n\nprivate static Cipher cipher;\n\nstatic {\n    key = new SecretKeySpec(\"P@ssw0Rd!@#**&&&P@ssw0Rd!@#**&&&\".getBytes(), \"AES\");\n    try {\n        cipher = Cipher.getInstance(\"AES/ECB/PKCS5PADDING\",\"SunJCE\");\n    } catch (Exception e) {\n        e.printStackTrace();\n    }\n}\n\npublic static String encryptData(String plainText) {\n    try {\n        cipher.init(Cipher.ENCRYPT_MODE, key);\n        byte[] encrypted = cipher.doFinal(plainText.getBytes());\n        return new BASE64Encoder().encode(encrypted);\n    } catch (Exception e) {\n        throw new IllegalArgumentException(e);\n    }\n}\n\npublic static String decryptData(String encryptedValue) {\n    try {\n        cipher.init(Cipher.DECRYPT_MODE, key);\n        byte[] decordedValue = new BASE64Decoder().decodeBuffer(encryptedValue);\n        int maxKeyLen = Cipher.getMaxAllowedKeyLength(\"AES\");\n        System.out.println(\"Length===\"+maxKeyLen);\n        return new String(cipher.doFinal(decordedValue));\n    } catch (Exception e) {\n        throw new IllegalArgumentException(e);\n    }\n}\n", "idx": 2042}
{"project": "cipher", "commit_id": "Snippet45911218_27985.java", "target": 1, "func": "Cipher cipher = Cipher.getInstance(\"AES/CBC/PKCS5Padding\");\n", "idx": 2764}
{"project": "cipher", "commit_id": "Snippet47586317_29603.java", "target": 1, "func": "    public static String decryption(byte[] encryptedIvTextBytes, String key) throws Exception {\n\n    int ivSize = 16;\n    int keySize = 16;\n\n    // Extract IV.\n   byte[] iv = new byte[ivSize];\n    System.arraycopy(encryptedIvTextBytes, 0, iv, 0, iv.length);\n\n    IvParameterSpec ivParameterSpec = new IvParameterSpec(iv);\n\n    // Extract encrypted part.\n   int encryptedSize = encryptedIvTextBytes.length - ivSize;\n    byte[] encryptedBytes = new byte[encryptedSize];\n    System.arraycopy(encryptedIvTextBytes, ivSize, encryptedBytes, 0, encryptedSize);\n\n    // Hash key.\n    byte[] keyBytes = new byte[keySize];\n    MessageDigest md = MessageDigest.getInstance(\"SHA-256\");\n    md.update(key.getBytes());\n    System.arraycopy(md.digest(), 0, keyBytes, 0, keyBytes.length);\n    SecretKeySpec secretKeySpec = new SecretKeySpec(keyBytes, \"AES\");\n\n    // Decrypt.\nCipher cipherDecrypt = Cipher.getInstance(\"AES/CBC/PKCS5Padding\");\n    cipherDecrypt.init(Cipher.DECRYPT_MODE, secretKeySpec, ivParameterSpec);\n    byte[] decrypted = cipherDecrypt.doFinal(encryptedBytes);\n\n    return new String(decrypted);\n\n}  \n", "idx": 2400}
{"project": "cipher", "commit_id": "Snippet14637520_37863.java", "target": 1, "func": "import java.net.DatagramPacket;\nimport java.net.DatagramSocket;\nimport java.net.InetSocketAddress;\nimport java.net.SocketException;\nimport java.nio.charset.Charset;\n\nimport javax.crypto.Cipher;\nimport javax.crypto.SecretKey;\nimport javax.crypto.spec.IvParameterSpec;\nimport javax.crypto.spec.SecretKeySpec;\n\npublic class UDP_AES {\n\n\n    /**\n     * @param args\n     * @throws SocketException \n     */\n    public static void main(String[] args) throws SocketException {\n\n\n        Thread t = new Thread(new Runnable() {\n            DatagramSocket socket;\n            byte[] receiveData = new byte[1024];\n            Cipher aesCipher;\n\n            {\n                try {\n                    socket = new DatagramSocket(18000);\n                    aesCipher = Cipher.getInstance(\"AES/CBC/PKCS5Padding\");\n                    IvParameterSpec zeroIV = new IvParameterSpec(new byte[aesCipher.getBlockSize()]);\n                    SecretKey key = new SecretKeySpec(new byte[] { 0, 1, 2, 3, 4, 5, 6, 7, 0, 1, 2, 3, 4, 5, 6, 7,}, \"AES\");\n                    aesCipher.init(Cipher.DECRYPT_MODE, key, zeroIV);\n                } catch (Exception e) {\n                    throw new IllegalStateException(\"Could not create server socket or cipher\", e);\n                }\n\n            }\n\n            @Override\n            public void run() {\n                while (true) {\n                    DatagramPacket packet = new DatagramPacket(receiveData, receiveData.length);\n\n                    try {\n                        socket.receive(packet);\n                        final byte[] plaintextBinary = aesCipher.doFinal(packet.getData(), 0, packet.getLength());\n                        String plaintext = new String(plaintextBinary, Charset.forName(\"UTF-8\"));\n                        System.out.println(plaintext);\n                    } catch (Exception e) {\n                        throw new IllegalStateException(\"Could not receive or decrypt packet\");\n                    }\n                }\n            }\n\n        });\n        t.start();\n\n        try {\n            Thread.sleep(1000);\n        } catch (InterruptedException e) {\n            // yeah, whatever\n        }\n\n        DatagramSocket sendingSocket = new DatagramSocket();\n        String plaintext = \"1234\";\n        byte[] plaintextBinary = plaintext.getBytes(Charset.forName(\"UTF-8\"));\n\n        try {\n            Cipher aesCipher = Cipher.getInstance(\"AES/CBC/PKCS5Padding\");\n            SecretKey key = new SecretKeySpec(new byte[] { 0, 1, 2, 3, 4, 5, 6, 7, 0, 1, 2, 3, 4, 5, 6, 7,}, \"AES\");\n            IvParameterSpec zeroIV = new IvParameterSpec(new byte[aesCipher.getBlockSize()]);\n            aesCipher.init(Cipher.ENCRYPT_MODE, key, zeroIV);\n            final byte[] ciphertextBinary = aesCipher.doFinal(plaintextBinary);\n\n        DatagramPacket sendingPacket = new DatagramPacket(ciphertextBinary, ciphertextBinary.length);\n        sendingPacket.setSocketAddress(new InetSocketAddress(\"localhost\", 18000));\n            sendingSocket.send(sendingPacket);\n        } catch (Exception e) {\n            throw new IllegalStateException(\"Could not send or encrypt\", e);\n        }\n    }\n\n}\n", "idx": 2688}
{"project": "cipher", "commit_id": "Snippet43581720_25737.java", "target": 0, "func": "package sample;\n\nimport javafx.application.Application;\nimport javafx.fxml.FXMLLoader;\nimport javafx.scene.Parent;\nimport javafx.scene.Scene;\nimport javafx.stage.Stage;\nimport sun.misc.BASE64Decoder;\nimport sun.misc.BASE64Encoder;\n\nimport javax.crypto.*;\nimport javax.crypto.spec.SecretKeySpec;\nimport java.security.InvalidKeyException;\nimport java.security.Key;\nimport java.security.MessageDigest;\nimport java.security.NoSuchAlgorithmException;\nimport java.util.Arrays;\nimport java.util.Base64;\n\npublic class Main  {\n\n\n    private static final String ALGO =\"AES\";\n    private static String string  = \"TheBestSecretKey\";\n    private static  byte[] key ;\n    private static SecretKeySpec secretKeySpec;\n\n\n\n    public static String  aesEncrypt(String en) throws Exception {\n\n        Key key = new SecretKeySpec(string.getBytes(),ALGO);\n        Cipher c = Cipher.getInstance(\"AES/ECB/PKCS5Padding\");\n        c.init(Cipher.ENCRYPT_MODE,key);\n        byte[] encValue =c.doFinal(en.getBytes(\"UTF-8\"));\n        String encryptedValue= new BASE64Encoder().encode(encValue);\nreturn encryptedValue;\n\n    }\n\n    public static String aesDecrypt(String De) throws Exception{\n\n        Key key = new SecretKeySpec(string.getBytes(),\"AES\");\n\n        Cipher c = Cipher.getInstance(\"AES/ECB/PKCS5Padding\");\n        c.init(Cipher.DECRYPT_MODE,key);\n       // return  new String(c.doFinal(Base64.getDecoder().decode(De)));\n\n        byte[]decodedVlue=new BASE64Decoder().decodeBuffer(De);\n        byte[] decValue = c.doFinal(decodedVlue);\n        String deccryptedValue = new String(decValue);\n        return deccryptedValue;\n\n    }\n\n    public static void main(String[] args) throws Exception {\n\n        String password = \"hello\";\n        String passEnc= Main.aesEncrypt(password);\n        System.out.println(passEnc);\n        String passDec = Main.aesDecrypt(passEnc);\n        System.out.println(passDec);\n\n    }\n}\n", "idx": 2001}
{"project": "cipher", "commit_id": "Snippet30736787_12928.java", "target": 1, "func": "public SecretKeyWrapper(Context context, String alias) throws GeneralSecurityException, IOException {\n    mCipher = Cipher.getInstance(\"RSA/ECB/PKCS1Padding\");\n    final KeyStore keyStore = KeyStore.getInstance(\"AndroidKeyStore\");\n    keyStore.load(null);\n\n    if (!keyStore.containsAlias(alias)) {\n        generateKeyPair(context, alias);\n    }\n\n    final KeyStore.PrivateKeyEntry entry = (KeyStore.PrivateKeyEntry) keyStore.getEntry(alias, null);\n    mPair = new KeyPair(entry.getCertificate().getPublicKey(), entry.getPrivateKey());\n}\n\nprivate static void generateKeyPair(Context context, String alias) throws GeneralSecurityException {\n    final Calendar start = new GregorianCalendar();\n    final Calendar end = new GregorianCalendar();\n    end.add(Calendar.YEAR, 100);\n\n    final KeyPairGeneratorSpec spec = new KeyPairGeneratorSpec.Builder(context)\n            .setAlias(alias)\n            .setSubject(new X500Principal(\"CN=\" + alias))\n            .setSerialNumber(BigInteger.ONE)\n            .setStartDate(start.getTime())\n            .setEndDate(end.getTime())\n            .build();\n\n    final KeyPairGenerator gen = KeyPairGenerator.getInstance(\"RSA\", \"AndroidKeyStore\");\n    gen.initialize(spec);\n    gen.generateKeyPair();\n}\n", "idx": 2501}
{"project": "cipher", "commit_id": "Snippet11898139_35879.java", "target": 0, "func": "package com.kushal.utils;\n\nimport java.security.spec.KeySpec;\n\nimport javax.crypto.Cipher;\nimport javax.crypto.SecretKey;\nimport javax.crypto.SecretKeyFactory;\nimport javax.crypto.spec.DESKeySpec;\nimport sun.misc.BASE64Decoder;\nimport sun.misc.BASE64Encoder;\n\npublic class DESEncryption {\n\nprivate static final String UNICODE_FORMAT = \"UTF8\";\npublic static final String DES_ENCRYPTION_SCHEME = \"DES\";\nprivate KeySpec myKeySpec;\nprivate SecretKeyFactory mySecretKeyFactory;\nprivate Cipher cipher;\nbyte[] keyAsBytes;\nprivate String myEncryptionKey;\nprivate String myEncryptionScheme;\nSecretKey key;\n\npublic DESEncryption() throws Exception\n{\n    myEncryptionKey = \"ThisIsSecretEncryptionKey\";\n    myEncryptionScheme = DES_ENCRYPTION_SCHEME;\n    keyAsBytes = myEncryptionKey.getBytes(UNICODE_FORMAT);\n    myKeySpec = new DESKeySpec(keyAsBytes);\n    mySecretKeyFactory = SecretKeyFactory.getInstance(myEncryptionScheme);\n    cipher = Cipher.getInstance(myEncryptionScheme);\n    key = mySecretKeyFactory.generateSecret(myKeySpec);\n}\n\n/**\n * Method To Encrypt The String\n */\npublic String encrypt(String unencryptedString) {\n    String encryptedString = null;\n    try {\n        cipher.init(Cipher.ENCRYPT_MODE, key);\n        byte[] plainText = unencryptedString.getBytes(UNICODE_FORMAT);\n        byte[] encryptedText = cipher.doFinal(plainText);\n        BASE64Encoder base64encoder = new BASE64Encoder();\n        encryptedString = base64encoder.encode(encryptedText);\n    } catch (Exception e) {\n        e.printStackTrace();\n    }\n    return encryptedString;\n}\n/**\n * Method To Decrypt An Ecrypted String\n */\npublic String decrypt(String encryptedString) {\n    String decryptedText=null;\n    try {\n        cipher.init(Cipher.DECRYPT_MODE, key);\n        BASE64Decoder base64decoder = new BASE64Decoder();\n        byte[] encryptedText = base64decoder.decodeBuffer(encryptedString);\n        byte[] plainText = cipher.doFinal(encryptedText);\n        decryptedText= bytes2String(plainText);\n    } catch (Exception e) {\n        e.printStackTrace();\n    }\n    return decryptedText;\n}\n/**\n * Returns String From An Array Of Bytes\n */\nprivate static String bytes2String(byte[] bytes) {\n    StringBuffer stringBuffer = new StringBuffer();\n    for (int i = 0; i &lt; bytes.length; i++) {\n        stringBuffer.append((char) bytes[i]);\n    }\n    return stringBuffer.toString();\n}\n\n/**\n * Testing the DES Encryption And Decryption Technique\n */\npublic static void main(String args []) throws Exception\n{\n    DESEncryption myEncryptor= new DESEncryption();\n\n    String stringToEncrypt=\"Sanjaal.com\";\n    String encrypted=myEncryptor.encrypt(stringToEncrypt);\n    String decrypted=myEncryptor.decrypt(encrypted);\n\n    System.out.println(\"String To Encrypt: \"+stringToEncrypt);\n    System.out.println(\"Encrypted Value :\" + encrypted);\n    System.out.println(\"Decrypted Value :\"+decrypted);\n\n}   \n\n}\n", "idx": 2080}
{"project": "cipher", "commit_id": "Snippet13896778_37340.java", "target": 1, "func": "protected String Decrypt(String text, String key) throws Exception\n{\n    Cipher cipher = Cipher.getInstance(\"AES/CBC/PKCS7Padding\");\n    byte[] keyBytes= new byte[16];\n    byte[] b= key.getBytes(\"UTF-8\");\n    int len= b.length;\n    if (len > keyBytes.length) len = keyBytes.length;\n    System.arraycopy(b, 0, keyBytes, 0, len);\n    SecretKeySpec keySpec = new SecretKeySpec(keyBytes, \"AES\");\n    IvParameterSpec ivSpec = new IvParameterSpec(keyBytes);\n    cipher.init(Cipher.DECRYPT_MODE,keySpec,ivSpec);\n\n    byte [] results = cipher.doFinal(Base64Coder.decode(text));\n    return new String(results,\"UTF-8\");\n}\n", "idx": 2689}
{"project": "cipher", "commit_id": "Snippet42806026_24877.java", "target": 1, "func": "    Cipher cipher = Cipher.getInstance(\"ECIESwithAES-CBC\", getInstanceProvider());\n    cipher.init(Cipher.ENCRYPT_MODE,ecPublicKey1,new SecureRandom());\n    byte[] var22 = cipher.doFinal(data);\n    String s = Hex.toHexString(var22);\n    System.out.println(s);\n", "idx": 2548}
{"project": "cipher", "commit_id": "Snippet15950690_38884.java", "target": 0, "func": "String encryptedString = \u2026 ;  \nString decryptedString = null;\nSecretKeySpec key = new SecretKeySpec(myKey.getBytes(), \"Blowfish\");\nprivate static byte[] linebreak = {}; // Remove Base64 encoder default linebreak\nprivate static Base64 coder;\nCipher cipher;\ntry {\n    coder = new Base64(32, linebreak, true);\n    cipher = Cipher.getInstance(\"Blowfish\");\n    cipher.init(Cipher.DECRYPT_MODE, key);\n    byte[] decrypted = cipher.doFinal(encryptedString.getBytes());\n    decryptedString = new String(coder.encode(decrypted));\n} [ catch Exceptions \u2026 ]\n", "idx": 2021}
{"project": "cipher", "commit_id": "Snippet43703523_25833.java", "target": 0, "func": "public static String generateSalt() {\n    SecureRandom random = new SecureRandom();\n    String salt = new BigInteger(130, random).toString(32);\n    return salt;\n}\npublic static String hashKey(String key, String salt) throws UnsupportedEncodingException, NoSuchAlgorithmException {\n    String combinedKey = key + salt;\n    MessageDigest digest = MessageDigest.getInstance(\"SHA-256\");\n    digest.update(combinedKey.getBytes(\"UTF-8\"));\n    byte[] hash = digest.digest();\n    String hashedKey = String.format(\"%032X\", new BigInteger(+1, hash));\n    return hashedKey;\n}\nprivate static SecretKeySpec getSecretKey(String myKey) {\n    SecretKeySpec secretKey = null;\n    byte[] key;\n    MessageDigest sha = null;\n    try {\n        key = myKey.getBytes(\"UTF-8\");\n        sha = MessageDigest.getInstance(\"SHA-1\");\n        key = sha.digest(key);\n        System.out.println(Base64.encode(key));\n        key = Arrays.copyOf(key, 16);\n        String a = Base64.encode(key);\n        System.out.println(\"key:\"+a);\n        secretKey = new SecretKeySpec(key, \"AES\");\n\n    } catch (NoSuchAlgorithmException e) {\n        e.printStackTrace();\n    } catch (UnsupportedEncodingException e) {\n        e.printStackTrace();\n    }\n\n    return secretKey;\n}\npublic static String encrypt(String stringToEncrypt, String secret) {\n    String encodedEncryptedData = null;\n\n    try {\n        SecretKeySpec secretKey = getSecretKey(secret);\n        Cipher cipher = Cipher.getInstance(\"AES/ECB/PKCS5Padding\");\n        cipher.init(Cipher.ENCRYPT_MODE, secretKey);\n        byte[] encryptedData = cipher.doFinal(stringToEncrypt.getBytes(\"UTF-8\"));\n        //System.out.println(encryptedData);\n        encodedEncryptedData = Base64.encode(encryptedData);\n    } catch (Exception e) {\n        System.out.println(\"Error while encrypting: \" + e.toString());\n    }\n    return encodedEncryptedData;\n}\n\npublic static void main(String[] args) throws NoSuchAlgorithmException, UnsupportedEncodingException {\n    String salt = generateSalt();\n    String hash = hashKey(\"FEAD286FF2678F57C7865B6D6935C0C3\",salt);\n    //System.out.println(hash);\n    String message = \"60;50;28042017080701\";\n    String encryptedData = encrypt(message,hash);\n    System.out.println(encryptedData);\n}\n", "idx": 2081}
{"project": "cipher", "commit_id": "Snippet26417778_8565.java", "target": 0, "func": "import java.util.Arrays;\n\nimport javax.crypto.Cipher;\nimport javax.crypto.SecretKey;\nimport javax.crypto.SecretKeyFactory;\nimport javax.crypto.spec.DESedeKeySpec;\n\nimport org.apache.commons.codec.binary.Base64;\n\n\npublic class Encoder {\n\n\n    public String encrypt(String message, String encryptionKey) throws Exception {  \n\n        // handle the key \n        SecretKey secretKey = null;\n        byte[] keyValueAsBytes  =  Arrays.copyOf(encryptionKey.getBytes(\"UTF-8\"), 24);\n\n        DESedeKeySpec keySpec = new DESedeKeySpec(keyValueAsBytes);\n        SecretKeyFactory keyFactory = SecretKeyFactory.getInstance(\"DESede\"); \n        secretKey = keyFactory.generateSecret(keySpec);\n\n        // cipher \n        Cipher cipher = Cipher.getInstance(\"DESede/ECB/PKCS5Padding\");\n        cipher.init(Cipher.ENCRYPT_MODE, secretKey);\n\n        // encode\n        byte[] plainText = message.getBytes(\"UTF-8\");\n        byte[] encryptedText = cipher.doFinal(plainText);       \n        return Base64.encodeBase64String(encryptedText);\n    }\n\n\n    public static void main(String[] args) throws Exception{\n        String secretKey = \"bC5PEcLzvb+jY1FZWuP4pw50\";\n        String message = \"subscriptionId=0214288302000000207\";\n\n        Encoder enc = new Encoder();\n        System.out.println(enc.encrypt(message, secretKey));\n        //returns:hw6JzwdvmjwORzmitXcQ6vsmskK6vtdIObu+KYiGW4D4DRwNGHEX2w==\n    }\n}\n", "idx": 2136}
{"project": "cipher", "commit_id": "Snippet40137201_22059.java", "target": 1, "func": "Cipher.getInstance(\"RSA/ECB/NOPADDING\")", "idx": 2507}
{"project": "cipher", "commit_id": "Snippet32456028_14524.java", "target": 0, "func": "/**\n * Warning, this gives a false sense of security.  If an attacker has enough access to\n * acquire your password store, then he almost certainly has enough access to acquire your\n * source binary and figure out your encryption key.  However, it will prevent casual\n * investigators from acquiring passwords, and thereby may prevent undesired negative\n * publicity.\n */\npublic class ObscuredSharedPreferences implements SharedPreferences {\n    protected static final String UTF8 = \"utf-8\";\n    private static final char[] SEKRIT = ... ; // INSERT A RANDOM PASSWORD HERE.\n                                               // Don't use anything you wouldn't want to\n                                               // get out there if someone decompiled\n                                               // your app.\n\n\n    protected SharedPreferences delegate;\n    protected Context context;\n\n    public ObscuredSharedPreferences(Context context, SharedPreferences delegate) {\n        this.delegate = delegate;\n        this.context = context;\n    }\n\n    public class Editor implements SharedPreferences.Editor {\n        protected SharedPreferences.Editor delegate;\n\n        public Editor() {\n            this.delegate = ObscuredSharedPreferences.this.delegate.edit();                    \n        }\n\n        @Override\n        public Editor putBoolean(String key, boolean value) {\n            delegate.putString(key, encrypt(Boolean.toString(value)));\n            return this;\n        }\n\n        @Override\n        public Editor putFloat(String key, float value) {\n            delegate.putString(key, encrypt(Float.toString(value)));\n            return this;\n        }\n\n        @Override\n        public Editor putInt(String key, int value) {\n            delegate.putString(key, encrypt(Integer.toString(value)));\n            return this;\n        }\n\n        @Override\n        public Editor putLong(String key, long value) {\n            delegate.putString(key, encrypt(Long.toString(value)));\n            return this;\n        }\n\n        @Override\n        public Editor putString(String key, String value) {\n            delegate.putString(key, encrypt(value));\n            return this;\n        }\n\n        @Override\n        public void apply() {\n            delegate.apply();\n        }\n\n        @Override\n        public Editor clear() {\n            delegate.clear();\n            return this;\n        }\n\n        @Override\n        public boolean commit() {\n            return delegate.commit();\n        }\n\n        @Override\n        public Editor remove(String s) {\n            delegate.remove(s);\n            return this;\n        }\n    }\n\n    public Editor edit() {\n        return new Editor();\n    }\n\n\n    @Override\n    public Map<String, ?> getAll() {\n        throw new UnsupportedOperationException(); // left as an exercise to the reader\n    }\n\n    @Override\n    public boolean getBoolean(String key, boolean defValue) {\n        final String v = delegate.getString(key, null);\n        return v!=null ? Boolean.parseBoolean(decrypt(v)) : defValue;\n    }\n\n    @Override\n    public float getFloat(String key, float defValue) {\n        final String v = delegate.getString(key, null);\n        return v!=null ? Float.parseFloat(decrypt(v)) : defValue;\n    }\n\n    @Override\n    public int getInt(String key, int defValue) {\n        final String v = delegate.getString(key, null);\n        return v!=null ? Integer.parseInt(decrypt(v)) : defValue;\n    }\n\n    @Override\n    public long getLong(String key, long defValue) {\n        final String v = delegate.getString(key, null);\n        return v!=null ? Long.parseLong(decrypt(v)) : defValue;\n    }\n\n    @Override\n    public String getString(String key, String defValue) {\n        final String v = delegate.getString(key, null);\n        return v != null ? decrypt(v) : defValue;\n    }\n\n    @Override\n    public boolean contains(String s) {\n        return delegate.contains(s);\n    }\n\n    @Override\n    public void registerOnSharedPreferenceChangeListener(OnSharedPreferenceChangeListener onSharedPreferenceChangeListener) {\n        delegate.registerOnSharedPreferenceChangeListener(onSharedPreferenceChangeListener);\n    }\n\n    @Override\n    public void unregisterOnSharedPreferenceChangeListener(OnSharedPreferenceChangeListener onSharedPreferenceChangeListener) {\n        delegate.unregisterOnSharedPreferenceChangeListener(onSharedPreferenceChangeListener);\n    }\n\n\n\n\n    protected String encrypt( String value ) {\n\n        try {\n            final byte[] bytes = value!=null ? value.getBytes(UTF8) : new byte[0];\n            SecretKeyFactory keyFactory = SecretKeyFactory.getInstance(\"PBEWithMD5AndDES\");\n            SecretKey key = keyFactory.generateSecret(new PBEKeySpec(SEKRIT));\n            Cipher pbeCipher = Cipher.getInstance(\"PBEWithMD5AndDES\");\n            pbeCipher.init(Cipher.ENCRYPT_MODE, key, new PBEParameterSpec(Settings.Secure.getString(context.getContentResolver(),Settings.System.ANDROID_ID).getBytes(UTF8), 20));\n            return new String(Base64.encode(pbeCipher.doFinal(bytes), Base64.NO_WRAP),UTF8);\n\n        } catch( Exception e ) {\n            throw new RuntimeException(e);\n        }\n\n    }\n\n    protected String decrypt(String value){\n        try {\n            final byte[] bytes = value!=null ? Base64.decode(value,Base64.DEFAULT) : new byte[0];\n            SecretKeyFactory keyFactory = SecretKeyFactory.getInstance(\"PBEWithMD5AndDES\");\n            SecretKey key = keyFactory.generateSecret(new PBEKeySpec(SEKRIT));\n            Cipher pbeCipher = Cipher.getInstance(\"PBEWithMD5AndDES\");\n            pbeCipher.init(Cipher.DECRYPT_MODE, key, new PBEParameterSpec(Settings.Secure.getString(context.getContentResolver(),Settings.System.ANDROID_ID).getBytes(UTF8), 20));\n            return new String(pbeCipher.doFinal(bytes),UTF8);\n\n        } catch( Exception e) {\n            throw new RuntimeException(e);\n        }\n    }\n\n}\n", "idx": 1944}
{"project": "cipher", "commit_id": "Snippet34384612_16353.java", "target": 0, "func": "DESKeySpec dks;\nboolean status=false;\ntry {\n    dks = new DESKeySpec(key.getBytes());\n    SecretKeyFactory skf = SecretKeyFactory.getInstance(\"DES\");\n    SecretKey desKey = skf.generateSecret(dks);\n    Cipher cipher = Cipher.getInstance(\"DES/ECB/PKCS5Padding\");\n        cipher.init(Cipher.DECRYPT_MODE, desKey);\n        CipherOutputStream cos = new CipherOutputStream(os, cipher);\n        status=doCopy(is, cos);\n", "idx": 2153}
{"project": "cipher", "commit_id": "Snippet20837986_3456.java", "target": 0, "func": "  import java.io.BufferedReader;\n import java.io.File;\n     import java.io.FileInputStream;\n     import java.io.FileOutputStream;\n     import java.io.FilterWriter;\n     import java.io.InputStream;\n     import java.io.InputStreamReader;\n\n     import javax.crypto.Cipher;\n     import javax.crypto.CipherInputStream;\n     import javax.crypto.KeyGenerator;\n     import javax.crypto.SecretKey;\n\n import android.os.Bundle;\n import android.app.Activity;\n import android.view.Menu;\n import android.view.View;\n import android.view.View.OnClickListener;\n import android.widget.Button;\n import android.widget.EditText;\n import org.apache.commons.codec.binary.Base64;\n\n  public class EncryptionTest1 extends Activity {\nEditText output, outputDecrypt;\nEditText input;\nString plainData = \"\";\nString cipherText, decryptedText;\nKeyGenerator keyGen;\nSecretKey secretKey;\n\nCipher aesCipher;\nFileOutputStream fos;\n\nbyte[] byteDataToEncrypt, byteCipherText, byteDecryptedText;\nbyte[] xmlStream;\n\n@Override\n   protected void onCreate(Bundle savedInstanceState) {\n    super.onCreate(savedInstanceState);\n    setContentView(R.layout.activity_encryption_test1);\n    input = (EditText) findViewById(R.id.text_inputText1);\n    output = (EditText) findViewById(R.id.text_Result1);\n    outputDecrypt = (EditText) findViewById(R.id.text_decrypt_Result1);\n\n    Button btn_encrypt = (Button) findViewById(R.id.btn_encrpyt1);\n\n    btn_encrypt.setOnClickListener(new OnClickListener() {\n\n        @Override\n        public void onClick(View v) {\n\n            try {\n                plainData = input.getText().toString();\n                System.out.println(\"input==>>\" + plainData);\n                byte[] fileStreams = fileOpening(\"SaleReport.xml\");\n                byte[] DataEncrypt = encrypt(fileStreams);\n                String DataDecrypt = decrypt(DataEncrypt);\n\n            System.out.println(\"Decrypted Text:===>>\" + DataDecrypt);\n                outputDecrypt.setText(DataDecrypt);\n            } catch (Exception e) {\n                e.printStackTrace();\n            }\n        }\n\n    });\n  }\n\nprivate byte[] fileOpening(String fileName) throws Exception {\n    InputStream is = getAssets().open(fileName);\n    int size = is.available();\n    xmlStream = new byte[size];\n    is.read(xmlStream);\n    System.out.println(\"xmlstream length==>>\" + xmlStream.length);\n    return xmlStream;\n}\n\nprivate byte[] encrypt(byte[] xmlStream) throws Exception {\n\n    keyGen = KeyGenerator.getInstance(\"AES\");\n    keyGen.init(128);\n    secretKey = keyGen.generateKey();\n    aesCipher = Cipher.getInstance(\"AES\");\n    aesCipher.init(Cipher.ENCRYPT_MODE, secretKey);\n    // byteDataToEncrypt = plainData.getBytes();\n\n    byteCipherText = aesCipher.doFinal(xmlStream);\n    cipherText = new String(new Base64().encodeBase64(byteCipherText));\n    output.setText(cipherText);\n    System.out.println(cipherText);\n\n    return byteCipherText;\n\n}\n\npublic String decrypt(byte[] DataEncrypt) throws Exception {\n    aesCipher.init(Cipher.DECRYPT_MODE, secretKey,\n    aesCipher.getParameters());\n    byteDecryptedText = aesCipher.doFinal(DataEncrypt);\n    decryptedText = new String(byteDecryptedText);\n    return decryptedText;\n  }\n\n@Override\npublic boolean onCreateOptionsMenu(Menu menu) {\n    // Inflate the menu; this adds items to the action bar if it is present.\n    getMenuInflater().inflate(R.menu.encryption_test1, menu);\n    return true;\n}\n\n   }\n", "idx": 2114}
{"project": "cipher", "commit_id": "Snippet42153463_24105.java", "target": 0, "func": "import java.security.SecureRandom;\nimport javax.crypto.Cipher;\nimport javax.crypto.KeyGenerator;\nimport javax.crypto.SecretKey;\nimport javax.crypto.spec.SecretKeySpec;\n\npublic class AESHelper {\n\npublic static String encrypt(String seed, String cleartext) throws Exception {\n    byte[] rawKey = getRawKey(seed.getBytes());\n    byte[] result = encrypt(rawKey, cleartext.getBytes());\n    return toHex(result);\n}\n\npublic static String decrypt(String seed, String encrypted) throws Exception {\n    byte[] rawKey = getRawKey(seed.getBytes());\n    byte[] enc = toByte(encrypted);\n    byte[] result = decrypt(rawKey, enc);\n    return new String(result);\n}\n\nprivate static byte[] getRawKey(byte[] seed) throws Exception {\n    KeyGenerator kgen = KeyGenerator.getInstance(\"AES\");\n    SecureRandom sr = SecureRandom.getInstance(\"SHA1PRNG\",\"Crypto\");\n    sr.setSeed(seed);\n    kgen.init(128, sr); // 192 and 256 bits may not be available\n    SecretKey skey = kgen.generateKey();\n    byte[] raw = skey.getEncoded();\n    return raw;\n}\n\n\nprivate static byte[] encrypt(byte[] raw, byte[] clear) throws Exception {\n    SecretKeySpec skeySpec = new SecretKeySpec(raw, \"AES\");\n    Cipher cipher = Cipher.getInstance(\"AES\");\n    cipher.init(Cipher.ENCRYPT_MODE, skeySpec);\n    byte[] encrypted = cipher.doFinal(clear);\n    return encrypted;\n}\n\nprivate static byte[] decrypt(byte[] raw, byte[] encrypted) throws Exception {\n    SecretKeySpec skeySpec = new SecretKeySpec(raw, \"AES\");\n    Cipher cipher = Cipher.getInstance(\"AES\");\n    cipher.init(Cipher.DECRYPT_MODE, skeySpec);\n    byte[] decrypted = cipher.doFinal(encrypted);\n    return decrypted;\n}\n\npublic static String toHex(String txt) {\n    return toHex(txt.getBytes());\n}\npublic static String fromHex(String hex) {\n    return new String(toByte(hex));\n}\n\npublic static byte[] toByte(String hexString) {\n    int len = hexString.length()/2;\n    byte[] result = new byte[len];\n    for (int i = 0; i < len; i++)\n        result[i] = Integer.valueOf(hexString.substring(2*i, 2*i+2), 16).byteValue();\n    return result;\n}\n\npublic static String toHex(byte[] buf) {\n    if (buf == null)\n        return \"\";\n    StringBuffer result = new StringBuffer(2*buf.length);\n    for (int i = 0; i < buf.length; i++) {\n        appendHex(result, buf[i]);\n    }\n    return result.toString();\n}\nprivate final static String HEX = \"0123456789ABCDEF\";\nprivate static void appendHex(StringBuffer sb, byte b) {\n    sb.append(HEX.charAt((b>>4)&0x0f)).append(HEX.charAt(b&0x0f));\n}\n}\n", "idx": 2194}
{"project": "cipher", "commit_id": "Snippet22799815_5178.java", "target": 1, "func": "import java.io.*;\nimport java.net.*;\nimport javax.crypto.*;\nimport javax.crypto.spec.SecretKeySpec;\nimport org.apache.commons.codec.binary.Base64;\n\nclass TCPServer\n{\n   public static void main(String argv[]) throws Exception\n      {\n         String clientSentence;\n         String capitalizedSentence;\n         ServerSocket welcomeSocket = new ServerSocket(6808);\n\n         while(true)\n         {\n            Socket connectionSocket = welcomeSocket.accept();\n            BufferedReader inFromClient =\n               new BufferedReader(new InputStreamReader(connectionSocket.getInputStream()));\n            DataOutputStream outToClient = new DataOutputStream(connectionSocket.getOutputStream());\n            clientSentence = inFromClient.readLine();\n            System.out.println(\"Received: \" + clientSentence);\n\n            byte[] raw = new byte[]{'T', 'h', 'i', 's', 'I', 's', 'A', 'S', 'e', 'c', 'r', 'e', 't', 'K', 'e', 'y'};\n            //SecretKeySpec skeySpec = new SecretKeySpec(raw, \"AES\");\n            SecretKeySpec skeySpec = new SecretKeySpec(Base64.decodeBase64(raw), \"AES\");\n            Cipher cipher = Cipher.getInstance(\"AES/CBC/PKCS5Padding\");\n            cipher.init(Cipher.DECRYPT_MODE, new SecretKeySpec(skeySpec.getEncoded(),\"AES\"));\n            byte[] original = cipher.doFinal(Base64.decodeBase64(clientSentence));\n            original.toString();\n\n            System.out.println(\"Sent: \" + original);\n\n            capitalizedSentence = (new String(original)).toUpperCase() + '\\n';\n            System.out.println(\"Sent: \" + capitalizedSentence);\n            outToClient.writeBytes(capitalizedSentence);\n         }\n      }\n}\n", "idx": 2541}
{"project": "cipher", "commit_id": "Snippet20262878_2904.java", "target": 1, "func": "private void createAndSendAES() throws NoSuchAlgorithmException, NoSuchPaddingException, IllegalBlockSizeException, IOException, InvalidKeyException, BadPaddingException {\n    KeyGenerator keyGen = KeyGenerator.getInstance(\"AES\");\n    keyGen.init(128);\n    this.AESBlackboardKey = keyGen.generateKey(); // My AES key\n\n     byte[] raw = AESBlackboardKey.getEncoded();\n     System.out.println(raw.length); // Prints 16\n\n    Cipher cipher = Cipher.getInstance(\"RSA\");\n    cipher.init(Cipher.ENCRYPT_MODE, this.clientPubKey);\n\n\n    SealedObject encryptedAESBlackboardKey = new SealedObject(this.AESBlackboardKey, cipher); // ERROR HERE\n\n    ObjectOutputStream outO = new ObjectOutputStream(this.clientSocket.getOutputStream());\n    outO.writeObject(encryptedAESBlackboardKey); //Transmitting the key over socket link\n    outO.flush();\n\n    System.out.println(\"AS: Blackboard AES key sent.\");\n\n}\n", "idx": 2502}
{"project": "cipher", "commit_id": "Snippet29881041_11945.java", "target": 0, "func": "private final String CIPHER_NAME = \"AES/ECB/PKCS5Padding\";\nprivate final String ALGORITHM_NAME = \"AES\"; // keySizes 128, 192, 256\n// private final String CIPHER_NAME = \"DES/ECB/PKCS5Padding\";\n// private final String ALGORITHM_NAME = \"DES\"; // keySize 56\n// private final String CIPHER_NAME = \"DESede/ECB/PKCS5Padding\";\n// private final String ALGORITHM_NAME = \"DESede\"; // keySize 168\n\nbyte[] encrypt(SecretKey key, long num) {\n    BigInteger bignum = BigInteger.valueOf(num);\n    Cipher cipher = Cipher.getInstance(CIPHER_NAME);\n    cipher.init(Cipher.ENCRYPT_MODE, key);\n    return cipher.doFinal(bignum.toByteArray());\n}\n\nlong decrypt(SecretKey key, byte[] ct) {\n    Cipher cipher = Cipher.getInstance(CIPHER_NAME);\n    cipher.init(Cipher.DECRYPT_MODE, key);\n    byte[] pt = cipher.doFinal(ct);\n    BigInteger bignum = new BigInteger(pt);\n    return bignum.longValue();\n}\n\nSecretKey keyGen(String algorithm, int keySize) {\n    KeyGenerator keygen = KeyGenerator.getInstance(algorithm);\n    keygen.init(keySize);\n    return keygen.generateKey();\n}\n", "idx": 2192}
{"project": "cipher", "commit_id": "Snippet38823929_20726.java", "target": 1, "func": " Cipher cipher = Cipher.getInstance(\"AES/CFB128/NoPadding\");\n SecretKeySpec keySpec = new SecretKeySpec(\"1234567890123456\".getBytes(), \"AES\");\n byte[] iv = \"1234567890123456\".getBytes();\n cipher.init(Cipher.ENCRYPT_MODE, keySpec, new IvParameterSpec(iv));\n Cipher decryptCipher = Cipher.getInstance(\"AES/CFB128/NoPadding\");\n decryptCipher.init(Cipher.DECRYPT_MODE, keySpec, new IvParameterSpec(iv));\n byte[] data = cipher.doFinal(\"1234567890123456\".getBytes());\n\n for (byte b : data) {\n    byte[] output = decryptCipher.update(new byte[]{b});\n    System.out.println(new String(output));\n }\n", "idx": 2725}
{"project": "cipher", "commit_id": "Snippet19277401_2107.java", "target": 1, "func": "IvParameterSpec salt = new IvParameterSpec(iv);\nCipher cipher = Cipher.getInstance(\"AES/CBC/PKCS5Padding\", \"BC\");\n", "idx": 2481}
{"project": "cipher", "commit_id": "Snippet31930949_13977.java", "target": 0, "func": "private static byte[] decrypt(byte[] raw, byte[] encrypted) throws Exception {\n    SecretKeySpec skeySpec = new SecretKeySpec(raw, \"AES\");\n    Cipher cipher = Cipher.getInstance(\"AES\");\n    cipher.init(Cipher.DECRYPT_MODE, skeySpec);\n    byte[] decrypted = cipher.doFinal(encrypted);//ERROR HERE////////////////////////////////////////////////////////////////////////////\n    return decrypted;\n} \n", "idx": 2057}
