{"project": "cipher", "commit_id": "Snippet30908637_13060.java", "target": 0, "func": "public class DESCodec {\n\n    /**\n     * Secret key that shall be used for encryption and decryption.\n     */\n    private String strSecretKey = \"12345678\";\n\n    private static final String UNICODE_FORMAT = \"UTF-8\";\n\n    private static final String DES_ENCRYPTION_SCHEME = \"DES\";\n\n    private static final String TAG = \"DESCodec\";\n\n    private Cipher cipher;\n\n    private SecretKey key;\n\n\n    public DESCodec() {\n        try {\n            this.strSecretKey = strSecretKey;\n            String myEncryptionScheme = DES_ENCRYPTION_SCHEME;\n            byte[] keyAsBytes = strSecretKey.getBytes(UNICODE_FORMAT);\n            DESKeySpec myKeySpec = new DESKeySpec(keyAsBytes);\n            SecretKeyFactory mySecretKeyFactory = SecretKeyFactory.getInstance(myEncryptionScheme);\n            cipher = Cipher.getInstance(myEncryptionScheme);\n            key = mySecretKeyFactory.generateSecret(myKeySpec);\n        } catch (Exception e) {\n            e.printStackTrace();\n        }\n    }\n\n\n\n    public String desEncrypt(String message) {\n        String encryptedString = null;\n        try {\n            cipher.init(Cipher.ENCRYPT_MODE, key);\n            byte[] plainText = message.getBytes(UNICODE_FORMAT);\n            byte[] encryptedText = cipher.doFinal(plainText);\n\n            encryptedString = Base64.encodeToString(encryptedText, Base64.DEFAULT);\n        } catch (Exception e) {\n            e.printStackTrace();\n        }\n        return encryptedString;\n    }\n\n    public String desDecrypt(String message) {\n        String decryptedText = null;\n        try {\n            cipher.init(Cipher.DECRYPT_MODE, key);\n            byte[] encryptedText = Base64.decode(message, Base64.DEFAULT);\n            byte[] plainText = cipher.doFinal(encryptedText);\n            decryptedText = bytes2String(plainText);\n        } catch (Exception e) {\n            e.printStackTrace();\n        }\n        return decryptedText;\n    }\n\n    private String bytes2String(byte[] bytes) {\n        try {\n            return new String(bytes, UNICODE_FORMAT);\n        } catch (UnsupportedEncodingException e) {\n            e.printStackTrace();\n        }\n        return null;\n    }\n\n}\n", "idx": 1864}
{"project": "cipher", "commit_id": "Snippet26367225_8505.java", "target": 1, "func": "  PKCS8EncodedKeySpec privSpec = new PKCS8EncodedKeySpec(ConvertData.hexStringToByteArray(hexPrivateKey));\n        KeyFactory kf;\n        PrivateKey privateKey;\n        Cipher cipher;\n        kf = KeyFactory.getInstance(\"RSA\");\n        privateKey = kf.generatePrivate(privSpec);\n        cipher = Cipher.getInstance(\"RSA/ECB/PKCS1Padding\");\n        cipher.init(Cipher.DECRYPT_MODE, privateKey);\n\n        byte[] encryptedBytes = ConvertData.hexStringToByteArray(hexEncodedData);\n        int keySize = keyMode;\n        int blockSize = (keySize / 8);\n\n        int blocksCount = encryptedBytes.length / blockSize;\n        int i = 0;\n        int n = blocksCount;\n        int startIndex;\n        int endIndex;\n        byte[] byteChunkData;\n        byte[] decryptedChunk;\n        byte[] decryptedMessage = new byte[0];\n        while (i < n) {\n            startIndex = i * (blockSize);\n            endIndex = startIndex + blockSize;\n            byteChunkData = Arrays.copyOfRange(encryptedBytes, startIndex, endIndex);\n            decryptedChunk = cipher.doFinal(byteChunkData);\n            decryptedMessage = concatenateByteArrays(decryptedMessage, decryptedChunk);\n            i++;\n        }\n        String plainText = new String(decryptedMessage, ENCODING);\n        return plainText;\n", "idx": 2109}
{"project": "cipher", "commit_id": "Snippet47592499_29612.java", "target": 1, "func": "private byte[] getTag(SecretKey key, byte[] nonce, byte[] message,   byte[] associatedData) throws ... {\n   Cipher aeadCipher = Cipher.getInstance(AES_GCM_NOPADDING);\n   aeadCipher.init(Cipher.ENCRYPT_MODE, kint, new GCMParameterSpec(GCM_MAC_SIZE, nonce);\n   aeadCipher.updateAAD(associatedData);\n   byte[] encrypted = aeadCipher.doFinal(message);\n   // Assuming you have an AAD_SIZE = 128 bits (16 bytes)\n   return Arrays.copyOfRange (encrypted, encrypted.length-16, encrypted.length)\n", "idx": 2299}
{"project": "cipher", "commit_id": "Snippet43486764_25614.java", "target": 1, "func": "public class Server2 {\n    private static final int NumberOfThreads = 5;\n    private static ExecutorService executorService =Executors.newScheduledThreadPool(NumberOfThreads);\n    private static final int port = 1111;\n    private static ServerSocket serverSocket;\n    private static final String privateKeyFile = \"privateServer.der\";\n    private static final String signedCert = \"h.crt\";\n\npublic static void main(String[] args) {\n    try{\n        serverSocket = new ServerSocket(port);\n    }catch (IOException e){\n        e.printStackTrace();\n    }\n\n    while(true){\n        System.out.println(\"Server is waiting for connection....\");\n        try {\n            final Socket clientSocket = serverSocket.accept();\n            System.out.println(\"connection established....\");\n            Runnable task = new Runnable() {\n                @Override\n                public void run() {\n                    try {\n                        handleClient(clientSocket);\n                    }catch (Exception e){\n                        e.printStackTrace();\n                    }\n                }\n            };\n            executorService.execute(task);\n        } catch (IOException e) {\n            e.printStackTrace();\n        }\n    }\n}\n\nprivate static void handleClient(Socket clientSocket) throws Exception{\n    //for getting the byte input and output\n    OutputStream byteOut = clientSocket.getOutputStream();\n    InputStream byteIn = clientSocket.getInputStream();\n    //for getting the string input and output\n    PrintWriter stringOut = new PrintWriter(clientSocket.getOutputStream(),true);\n    BufferedReader stringIn = new BufferedReader(new InputStreamReader(clientSocket.getInputStream()));\n    //print out client msg\n    System.out.println(stringIn.readLine());\n    stringOut.println(\"From Server: I am Server!\");\n    stringOut.flush();\n    System.out.println(\"Sent to client: I am Server!\");\n\n    //receive nonce from client\n    String nonceLen = stringIn.readLine();\n    byte[] nonce = new byte[Integer.parseInt(nonceLen)];\n    readByte(nonce,byteIn);\n    System.out.println(\"Nonce Received!\");\n\n    //get private key from privateServer.der\n    PrivateKey privateKey = getPrivateKey();\n\n    //use private key to initialize the encryption mode\n    Cipher RSAEncrypt = Cipher.getInstance(\"RSA/ECB/PKCS1Padding\");\n    RSAEncrypt.init(Cipher.ENCRYPT_MODE,privateKey);\n\n    //encrypt nonce and send it to the client\n    byte[] encryptedNonce = RSAEncrypt.doFinal(nonce);\n    stringOut.println(Integer.toString(encryptedNonce.length));\n    byteOut.write(encryptedNonce,0,encryptedNonce.length);\n    System.out.println(encryptedNonce);\n    byteOut.flush();\n    System.out.println(\"Sent to client: encrypted nonce\");\n    }\n}\n", "idx": 2076}
{"project": "cipher", "commit_id": "Snippet12621128_36374.java", "target": 1, "func": "Cipher c = Cipher.getInstance(key.getAlgorithm());\nc.init(Cipher.ENCRYPT_MODE, key); \n", "idx": 2220}
{"project": "cipher", "commit_id": "Snippet9978943_34367.java", "target": 1, "func": "EncryptionParameter encryptionParameter = new EncryptionParameter ();\nencryptionParameter.setEncrParameter(reciver , message);\n// the reciverand the message are both String\n\n// I created  a class to convert an object to byte[]  called ObjectToByte\nObjectToByte otp = new ObjectToByte();\nbyte[] MByte = otp.convert(encryptionParameter); // convert the object to byte[]\n//  Encrypt the message \nCipher c = Cipher.getInstance(\"RSA\");\nc.init(Cipher.ENCRYPT_MODE,reciverKey); \nbyte[] myEncryptMessage = c.doFinal(MByte);\n", "idx": 2309}
{"project": "cipher", "commit_id": "Snippet16358035_39306.java", "target": 0, "func": "    public class Encryption {\nprivate final static String HEX = \"0123456789ABCDEF\";\nprivate final static int JELLY_BEAN_4_2 = 17;\nprivate final static byte[] key = { 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,\n        0, 0, 0 };\n\npublic static String encrypt(String seed, String cleartext)\n        throws Exception {\n    byte[] rawKey = getRawKey(seed.getBytes());\n    byte[] result = encrypt(rawKey, cleartext.getBytes());\n    String fromHex = toHex(result);\n    return fromHex;\n}\n\npublic static String decrypt(String seed, String encrypted)\n        throws Exception {\n    byte[] seedByte = seed.getBytes();\n    System.arraycopy(seedByte, 0, Constants.SEED, 0,\n            ((seedByte.length < 16) ? seedByte.length : 16));\n    String base64 = new String(Base64.decode(encrypted, 0));\n    byte[] rawKey = getRawKey(seedByte);\n    byte[] enc = toByte(base64);\n    byte[] result = decrypt(rawKey, enc);\n    return new String(result);\n}\n\npublic static byte[] encryptBytes(String seed, byte[] cleartext)\n        throws Exception {\n    byte[] rawKey = getRawKey(seed.getBytes());\n    byte[] result = encrypt(rawKey, cleartext);\n    return result;\n}\n\npublic static byte[] decryptBytes(String seed, byte[] encrypted)\n        throws Exception {\n    byte[] rawKey = getRawKey(seed.getBytes());\n    byte[] result = decrypt(rawKey, encrypted);\n    return result;\n}\n\nprivate static byte[] getRawKey(byte[] seed) throws Exception {\n    KeyGenerator kgen = KeyGenerator.getInstance(\"AES\");\n    SecureRandom sr = null;\n    if (android.os.Build.VERSION.SDK_INT >= JELLY_BEAN_4_2) {\n        sr = SecureRandom.getInstance(\"SHA1PRNG\", \"Crypto\");\n    } else {\n        sr = SecureRandom.getInstance(\"SHA1PRNG\");\n    }\n    sr.setSeed(seed);\n    try {\n        kgen.init(256, sr);\n    } catch (Exception e) {\n        // \"This device doesn't suppor 256bits, trying 192bits.\");\n        try {\n            kgen.init(192, sr);\n        } catch (Exception e1) {\n             Log.w(LOG,\n             \"This device doesn't suppor 192bits, trying 128bits.\");\n            kgen.init(128, sr);\n        }\n    }\n    SecretKey skey = kgen.generateKey();\n    byte[] raw = skey.getEncoded();\n    return raw;\n}\n\nprivate static byte[] encrypt(byte[] raw, byte[] clear) throws Exception {\n    SecretKeySpec skeySpec = new SecretKeySpec(raw, \"AES\");\n    Cipher cipher = Cipher.getInstance(\"AES\");\n    cipher.init(Cipher.ENCRYPT_MODE, skeySpec);\n    byte[] encrypted = cipher.doFinal(clear);\n    return encrypted;\n}\n\nprivate static byte[] decrypt(byte[] raw, byte[] encrypted)\n        throws Exception {\n    SecretKeySpec skeySpec = new SecretKeySpec(raw, \"AES\");\n    Cipher cipher = Cipher.getInstance(\"AES\");\n    cipher.init(Cipher.DECRYPT_MODE, skeySpec);\n    byte[] decrypted = cipher.doFinal(encrypted);\n    return decrypted;\n}\n\npublic static String toHex(String txt) {\n    return toHex(txt.getBytes());\n}\n\npublic static String fromHex(String hex) {\n    return new String(toByte(hex));\n}\n\npublic static byte[] toByte(String hexString) {\n    int len = hexString.length() / 2;\n    byte[] result = new byte[len];\n    for (int i = 0; i < len; i++)\n        result[i] = Integer.valueOf(hexString.substring(2 * i, 2 * i + 2),\n                16).byteValue();\n    return result;\n}\n\npublic static String toHex(byte[] buf) {\n    if (buf == null)\n        return \"\";\n    StringBuffer result = new StringBuffer(2 * buf.length);\n    for (int i = 0; i < buf.length; i++) {\n        appendHex(result, buf[i]);\n    }\n    return result.toString();\n}\n\nprivate static void appendHex(StringBuffer sb, byte b) {\n    sb.append(HEX.charAt((b >> 4) & 0x0f)).append(HEX.charAt(b & 0x0f));\n}\n\n}\n", "idx": 1854}
{"project": "cipher", "commit_id": "Snippet11125371_35332.java", "target": 0, "func": "public String decryptBlowfish(String to_decrypt, String strkey) {\n    System.out.println(to_decrypt);\n    try {\n        SecretKeySpec key = new SecretKeySpec(strkey.getBytes(), \"Blowfish\");\n        Cipher cipher = Cipher.getInstance(\"Blowfish\");\n        cipher.init(Cipher.DECRYPT_MODE, key);\n        byte[] decrypted = cipher.doFinal(to_decrypt.getBytes());\n        return new String(decrypted);\n    } catch (Exception e) {\n        System.out.println(e.getMessage());\n        ;\n        return null;\n    }\n}\n", "idx": 1601}
{"project": "cipher", "commit_id": "Snippet39593428_21527.java", "target": 1, "func": "private byte[] decrypt_chunk(byte[] data, ByteString chunk_encryption_key) {\n        SecretKeySpec skeySpec = new SecretKeySpec(chunk_encryption_key.toByteArray(), 1, 16, \"AES\");\n        Cipher cipher;\n        byte[] decrypted = new byte[0];\n        try {\n            cipher = Cipher.getInstance(\"AES/CFB/NoPadding\");\n\n            cipher.init(Cipher.DECRYPT_MODE, skeySpec, new IvParameterSpec(getIV(0)));\n\n            decrypted = cipher.doFinal(data);\n\n        } catch (NoSuchAlgorithmException | NoSuchPaddingException e) {\n            e.printStackTrace();\n        } catch (InvalidKeyException e) {\n            e.printStackTrace();\n        }  catch (InvalidAlgorithmParameterException e) {\n            e.printStackTrace();\n        } catch (ShortBufferException e) {\n            e.printStackTrace();\n        }\n\n        return decrypted;\n    }\n", "idx": 2150}
{"project": "cipher", "commit_id": "Snippet30396370_12562.java", "target": 1, "func": "public static []byte RSADecryptB(PrivateKey privatekey, byte[] cipherText) {\nbyte[] ll = null;\n  try {\n     /* Create cipher for decryption. */\n     Cipher decrypt_cipher = Cipher.getInstance(\"RSA\");\n     decrypt_cipher.init(Cipher.DECRYPT_MODE, privatekey);\n\n\n     ll = decrypt_cipher.doFinal(cipherText);\n\n  } catch (IllegalBlockSizeException e) {\n     System.out.println(\"1\");\n     e.printStackTrace();\n  }\n  catch (InvalidKeyException et) {\n     System.out.println(\"2\");\n     et.printStackTrace();\n  }\n  catch (NoSuchAlgorithmException ev) {\n     System.out.println(\"3\");\n     ev.printStackTrace();\n  }\n  catch (BadPaddingException ea) {\n     System.out.println(\"4\");\n     ea.printStackTrace();\n  }\n  catch (NoSuchPaddingException eo) {\n     System.out.println(\"5\");\n     eo.printStackTrace();\n  }\n  return ll;\n", "idx": 1945}
{"project": "cipher", "commit_id": "Snippet19649058_2377.java", "target": 0, "func": "/**\n     * Method To Decrypt An Ecrypted String\n     */\n    public String decrypt(String encryptedString, String myEncryptionKey) {\n        String decryptedText = null;\n        try {\n            byte[] keyAsBytes = myEncryptionKey.getBytes(\"UTF8\");\n            KeySpec myKeySpec = new DESedeKeySpec(keyAsBytes);\n            SecretKeyFactory mySecretKeyFactory = \n                    SecretKeyFactory.getInstance(\"DESede\");\n            Cipher cipher = Cipher.getInstance(\"DESede/ECB/NoPadding\");\n            SecretKey key = mySecretKeyFactory.generateSecret(myKeySpec);\n\n            cipher.init(Cipher.DECRYPT_MODE, key);\n//            BASE64Decoder base64decoder = new BASE64Decoder();\n//            byte[] encryptedText = base64decoder.decodeBuffer(encryptedString);\n\n            byte[] encryptedText =  org.apache.commons.codec.binary.Base64.decodeBase64(encryptedString);\n            byte[] plainText = cipher.doFinal(encryptedText);\n            decryptedText= bytes2String(plainText);\n        } catch (Exception e) {\n            e.printStackTrace();\n        }\n        return decryptedText;\n    }\n", "idx": 1725}
{"project": "cipher", "commit_id": "Snippet17690611_810.java", "target": 0, "func": "public static byte[] encrypt(String message) throws Exception {\n        final MessageDigest md = MessageDigest.getInstance(\"SHA-1\");\n        final byte[] digestOfPassword = md.digest(token\n                .getBytes(\"utf-8\"));\n        final byte[] keyBytes = Arrays.copyOf(digestOfPassword, 24);\n        for (int j = 0, k = 16; j < 8; ) {\n            keyBytes[k++] = keyBytes[j++];\n        }\n\n        final SecretKey key = new SecretKeySpec(keyBytes, \"DESede\");\n        final IvParameterSpec iv = new IvParameterSpec(new byte[8]);\n        final Cipher cipher = Cipher.getInstance(\"DESede/CBC/PKCS5Padding\");\n        cipher.init(Cipher.ENCRYPT_MODE, key, iv, new SecureRandom(new byte[5]));\n        cipher.init(Cipher.ENCRYPT_MODE, key, iv);\n\n        final byte[] plainTextBytes = message.getBytes(\"utf-8\");\n        final byte[] cipherText = cipher.doFinal(plainTextBytes);\n        return cipherText;\n    }\n", "idx": 1770}
{"project": "cipher", "commit_id": "Snippet13923672_37363.java", "target": 1, "func": "String vParameter= \"ksyR31QsRcbeJoysNOsAGBHajLKWsT00wavt9LJYGOMRC8zc_vqrNOeOlGHKJHIt3sLmFhDVw_JZKr4JT0H3Jj7_Di9bKNw99qCzMOKCXYM=\";  //The string that nees to be decoded.\nbyte[] encryptedV = Base64.decodeBase64(vParameter);\nString salt = \u201cjkjkyt4\u201d; // the i parameter - user\u2019s id\nString password = \u201c^hjkh673!v@!a89mz+%5rT\u201d; // application specific\nMessageDigest digester = MessageDigest.getInstance(\"SHA-1\");\ndigester.update((salt + password).getBytes(\"UTF-8\"));\nbyte[] key = digester.digest();\nSecretKeySpec secretKey = new SecretKeySpec(key, 2, 16, \u201cAES\u201d);\nString appIV = \"SampleIV\"// application specific\nIvParameterSpec iv= new IvParameterSpec(appIV.getBytes(\u201cUTF-8\u201d));\nCipher cipher = Cipher.getInstance(\"AES/CBC/PKCS5Padding\");\ncipher.init(Cipher.DECRYPT_MODE, secretKey, iv);\nbyte[] decryptedV = cipher.doFinal(encryptedV, 0, encryptedV.length);\nString v = new String(decryptedV, \u201cUTF-8\u201d);\n", "idx": 2117}
{"project": "cipher", "commit_id": "Snippet4851361_31341.java", "target": 0, "func": "// Create Key\nDESKeySpec desKeySpec = new DESKeySpec(key);\nSecretKeyFactory keyFactory = SecretKeyFactory.getInstance(\"DES\");\nSecretKey secretKey = keyFactory.generateSecret(desKeySpec);\n\n// Create Cipher\nCipher desCipher = Cipher.getInstance(\"DES/ECB/PKCS5Padding\");\ndesCipher.init(Cipher.ENCRYPT_MODE, secretKey);\n", "idx": 1909}
{"project": "cipher", "commit_id": "Snippet18364968_1410.java", "target": 1, "func": "KeyFactory kf1 = KeyFactory.getInstance(\"RSA\");\nPublicKey pkPublic1 = kf1.generatePublic(publicKeySpec1);\n\nCipher pkCipher1 = Cipher.getInstance(\"RSA/ECB/PKCS1PADDING\");\npkCipher1.init(Cipher.DECRYPT_MODE, pkPublic1)\n", "idx": 2124}
{"project": "cipher", "commit_id": "Snippet30529229_12714.java", "target": 1, "func": "@Test\npublic void testAes() throws InvalidKeyException, InvalidAlgorithmParameterException, NoSuchAlgorithmException, NoSuchPaddingException, IllegalBlockSizeException, BadPaddingException {\n  byte[] key = \"AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA\".getBytes();\n  byte[] data = \"x\".getBytes();\n  byte[] iv = \"1111111111111111\".getBytes();\n  Cipher cipher = Cipher.getInstance(\"AES/CBC/PKCS5PADDING\");\n  IvParameterSpec ivspec = new IvParameterSpec(iv);\n  cipher.init(Cipher.ENCRYPT_MODE, new SecretKeySpec(key, \"AES\"), ivspec);\n  byte[] result = cipher.doFinal(data);\n  assertEquals(\"0eddfe1857248c7057904455d189cf31\", DatatypeConverter.printHexBinary(result).toLowerCase());\n}\n", "idx": 2000}
{"project": "cipher", "commit_id": "Snippet28506922_10668.java", "target": 0, "func": "String secret = \"1234567812345678\";\nKey key = new SecretKeySpec(secret.getBytes(), \"AES\");\n\n// Encrypt\nCipher cipher = Cipher.getInstance(\"AES\");\ncipher.init(Cipher.ENCRYPT_MODE, key);\nbyte[] encryptedData = cipher.doFinal(\"helloworld\".getBytes());\n\n// Decrypt\ncipher.init(Cipher.DECRYPT_MODE, key);\nbyte[] decryptedData = cipher.doFinal(encryptedData);\nSystem.out.println(new String(decryptedData, \"UTF-8\"));\n", "idx": 1707}
{"project": "cipher", "commit_id": "Snippet23387143_5755.java", "target": 0, "func": "public static String encryptPassword(String pass) {\n\n        public static final String DESKEY = \"REPPIFY_ABCDEFGHIJKLMNOPQRSTUVWXYZ\";\n            System.out.println(\"Here is my password = \"+pass);\n        DESKeySpec keySpec = null;\n        SecretKeyFactory keyFactory = null;\n        SecretKey key = null;\n        Cipher cipher = null;\n        BASE64Encoder base64encoder = new BASE64Encoder();\n\n        byte[] cleartext = null;\n        String encrypedPwd = null;\n            String pass = \"ankit@123\";\n\n        try {\n            keySpec = new DESKeySpec(DESKEY.getBytes(\"UTF8\"));\n            keyFactory = SecretKeyFactory.getInstance(\"DES\");\n            key = keyFactory.generateSecret(keySpec);\n            if(pass!=null) {\n                cleartext = pass.getBytes(\"UTF8\");\n                cipher = Cipher.getInstance(\"DES\");\n                cipher.init(Cipher.ENCRYPT_MODE, key);\n                encrypedPwd = base64encoder.encode(cipher.doFinal(cleartext));\n            }\n        } catch (InvalidKeyException e) {\n            e.printStackTrace();\n        } catch (NoSuchAlgorithmException e) {\n            e.printStackTrace();\n        } catch (InvalidKeySpecException e) {\n            e.printStackTrace();\n        } catch (UnsupportedEncodingException e) {\n            e.printStackTrace();\n        } catch (NoSuchPaddingException e) {\n            e.printStackTrace();\n        } // cipher is not thread safe \n        catch (IllegalBlockSizeException e) {\n            e.printStackTrace();\n        } catch (BadPaddingException e) {\n            e.printStackTrace();\n        }\n        System.out.println(\"Here I am printing encrypted pwd = \"+encrypedPwd);\n        return encrypedPwd;\n    }\n", "idx": 1898}
{"project": "cipher", "commit_id": "Snippet31375291_13480.java", "target": 1, "func": "public static String Encrypt(String text, String key) throws Exception {\n    Cipher cipher = Cipher.getInstance(\"AES/CBC/PKCS5Padding\");\n    byte[] keyBytes = new byte[16];\n    byte[] b = key.getBytes(\"UTF-8\");\n    int len = b.length;\n    if (len > keyBytes.length) len = keyBytes.length;\n    System.arraycopy(b, 0, keyBytes, 0, len);\n    SecretKeySpec keySpec = new SecretKeySpec(keyBytes, \"AES\");\n    IvParameterSpec ivSpec = new IvParameterSpec(keyBytes);\n    cipher.init(Cipher.ENCRYPT_MODE, keySpec, ivSpec);\n\n    byte[] results = cipher.doFinal(text.getBytes(\"UTF-8\"));\n    String result = Base64.encodeToString(results, 0);\n    return result;\n}\n", "idx": 2129}
{"project": "cipher", "commit_id": "Snippet4695400_31269.java", "target": 0, "func": "\nKeySpec ks = new DESKeySpec(\"key12345\".getBytes(\"UTF-8\"));\nSecretKey key = SecretKeyFactory.getInstance(\"DES\").generateSecret(ks);\n\nIvParameterSpec iv = new IvParameterSpec(\n        Hex.decodeHex(\"1234567890ABCDEF\".toCharArray()));\n\nCipher cipher = Cipher.getInstance(\"DES/CBC/PKCS5Padding\");\ncipher.init(Cipher.DECRYPT_MODE, key, iv);\n\nbyte[] decoded = cipher.doFinal(Base64.decodeBase64(\"B3xogi/Qfsc=\"));\n\nSystem.out.println(\"Decoded: \" + new String(decoded, \"UTF-8\"));\n", "idx": 1860}
{"project": "cipher", "commit_id": "Snippet45133268_27283.java", "target": 0, "func": "public class encrypt {\n\n    public static void main(String[] args) throws NoSuchAlgorithmException, NoSuchPaddingException, InvalidKeyException, IOException {\n        //Key is created and saved in File\n        KeyGenerator keygenerator = KeyGenerator.getInstance(\"AES\");\n        SecretKey myDesKey = keygenerator.generateKey();\n        String encodedKey = Base64.getEncoder().encodeToString(myDesKey.getEncoded());\n        Path keypath = Paths.get(\"C:/xxx/key.txt\");\n        Path keyfile = Files.createFile(keypath);\n        Files.write(keyfile, encodedKey.getBytes(), StandardOpenOption.WRITE);\n\n        Cipher desalgCipher;\n        desalgCipher = Cipher.getInstance(\"AES\");\n        desalgCipher.init(Cipher.ENCRYPT_MODE, myDesKey);\n\n        Path target = Paths.get(\"C:/xxx/encrypted.txt\");\n        Path file = Files.createFile(target);\n\n        Path path = Paths.get(\"test.txt\");               \n        try(InputStream is = Files.newInputStream(path);      \n        CipherInputStream cipherIS = new CipherInputStream(is, desalgCipher);   \n        BufferedReader reader = new BufferedReader(new InputStreamReader(cipherIS));){  \n            String line;\n            while((line = reader.readLine()) != null){\n                System.out.println(line);\n                Files.write(file, line.getBytes(), StandardOpenOption.WRITE);\n            }\n        }          \n    }\n}\n", "idx": 1638}
{"project": "cipher", "commit_id": "Snippet40527375_22371.java", "target": 0, "func": "private static byte[] encryptData(ByteArrayOutputStream data, byte[] symmetricKey) throws EncryptionException {\n        try {\n            SecretKey secKey = new SecretKeySpec(symmetricKey, \"AES\");\n            Cipher cipher = Cipher.getInstance(\"AES\");\n            cipher.init(Cipher.ENCRYPT_MODE, secKey);\n            return cipher.doFinal(data.toByteArray());\n        } catch (NoSuchAlgorithmException | NoSuchPaddingException | IllegalBlockSizeException |\n                InvalidKeyException |\n                BadPaddingException e) {\n            throw new EncryptionException(e);\n        }\n    }\n", "idx": 1903}
{"project": "cipher", "commit_id": "Snippet41556163_23476.java", "target": 1, "func": "import java.io.ByteArrayInputStream;\nimport java.io.ByteArrayOutputStream;\nimport java.io.IOException;\nimport java.io.InputStream;\nimport java.security.InvalidAlgorithmParameterException;\nimport java.security.InvalidKeyException;\nimport java.security.NoSuchAlgorithmException;\nimport java.security.SecureRandom;\nimport java.security.spec.InvalidKeySpecException;\nimport java.security.spec.KeySpec;\nimport java.util.Base64;\nimport java.util.Date;\nimport java.util.Optional;\n\nimport javax.crypto.BadPaddingException;\nimport javax.crypto.Cipher;\nimport javax.crypto.IllegalBlockSizeException;\nimport javax.crypto.NoSuchPaddingException;\nimport javax.crypto.SecretKey;\nimport javax.crypto.SecretKeyFactory;\nimport javax.crypto.spec.IvParameterSpec;\nimport javax.crypto.spec.PBEKeySpec;\nimport javax.crypto.spec.SecretKeySpec;\nimport javax.mail.Message;\nimport javax.mail.MessagingException;\nimport javax.mail.Multipart;\nimport javax.mail.Session;\nimport javax.mail.internet.InternetAddress;\nimport javax.mail.internet.MimeBodyPart;\nimport javax.mail.internet.MimeMessage;\nimport javax.mail.internet.MimeMultipart;\n\npublic class Stackoverflow {\n\n    private static final int keySize = 128;\n    static byte[] saltForThisRun = new byte[8];\n    static {\n        SecureRandom random = new SecureRandom();\n        random.nextBytes(saltForThisRun);\n    }\n\n    public static void main(\n            String[] args) throws Exception {\n        Message message = buildTestMessage(\"from@null.org\", new String[] { \"to@null.org\", \"to2@null.org\" },\n                \"Subject is needed here\", Optional.of(\"This is just a text\"), Optional.empty());\n\n        char[] password = \"password\".toCharArray();\n        String encryptedMsg = encrypt(password, saltForThisRun, message);\n        System.out.println(\"encryptedMsg: \" + encryptedMsg);\n        Message message2 = decrypt(password, saltForThisRun, encryptedMsg);\n\n        // out sth. like from@domain <--> null\n        System.out.println(message.getFrom()[0] + \" <--> \" + message2.getFrom()[0]);\n\n    }\n\n    private static Message decrypt(\n            char[] password,\n            byte[] salt,\n            String base64CipherText) throws EncryptionException {\n        try {\n            SecretKey secretKey = generateKey(password, salt, keySize);\n            byte[] initializationVector = createInitializationVector(keySize);\n\n            Cipher aesCipherForDecryption = Cipher.getInstance(\"AES/CBC/PKCS5PADDING\");\n\n            aesCipherForDecryption.init(Cipher.DECRYPT_MODE, secretKey, new IvParameterSpec(initializationVector));\n            byte[] decryptedByteCipherText = Base64.getDecoder().decode(base64CipherText);\n            byte[] byteDecryptedMessage = aesCipherForDecryption.doFinal(decryptedByteCipherText);\n            return createMessageFromBytes(byteDecryptedMessage);\n        } catch (IllegalStateException | InvalidKeyException | InvalidAlgorithmParameterException\n                | NoSuchAlgorithmException | NoSuchPaddingException | InvalidKeySpecException\n                | IllegalBlockSizeException | BadPaddingException | MessagingException e) {\n            throw new EncryptionException(String.format(\"Unable to enrypt message due to: %s\", e.getMessage()), e);\n        }\n    }\n\n    /**\n     * \n     * @param password\n     * @param salt\n     * @param message\n     * @param charArray\n     * @return Base64 encoded CipherText\n     * @throws EncryptionException\n     *             If sth. goes wrong\n     */\n    private static String encrypt(\n            char[] password,\n            byte[] salt,\n            Message message) throws EncryptionException {\n        try {\n            /**\n             * Step 1. Generate an AES key with password and salt\n             * \n             */\n            SecretKey secretKey = generateKey(password, salt, keySize);\n            System.out.println(secretKey.getEncoded().length);\n\n            /**\n             * Step 2. Generate an Initialization Vector (IV)\n             * a. Use SecureRandom to generate random bits\n             * The size of the IV matches the blocksize of the cipher (e.g. 128 bits for AES)\n             * b. Construct the appropriate IvParameterSpec object for the data to pass to Cipher's init() method\n             */\n            byte[] initializationVector = createInitializationVector(keySize);\n\n            /**\n             * Step 3. Create a Cipher by specifying the following parameters\n             * a. Algorithm name - here it is AES\n             * b. Mode - here it is CBC mode\n             * c. Padding - e.g. PKCS7 or PKCS5\n             * \n             * Must specify the mode explicitly as most JCE providers default to ECB mode!!\n             */\n            Cipher aesCipherForEncryption = Cipher.getInstance(\"AES/CBC/PKCS5PADDING\");\n\n            /**\n             * Step 4. Initialize the Cipher for Encryption\n             */\n            aesCipherForEncryption.init(Cipher.ENCRYPT_MODE, secretKey, new IvParameterSpec(initializationVector));\n\n            /**\n             * Step 5. Encrypt the Data\n             * a. Declare / Initialize the Data. Here the data is of type String\n             * b. Convert the Input Text to Bytes\n             * c. Encrypt the bytes using doFinal method\n             */\n            byte[] byteCipherText = updateCipherWithMessage(aesCipherForEncryption, message);\n            return new String(Base64.getEncoder().encode(byteCipherText));\n\n        } catch (IllegalBlockSizeException | BadPaddingException | IOException | MessagingException\n                | InvalidKeyException | InvalidAlgorithmParameterException | NoSuchAlgorithmException\n                | NoSuchPaddingException | InvalidKeySpecException e) {\n            throw new EncryptionException(String.format(\"Unable to enrypt message due to: %s\", e.getMessage()), e);\n        }\n\n    }\n\n    private static MimeMessage createMessageFromBytes(\n            byte[] decodedBytes) throws MessagingException {\n        InputStream is = new ByteArrayInputStream(decodedBytes);\n        Session session = null;\n        return new MimeMessage(session, is);\n    }\n\n    private static byte[] updateCipherWithMessage(\n            Cipher cipher,\n            Message message) throws IOException, MessagingException, IllegalBlockSizeException, BadPaddingException {\n        ByteArrayOutputStream os = new ByteArrayOutputStream();\n        try {\n            message.writeTo(os);\n            return cipher.doFinal(os.toByteArray());\n        } finally {\n            os.close();\n        }\n    }\n\n    private static byte[] createInitializationVector(\n            int keyLength) {\n        // Save the IV bytes or send it in plaintext with the encrypted data so you can decrypt the data later\n        byte[] iv = new byte[keyLength / 8];\n\n        SecureRandom prng = new SecureRandom();\n        prng.nextBytes(iv);\n        return iv;\n    }\n\n    private static SecretKey generateKey(\n            char[] password,\n            byte[] salt,\n            int keySize) throws InvalidKeySpecException, NoSuchAlgorithmException {\n        int nIterations = 65536;\n        SecretKeyFactory factory = SecretKeyFactory.getInstance(\"PBKDF2WithHmacSHA1\");\n        KeySpec spec = new PBEKeySpec(password, salt, nIterations, keySize);\n        SecretKey tmp = factory.generateSecret(spec);\n        return new SecretKeySpec(tmp.getEncoded(), \"AES\");\n    }\n\n    private static Message buildTestMessage(\n            String from,\n            String[] to,\n            String subject,\n            Optional<String> text,\n            Optional<String> html) throws Exception {\n        String replyto = from;\n        Session session = null;\n        Message message = new MimeMessage(session);\n        Multipart multiPart = new MimeMultipart(\"alternative\");\n\n        try {\n\n            if (text.isPresent()) {\n                MimeBodyPart textPart = new MimeBodyPart();\n                textPart.setText(text.get(), \"utf-8\");\n                multiPart.addBodyPart(textPart);\n            }\n            if (html.isPresent()) {\n                MimeBodyPart htmlPart = new MimeBodyPart();\n                htmlPart.setContent(html, \"text/html; charset=utf-8\");\n                multiPart.addBodyPart(htmlPart);\n            }\n\n            message.setContent(multiPart);\n\n            if (from != null) {\n                message.setFrom(new InternetAddress(from));\n            } else\n                message.setFrom();\n\n            if (replyto != null)\n                message.setReplyTo(new InternetAddress[] { new InternetAddress(replyto) });\n            else\n                message.setReplyTo(new InternetAddress[] { new InternetAddress(from) });\n\n            InternetAddress[] toAddresses = new InternetAddress[to.length];\n            for (int i = 0; i < toAddresses.length; i++) {\n                toAddresses[i] = new InternetAddress(to[i]);\n            }\n            message.setRecipients(Message.RecipientType.TO, toAddresses);\n            message.setSubject(subject);\n            message.setSentDate(new Date());\n\n            return message;\n\n        } catch (Exception e) {\n            e.printStackTrace();\n            System.out.println(\"Exception: \" + e.getMessage());\n            throw e;\n\n        }\n\n    }\n\n}\n", "idx": 2138}
{"project": "cipher", "commit_id": "Snippet20571667_3052.java", "target": 1, "func": "Cipher cipher1 = Cipher.getInstance(\"RSA/ECB/PKCS1Padding\", \"AndroidOpenSSL\");\n", "idx": 1941}
{"project": "cipher", "commit_id": "Snippet45340410_27448.java", "target": 0, "func": "public static String encryptData(byte[] clearData, String key, int keySize, boolean paddingEnable)\n        throws Exception {\n    byte[] keyBytes = getEncryptionKey(key, keySize);\n    SecretKey secretKey = new SecretKeySpec(keyBytes, \"DESede\");\n    String algo = \"DESede/ECB/pkcs5padding\";\n    Cipher cipher = Cipher.getInstance(algo);\n    cipher.init(Cipher.ENCRYPT_MODE, secretKey);\n    byte[] cipherText = cipher.doFinal(clearData);\n         System.out.println(clearData.toString());\n    return String.valueOf(Hex.encodeHex(cipherText, false));\n}\n\npublic static String decryptData(String clearData, String key, int keySize, boolean paddingEnable)\n        throws Exception {\n   byte[] keyBytes = getEncryptionKey(key, keySize);\n    SecretKey secretKey = new SecretKeySpec(keyBytes, \"DESede\");\n    String algo = \"DESede/ECB/pkcs5padding\";\n    Cipher cipher = Cipher.getInstance(algo);\n    byte[] stringDecode = Hex.decodeHex(clearData.toCharArray());\n    cipher.init(Cipher.DECRYPT_MODE, secretKey);\n    byte[] cipherText = cipher.doFinal(stringDecode);\n    return cipherText.toString();\n}\n\n\nprivate static byte[] getEncryptionKey(String keyString, int keySize)\n        throws Exception {\n    int keyLength = keyString.length();\n    switch (keySize) {\n        case 56:\n            if (keyLength != 16) {\n                throw new InvalidKeyException(\"Hex Key length should be 16 for a 56 Bit Encryption, found [\" + keyLength + \"]\");\n            }\n            break;\n        case 112:\n            if (keyLength != 32) {\n                throw new InvalidKeyException(\"Hex Key length should be 32 for a 112 Bit Encryption, found[\" + keyLength + \"]\");\n            }\n            break;\n        case 168:\n            if ((keyLength != 32) && (keyLength != 48)) {\n                throw new InvalidKeyException(\"Hex Key length should be 32 or 48 for a 168 Bit Encryption, found[\" + keyLength + \"]\");\n            }\n            if (keyLength == 32) {\n                keyString = keyString + keyString.substring(0, 16);\n            }\n            break;\n        default:\n            throw new InvalidKeyException(\"Invalid Key Size, expected one of [56, 112, 168], found[\" + keySize + \"]\");\n    }\n    return Hex.decodeHex(keyString.toCharArray());\n}\n", "idx": 1621}
{"project": "cipher", "commit_id": "Snippet40242396_22157.java", "target": 0, "func": "Cipher cipher = Cipher.getInstance(\"DESede/ECB/NoPadding\"); \ncipher.init(Cipher.ENCRYPT_MODE, key);\nbyte[] result = cipher.doFinal(data);\n", "idx": 1672}
{"project": "cipher", "commit_id": "Snippet46013514_28103.java", "target": 1, "func": "import org.bouncycastle.jce.provider.BouncyCastleProvider;\nimport org.bouncycastle.util.encoders.Base64;\nimport tech.dashman.dashman.crypto.Util;\n\nimport javax.crypto.Cipher;\nimport javax.crypto.SecretKey;\nimport javax.crypto.SecretKeyFactory;\nimport javax.crypto.spec.IvParameterSpec;\nimport javax.crypto.spec.PBEKeySpec;\nimport java.security.SecureRandom;\nimport java.security.Security;\nimport java.util.Arrays;\n\npublic class Scratch {\n    public static void main(String[] args) throws Exception {\n        Security.insertProviderAt(new BouncyCastleProvider(), 1);\n\n        String password = \"password\";\n        String payload = \"Lorem ipsum dolor sit amet, consectetur adipiscing elit. Aenean in tincidunt metus. Nam nec diam sed velit blandit porta quis et augue. Praesent imperdiet, nulla vel aliquam porta, dui nisi dictum justo, pellentesque elementum purus orci at leo. Duis scelerisque, urna sit amet fringilla interdum, mauris felis sagittis eros, eleifend tincidunt risus nulla ut erat. Aliquam id sapien non neque rutrum lacinia at vitae lorem. Vivamus quis ligula nunc. Aenean facilisis pretium leo, vitae gravida quam ultrices et. Ut venenatis eros in justo semper fermentum. Pellentesque convallis lectus urna, fringilla rhoncus metus faucibus quis. Sed eu rhoncus tortor. Donec lacinia tempor elementum.\";\n\n        int keyLength = 256;\n        int saltLength = keyLength / 8; // It's bytes, not bits.\n        int iterations = 65536;\n\n        byte[] salt = new SecureRandom().generateSeed(saltLength);\n        PBEKeySpec keySpec = new PBEKeySpec(password.toCharArray(), salt, iterations, keyLength);\n        SecretKeyFactory secretKeyFactory = SecretKeyFactory.getInstance(\"PBKDF2WithHmacSHA256\", \"BC\");\n        SecretKey passwordKey = secretKeyFactory.generateSecret(keySpec);\n\n        Cipher cipher = Cipher.getInstance(\"AES/GCM/NoPadding\", \"BC\");\n        cipher.init(Cipher.ENCRYPT_MODE, passwordKey);\n        byte[] iv = cipher.getIV();\n        System.out.println(Arrays.toString(cipher.getIV()));\n        byte[] cipherText = cipher.doFinal(payload.getBytes());\n\n        System.out.println(Base64.toBase64String(cipherText));\n\n        keySpec = new PBEKeySpec(password.toCharArray(), salt, iterations, keyLength);\n        secretKeyFactory = SecretKeyFactory.getInstance(\"PBKDF2WithHmacSHA256\", \"BC\");\n        passwordKey = secretKeyFactory.generateSecret(keySpec);\n\n        cipher = Cipher.getInstance(\"AES/GCM/NoPadding\", \"BC\");\n        cipher.init(Cipher.DECRYPT_MODE, passwordKey, new IvParameterSpec(iv));\n        System.out.println(Arrays.toString(cipher.getIV()));\n        byte[] plainText = cipher.doFinal(payload.getBytes());\n        System.out.println(new String(plainText));\n    }\n}\n", "idx": 2252}
{"project": "cipher", "commit_id": "Snippet40457339_22322.java", "target": 1, "func": "Cipher.getInstance(\"AES/CBC/PKCS5Padding\", \"BC\")\n", "idx": 2340}
{"project": "cipher", "commit_id": "Snippet37802869_19710.java", "target": 1, "func": "Cipher cipher = Cipher.getInstance(\"RSA/ECB/OAEPWITHSHA-256ANDMGF1PADDING\");\n\nbyte[] publicBytes = Base64.decode(Configs.PUBLIC_KEY.getBytes(\"UTF-8\"),Base64.DEFAULT);\nX509EncodedKeySpec keySpec = new X509EncodedKeySpec(publicBytes);\n\nKeyFactory keyFactory = KeyFactory.getInstance(\"RSA\");\nPublicKey pubKey = keyFactory.generatePublic(keySpec);\n\ncipher.init(Cipher.ENCRYPT_MODE, pubKey);\n\nString plaintext = \"test\";\n\nbyte[] encryptedBytes = cipher.doFinal(plaintext.getBytes(\"UTF-8\"));\nString chipertext = Base64.encodeToString(encryptedBytes,Base64.DEFAULT);\nLog.d(TAG,\"encrypted (chipertext) = \" + chipertext);\n", "idx": 2296}
{"project": "cipher", "commit_id": "Snippet15952618_38939.java", "target": 0, "func": "byte[] key = \"1428324560542678\".getBytes();\n\nCipher c = null;\n            try {\n                c = Cipher.getInstance(\"AES/ECB/PKCS7Padding\");\n            } catch (NoSuchAlgorithmException e) {\n                // TODO Auto-generated catch block\n                e.printStackTrace();\n            } catch (NoSuchPaddingException e) {\n                // TODO Auto-generated catch block\n                e.printStackTrace();\n            }\n\nSecretKeySpec k =  new SecretKeySpec(key, \"AES\");\n            try {\n                c.init(Cipher.ENCRYPT_MODE, k);\n            } catch (InvalidKeyException e) {\n                // TODO Auto-generated catch block\n                e.printStackTrace();\n            }\n\n    try {\n        EditText tv1passwordText = (EditText) findViewById(R.id.password);\n        String password = URLEncoder.encode(tv1passwordText.getText().toString(), \"UTF-8\");\n\n            byte[] encryptedData = c.doFinal( password.getBytes());\n", "idx": 1655}
{"project": "cipher", "commit_id": "Snippet45503824_27572.java", "target": 0, "func": "public class CipherServer\n{\n    public static void main(String[] args) throws Exception \n    {\n        int port = 7999;\n        ServerSocket server = new ServerSocket(port);\n        Socket s = server.accept();\n\n        // -Read the key from the file generated by the client.\n        ObjectInputStream in = new ObjectInputStream(new FileInputStream(\"KeyFile.xx\"));\n        Key key = (Key)in.readObject();\n        in.close();\n\n        // -Use the key to decrypt the incoming message from socket s.      \n        Cipher cipher = Cipher.getInstance(\"DES/ECB/PKCS5Padding\");\n        cipher.init(Cipher.DECRYPT_MODE, key);\n        CipherInputStream cipherIn = new CipherInputStream(s.getInputStream(), cipher);\n\n        byte[] array = new byte[44];\n        cipherIn.read(array);\n        cipherIn.close();\n        s.close();\n\n        String message = new String(array);\n        System.out.println(message);\n    }\n}\n", "idx": 1794}
{"project": "cipher", "commit_id": "Snippet42481268_24496.java", "target": 1, "func": "import java.math.BigInteger;\nimport java.security.InvalidKeyException;\nimport java.security.KeyPair;\nimport java.security.KeyPairGenerator;\nimport java.security.NoSuchAlgorithmException;\nimport java.security.NoSuchProviderException;\nimport java.security.Security;\nimport java.security.interfaces.RSAPrivateKey;\nimport java.security.interfaces.RSAPublicKey;\nimport java.security.spec.InvalidKeySpecException;\n\nimport javax.crypto.BadPaddingException;\nimport javax.crypto.Cipher;\nimport javax.crypto.IllegalBlockSizeException;\nimport javax.crypto.NoSuchPaddingException;\n\nimport org.bouncycastle.jce.provider.BouncyCastleProvider;\n\npublic class cryptoAndBigIntegerFIX {\n    public static void main(String[] args) throws NoSuchAlgorithmException, NoSuchProviderException, InvalidKeyException, NoSuchPaddingException, IllegalBlockSizeException, BadPaddingException, InvalidKeySpecException{\n        Security.addProvider(new BouncyCastleProvider());\n        System.out.println(\"input <> encrypted <> decrypted\");\n        cryptoAndBigIntegerFIX.keygen();\n\n        BigInteger encryptbytes;\n        BigInteger decryptbytes;\n\n        //Multiple tests with powers of 3 for some reason :D\n        for(int i=1;i<1000;i*=3){\n            encryptbytes = cryptoAndBigIntegerFIX.encrypt(new BigInteger(\"\"+i));\n            System.out.print(i + \" <> \" + encryptbytes.intValue() + \" <> \");\n            decryptbytes = cryptoAndBigIntegerFIX.decrypt(encryptbytes);\n            System.out.println(decryptbytes.intValue());            \n        }\n    }\n\n    public static RSAPrivateKey priv;\n    public static RSAPublicKey pub;\n\n    public static void keygen() throws NoSuchAlgorithmException, NoSuchProviderException, InvalidKeySpecException{\n        KeyPairGenerator generator = KeyPairGenerator.getInstance(\"RSA\");\n\n        generator.initialize(512);\n        KeyPair keyPair = generator.generateKeyPair();\n        priv = (RSAPrivateKey) keyPair.getPrivate();\n        pub = (RSAPublicKey) keyPair.getPublic();       \n    }\n\n    //Encrypt with javas API\n    public static BigInteger encrypt(BigInteger bg) throws NoSuchAlgorithmException, NoSuchPaddingException, InvalidKeyException, IllegalBlockSizeException, BadPaddingException, NoSuchProviderException{\n        byte[] encoded;\n        Cipher cipher=Cipher.getInstance(\"RSA/ECB/NoPadding\");\n        cipher.init(Cipher.ENCRYPT_MODE, pub);\n        encoded=cipher.doFinal(bg.toByteArray());\n        return new BigInteger(encoded);\n    }\n\n    //Decrypt manually\n    public static BigInteger decrypt(BigInteger bg){\n        BigInteger decoded = bg.modPow(priv.getPrivateExponent(),priv.getModulus());\n        return decoded;\n\n    }\n\n}\n", "idx": 2053}
{"project": "cipher", "commit_id": "Snippet22827221_5220.java", "target": 0, "func": "    // Decode EncryptKey with GameId\n    byte[] gameIdBytes = (\"502719605\").getBytes();\n    SecretKeySpec gameIdKeySpec = new SecretKeySpec(gameIdBytes, \"Blowfish\");\n    Cipher gameIdCipher = Cipher.getInstance(\"Blowfish/ECB/PKCS5Padding\");\n    gameIdCipher.init(Cipher.DECRYPT_MODE, gameIdKeySpec);\n    byte[] encryptKeyBytes = Base64.decode(\"Sf9c+zGDyyST9DtcHn2zToscfeuN4u3/\");\n    byte[] encryptkeyDecryptedByGameId = gameIdCipher.doFinal(encryptKeyBytes);\n\n    // Initialize the chunk cipher\n    SecretKeySpec chunkSpec = new SecretKeySpec(encryptkeyDecryptedByGameId, \"Blowfish\");\n    Cipher chunkCipher = Cipher.getInstance(\"Blowfish/ECB/PKCS5Padding\");\n    chunkCipher.init(Cipher.DECRYPT_MODE, chunkSpec);\n\n    byte[] chunkContent = getChunkContent();\n    byte[] chunkDecryptedBytes = chunkCipher.doFinal(chunkContent);\n", "idx": 1785}
{"project": "cipher", "commit_id": "Snippet30550481_12766.java", "target": 1, "func": "public String decrypte (String encCardNo) throws KeyStoreException, NoSuchAlgorithmException, CertificateException, IOException, UnrecoverableEntryException, NoSuchPaddingException, InvalidKeyException, IllegalBlockSizeException, BadPaddingException{\n    FileInputStream is = new FileInputStream(\"C:/Users/admin/Desktop/keystore/ksjksformat.jks\");    \n    String keystpassw = \"9801461740\";\n    String alias = \"ksjksformat\";       \n        KeyStore ks = KeyStore.getInstance(KeyStore.getDefaultType());                      \n        ks.load(is,keystpassw.toCharArray() );      \n        Key key = ks.getKey(alias, keystpassw.toCharArray());\n        Certificate cert = ks.getCertificate(alias);\n        PublicKey publicKey = cert.getPublicKey();\n        new KeyPair(publicKey, (PrivateKey) (key));     \n        KeyStore.ProtectionParameter protParam = new KeyStore.PasswordProtection(keystpassw.toCharArray());\n        KeyStore.PrivateKeyEntry pkentry = (PrivateKeyEntry) ks.getEntry(alias, protParam);\n        PrivateKey myPrivateKey =pkentry.getPrivateKey();\n        Cipher cipher = Cipher.getInstance(\"RSA\");\n        cipher.init(Cipher.DECRYPT_MODE, myPrivateKey); \n        byte[] decoded = Base64.decodeBase64(encCardNo);        \n        byte[] cipherData = cipher.doFinal(decoded);\n        return new String(cipherData);      \n}`\n", "idx": 1984}
{"project": "cipher", "commit_id": "Snippet6084923_31927.java", "target": 1, "func": "Cipher.getInstance(\"AES/CBC/PKCS7Padding\", \"BC\");", "idx": 2104}
{"project": "cipher", "commit_id": "Snippet28938923_10998.java", "target": 1, "func": "Cipher.getInstance(\"RSA/ECB/PKCS1Padding\", new org.bouncycastle.jce.provider.BouncyCastleProvider());\n", "idx": 2306}
{"project": "cipher", "commit_id": "Snippet32548248_14663.java", "target": 0, "func": "Cipher.getInstance(\"DESede/ECB/ZeroPadding\", \"BC\")", "idx": 1877}
{"project": "cipher", "commit_id": "Snippet45412178_27486.java", "target": 0, "func": "package org.apache.drill.exec.fn.impl;\n\nimport com.google.common.base.Charsets;\nimport io.netty.buffer.DrillBuf;\nimport org.apache.commons.codec.DecoderException;\nimport org.apache.commons.codec.net.BCodec;\nimport org.apache.drill.exec.expr.DrillSimpleFunc;\nimport org.apache.drill.exec.expr.annotations.FunctionTemplate;\nimport org.apache.drill.exec.expr.annotations.Output;\nimport org.apache.drill.exec.expr.annotations.Param;\nimport org.apache.drill.exec.expr.annotations.Workspace;\nimport org.apache.drill.exec.expr.holders.VarCharHolder;\n\nimport javax.crypto.*;\nimport javax.crypto.spec.DESKeySpec;\nimport javax.crypto.spec.SecretKeySpec;\nimport javax.inject.Inject;\n\n@functiontemplate(\nname = \"decode_cid\",\nscope = FunctionTemplate.FunctionScope.SIMPLE,\nnulls = FunctionTemplate.NullHandling.NULL_IF_NULL\n)\n\npublic class DecodeCidFunction implements DrillSimpleFunc {\n\n@Param\nVarCharHolder raw_input;\n// @Param\n// VarCharHolder raw_key;\n\n@Output\nVarCharHolder out;\n\n@Inject\nDrillBuf buffer;\n// @workspace\n// KeyGenerator keygenerator;\n\n@Workspace\nSecretKey myDesKey;\n\n@Workspace\nCipher desCipher;\n\n@Workspace\nBCodec bCodec;\n\n@Override\npublic void setup() {\n    try {\n        String key = \"this is a secret\";\n        javax.crypto.SecretKeyFactory factory = javax.crypto.SecretKeyFactory.getInstance(\"DES\");\n        myDesKey = factory.generateSecret(new javax.crypto.spec.DESKeySpec(key.getBytes())) ;\n        System.out.println(\"myDesKey = \"+myDesKey.toString());\n        // Create the cipher\n        desCipher = Cipher.getInstance(\"DES\");\n\n        // Initialize the cipher for encryption\n        desCipher.init(Cipher.DECRYPT_MODE, myDesKey);\n\n        bCodec =  new BCodec(\"UTF-8\");\n\n    } catch(Exception e) {\n        System.out.println(\"may i come here\");\n        e.printStackTrace();\n    }\n}\n\n@Override\npublic void eval() {\n    String input = org.apache.drill.exec.expr.fn.impl.StringFunctionHelpers.toStringFromUTF8(raw_input.start, raw_input.end, raw_input.buffer);\n    String output = \"\";\n    System.out.println(\"input = \" + input);\n    if (input.startsWith(\"=?\"))\n    {\n        try{\n            output = bCodec.decode(input);\n        }catch(Exception e){\n            System.out.println(\"find an error :\" +e.toString());\n            output  = \"\";\n        }\n    }else{\n        byte[] bts = new byte[input.length() / 2];\n        for (int i = 0; i < bts.length; i++) {\n            bts[i] = (byte) Integer.parseInt(input.substring(2*i, 2*i+2), 16);\n        }\n        System.out.println(\"bts = \" +bts.toString());\n        try{\n            byte[] decodedString = desCipher.doFinal(bts) ;\n            output = new String(decodedString, \"utf-8\");\n        }catch(Exception e){\n            System.out.println(\"i come here \" + e.toString());\n            output=\"\";\n        }\n    }\n    System.out.println(\"output = \" + output);\n    out.buffer = buffer;\n    out.start = 0;\n    out.end = output.getBytes().length;\n    buffer.setBytes(0, output.getBytes());\n}\n}\n", "idx": 1627}
{"project": "cipher", "commit_id": "Snippet36016288_17926.java", "target": 1, "func": "Cipher.getInstance(\"RSA/ECB/PKCS1Padding\")", "idx": 2348}
{"project": "cipher", "commit_id": "Snippet24807123_7132.java", "target": 0, "func": "byte key_bytes[] = \"12345678\".getBytes();\nSecretKeySpec _keyspec = new SecretKeySpec(key_bytes, \"DES\");\nCipher dcipher = Cipher.getInstance(\"DES/ECB/PKCS5Padding\");\ndcipher.init(Cipher.DECRYPT_MODE, _keyspec);\n\nbyte[] dec = new Base64().decode(value);\nbyte[] utf8 = dcipher.doFinal(dec);  // Decrypt, throws exception\nreturn new String(utf8, \"UTF8\");\n", "idx": 1628}
{"project": "cipher", "commit_id": "Snippet36724600_18634.java", "target": 1, "func": "private static final String ALGORITHM = \"AES/CBC/PKCS5Padding\";\nprivate static int ITERATIONS = 65536;\nprivate static SecretKey secretKey = null;\nfinal private static short KEY_LEN_IN_BITS = (short)128;\nfinal private static byte[] BUFFER = new byte[1024 * 64];\n\nprivate static byte[] generateSalt() throws NoSuchAlgorithmException {  \n    Random random = SecureRandom.getInstance(\"SHA1PRNG\");\n    byte[] salt = new byte[8];\n    random.nextBytes(salt);\n    return salt;\n}\n\nstatic ArrayList<Object> encrypt256(final FileInputStream fis, final String encryptFileTarget, final String fileTitle, final String keyVal) throws Exception{\n\n    final ArrayList<Object> encryptInfo = new ArrayList<Object>();\n\n    try{\n        byte[] saltBytes = new byte[8];\n        saltBytes = generateSalt();\n\n        SecretKeyFactory skf = SecretKeyFactory.getInstance(\"PBKDF2WithHmacSHA1\");\n        KeySpec spec = new PBEKeySpec(keyVal.toCharArray(), saltBytes, ITERATIONS, KEY_LEN_IN_BITS);\n        secretKey = skf.generateSecret(spec);\n        SecretKey secret = new SecretKeySpec(secretKey.getEncoded(), \"AES\");//\"ISO-8859-1\"\n\n        Cipher cipher = Cipher.getInstance(ALGORITHM);\n        cipher.init(Cipher.ENCRYPT_MODE, secret);\n\n        AlgorithmParameters params = cipher.getParameters ();\n        byte[] initIVVector = params.getParameterSpec (IvParameterSpec.class).getIV();\n\n        FileOutputStream fos = new FileOutputStream(encryptFileTarget, true);\n        CipherOutputStream cos = new CipherOutputStream(fos, cipher);\n\n        InputStream is = new BufferedInputStream(fis);\n        int bytesRead = -1;\n        int count = 0;\n\n        while((bytesRead = is.read(BUFFER)) != -1){\n            //System.out.println(\"bytesRead values is : \" + bytesRead);\n            cos.write(BUFFER, 0, bytesRead);\n        }\n\n        cos.flush();\n        cos.close();\n        is.close();\n        fos.flush();\n        fos.close();\n        fis.close();\n\n        encryptInfo.add(Hex.encodeHexString(initIVVector));\n        encryptInfo.add(Hex.encodeHexString(saltBytes));\n\n    }catch(Exception exp){\n        exp.printStackTrace();\n    }\n\n    return encryptInfo;\n}\n", "idx": 2096}
{"project": "cipher", "commit_id": "Snippet36293503_18150.java", "target": 1, "func": "public static PrivateKey getPrivateKey(String key) {\n    try {\n        /* Add PKCS#8 formatting */\n        byte[] byteKey = Base64.getDecoder().decode(key.getBytes());\n        ASN1EncodableVector v = new ASN1EncodableVector();\n        v.add(new ASN1Integer(0));\n        ASN1EncodableVector v2 = new ASN1EncodableVector();\n        v2.add(new ASN1ObjectIdentifier(PKCSObjectIdentifiers.rsaEncryption.getId()));\n        v2.add(DERNull.INSTANCE);\n        v.add(new DERSequence(v2));\n        v.add(new DEROctetString(byteKey));\n        ASN1Sequence seq = new DERSequence(v);\n        byte[] privKey = seq.getEncoded(\"DER\");\n\n        PKCS8EncodedKeySpec keySpec = new PKCS8EncodedKeySpec(privKey);\n        KeyFactory kf = KeyFactory.getInstance(\"RSA\");\n        return kf.generatePrivate(keySpec);\n    } catch (Exception e) {\n        e.printStackTrace();\n    }\n    return null;\n}\n\npublic static String decrypt(String cipherString,PrivateKey privateKey){\n    try{\n        Cipher cipher = Cipher.getInstance(\"RSA\");\n        cipher.init(Cipher.DECRYPT_MODE, privateKey);\n        byte[] plainByte = cipher.doFinal(Base64.getDecoder().decode(cipherString));\n        return Base64.getEncoder().encodeToString(plainByte);\n    }\n    catch (Exception e) {\n        e.printStackTrace();\n    }\n    return null;\n}\n", "idx": 1988}
{"project": "cipher", "commit_id": "Snippet33284294_15339.java", "target": 1, "func": "package javaapplication1;\n\nimport org.apache.commons.codec.binary.Base64;\nimport org.apache.commons.codec.binary.StringUtils;\nimport org.apache.commons.codec.binary.Hex;\n\nimport java.security.InvalidAlgorithmParameterException;\nimport java.security.InvalidKeyException;\nimport java.security.NoSuchAlgorithmException;\nimport java.security.SecureRandom;\n\nimport javax.crypto.BadPaddingException;\nimport javax.crypto.Cipher;\nimport javax.crypto.IllegalBlockSizeException;\nimport javax.crypto.KeyGenerator;\nimport javax.crypto.NoSuchPaddingException;\nimport javax.crypto.SecretKey;\nimport javax.crypto.spec.IvParameterSpec;\nimport javax.crypto.spec.SecretKeySpec;\n\nimport javax.xml.bind.DatatypeConverter;\n\npublic class JavaApplication1 {\n\n    public static void main(String[] args) {\n        byte[] ENCRYPTION_KEY = JavaApplication1.toByteArray(\"SECRET_KEY_GOES_HERE\");\n        String INPUT = new String(\"cBVlMjBttr7DKW8fhHtqJOLyMBNrgxpIJsgFFPjkA/4MWxMIudOnYzS4WuxIhUjtgGgk4CzrkJ1G60R4OWBljNTMA9ATPKh9PXe7wXAwJfE9zc698bQv4lDkXRME+q4xCb3bK/UGQ/BPVIkmRYdHcBvIHXNzGd36Nn40giigY/g=\");\n\n        try {\n            System.out.println(JavaApplication1.decryptStringAES(INPUT, ENCRYPTION_KEY));\n        } catch (Exception exception) {\n            System.out.println(\"Error occured: \" + exception);\n        }\n    }\n\n    public static byte[] toByteArray(String s) {\n        return DatatypeConverter.parseHexBinary(s);\n    }\n\n    public static String decryptStringAES(String input, byte[] key) throws Exception {\n        byte[] IV = JavaApplication1.toByteArray(\"00000000000000000000000000000000\");\n\n        byte[] inputBytes = Base64.decodeBase64(input.getBytes());\n        Cipher decryptCipher = Cipher.getInstance(\"AES/CBC/PKCS5Padding\");\n        decryptCipher.init(Cipher.DECRYPT_MODE, new SecretKeySpec(key, \"AES\"), new\n        IvParameterSpec(IV));\n        byte[] decrypt = decryptCipher.doFinal(inputBytes);\n        return new String(decrypt);\n    }\n}\n", "idx": 2324}
{"project": "cipher", "commit_id": "Snippet30591269_12796.java", "target": 0, "func": "package com.example;\nimport java.security.Key;\nimport javax.crypto.Cipher;\nimport javax.crypto.spec.SecretKeySpec;\npublic class StrongAES \n{\n    public void run() \n    {\n        try \n        {\n            String text = \"Hello World\";\n            String key = \"Bar12345Bar12345\"; // 128 bit key\n            // Create key and cipher\n            Key aesKey = new SecretKeySpec(key.getBytes(), \"AES\");\n            Cipher cipher = Cipher.getInstance(\"AES\");\n            // encrypt the text\n            cipher.init(Cipher.ENCRYPT_MODE, aesKey);\n            byte[] encrypted = cipher.doFinal(text.getBytes());\n            System.err.println(new String(encrypted));\n            // decrypt the text\n            cipher.init(Cipher.DECRYPT_MODE, aesKey);\n            String decrypted = new String(cipher.doFinal(encrypted));\n            System.err.println(decrypted);\n        }\n        catch(Exception e) \n        {\n            e.printStackTrace();\n        }\n    }\n    public static void main(String[] args) \n    {\n        StrongAES app = new StrongAES();\n        app.run();\n    }\n}\n", "idx": 1800}
{"project": "cipher", "commit_id": "Snippet36671487_18530.java", "target": 0, "func": "import java.io.IOException;\nimport java.security.InvalidKeyException;\nimport java.security.Key;\nimport java.security.NoSuchAlgorithmException;\nimport java.util.Scanner;\n\nimport javax.crypto.BadPaddingException;\nimport javax.crypto.Cipher;\nimport javax.crypto.IllegalBlockSizeException;\nimport javax.crypto.NoSuchPaddingException;\nimport javax.crypto.spec.SecretKeySpec;\n\nimport sun.misc.BASE64Encoder;\nimport sun.misc.BASE64Decoder;\n\npublic class Application\n{\n    public static void main(String[] args)\n    {\n        Scanner input = new Scanner(System.in);\n        String textToEncrypt = \"Hello World\";\n        String textToDecrypt;\n        String textToDecryptAscii;\n        String result;\n        int operation;\n        Cipher cipher = null;\n        try {\n            cipher = Cipher.getInstance(\"AES\");\n        } catch (NoSuchAlgorithmException e1) {\n            // TODO Auto-generated catch block\n            e1.printStackTrace();\n        } catch (NoSuchPaddingException e1) {\n            // TODO Auto-generated catch block\n            e1.printStackTrace();\n        }\n        //String key = \"Bar12345Bar12345\"; // 128 bit key\n        String key = null;\n\n        BASE64Encoder asciiEncoder = new BASE64Encoder();\n        BASE64Decoder asciiDecoder = new BASE64Decoder();\n\n        System.out.printf(\"Enter:\\n1 for encryption\\n2 for decryption\\n\\nChoice: \");\n        operation = input.nextInt();\n        input.nextLine();\n\n        if (operation == 1)\n        {\n            try \n            {\n                System.out.print(\"Enter a 128-bit key to be used for encryption: \");\n                key = input.nextLine();\n\n                if(key.length() != 16)\n                {\n                    while(key.length() != 16)\n                    {\n                        System.out.print(\"You need to enter a *128-bit* key: \");\n                        key = input.nextLine();\n                    }\n                }\n\n                System.out.printf(\"\\n---------\\n\\nText to encrypt: \");\n                textToEncrypt = input.nextLine();\n\n                //Create key and cipher\n                Key aesKey = new SecretKeySpec(key.getBytes(), \"AES\");\n                //Cipher cipher = Cipher.getInstance(\"AES\");\n\n                //encrypt the text\n                cipher.init(Cipher.ENCRYPT_MODE, aesKey);\n                byte[] encrypted = cipher.doFinal(textToEncrypt.getBytes());\n\n                StringBuilder sb = new StringBuilder();\n                for (byte b: encrypted)\n                {\n                    sb.append((char)b);\n                }\n\n                // the encrypted String\n                String enc = sb.toString();\n                //System.out.println(\"encrypted:\" + enc);\n\n                String asciiEncodedEncryptedResult = asciiEncoder.encodeBuffer(enc.getBytes());\n\n                asciiEncodedEncryptedResult = asciiEncodedEncryptedResult.replace(\"\\n\", \"\").replace(\"\\r\", \"\");\n\n                System.out.println(\"Encrypted text: \" + asciiEncodedEncryptedResult);\n                //System.out.printf(\"\\n------------------------------\\nDecrypted text: \" + asciiEncodedEncryptedResult + \"\\n------------------------------\\n\\n\\n\");\n\n            }\n            catch(Exception e) \n            {\n                e.printStackTrace();\n            }\n        }\n        else if (operation == 2)\n        {\n            System.out.printf(\"\\n---------\\n\\nText to decrypt: \");\n            textToDecryptAscii = input.nextLine();\n\n            System.out.print(\"Enter the 128-bit decryption key: \");\n            key = input.nextLine();\n\n            if(key.length() != 16)\n            {\n                while(key.length() != 16)\n                {\n                    System.out.print(\"You need to enter a *128-bit* key: \");\n                    key = input.nextLine();\n                }\n            }\n\n            byte[] decodedBytes = null;\n            try\n            {\n                decodedBytes = asciiDecoder.decodeBuffer(textToDecryptAscii);\n            } catch (IOException e1) {\n                // TODO Auto-generated catch block\n                e1.printStackTrace();\n            }\n            //System.out.println(\"decodedBytes \" + new String(decodedBytes));\n\n            textToDecrypt = new String(decodedBytes);\n\n            //Convert the string to byte array\n            //for decryption\n            byte[] bb = new byte[textToDecrypt.length()];\n            for (int i=0; i<textToDecrypt.length(); i++)\n            {\n                bb[i] = (byte) textToDecrypt.charAt(i);\n            }\n\n            //decrypt the text\n            Key aesKey = new SecretKeySpec(key.getBytes(), \"AES\");\n            try\n            {\n                cipher.init(Cipher.DECRYPT_MODE, aesKey);\n            }\n            catch (InvalidKeyException e) {\n                // TODO Auto-generated catch block\n                e.printStackTrace();\n            }\n            String decrypted = null;\n            try\n            {\n                decrypted = new String(cipher.doFinal(bb));\n            }\n            catch (IllegalBlockSizeException e) {\n                // TODO Auto-generated catch block\n                e.printStackTrace();\n            }\n            catch (BadPaddingException e) {\n                // TODO Auto-generated catch block\n                e.printStackTrace();\n            }\n            System.out.printf(\"\\n------------------------------\\nDecrypted text: \" + decrypted + \"\\n------------------------------\\n\\n\\n\");\n        }\n    }\n}\n", "idx": 1736}
{"project": "cipher", "commit_id": "Snippet47476000_29466.java", "target": 1, "func": "public class TWOFISH {\n\n    public static byte[] encrypt(String toEncrypt, String key) throws Exception {\n      // create a binary key from the argument key (seed)\n      SecureRandom sr = new SecureRandom(key.getBytes());\n      KeyGenerator kg = KeyGenerator.getInstance(\"twofish\");\n      kg.init(sr);\n      SecretKey sk = kg.generateKey();\n\n      // create an instance of cipher\n      Cipher cipher = Cipher.getInstance(\"twofish\");\n\n      // initialize the cipher with the key\n      cipher.init(Cipher.ENCRYPT_MODE, sk);\n\n      // enctypt!\n      byte[] encrypted = cipher.doFinal(toEncrypt.getBytes());\n\n      return encrypted;\n   }\n\n   public static String decrypt(byte[] toDecrypt, String key) throws Exception {\n      // create a binary key from the argument key (seed)\n      SecureRandom sr = new SecureRandom(key.getBytes());\n      KeyGenerator kg = KeyGenerator.getInstance(\"twofish\");\n      kg.init(sr);\n      SecretKey sk = kg.generateKey();\n\n      // do the decryption with that key\n      Cipher cipher = Cipher.getInstance(\"twofish\");\n      cipher.init(Cipher.DECRYPT_MODE, sk);\n      byte[] decrypted = cipher.doFinal(toDecrypt);\n\n      return new String(decrypted);\n   }\n}\n", "idx": 2182}
{"project": "cipher", "commit_id": "Snippet22228711_4632.java", "target": 1, "func": "static {\n       Security.insertProviderAt(new BouncyCastleProvider(), 1);\n      }\n\n//...more code here\n\nbyte[] pka = Base64.decode(base64key);\n\nX509EncodedKeySpec x = new X509EncodedKeySpec(pka);\nPublicKey publicKey = KeyFactory.getInstance(\"RSA\").generatePublic(x);\n\nbyte[] testToByte = \"test\".getBytes(\"UTF8\"); \n\nKeyPairGenerator keyGen = KeyPairGenerator.getInstance(\"RSA\"); \nkeyGen.initialize(2048); \n\nCipher cipher = Cipher.getInstance(\"RSA\"); \ncipher.init(Cipher.ENCRYPT_MODE, publicKey); \n\nbyte[] cipherText = cipher.doFinal(testToByte); \n\nString encrypted = Base64.encode((new String(cipherText, \"UTF8\").toString().getBytes()))\n", "idx": 2337}
{"project": "cipher", "commit_id": "Snippet37946487_19979.java", "target": 0, "func": "package com.spencergang.fem;\n\nimport java.io.File;\nimport java.io.FileInputStream;\nimport java.io.FileOutputStream;\nimport java.io.IOException;\nimport java.security.InvalidKeyException;\nimport java.security.Key;\nimport java.security.NoSuchAlgorithmException;\n\nimport javax.crypto.BadPaddingException;\nimport javax.crypto.Cipher;\nimport javax.crypto.IllegalBlockSizeException;\nimport javax.crypto.NoSuchPaddingException;\nimport javax.crypto.spec.SecretKeySpec;\n\npublic class Cryptographer {\n    private static final String ALGORITHM = \"AES\";\n    private static final String TRANSFORMATION = \"AES\";\n\n    //Method for cryptography\n    public static void crypto(int cipherMode, String key, File inputFile, File outputFile) throws CryptoException {\n        try{\n            Key secretKey = new SecretKeySpec(key.getBytes(), ALGORITHM);\n            Cipher cipher = Cipher.getInstance(TRANSFORMATION);\n            cipher.init(cipherMode, secretKey);\n\n            FileInputStream inputStream = new FileInputStream(inputFile);\n            byte[] inputBytes = new byte[(int) inputFile.length()];\n            inputStream.read(inputBytes);\n\n            byte[] outputBytes = cipher.doFinal(inputBytes);\n\n            FileOutputStream outputStream = new FileOutputStream(outputFile);\n            outputStream.write(outputBytes);\n\n            inputStream.close();\n            outputStream.close();\n        }catch(NoSuchPaddingException | NoSuchAlgorithmException | InvalidKeyException | BadPaddingException | IllegalBlockSizeException | IOException ex){\n            throw new CryptoException(\"ERROR ENCRYPTING / DECRYPTING FILE\", ex);\n        }\n    }\n\n    //Encryption\n    public static void encrypt(String key, File inputFile, File outputFile) throws CryptoException {\n        crypto(Cipher.ENCRYPT_MODE, key, inputFile, outputFile);\n    }\n\n    //Decryption\n    public static void decrypt(String key, File inputFile, File outputFile) throws CryptoException {\n        crypto(Cipher.DECRYPT_MODE, key, inputFile, outputFile);\n    }\n}\n", "idx": 1862}
{"project": "cipher", "commit_id": "Snippet8597952_33365.java", "target": 0, "func": "Cipher.getInstance(\"DES/ECB/PKCS5Padding\")", "idx": 1760}
{"project": "cipher", "commit_id": "Snippet44365286_26428.java", "target": 0, "func": "public static String DESDecrypt(String src, String password) {\n    String result = src;\n    if (src == null) {\n        return result;\n    }\n\n        if (src.isEmpty()) {\n            return result;\n        }\n\n        byte[] item = password.substring(0, 8).getBytes();\n        try {\n            DESKeySpec item2 = new DESKeySpec(item);\n            SecretKey securekey = SecretKeyFactory.getInstance(\"DES\").generateSecret(item2);\n        } catch (InvalidKeyException e) {\n            // TODO Auto-generated catch block\n\n        }\n\n        return password.substring(0, 8);\n        /*AlgorithmParameterSpec iv = new IvParameterSpec(ivkey);\n        Cipher cipher = Cipher.getInstance(\"DES/CBC/PKCS5Padding\");\n        cipher.init(2, securekey, iv);\n        return new String(cipher.doFinal(Base64.getDecoder().decode(src)));*/\n\n}\n", "idx": 1586}
{"project": "cipher", "commit_id": "Snippet40637868_22494.java", "target": 1, "func": "public class AES {\n    public static String encrypt(String message, String key){\n        try {\n            SecretKeySpec KS = new SecretKeySpec(key.getBytes(), \"AES\");\n            Cipher cipher = Cipher.getInstance(\"AES/CBC/PKCS5Padding\");\n            cipher.init(Cipher.ENCRYPT_MODE, KS);\n            byte[] encrypted = cipher.doFinal(message.getBytes());      \n            return Base64.encodeToString(encrypted, Base64.NO_PADDING);\n        } catch (Exception e) {\n             return \"ERROR:\"+e.getMessage();\n        }\n    }\n\n    public static String decrypt(String chiperText, String key){\n        try {\n\n            SecretKeySpec KS = new SecretKeySpec(key.getBytes(), \"AES\");\n            Cipher cipher = Cipher.getInstance(\"AES/CBC/PKCS5Padding\");\n            cipher.init(Cipher.DECRYPT_MODE, KS);\n            byte[] decrypted = cipher.doFinal(Base64.decode(chiperText, Base64.NO_PADDING));\n            return new String(decrypted);\n        } catch (Exception e) {\n             return \"ERROR\";\n        }\n    }\n", "idx": 1961}
{"project": "cipher", "commit_id": "Snippet19610476_2339.java", "target": 0, "func": "Cipher.getInstance(\"DESede/ECB/PKCS5Padding\");\n", "idx": 1599}
{"project": "cipher", "commit_id": "Snippet5520786_31682.java", "target": 1, "func": "import java.security.MessageDigest;\nimport java.security.SecureRandom;\n\nimport javax.crypto.Cipher;\nimport javax.crypto.spec.IvParameterSpec;\nimport javax.crypto.spec.SecretKeySpec;\n\npublic class EncryptDecrypt {\n    public static void main(String[] args) throws Exception {\n        // here are your inputs\n        String keyString = \"averylongtext!@$@#$#@$#*&(*&}{23432432432dsfsdf\";\n        String input = \"john doe\";\n\n        // setup AES cipher in CBC mode with PKCS #5 padding\n        Cipher cipher = Cipher.getInstance(\"AES/CBC/PKCS5Padding\");\n\n        // setup an IV (initialization vector) that should be\n        // randomly generated for each input that's encrypted\n        byte[] iv = new byte[cipher.getBlockSize()];\n        new SecureRandom().nextBytes(iv);\n        IvParameterSpec ivSpec = new IvParameterSpec(iv);\n\n        // hash keyString with SHA-256 and crop the output to 128-bit for key\n        MessageDigest digest = MessageDigest.getInstance(\"SHA-256\");\n        digest.update(keyString.getBytes());\n        byte[] key = new byte[16];\n        System.arraycopy(digest.digest(), 0, key, 0, key.length);\n        SecretKeySpec keySpec = new SecretKeySpec(key, \"AES\");\n\n        // encrypt\n        cipher.init(Cipher.ENCRYPT_MODE, keySpec, ivSpec);\n        byte[] encrypted = cipher.doFinal(input.getBytes(\"UTF-8\"));\n        System.out.println(\"encrypted: \" + new String(encrypted));\n\n        // include the IV with the encrypted bytes for transport, you'll\n        // need the same IV when decrypting (it's safe to send unencrypted)\n\n        // decrypt\n        cipher.init(Cipher.DECRYPT_MODE, keySpec, ivSpec);\n        byte[] decrypted = cipher.doFinal(encrypted);\n        System.out.println(\"decrypted: \" + new String(decrypted, \"UTF-8\"));\n    }\n}\n", "idx": 2272}
{"project": "cipher", "commit_id": "Snippet16299042_39263.java", "target": 1, "func": "public class AdvancedCrypto {\n\n  public static final String PROVIDER = \"BC\";\n  public static final int SALT_LENGTH = 20;\n  public static final int IV_LENGTH = 16;\n  public static final int PBE_ITERATION_COUNT = 100;\n\n  private static final String RANDOM_ALGORITHM = \"SHA1PRNG\";\n  private static final String HASH_ALGORITHM = \"SHA-512\";\n  private static final String PBE_ALGORITHM = \"PBEWithSHA256And256BitAES-CBC-BC\";\n  private static final String CIPHER_ALGORITHM = \"AES/CBC/PKCS5Padding\";\n  private static final String SECRET_KEY_ALGORITHM = \"AES\";\n\n  public static byte[] toByte(String hexString) {\n    int len = hexString.length()/2;\n    byte[] result = new byte[len];\n    for (int i = 0; i < len; i++)\n    result[i] = Integer.valueOf(hexString.substring(2*i, 2*i+2), 16).byteValue();\n    return result;\n  }\n\n  public static String toHex(byte[] buf) {\n    if (buf == null)\n    return \"\";\n    StringBuffer result = new StringBuffer(2*buf.length);\n    for (int i = 0; i < buf.length; i++) {\n      appendHex(result, buf[i]);\n    }\n    return result.toString();\n  }    \n  private final static String HEX = \"0123456789ABCDEF\";\n  private static void appendHex(StringBuffer sb, byte b) {\n    sb.append(HEX.charAt((b>>4)&0x0f)).append(HEX.charAt(b&0x0f));\n  }\n\n  public static String encrypt(SecretKey secret, String cleartext) throws Exception {\n    try {\n\n      byte[] iv = generateIv();\n      String ivHex = toHex(iv);\n      IvParameterSpec ivspec = new IvParameterSpec(iv);\n\n      Cipher encryptionCipher = Cipher.getInstance(CIPHER_ALGORITHM, PROVIDER);\n      encryptionCipher.init(Cipher.ENCRYPT_MODE, secret, ivspec);\n      byte[] encryptedText = encryptionCipher.doFinal(cleartext.getBytes(\"UTF-8\"));\n      String encryptedHex = toHex(encryptedText);\n\n      return ivHex + encryptedHex;\n\n    } catch (Exception e) {\n      throw new Exception(\"Unable to encrypt\", e);\n    }\n  }\n\n  public static String decrypt(SecretKey secret, String encrypted) throws Exception {\n    try {\n      Cipher decryptionCipher = Cipher.getInstance(CIPHER_ALGORITHM, PROVIDER);\n      String ivHex = encrypted.substring(0, IV_LENGTH * 2);\n      String encryptedHex = encrypted.substring(IV_LENGTH * 2);\n      IvParameterSpec ivspec = new IvParameterSpec(toByte(ivHex));\n      decryptionCipher.init(Cipher.DECRYPT_MODE, secret, ivspec);\n      byte[] decryptedText = decryptionCipher.doFinal(toByte(encryptedHex));\n      String decrypted = new String(decryptedText, \"UTF-8\");\n      return decrypted;\n    } catch (Exception e) {\n      throw new Exception(\"Unable to decrypt\", e);\n    }\n  }\n\n  public static SecretKey getSecretKey(String password, String salt) throws Exception {\n    try {\n      PBEKeySpec pbeKeySpec = new PBEKeySpec(password.toCharArray(), toByte(salt), PBE_ITERATION_COUNT, 256);\n      SecretKeyFactory factory = SecretKeyFactory.getInstance(PBE_ALGORITHM, PROVIDER);\n      SecretKey tmp = factory.generateSecret(pbeKeySpec);\n      SecretKey secret = new SecretKeySpec(tmp.getEncoded(), SECRET_KEY_ALGORITHM);\n      return secret;\n    } catch (Exception e) {\n      throw new Exception(\"Unable to get secret key\", e);\n    }\n  }\n\n  public String getHash(String password, String salt) throws Exception {\n    try {\n      String input = password + salt;\n      MessageDigest md = MessageDigest.getInstance(HASH_ALGORITHM, PROVIDER);\n      byte[] out = md.digest(input.getBytes(\"UTF-8\"));\n      return toHex(out);\n    } catch (Exception e) {\n      throw new Exception(\"Unable to get hash\", e);\n    }\n  }\n\n  public String generateSalt() throws Exception {\n    try {\n      SecureRandom random = SecureRandom.getInstance(RANDOM_ALGORITHM);\n      byte[] salt = new byte[SALT_LENGTH];\n      random.nextBytes(salt);\n      String saltHex = toHex(salt);\n      return saltHex;\n    } catch (Exception e) {\n      throw new Exception(\"Unable to generate salt\", e);\n    }\n  }\n\n  private static byte[] generateIv() throws NoSuchAlgorithmException, NoSuchProviderException {\n    SecureRandom random = SecureRandom.getInstance(RANDOM_ALGORITHM);\n    byte[] iv = new byte[IV_LENGTH];\n    random.nextBytes(iv);\n    return iv;\n  }\n\n}\n", "idx": 1973}
{"project": "cipher", "commit_id": "Snippet15528057_38565.java", "target": 0, "func": "Cipher.getInstance(\"DES\")", "idx": 1690}
{"project": "cipher", "commit_id": "Snippet16997914_286.java", "target": 0, "func": "public class MainClass {\n  public static void main(String args[]) throws Exception {\n    KeyGenerator kg = KeyGenerator.getInstance(\"DES\");\n    kg.init(new SecureRandom());\n    SecretKey key = kg.generateKey();\n    SecretKeyFactory skf = SecretKeyFactory.getInstance(\"DES\");\n    Class spec = Class.forName(\"javax.crypto.spec.DESKeySpec\");\n    DESKeySpec ks = (DESKeySpec) skf.getKeySpec(key, spec);\n    ObjectOutputStream oos = new ObjectOutputStream(new FileOutputStream(\"keyfile\"));\n    oos.writeObject(ks.getKey());\n\n    Cipher c = Cipher.getInstance(\"DES/CFB8/NoPadding\");\n    c.init(Cipher.ENCRYPT_MODE, key);\n    CipherOutputStream cos = new CipherOutputStream(new FileOutputStream(\"ciphertext\"), c);\n    PrintWriter pw = new PrintWriter(new OutputStreamWriter(cos));\n    pw.println(\"Stand and unfold yourself\");\n    pw.close();\n    oos.writeObject(c.getIV());\n    oos.close();\n  }\n}\n", "idx": 1646}
{"project": "cipher", "commit_id": "Snippet23198243_5538.java", "target": 0, "func": "KeyGenerator keygenerator;\ntry {\n    keygenerator = KeyGenerator.getInstance(\"Blowfish\");\n    SecretKey secretkey = keygenerator.generateKey();\n\n    String Key = settings.getString(\"key\", \"\");\n    byte[] KeyData = Key.getBytes();\n    SecretKeySpec KS = new SecretKeySpec(KeyData, \"Blowfish\");\n    Cipher cipher = Cipher.getInstance(\"Blowfish\");\n    cipher.init(Cipher.ENCRYPT_MODE, KS);\n\n    byte[] encrypted = cipher.doFinal(message.getBytes());\n    message = new String(encrypted, \"UTF-8\");\n\n    System.out.println(\"encrypt ok\");\n} catch (Exception e){\n    System.out.println(\"encrypt error\");\n}\n", "idx": 1783}
{"project": "cipher", "commit_id": "Snippet24781318_7121.java", "target": 1, "func": "import javax.crypto.Cipher;\nimport javax.crypto.spec.IvParameterSpec;\nimport javax.crypto.spec.SecretKeySpec;\n\npublic class AES_CBC {\n\n    public static void main(String[] args) throws Exception {\n\n    byte[] keyBytes = new byte[] { 14, (byte) 0x0b, (byte) 0x41,\n            (byte) 0xb2, (byte) 0x2a, (byte) 0x29, (byte) 0xbe,\n            (byte) 0xb4, (byte) 0x06, (byte) 0x1b, (byte) 0xda,\n            (byte) 0x66, (byte) 0xb6, (byte) 0x74, (byte) 0x7e, (byte) 0x14 };\n\n    byte[] ivBytes = new byte[] { (byte) 0x4c, (byte) 0xa0, (byte) 0x0f,\n            (byte) 0xf4, (byte) 0xc8, (byte) 0x98, (byte) 0xd6,\n            (byte) 0x1e, (byte) 0x1e, (byte) 0xdb, (byte) 0xf1,\n            (byte) 0x80, (byte) 0x06, (byte) 0x18, (byte) 0xfb, (byte) 0x28 };\n\n    SecretKeySpec key = new SecretKeySpec(keyBytes, \"AES\");\n    IvParameterSpec ivSpec = new IvParameterSpec(ivBytes);\n\n    Cipher cipher = Cipher.getInstance(\"AES/CBC/PKCS5Padding\");\n\n    byte[] cipherText = new byte[] { (byte) 0x28, (byte) 0xa2, (byte) 0x26,\n            (byte) 0xd1, (byte) 0x60, (byte) 0xda, (byte) 0xd0,\n            (byte) 0x78, (byte) 0x83, (byte) 0xd0, (byte) 0x4e,\n            (byte) 0x00, (byte) 0x8a, (byte) 0x78, (byte) 0x97,\n            (byte) 0xee, (byte) 0x2e, (byte) 0x4b, (byte) 0x74,\n            (byte) 0x65, (byte) 0xd5, (byte) 0x29, (byte) 0x0d,\n            (byte) 0x0c, (byte) 0x0e, (byte) 0x6c, (byte) 0x68,\n            (byte) 0x22, (byte) 0x23, (byte) 0x6e, (byte) 0x1d,\n            (byte) 0xaa, (byte) 0xfb, (byte) 0x94, (byte) 0xff,\n            (byte) 0xe0, (byte) 0xc5, (byte) 0xda, (byte) 0x05,\n            (byte) 0xd9, (byte) 0x47, (byte) 0x6b, (byte) 0xe0,\n            (byte) 0x28, (byte) 0xad, (byte) 0x7c, (byte) 0x1d, (byte) 0x81 };\n\n    cipher.init(Cipher.DECRYPT_MODE, key, ivSpec);\n    byte[] original = cipher.doFinal(cipherText);\n    String plaintext = new String(original);\n    System.out.println(plaintext);\n}\n}\n", "idx": 2223}
{"project": "cipher", "commit_id": "Snippet37274768_19209.java", "target": 0, "func": "public class VincentFileCrypto {\n\npublic  byte[] encrypt(String seed, byte[] cleartext) throws Exception {\n    byte[] rawKey = getRawKey(seed.getBytes());\n    byte[] result = encrypt(rawKey, cleartext);\n    //  return toHex(result);\n    return result;\n}\n\npublic  byte[] decrypt(String seed, byte[] encrypted) throws Exception {\n    byte[] rawKey = getRawKey(seed.getBytes());\n    byte[] enc = encrypted;\n    byte[] result = decrypt(rawKey, enc);\n    return result;\n}\n\n//done\nprivate  byte[] getRawKey(byte[] seed) throws Exception {\n    KeyGenerator kgen = KeyGenerator.getInstance(\"AES\");\n    SecureRandom sr = SecureRandom.getInstance(\"SHA1PRNG\");\n    sr.setSeed(seed);\n    kgen.init(128, sr); // 192 and 256 bits may not be available\n    SecretKey skey = kgen.generateKey();\n    byte[] raw = skey.getEncoded();\n    return raw;\n}\n\nprivate  byte[] encrypt(byte[] raw, byte[] clear) throws Exception {\n    SecretKeySpec skeySpec = new SecretKeySpec(raw, \"AES\");\n    Cipher cipher = Cipher.getInstance(\"AES\");\n    cipher.init(Cipher.ENCRYPT_MODE, skeySpec);\n    byte[] encrypted = cipher.doFinal(clear);\n    return encrypted;\n}\n\nprivate  byte[] decrypt(byte[] raw, byte[] encrypted) throws Exception {\n    SecretKeySpec skeySpec = new SecretKeySpec(raw, \"AES\");\n    Cipher cipher = Cipher.getInstance(\"AES\");\n    cipher.init(Cipher.DECRYPT_MODE, skeySpec);\n    byte[] decrypted = cipher.doFinal(encrypted);\n    return decrypted;\n}\n", "idx": 1892}
{"project": "cipher", "commit_id": "Snippet3814972_30891.java", "target": 1, "func": "public AESObfuscator(byte[] salt, String applicationId, String deviceId) {\n        Log.w(\"AESObfuscator\", \"constructor starting\");\n        try {\n            Log.w(\"AESObfuscator\", \"1\");\n            SecretKeyFactory factory = SecretKeyFactory.getInstance(KEYGEN_ALGORITHM);\n            Log.w(\"AESObfuscator\", \"2\");\n            KeySpec keySpec =\n                new PBEKeySpec((applicationId + deviceId).toCharArray(), salt, 1024, 256);\n            Log.w(\"AESObfuscator\", \"3\");\n            SecretKey tmp = factory.generateSecret(keySpec);\n            Log.w(\"AESObfuscator\", \"4\");\n            SecretKey secret = new SecretKeySpec(tmp.getEncoded(), \"AES\");\n            Log.w(\"AESObfuscator\", \"5\");\n            mEncryptor = Cipher.getInstance(CIPHER_ALGORITHM);\n            Log.w(\"AESObfuscator\", \"6\");\n            mEncryptor.init(Cipher.ENCRYPT_MODE, secret, new IvParameterSpec(IV));\n            Log.w(\"AESObfuscator\", \"7\");\n            mDecryptor = Cipher.getInstance(CIPHER_ALGORITHM);\n            Log.w(\"AESObfuscator\", \"8\");\n            mDecryptor.init(Cipher.DECRYPT_MODE, secret, new IvParameterSpec(IV));\n        } catch (GeneralSecurityException e) {\n            // This can't happen on a compatible Android device.\n            throw new RuntimeException(\"Invalid environment\", e);\n        }\n        Log.w(\"AESObfuscator\", \"constructor done\");\n    }\n", "idx": 2328}
{"project": "cipher", "commit_id": "Snippet33995233_16048.java", "target": 1, "func": "public String doEncryption(String data) {\n    try {\n\n        if (android.os.Build.VERSION.SDK_INT >= android.os.Build.VERSION_CODES.M) {\n            ce = Cipher.getInstance(\"AES/GCM/NoPadding\");\n            sKey = (SecretKey) ks.getKey(keyName, null);\n            ce.init(Cipher.ENCRYPT_MODE, sKey);\n        } else {\n\n        }\n\n        encodedData = ce.doFinal(data.getBytes());\n        mEncodedData = Base64.encodeToString(encodedData, Base64.DEFAULT);\n    } catch (Exception e) {\n        Log.e(\"Main\", \"RSA Encription Error.!\");\n        Log.e(\"MainActivity\", \"RSA Decryption Error.!\", e);\n    }\n    Log.e(\"Main\", \"encripted DATA =\" + mEncodedData);\n    return mEncodedData;\n}\n", "idx": 2008}
{"project": "cipher", "commit_id": "Snippet31944374_14005.java", "target": 1, "func": "public static void decrypt(String originalZipFileName, String newZipFileName, String privateKeyFileName) throws Exception {\n    byte[] buffer = new byte[128];  \n\n    ZipFile originalZipFile = new ZipFile(originalZipFileName); \n    ZipOutputStream newZipFile = new ZipOutputStream(new FileOutputStream(newZipFileName));\n\n    Enumeration<? extends ZipEntry> zipEntries = originalZipFile.entries();\n\n    String privateKey = getKeyString(privateKeyFileName);\n    PrivateKey key = makePrivateKey(privateKey);\n\n    Cipher cipher = Cipher.getInstance(\"RSA\");\n\n    cipher.init(Cipher.DECRYPT_MODE, key);\n\n\n    while(zipEntries.hasMoreElements()){\n\n        ZipEntry entry = zipEntries.nextElement();          \n\n        ZipEntry copy = new ZipEntry(entry.getName());      \n        newZipFile.putNextEntry(copy);\n\n\n        InputStream inputEntry = originalZipFile.getInputStream(entry);\n\n\n        while(inputEntry.read(buffer) != -1){\n            newZipFile.write(cipher.doFinal(buffer));\n        }\n\n        newZipFile.closeEntry();\n        inputEntry.close();\n    }\n    newZipFile.close();\n    originalZipFile.close();\n}\n", "idx": 2038}
{"project": "cipher", "commit_id": "Snippet12106782_36047.java", "target": 1, "func": "import java.security.NoSuchAlgorithmException;\nimport java.security.spec.InvalidKeySpecException;\nimport java.security.spec.KeySpec;\n\nimport javax.crypto.Cipher;\nimport javax.crypto.SecretKey;\nimport javax.crypto.SecretKeyFactory;\nimport javax.crypto.spec.IvParameterSpec;\nimport javax.crypto.spec.PBEKeySpec;\nimport javax.crypto.spec.SecretKeySpec;\n\nimport sun.security.provider.SecureRandom;\n\npublic class DerivationExample {\n\n  private static SecretKey makeKeyFromUserInput(String userInput, byte[] salt)\n      throws NoSuchAlgorithmException, InvalidKeySpecException {\n\n    SecretKeyFactory factory = SecretKeyFactory\n        .getInstance(\"PBKDF2WithHmacSHA1\");\n    KeySpec keySpec = new PBEKeySpec(userInput.toCharArray(), salt, 1024, 256);\n    byte[] derivedKey = factory.generateSecret(keySpec).getEncoded();\n    return new SecretKeySpec(derivedKey, \"AES\");\n  }\n\n  public static void main(String[] args) throws Exception {\n    String userInput = \"foo\";\n\n    // PBKDF2 standard recommends at least 64-bit salt\n    // Note: you want to randomly generate this elsewhere and keep it constant\n    byte[] salt = new byte[8];\n    new SecureRandom().engineNextBytes(salt);\n\n    SecretKey derivedKey = makeKeyFromUserInput(userInput, salt);\n\n    Cipher cipher = Cipher.getInstance(\"AES/CBC/PKCS5Padding\");\n    cipher.init(Cipher.ENCRYPT_MODE, derivedKey, new IvParameterSpec(\n        new byte[16]));\n\n    String plaintext = \"Hello, World!\";\n    byte[] cipherText = cipher.doFinal(plaintext.getBytes());\n\n    // Derive key again to demonstrate it is the same\n    SecretKey derivedKey2 = makeKeyFromUserInput(userInput, salt);\n    cipher.init(Cipher.DECRYPT_MODE, derivedKey2, new IvParameterSpec(\n        new byte[16]));\n\n    byte[] plainText = cipher.doFinal(cipherText);\n    // Prints \"Hello, World!\"\n    System.out.println(new String(plainText));\n  }\n}\n", "idx": 2032}
{"project": "cipher", "commit_id": "Snippet26029278_8249.java", "target": 1, "func": "public void RSADecrypt(String inFileName, String outFileName) {\n        try {\n            /* Get the encrypted message from file. */\n            FileInputStream cipherfile = new FileInputStream(inFileName);\n\n            byte[] ciphertext = new byte[cipherfile.available()];\n            cipherfile.read(ciphertext);\n            cipherfile.close();         \n            PrivateKey privatekey =readPrivateKeyFromFile(\"D:\\\\Private.key\");\n\n            /* Create cipher for decryption. */\n            Cipher decrypt_cipher = Cipher.getInstance(\"RSA/ECB/PKCS1Padding\");\n            decrypt_cipher.init(Cipher.DECRYPT_MODE, privatekey);\n            FileOutputStream plainfile = new FileOutputStream(outFileName);\n            int n = ciphertext.length / 128;\n            System.out.println(\"len: \" + n);\n            byte[] data1 = new byte[128];\n            for (int i = 0; i < n; i++) {\n                for (int j = 0; j < 128; j++) {\n                    data1[j] = ciphertext[128 * i + j];\n                }\n                byte[] descryptedData = decrypt_cipher.doFinal(data1);\n                plainfile.write(descryptedData);\n\n            }\n\n            plainfile.close();\n        } catch (Exception e) {\n            e.printStackTrace();\n        }\n    }\npublic PrivateKey readPrivateKeyFromFile(String fileName)\n            throws IOException {\n        FileInputStream fis = null;\n        ObjectInputStream ois = null;\n        try {\n            fis = new FileInputStream(new File(fileName));\n            ois = new ObjectInputStream(fis);\n\n            BigInteger modulus = (BigInteger) ois.readObject();\n            BigInteger exponent = (BigInteger) ois.readObject();\n\n            // Get Private Key\n            RSAPrivateKeySpec rsaPrivateKeySpec = new RSAPrivateKeySpec(\n                    modulus, exponent);\n            KeyFactory fact = KeyFactory.getInstance(\"RSA\");\n            PrivateKey privateKey = fact.generatePrivate(rsaPrivateKeySpec);\n            System.out.println(\"get key ok: \" + privateKey.toString());\n            return privateKey;\n\n        } catch (Exception e) {\n            e.printStackTrace();\n        } finally {\n            if (ois != null) {\n                ois.close();\n                if (fis != null) {\n                    fis.close();\n                }\n            }\n        }\n        return null;\n    }\n", "idx": 2227}
{"project": "cipher", "commit_id": "Snippet24009707_6315.java", "target": 0, "func": "public class CBCTest {\n    public static void main(String[] args) throws Exception {\n        Cipher cc = Cipher.getInstance(\"DES/CBC/NoPadding\");\n        Key k = new SecretKeySpec(new byte[] {1,1,1,1,1,1,1,1}, \"DES\");\n        cc.init(Cipher.ENCRYPT_MODE, k);\n        byte[] data = new byte[]{1,2,3,4,5,6,7,8};\n        cc.doFinal(data);\n        System.out.println(\"Encrypted: \" + Arrays.toString(cc.doFinal(data)));\n    }\n}\n", "idx": 1731}
{"project": "cipher", "commit_id": "Snippet27385370_9572.java", "target": 0, "func": "import java.security.InvalidKeyException;\nimport java.security.NoSuchAlgorithmException;\nimport java.util.Scanner;\n\nimport javax.crypto.BadPaddingException;\nimport javax.crypto.Cipher;\nimport javax.crypto.IllegalBlockSizeException;\nimport javax.crypto.NoSuchPaddingException;\nimport javax.crypto.spec.SecretKeySpec;\n\n\npublic class Encrypt2 {\n\npublic static void main(String[] args) throws InvalidKeyException, IllegalBlockSizeException, BadPaddingException, NoSuchAlgorithmException, NoSuchPaddingException {\n    // TODO Auto-generated method stub\n\n    Encrypt();\n    Decrypt();\n\n}\n\n\npublic static void Encrypt() throws IllegalBlockSizeException, BadPaddingException, NoSuchAlgorithmException, NoSuchPaddingException, InvalidKeyException{\n\n    Scanner input = new Scanner(System.in);\n\n    System.out.println(\"Please enter a message you'd like to encrypt\");\n    String plaintext = input.nextLine();\n\n    System.out.println(\"Please enter a 16 digit password: \");\n    String pass = input.nextLine();\n\n    byte[] key = pass.getBytes();\n    SecretKeySpec aesKey = new SecretKeySpec(key, \"AES\");\n\n    Cipher aesCipher;\n\n    // Create the cipher \n    aesCipher = Cipher.getInstance(\"AES/ECB/PKCS5Padding\");\n\n    // Initialize the cipher for encryption\n    aesCipher.init(Cipher.ENCRYPT_MODE, aesKey);\n\n    //sensitive information\n    byte[] text = plaintext.getBytes();\n\n    System.out.println(\"Text [Byte Format] : \" + text);\n    System.out.println(\"Text : \" + new String(text));\n\n    // Encrypt the text\n    byte[] textEncrypted = aesCipher.doFinal(text);\n\n    System.out.println(\"Text Encryted : \" + textEncrypted);\n\n}\npublic static void Decrypt() throws NoSuchAlgorithmException, NoSuchPaddingException, InvalidKeyException, IllegalBlockSizeException, BadPaddingException{\n\n     Scanner input = new Scanner(System.in);\n\n     System.out.println(\"Please enter a message you'd like to decrypt\");\n        String ciphertext = input.nextLine();\n        byte[] textEncrypted = ciphertext.getBytes();\n\n\n        System.out.println(\"Please enter a 16 digit password: \");\n        String passw = input.nextLine();\n\n\n        byte[] key = passw.getBytes();\n        SecretKeySpec aesKey = new SecretKeySpec(key, \"AES\");\n\n        Cipher aesCipher;\n\n        // Create the cipher \n        aesCipher = Cipher.getInstance(\"AES/ECB/PKCS5Padding\");\n        String pass = input.nextLine(); // Initialize the same cipher for decryption\n        aesCipher.init(Cipher.DECRYPT_MODE, aesKey);\n\n        // Decrypt the text\n        byte[] textDecrypted = aesCipher.doFinal(textEncrypted);\n\n        System.out.println(\"Text Decryted : \" + new String(textDecrypted));\n}\n}\n", "idx": 1580}
{"project": "cipher", "commit_id": "Snippet19425603_2218.java", "target": 1, "func": "mDecipher = Cipher.getInstance(\"AES/CBC/PKCS5Padding\");\n", "idx": 2023}
{"project": "cipher", "commit_id": "Snippet8644989_33401.java", "target": 0, "func": "import java.security.MessageDigest;\nimport java.util.Arrays;\n\nimport javax.crypto.Cipher;\nimport javax.crypto.SecretKey;\nimport javax.crypto.spec.IvParameterSpec;\nimport javax.crypto.spec.SecretKeySpec;\n\n\n\nclass ZiggyTest2{\n\n\n        public static void main(String[] args) throws Exception{  \n            String text = \"I am sunil\";\n\n            byte[] codedtext = new ZiggyTest2().encrypt(text);\n            String decodedtext = new ZiggyTest2().decrypt(codedtext);\n\n            System.out.println(codedtext); // this is a byte array, you'll just see a reference to an array\n            System.out.println(decodedtext); // This correctly shows \"kyle boon\"\n        }\n\n        public byte[] encrypt(String message) throws Exception {\n            MessageDigest md = MessageDigest.getInstance(\"md5\");\n            byte[] digestOfPassword = md.digest(\"ABCDEABCDE\"\n                            .getBytes(\"utf-8\"));\n            byte[] keyBytes = Arrays.copyOf(digestOfPassword, 24);\n            for (int j = 0, k = 16; j < 8;) {\n                    keyBytes[k++] = keyBytes[j++];\n            }\n\n            SecretKey key = new SecretKeySpec(keyBytes, \"DESede\");\n            IvParameterSpec iv = new IvParameterSpec(new byte[8]);\n            Cipher cipher = Cipher.getInstance(\"DESede/CBC/PKCS5Padding\");\n            cipher.init(Cipher.ENCRYPT_MODE, key, iv);\n\n            byte[] plainTextBytes = message.getBytes(\"utf-8\");\n            byte[] cipherText = cipher.doFinal(plainTextBytes);\n            // String encodedCipherText = new sun.misc.BASE64Encoder()\n            // .encode(cipherText);\n\n            return cipherText;\n        }\n\n        public String decrypt(byte[] message) throws Exception {\n            MessageDigest md = MessageDigest.getInstance(\"md5\");\n            byte[] digestOfPassword = md.digest(\"ABCDEABCDE\"\n                            .getBytes(\"utf-8\"));\n            byte[] keyBytes = Arrays.copyOf(digestOfPassword, 24);\n            for (int j = 0, k = 16; j < 8;) {\n                    keyBytes[k++] = keyBytes[j++];\n            }\n\n            SecretKey key = new SecretKeySpec(keyBytes, \"DESede\");\n            IvParameterSpec iv = new IvParameterSpec(new byte[8]);\n            Cipher decipher = Cipher.getInstance(\"DESede/CBC/PKCS5Padding\");\n            decipher.init(Cipher.DECRYPT_MODE, key, iv);\n\n            byte[] plainText = decipher.doFinal(message);\n\n            return new String(plainText, \"UTF-8\");\n        }\n    }\n", "idx": 1598}
{"project": "cipher", "commit_id": "Snippet32197342_14314.java", "target": 1, "func": "import javax.crypto.Cipher;\n\nString payload = \"something\";\npublic static void main(String[] args) throws Exception {\n    String dig = makeDigest(payload, \"SHA-1\");\n    Key k = getKey();\n    String signature = encrypt(dig, \"RSA/ECB/PKCS1Padding\", k);\n    System.out.print(signature);\n}\n\npublic static String makeDigest(String payload, String digestAlgo) {\n    String strDigest = \"\";\n    try {\n        MessageDigest md = MessageDigest.getInstance(digestAlgo);\n        byte[] p_b = payload.getBytes(\"UTF-8\");\n        md.update(p_b);\n        byte[] digest = md.digest();\n        byte[] encoded = Hex.encode(digest);\n        strDigest = new String(encoded);\n    }\n    catch (Exception ex) {\n        ex.printStackTrace();\n    }\n    return strDigest;\n}\n\npublic static String encrypt(String sha, String encryptAlgo, Key k) {\n    String strEncrypted = \"\";\n    try {\n        Cipher cipher = Cipher.getInstance(encryptAlgo);\n        cipher.init(Cipher.ENCRYPT_MODE, k);\n        byte[] encrypted = cipher.doFinal(sha.getBytes(\"UTF-8\"));\n        byte[] encoded = Hex.encode(encrypted);\n        strEncrypted = new String(encoded);\n    }\n    catch (Exception ex) {\n        ex.printStackTrace();\n    }\n    return strEncrypted;\n}\n", "idx": 2054}
{"project": "cipher", "commit_id": "Snippet11272575_35430.java", "target": 0, "func": "Cipher cipher = Cipher.getInstance(\"DES/CBC/PKCS5Padding\");\n\ncipher.init(Cipher.ENCRYPT_MODE, key, ivSpec);\n", "idx": 1663}
{"project": "cipher", "commit_id": "Snippet37803710_19795.java", "target": 1, "func": "public static String encrypt(String input, String key){\n    byte[] crypted = null;\n\n    SecretKeySpec skey = new SecretKeySpec(getHash(\"MD5\", key), \"AES\");\n    IvParameterSpec iv = new IvParameterSpec(new byte[] { 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0 });\n    Cipher cipher = Cipher.getInstance(\"AES/CBC/PKCS5Padding\");\n    cipher.init(Cipher.ENCRYPT_MODE, skey, iv);\n    crypted = cipher.doFinal(input.getBytes());\n    return new String(Base64.encodeBase64(crypted));\n}\n\n private static byte[] getHash(String algorithm, String text) {\n    try {\n        byte[] bytes = text.getBytes(\"UTF-8\");\n        final MessageDigest digest = MessageDigest.getInstance(algorithm);\n        digest.update(bytes);\n        return digest.digest();\n    } catch (final Exception ex) {\n        throw new RuntimeException(ex.getMessage());\n    }\n}\n", "idx": 2083}
{"project": "cipher", "commit_id": "Snippet27955414_10118.java", "target": 1, "func": "import codec.Base64;\nimport codec.CorruptedCodeException;\nimport java.security.InvalidKeyException;\nimport java.security.KeyFactory;\nimport java.security.NoSuchAlgorithmException;\nimport java.security.NoSuchProviderException;\nimport java.security.PrivateKey;\nimport java.security.Security;\nimport java.security.spec.InvalidKeySpecException;\nimport java.security.spec.PKCS8EncodedKeySpec;\nimport javax.crypto.BadPaddingException;\nimport javax.crypto.Cipher;\nimport javax.crypto.IllegalBlockSizeException;\nimport javax.crypto.NoSuchPaddingException;\nimport org.bouncycastle.jce.provider.BouncyCastleProvider;\n...\n    Security.addProvider(new BouncyCastleProvider());\n// Assume that we know the encoded private key\n    byte[] decodedPrivate = Base64.decode(\"MHECAQAwFAYHKoZIzj0CAQYJKyQDAwIIAQEBBFYwVAIBAQQUQmA9ifs472gNHBc5NSGYq56TlOKgCwYJKyQDAwIIAQEBoSwDKgAE1dyVya1S3z+uUY3julzxmnGRaA2C0p54d2xUPSQhYtQwRQudyEZk8A==\".getBytes());\n\n    PKCS8EncodedKeySpec formatted_private = new PKCS8EncodedKeySpec(decodedPrivate);\n    KeyFactory kf = KeyFactory.getInstance(\"EC\", \"BC\");\n    PrivateKey privKey = kf.generatePrivate(formatted_private);\n\n    Cipher c = Cipher.getInstance(\"ECIES\");\n    c.init(Cipher.DECRYPT_MODE, privKey); //How can i adding the **AES128_CBC** ies param ?\n\n// Assume that we know the encoded cipher text\n    byte[] plaintext = c.doFinal(Base64.decode(\"BKbCsKY7gDPld+F4jauQXvKSayYCt6vOjIGbsyXo5fHWo4Ax+Nt5BQ5FlkAGksFNRQ46agzfxjfuoxWkVfnt4gReDmpPYueUbiRiHp1Gwp0=\"));\n    System.out.println(\"\\nPlaintext : \"+ new String (plaintext));\n...\n", "idx": 2255}
{"project": "cipher", "commit_id": "Snippet26651771_8765.java", "target": 0, "func": "KeyGenerator keyGenerator = KeyGenerator.getInstance(\"RC4\");\nSecretKey secretKey = keyGenerator.generateKey();\nCipher cipher = Cipher.getInstance(\"RC4\");  \nString mainKey=secretKey.toString();\nString cipherkey=cipher.toString());\n", "idx": 1610}
{"project": "cipher", "commit_id": "Snippet24066679_6375.java", "target": 1, "func": "package aes;\n\nimport javax.crypto.*;\nimport javax.crypto.spec.IvParameterSpec;\nimport javax.crypto.spec.SecretKeySpec;\nimport javax.swing.JOptionPane;\nimport java.util.Date;\nimport java.text.DateFormat;\nimport java.text.SimpleDateFormat;\n\npublic class EncryptionExample {\n\nprivate static SecretKeySpec    key;\nprivate static IvParameterSpec  ivSpec;\nprivate static Cipher           cipher; \nprivate static byte[]           keyBytes;\nprivate static byte[]           ivBytes;\nprivate static int              enc_len;\n\npublic static void generateKey() throws Exception\n        {\n\n            String complex = new String (\"9#82jdkeo!2DcASg\");\n            keyBytes = complex.getBytes();\n            key = new SecretKeySpec(keyBytes, \"AES\");\n\n            complex = new String(\"@o9kjbhylK8(kJh7\"); //just some randoms, for now\n            ivBytes = complex.getBytes();\n            ivSpec = new IvParameterSpec(ivBytes);\n\n            cipher = Cipher.getInstance(\"AES/CBC/PKCS5Padding\");\n        }\n\n        public static String encrypt(String packet) throws Exception\n        {\n            byte[] packet2 = packet.getBytes();\n            cipher.init(Cipher.ENCRYPT_MODE, key, ivSpec);\n            byte[] encrypted = new byte[cipher.getOutputSize(packet2.length)];\n            enc_len = cipher.update(packet2, 0, packet2.length, encrypted, 0);\n            enc_len += cipher.doFinal(encrypted, enc_len);\n\n            return packet = new String(encrypted);\n        }\n\n        public static String decrypt(String packet) throws Exception\n        {\n            byte[] packet2 = packet.getBytes();\n            cipher.init(Cipher.DECRYPT_MODE, key, ivSpec);\n            byte[] decrypted = new byte[cipher.getOutputSize(enc_len)];\n            int dec_len = cipher.update(packet2, 0, enc_len, decrypted, 0);\nHERE EXCEPTION>>>>> dec_len += cipher.doFinal(decrypted, dec_len);  <<<<<<<<<\n\n            return packet = new String(decrypted);\n        }\n\n\n        // and display the results\n    public static void main (String[] args) throws Exception \n    {\n\n          // get the text to encrypt\n        generateKey();\n        String inputText = JOptionPane.showInputDialog(\"Input your message: \");\n\n        String encrypted = encrypt(inputText);\n        String decrypted = decrypt(encrypted);            \n\n        JOptionPane.showMessageDialog(JOptionPane.getRootFrame(),\n                    \"Encrypted:  \" + new String(encrypted) + \"\\n\"\n                      +  \"Decrypted: : \" + new String(decrypted));\n          .exit(0);\n    }\n}\n", "idx": 1992}
{"project": "cipher", "commit_id": "Snippet29029410_11091.java", "target": 0, "func": "public class FileLogger {\n\n//file and folder name\npublic static String LOG_FILE_NAME = \"my_log.txt\";\npublic static String LOG_FOLDER_NAME = \"my_log_folder\";\n\nstatic SimpleDateFormat formatter = new SimpleDateFormat(\"yyyy-MM-dd_HH-mm-ss_SSS\");\n\n//My secret key, 16 bytes = 128 bit\nstatic byte[] key = {1,2,3,4,5,6,7,8,9,0,1,2,3,4,5,6};\n\n//Appends to a log file, using encryption\npublic static void appendToLog(Context context, Object msg) {\n\n    String msgStr;\n    String timestamp = \"t:\" + formatter.format(new java.util.Date());\n\n    msgStr = msg + \"|\" + timestamp + \"\\n\";\n\n    File sdcard = Environment.getExternalStorageDirectory();\n    File dir = new File(sdcard.getAbsolutePath() + \"/\" + LOG_FOLDER_NAME);\n    if (!dir.exists()) {\n        dir.mkdir();\n    }\n\n    File encryptedFile = new File(dir, LOG_FILE_NAME);\n\n    try {\n\n        //Encryption using my key above defined\n        Key secretKey = new SecretKeySpec(key, \"AES\");\n        Cipher cipher = Cipher.getInstance(\"AES\");\n        cipher.init(Cipher.ENCRYPT_MODE, secretKey);\n\n        byte[] outputBytes = cipher.doFinal(msgStr.getBytes());\n\n        //Writing to the file using append mode\n        FileOutputStream outputStream = new FileOutputStream(encryptedFile, true);\n        outputStream.write(outputBytes);\n        outputStream.close();\n\n\n    } catch (FileNotFoundException e) {\n        e.printStackTrace();\n    } catch (IOException e) {\n        e.printStackTrace();\n    } catch (NoSuchAlgorithmException e) {\n        e.printStackTrace();\n    } catch (NoSuchPaddingException e) {\n        e.printStackTrace();\n    } catch (IllegalBlockSizeException e) {\n        e.printStackTrace();\n    } catch (BadPaddingException e) {\n        e.printStackTrace();\n    } catch (InvalidKeyException e) {\n        e.printStackTrace();\n    }\n\n}\n\n}\n", "idx": 1858}
{"project": "cipher", "commit_id": "Snippet38062041_20058.java", "target": 1, "func": "import javax.crypto.Cipher;\nimport javax.xml.bind.DatatypeConverter;\nimport java.security.Key;\nimport java.security.KeyPair;\nimport java.security.KeyPairGenerator;\nimport java.security.KeyStore;\nimport java.security.cert.Certificate;\n\npublic class Main {\n\n    public static void main(String[] args) {\n\n        byte[] txt = \"This is a secret message for your own eyes only\".getBytes();\n        byte[] encText;\n        try{\n\n            // Load the keystore\n            KeyStore ks = KeyStore.getInstance(KeyStore.getDefaultType());\n            char[] password = \"keystorePassword\".toCharArray();\n            java.io.FileInputStream fis = new java.io.FileInputStream(\"/path/to/keystore/myKeyStore.jks\");\n            ks.load(fis, password);\n            fis.close();\n\n            Key rsakey = ks.getKey(\"mykeyalias\", password);\n            Cipher cipher = Cipher.getInstance(\"RSA/ECB/PKCS1Padding\");\n\n            // Encrypt\n            Certificate cert = ks.getCertificate(\"mykeyalias\");\n            try\n            {\n                cipher.init(Cipher.ENCRYPT_MODE, cert.getPublicKey());\n                encText = cipher.doFinal(txt);\n                System.out.println(encText.toString());\n            }\n            catch (Throwable e)\n            {\n                e.printStackTrace();\n                return;\n            }\n\n            // Decrypt\n            cipher.init(Cipher.DECRYPT_MODE, rsakey);\n            String decrypted = new String(cipher.doFinal(encText));\n            System.out.println(decrypted);\n\n\n        } catch (Exception e) {\n            System.out.println(\"error\" + e);\n        }\n}\n", "idx": 2253}
{"project": "cipher", "commit_id": "Snippet45518870_27589.java", "target": 1, "func": "* \n    /**\n     * \n     */\n    package in.bets.gsm.util;\n\n    import javax.crypto.Cipher;\n    import javax.crypto.spec.IvParameterSpec;\n    import javax.crypto.spec.SecretKeySpec;\n\n    import org.apache.commons.codec.binary.Base64;\n\n    /**\n     * @author VKatz\n     *\n     */\n    public class SecurePath {\n\n        /**\n         * \n         */\n        public SecurePath() {\n            // TODO Auto-generated constructor stub\n        }\n\n        public static String key = \"Bar12345Bar12345\";\n        public static String initVector = \"RandomInitVector\"; \n\n        public static String encrypt(String value) {\n            try {\n                IvParameterSpec iv = new IvParameterSpec(initVector.getBytes(\"UTF-8\"));\n                SecretKeySpec [skeySpec][4] = new SecretKeySpec(key.getBytes(\"UTF-8\"), \"AES\");\n\n                Cipher cipher = Cipher.getInstance(\"AES/CBC/PKCS5PADDING\");\n                cipher.init(Cipher.ENCRYPT_MODE, skeySpec, iv);\n\n                byte[] encrypted = cipher.doFinal(value.getBytes());\n                System.out.println(\"encrypted string: \"\n                        + Base64.encodeBase64String(encrypted));\n\n                return Base64.encodeBase64String(encrypted);\n            } catch (Exception ex) {\n                ex.printStackTrace();\n            }\n\n            return null;\n        }\n\n        public static String decrypt(String encrypted) {\n            try {\n                IvParameterSpec iv = new IvParameterSpec(initVector.getBytes(\"UTF-8\"));\n                SecretKeySpec skeySpec = new SecretKeySpec(key.getBytes(\"UTF-8\"), \"AES\");\n\n                Cipher cipher = Cipher.getInstance(\"AES/CBC/PKCS5PADDING\");\n                cipher.init(Cipher.DECRYPT_MODE, skeySpec, iv);\n\n                byte[] original = cipher.doFinal(Base64.decodeBase64(encrypted));\n\n                return new String(original);\n            } catch (Exception ex) {\n                ex.printStackTrace();\n            }\n\n            return null;\n        }\n\n    public static void main(String[] args) {\n\n            String encText = encrypt(\"abceeffslaj\");\n\n            System.out.println(\"Decripted text ::  \" + decrypt(\"XZy6gJinORmH+LOiZL6/Jw==\"));\n        }\n\n    }\n\n\n\nOutput: \nSimple Text ::\u2002\u2002abceeffslaj\nEncrypted\u2002\u2002text ::\u2002\u2002XZy6gJinORmH+LOiZL6/Jw==\nDecripted Text ::\u2002\u2002abceeffslaj\n", "idx": 2334}
{"project": "cipher", "commit_id": "Snippet47170338_29171.java", "target": 1, "func": "val cipher = Cipher.getInstance(\"AES/CBC/PKCS7Padding\")\nval key = keystore.getAlias(\"MyKey\", null)\n\nval iv = ByteArray(16)\nval random = SecureRandom()\nrandom.nextBytes(iv)\n\ncipher.init(Cipher.ENCRYPT_MODE, key, IvParameterSpec(iv))\n", "idx": 2180}
{"project": "cipher", "commit_id": "Snippet44632458_26741.java", "target": 1, "func": "public class AESFileEncryption {\npublic static void encrypt(String path,String pwd) throws Exception {\n\n    FileOutputStream outFile;\n\n    try ( \n            FileInputStream inFile = new FileInputStream(path)) {\n\n        String fileName=path;\n\n        System.out.println(path);\n\n        outFile = new FileOutputStream(fileName+\".aes\");\n        // password to encrypt the file\n        String password = pwd;\n        byte[] salt = {\n        (byte)0xc7, (byte)0x73, (byte)0x21, (byte)0x8c,\n        (byte)0x7e, (byte)0xc8, (byte)0xee, (byte)0x99\n       };\n\n        SecretKeyFactory factory = SecretKeyFactory\n                .getInstance(\"PBKDF2WithHmacSHA1\");\n        KeySpec keySpec = new PBEKeySpec(password.toCharArray(),salt,65536,128);// user-chosen password that can be used with password-based encryption (PBE).\n        SecretKey secretKey = factory.generateSecret(keySpec);\n        SecretKey secret = new SecretKeySpec(secretKey.getEncoded(), \"AES\");//Secret KeySpec is a class and implements inteface SecretKey\n\n        Cipher cipher = Cipher.getInstance(\"AES/CBC/PKCS5Padding\");\n        SecureRandom random = new SecureRandom();\n        byte bytes[] = new byte[16];\n        random.nextBytes(bytes);\n     IvParameterSpec ivspec = new IvParameterSpec(bytes);   \n        cipher.init(Cipher.ENCRYPT_MODE, secret,ivspec);//opmode,key\n        outFile.write(bytes);\n        byte[] input = new byte[64];\n        int bytesRead;\n        while ((bytesRead = inFile.read(input)) != -1) {\n            byte[] output = cipher.update(input, 0, bytesRead);\n            if (output != null)\n                Files.write(Paths.get(fileName+\".aes\"), output, StandardOpenOption.APPEND);\n\n        }   byte[] output = cipher.doFinal();\n        if (output != null)\n            Files.write(Paths.get(fileName+\".aes\"), output, StandardOpenOption.APPEND);\n    }\n    outFile.flush();\n    outFile.close();\n    File f=new File(path);\n    boolean x=f.delete();\n    if(x){\n        System.out.println(\"File deleted\");\n    }\n    JOptionPane.showMessageDialog(null,\"File Encrypted.\");\n\n}\n}\n", "idx": 2209}
{"project": "cipher", "commit_id": "Snippet31504348_13657.java", "target": 1, "func": "import java.nio.charset.Charset;\nimport java.security.AlgorithmParameters;\nimport java.security.SecureRandom;\n\nimport javax.crypto.Cipher;\nimport javax.crypto.KeyGenerator;\nimport javax.crypto.SecretKey;\nimport javax.crypto.spec.IvParameterSpec;\nimport javax.crypto.spec.SecretKeySpec;\n\nimport org.apache.commons.codec.binary.Base64;\n\n\n/*\n* This software is provided 'as-is', without any express or implied\n* warranty.  In no event will Google be held liable for any damages\n* arising from the use of this software.\n*\n* Permission is granted to anyone to use this software for any purpose,\n* including commercial applications, and to alter it and redistribute it\n* freely, as long as the origin is not misrepresented.\n* \n* @author: Ricardo Champa\n* \n*/\n\npublic class MyCipher {\n\n    private final static String ALGORITHM = \"AES\";\n    private String mySecret;\n\n    public MyCipher(String mySecret){\n        this.mySecret = mySecret;\n    }\n\n    public MyCipherData encryptUTF8(String data){\n        try{\n            byte[] bytes = data.toString().getBytes(\"utf-8\");\n            byte[] bytesBase64 = Base64.encodeBase64(bytes);\n            return encrypt(bytesBase64);\n        }\n        catch(Exception e){\n            MyLogs.show(e.getMessage());\n            return null;\n        }\n\n    }\n\n    public String decryptUTF8(byte[] encryptedData, IvParameterSpec iv){\n        try {\n            byte[] decryptedData = decrypt(encryptedData, iv);\n            byte[] decodedBytes = Base64.decodeBase64(decryptedData);\n            String restored_data = new String(decodedBytes, Charset.forName(\"UTF8\"));\n            return restored_data;\n        } catch (Exception e) {\n            MyLogs.show(e.getMessage());;\n            return null;\n        }\n    }\n\n    //AES\n    private MyCipherData encrypt(byte[] raw, byte[] clear) throws Exception {\n        SecretKeySpec skeySpec = new SecretKeySpec(raw, ALGORITHM);\n        Cipher cipher = Cipher.getInstance(\"AES/CBC/PKCS5Padding\");\n        //solved using PRNGFixes class\n        cipher.init(Cipher.ENCRYPT_MODE, skeySpec);\n        byte[] data = cipher.doFinal(clear);\n\n        AlgorithmParameters params = cipher.getParameters();\n        byte[] iv = params.getParameterSpec(IvParameterSpec.class).getIV();\n        return new MyCipherData(data, iv);\n    }\n\n    private byte[] decrypt(byte[] raw, byte[] encrypted, IvParameterSpec iv) throws Exception {\n        SecretKeySpec skeySpec = new SecretKeySpec(raw, ALGORITHM);\n        Cipher cipher = Cipher.getInstance(\"AES/CBC/PKCS5Padding\");\n        cipher.init(Cipher.DECRYPT_MODE, skeySpec, iv);\n        byte[] decrypted = cipher.doFinal(encrypted);\n        return decrypted;\n    }\n\n    private byte[] getKey() throws Exception{\n        byte[] keyStart = this.mySecret.getBytes(\"utf-8\");\n        KeyGenerator kgen = KeyGenerator.getInstance(ALGORITHM);\n\n        SecureRandom sr = SecureRandom.getInstance(\"SHA1PRNG\", \"Crypto\");\n        //      if (android.os.Build.VERSION.SDK_INT >= 17) {\n        //          sr = SecureRandom.getInstance(\"SHA1PRNG\", \"Crypto\");\n        //      } else {\n        //          sr = SecureRandom.getInstance(\"SHA1PRNG\");\n        //      }\n        sr.setSeed(keyStart);\n        kgen.init(128, sr); // 192 and 256 bits may not be available\n        SecretKey skey = kgen.generateKey();\n        byte[] key = skey.getEncoded();\n        return key;\n\n    }\n    ////////////////////////////////////////////////////////////\n    private MyCipherData encrypt(byte[] data) throws Exception{\n        return encrypt(getKey(),data);\n    }\n    private byte[] decrypt(byte[] encryptedData, IvParameterSpec iv) throws Exception{\n        return decrypt(getKey(),encryptedData, iv);\n    }\n}\n", "idx": 2289}
{"project": "cipher", "commit_id": "Snippet42683230_24716.java", "target": 0, "func": "    // Generate double length 3DES Master Key\n    KeyGenerator masterEncKeyGenerator = KeyGenerator.getInstance(\"DESede\");\n    masterEncKeyGenerator.init(112);\n    SecretKey masterKey = masterEncKeyGenerator.generateKey();\n\n    //Prepare random bytes\n    byte[] randomKeyValue = \"rn4yrbdy\".getBytes();\n\n    // Encrypt random bytes with the 3DES Master key\n    final Cipher cipher = Cipher.getInstance(\"DESede/ECB/PKCS5Padding\");\n    cipher.init(Cipher.ENCRYPT_MODE, masterKey);\n    byte[] encryptedRandomValue = cipher.doFinal(randomKeyValue);\n\n    // Derive new key 3DES Key\n    SecretKeyFactory mySecretKeyFactory = SecretKeyFactory.getInstance(\"DESede\");\n    DESedeKeySpec myKeySpec = new DESedeKeySpec(encryptedRandomValue);\n    SecretKey derivedKey = mySecretKeyFactory.generateSecret(myKeySpec);\n", "idx": 1901}
{"project": "cipher", "commit_id": "Snippet28545920_10707.java", "target": 1, "func": "Cipher cipher = Cipher.getInstance(\"RSA/None/PKCS1Padding\");\n", "idx": 1998}
{"project": "cipher", "commit_id": "Snippet33505223_15558.java", "target": 0, "func": "public byte[] createMac(byte[] fileBytes, String nick){\n    byte[] mac = null;\n    byte[] digest;\n    try {\n        MessageDigest md = MessageDigest.getInstance(\"SHA-256\");\n        md.update(fileBytes);\n        digest = md.digest();\n\n        KeyFactory keyFactory = KeyFactory.getInstance(\"DH\");\n\n        byte[] myPrivateKey = Files.readAllBytes(Paths.get(dirMyKeys+\"//dhPrivateKey.txt\"));\n        PrivateKey dhPrivKey = keyFactory.generatePrivate(new PKCS8EncodedKeySpec(myPrivateKey));\n\n\n        byte[] myPublicKey = Files.readAllBytes(Paths.get(dirKeys+\"/\"+nick+\"DhPublicKey.txt\"));\n        System.out.println(dirKeys+\"/\"+nick+\"DhPublicKey.txt\");\n        PublicKey dhPubKey = keyFactory.generatePublic(new X509EncodedKeySpec(myPublicKey));\n\n        SecretKey secretKey = combine(dhPrivKey, dhPubKey);\n\n        Cipher cipher = Cipher.getInstance(\"AES\");\n        System.out.println( \"\\nStart decryption\" );\n        cipher.init(Cipher.ENCRYPT_MODE, secretKey);\n        mac = cipher.doFinal(digest);\n        System.out.println( \"Finish decryption: \" );\n\n        return mac;\n\n    } catch (NoSuchAlgorithmException | IOException | InvalidKeySpecException | InvalidKeyException | IllegalBlockSizeException | BadPaddingException | NoSuchPaddingException ex) {\n        Logger.getLogger(Client.class.getName()).log(Level.SEVERE, null, ex);\n    }\n    return mac;\n}\n\nprivate static SecretKey combine(PrivateKey private1, PublicKey public1) throws NoSuchAlgorithmException, InvalidKeyException  {\n    KeyAgreement ka = KeyAgreement.getInstance(\"DH\");\n    ka.init(private1);\n    //error on this line\n    ka.doPhase(public1, true);\n    SecretKey secretKey = ka.generateSecret(\"DES\");\n    return secretKey;\n}\n", "idx": 1624}
{"project": "cipher", "commit_id": "Snippet41737517_23701.java", "target": 1, "func": "public static void encryptFile() {\n    File file = new File(Environment.getExternalStorageDirectory().getPath() + \"/\" + TARGET_FILE);\n\n    FileInputStream fileInputStream;\n    FileOutputStream fileOutputStream;\n\n    byte[] buffer = new byte[1024 * 8];\n\n    IvParameterSpec ivParameterSpec = new IvParameterSpec(\"1234567890123456\".getBytes());\n\n    byte[] key = \"only for testing\".getBytes();\n    MessageDigest sha;\n    try {\n        sha = MessageDigest.getInstance(\"SHA-1\");\n        key = sha.digest(key);\n    } catch (NoSuchAlgorithmException e) {\n        e.printStackTrace();\n    }\n    key = Arrays.copyOf(key, 16); // use only first 128 bit\n\n    SecretKeySpec secretKeySpec = new SecretKeySpec(key, \"AES\");\n\n    try {\n        fileInputStream = new FileInputStream(file);\n        fileOutputStream = new FileOutputStream(Environment.getExternalStorageDirectory().getPath() + \"/\" + ENCRYPT_FILE);\n\n        Cipher cipher = Cipher.getInstance(\"AES/CBC/PKCS5Padding\");\n        cipher.init(Cipher.ENCRYPT_MODE, secretKeySpec, ivParameterSpec);\n\n        //CipherOutputStream cipherOutputStream = new CipherOutputStream(fileOutputStream, cipher);\n\n        int read;\n\n        while ((read = fileInputStream.read(buffer)) > 0) {\n            Log.i(TAG, \"encrypt read= \" + read);\n\n            byte[] encryptedData = cipher.doFinal(buffer);\n            if (encryptedData != null) {\n                Log.i(TAG, \"encrypted size= \" + encryptedData.length);\n                fileOutputStream.write(encryptedData, 0, read);\n            }\n\n            //cipherOutputStream.write(buffer, 0, buffer.length);\n        }\n        //cipherOutputStream.flush();\n        //cipherOutputStream.close();\n        fileInputStream.close();\n        fileOutputStream.close();\n\n    } catch (IOException | NoSuchAlgorithmException | NoSuchPaddingException\n            | IllegalBlockSizeException | BadPaddingException\n            | InvalidAlgorithmParameterException | InvalidKeyException e) {\n        e.printStackTrace();\n    }\n}\n", "idx": 2074}
{"project": "cipher", "commit_id": "Snippet14260734_37598.java", "target": 0, "func": "import javax.crypto.Cipher;\nimport javax.crypto.spec.SecretKeySpec;\n\nimport org.apache.commons.codec.binary.Base64;\n\npublic class EncryptDecryptExample\n{\n    // \"thisIsASecretKey\";\n    private static byte[] key = { 0x74, 0x68, 0x69, 0x73, 0x49, 0x73, 0x41, 0x53, 0x65, 0x63, 0x72, 0x65, 0x74, 0x4b, 0x65,\n            0x79 };\n\n    public static void main(String[] args) throws Exception\n    {\n        //********************WORKS**********************\n        String x = \"Hello\";\n        System.out.println(\"Plain Text: \" + x);\n        String e = EncryptString(x);\n        System.out.println(\"Encrypted: \" + e);\n        String d = decryptString(e);\n        System.out.println(\"Deccypted: \" + d);\n\n        //********************WORKS**********************\n        Byte b = 124;\n        System.out.println(\"Plain Byte: \"+b.toString());\n        String eb = EncryptString(b.toString());\n        System.out.println(\"Encrypted Byte: \"+eb);\n        String bd = decryptString(eb);\n        System.out.println(\"Decrypted Byte: \"+bd);\n\n        //********************DOESNT*WORK*********************\n        Byte[] bArray = {23, 42, 55};\n        System.out.println(\"Plain Byte Array: \"+bArray[0].toString()+\",\"+bArray[1].toString()+\",\"+bArray[2].toString());\n        String eba = EncryptString(bArray.toString());\n        System.out.println(\"Encrypted Byte Array: \"+eba.toString());\n        String deba = decryptString(eba.toString());\n        System.out.println(\"Decrypted Byte Array: \"+deba.getBytes()[0]);  //<--- Doesn't work\n        //*********************************************\n    }\n\n    public static String EncryptString(String strToEncrypt) throws Exception\n    {\n        Cipher cipher = Cipher.getInstance(\"AES/ECB/PKCS5Padding\");\n        SecretKeySpec secretKey = new SecretKeySpec(key, \"AES\");\n        cipher.init(Cipher.ENCRYPT_MODE, secretKey);\n        String encryptedString = Base64.encodeBase64String(cipher.doFinal(strToEncrypt.getBytes()));\n        return encryptedString;\n    }\n\n    public static String decryptString(String strToDecrypt) throws Exception\n    {\n        Cipher cipher = Cipher.getInstance(\"AES/ECB/PKCS5PADDING\");\n        SecretKeySpec secretKey = new SecretKeySpec(key, \"AES\");\n        cipher.init(Cipher.DECRYPT_MODE, secretKey);\n        String decryptedString = new String(cipher.doFinal(Base64.decodeBase64(strToDecrypt)));\n        return decryptedString;\n    }\n\n}\n", "idx": 1911}
{"project": "cipher", "commit_id": "Snippet4663912_31254.java", "target": 1, "func": "long start = System.currentTimeMillis()/1000L;\n            try {\n                SecretKeySpec skeySpec = new SecretKeySpec(key, \"AES\");\n                Cipher cipher = Cipher.getInstance(\"AES/CBC/PKCS5Padding\");\n                cipher.init(Cipher.DECRYPT_MODE, skeySpec, ivspec);\n\n                 android.util.Log.d(\"TEST\", \"Start decoding....\" + String.valueOf(length));\n\n                byte[] decrypted = cipher.doFinal(content);\n\n                File file2 = new File(Environment.getExternalStorageDirectory().getPath() + \"/test.mp3\");\n                OutputStream os = new FileOutputStream(file2);\n                os.write(decrypted);\n            } catch (Exception ex) {\n                ex.printStackTrace();\n            }\n            long end = System.currentTimeMillis()/1000L;\n\n            android.util.Log.d(\"TEST\",\"Time \"+ String.valueOf(end-start));\n", "idx": 1999}
{"project": "cipher", "commit_id": "Snippet40388427_22254.java", "target": 1, "func": "class Crypt {\n\nprivate final String TAG = Crypt.class.getSimpleName();\n\nprivate String seedValue = \"\";\nprivate String ivValue = \"\";\n\nprivate Context c;\n\nCrypt() {\n    if (!checkKeys() && c != null) {\n        generateKeys();\n    } else {\n        Log.d(TAG, \"No context - can't generate keys\");\n    }\n}\n\nCrypt(Context c) {\n    this.c = c;\n    if (!checkKeys()) {\n        generateKeys();\n    } else {\n        SharedPreferences seed = c.getSharedPreferences(\"Seed\", Context.MODE_PRIVATE);\n        seedValue = seed.getString(\"SeedKey\", \"\");\n        SharedPreferences iv = c.getSharedPreferences(\"Iv\", Context.MODE_PRIVATE);\n        ivValue = iv.getString(\"IvKey\", \"\");\n    }\n}\n\nString encrypt(String input) {\n    String encryptedString = \"\";\n    Log.d(TAG + \"$Encrypt\", seedValue + \"\\n\" + ivValue + \"\\n\" + String.valueOf(checkKeys()));\n    try {\n        SecretKeySpec aesSpec = new SecretKeySpec(seedValue.getBytes(\"UTF-8\"), 0, 32, \"AES\");\n        Cipher c = Cipher.getInstance(\"AES/CBC/PKCS5PADDING\");\n        IvParameterSpec ivSpec = new IvParameterSpec(ivValue.getBytes(\"UTF-8\"), 0, 16);\n        c.init(Cipher.ENCRYPT_MODE, aesSpec, ivSpec);\n        byte[] encryptedBytes = c.doFinal(input.getBytes(\"UTF-8\"));\n        encryptedString = Base64.encodeToString(encryptedBytes, Base64.DEFAULT);\n        Log.d(TAG, encryptedString);\n    } catch (Exception e) {\n        e.printStackTrace();\n    }\n    return encryptedString;\n}\n\nString decrypt(String input) {\n    String decryptedString = \"\";\n    Log.d(TAG + \"$Decrypt\", seedValue + \"\\n\" + ivValue + \"\\n\" + String.valueOf(checkKeys()));\n    try {\n        SecretKeySpec aesSpec = new SecretKeySpec(seedValue.getBytes(\"UTF-8\"), 0, 32, \"AES\");\n        Cipher cipher = Cipher.getInstance(\"AES/CBC/PKCS5PADDING\");\n        IvParameterSpec ivSpec = new IvParameterSpec(ivValue.getBytes(\"UTF-8\"), 0, 16);\n        cipher.init(Cipher.DECRYPT_MODE, aesSpec, ivSpec);\n        byte[] decodedBytes = Base64.decode(input.getBytes(), Base64.DEFAULT);\n        byte[] decryptedBytes = cipher.doFinal(decodedBytes);\n        decryptedString = Base64.encodeToString(decryptedBytes, Base64.DEFAULT);\n    } catch (Exception e) {\n        e.printStackTrace();\n    }\n    return decryptedString;\n}\n\nprivate void generateKeys() {\n    KeyGeneratorAsyncTask keyGenerator = new KeyGeneratorAsyncTask();\n    String seedIv = keyGenerator.doInBackground();\n\n    final StringBuilder seedRegenerator = new StringBuilder();\n    for (int i = 0; i < 32; i++) {\n        seedRegenerator.append(seedIv.charAt(i));\n    }\n    seedValue = seedRegenerator.toString();\n\n    final StringBuilder ivRegenerator = new StringBuilder();\n    for (int i = 33; i < 49; i++) {\n        ivRegenerator.append(seedIv.charAt(i));\n    }\n    ivValue = ivRegenerator.toString();\n\n    SharedPreferences prefs = c.getSharedPreferences(\"Keys\", Context.MODE_PRIVATE);\n    SharedPreferences.Editor editor = prefs.edit();\n    editor.putBoolean(\"HasKeys\", true).apply();\n\n    SharedPreferences hasSeed = c.getSharedPreferences(\"Seed\", Context.MODE_PRIVATE);\n    SharedPreferences.Editor hasSeedEditor = hasSeed.edit();\n    hasSeedEditor.putString(\"SeedKey\", seedValue).apply();\n\n    SharedPreferences hasIv = c.getSharedPreferences(\"Iv\", Context.MODE_PRIVATE);\n    SharedPreferences.Editor hasIvEditor = hasIv.edit();\n    hasIvEditor.putString(\"IvKey\", ivValue).apply();\n}\n\nprivate boolean checkKeys() {\n    SharedPreferences preferences = c.getSharedPreferences(\"Keys\", Context.MODE_PRIVATE);\n    return preferences.getBoolean(\"HasKeys\", false);\n}\n", "idx": 2200}
{"project": "cipher", "commit_id": "Snippet36680037_18551.java", "target": 1, "func": "private static final byte[] ivBytes = {109,15,57,79,75,112,50,91,18,18,107,127,65,68,12,69};\n\npublic static SecretKey generateKey(Context c, char[] passphraseOrPin) throws NoSuchAlgorithmException, InvalidKeySpecException {\n    // Number of PBKDF2 hardening rounds to use. Larger values increase\n    // computation time. You should select a value that causes computation\n    // to take >100ms.\n    byte[] salt = Settings.Secure.getString(c.getContentResolver(),\n            Settings.Secure.ANDROID_ID).getBytes();\n\n    final int iterations = 1000;\n\n    final int outputKeyLength = 128;\n\n    SecretKeyFactory secretKeyFactory = SecretKeyFactory.getInstance(\"PBKDF2WithHmacSHA1\");\n    KeySpec keySpec = new PBEKeySpec(passphraseOrPin, salt, iterations, outputKeyLength);\n    SecretKey secretKey = secretKeyFactory.generateSecret(keySpec);\n    return secretKey;\n}\n\npublic static boolean decryptFileFromUri(Context context, Uri file, String keyphrase) {\n    try {\n        File f = new File(getRealPathFromURI(context, file));\n        FileInputStream fis = new FileInputStream(f);\n\n        File ef = new File(f.toString().replace(\".epf\", \"\"));\n        FileOutputStream fos = new FileOutputStream(ef);\n\n        SecretKey key = generateKey(context, keyphrase.toCharArray());\n        Cipher cipher = Cipher.getInstance(\"AES/CBC/PKCS5Padding\");\n\n        cipher.init(Cipher.DECRYPT_MODE, key, new IvParameterSpec(ivBytes));\n        // Wrap the output stream\n        CipherInputStream cis = new CipherInputStream(fis, cipher);\n        // Write bytes\n        int b;\n        byte[] d = new byte[8];\n        while ((b = cis.read(d)) != -1) {\n            fos.write(d, 0, b);\n            fos.flush();\n        }\n        // Flush and close streams.\n        fos.close();\n        cis.close();\n\n        f.delete();\n        return true;\n    } catch (IOException e){\n        e.printStackTrace();\n    } catch (NoSuchPaddingException e) {\n        e.printStackTrace();\n    } catch (NoSuchAlgorithmException e) {\n        e.printStackTrace();\n    } catch (InvalidKeyException e) {\n        e.printStackTrace();\n    } catch (InvalidKeySpecException e) {\n        e.printStackTrace();\n    } catch (InvalidAlgorithmParameterException e) {\n        e.printStackTrace();\n    }\n    return false;\n}\n\npublic static boolean encryptFileFromUri(Context context, Uri file, String keyphrase) {\n    try {\n        File f = new File(getRealPathFromURI(context, file));\n        FileInputStream fis = new FileInputStream(f);\n\n        File ef = new File(f.toString() + \".epf\");\n        FileOutputStream fos = new FileOutputStream(ef);\n\n        SecretKey key = generateKey(context, keyphrase.toCharArray());\n        Cipher cipher = Cipher.getInstance(\"AES/CBC/PKCS5Padding\");\n        cipher.init(Cipher.ENCRYPT_MODE, key, new IvParameterSpec(ivBytes));\n        // Wrap the output stream\n        CipherOutputStream cos = new CipherOutputStream(fos, cipher);\n        // Write bytes\n        int b;\n        byte[] d = new byte[8];\n        while ((b = fis.read(d)) != -1) {\n            cos.write(d, 0, b);\n            cos.flush();\n        }\n        // Flush and close streams.\n        cos.close();\n        fis.close();\n        f.delete();\n        return true;\n    } catch (IOException e){\n        e.printStackTrace();\n    } catch (NoSuchPaddingException e) {\n        e.printStackTrace();\n    } catch (NoSuchAlgorithmException e) {\n        e.printStackTrace();\n    } catch (InvalidKeyException e) {\n        e.printStackTrace();\n    } catch (InvalidKeySpecException e) {\n        e.printStackTrace();\n    } catch (InvalidAlgorithmParameterException e) {\n        e.printStackTrace();\n    }\n    return false;\n}\n", "idx": 2080}
{"project": "cipher", "commit_id": "Snippet17280104_518.java", "target": 0, "func": "Cipher c = Cipher.getInstance(\"DESede\");\n\nCipher cipher = Cipher.getInstance(\"TripleDES/ECB/PKCS5Padding\");\n", "idx": 1674}
{"project": "cipher", "commit_id": "Snippet38487481_20453.java", "target": 0, "func": "public class DecryptActivity extends AppCompatActivity {\n\nEditText ed1;\nTextView tv;\nButton b1,b2;\nbyte[] decrypted;\nString decryptedText = null;\n@Override\nprotected void onCreate(Bundle savedInstanceState) {\n    super.onCreate(savedInstanceState);\n    setContentView(R.layout.decrypt_activity);\n    ed1 = (EditText) findViewById(R.id.decrypteditText);\n    b1 = (Button) findViewById(R.id.decryptbutton);\n    b1.setOnClickListener(new View.OnClickListener() {\n\n        @Override\n        public void onClick(View v) {\n            Log.d(\"asd\",\"inside onclick\");\n            try {\n                Log.d(\"asd\",\"inside try of decryptActivity\");\n                KeyGenerator keygenerator = KeyGenerator.getInstance(\"Blowfish\");\n                SecretKey secretkey = keygenerator.generateKey();\n                Cipher cipher2 = Cipher.getInstance(\"Blowfish\");\n                  cipher2.init(Cipher.DECRYPT_MODE,secretkey);\n                Log.d(\"asd\",\"in decrypt key is\"+secretkey.toString());\n                Log.d(\"asd\",\"before getBytes\");\n                byte[] encrypted =ed1.getText().toString().getBytes();\n                Log.d(\"asd\",ed1.getText().toString());\n                decrypted = cipher2.doFinal(encrypted);\n                tv=(EditText)findViewById((R.id.textView));\n                tv.setText(\"Asd\");\n                Log.d(\"asd\",new String(decrypted));\n            } catch (Exception e) {\n            }\n            Toast.makeText(getApplicationContext(), \"Text Pasted\", Toast.LENGTH_SHORT).show();\n        }\n    });\n}\n", "idx": 1778}
{"project": "cipher", "commit_id": "Snippet47390097_29354.java", "target": 0, "func": "    public static String desEncrypt(String text) throws NoSuchAlgorithmException, NoSuchPaddingException, InvalidKeyException, IllegalBlockSizeException, BadPaddingException \n{\n    String keyString = AESEncryption.convertToUTF8(\"8DJE7K01U8B51807B3E17D21\");\n\n    byte[] keyValue = Base64.getEncoder().encode(keyString.getBytes(StandardCharsets.UTF_8));\n    Key key = new SecretKeySpec(keyValue, \"AES\");\n    Cipher c1 = Cipher.getInstance(\"AES/ECB/PKCS5Padding\");\n\n    c1.init(Cipher.DECRYPT_MODE, key);\n    byte[]   encodedText = Base64.getDecoder().decode(text.getBytes(StandardCharsets.UTF_8));\n    byte[] encVal = c1.doFinal(encodedText);\n\n    System.out.println(new String(encodedText));\n    return new String(encVal,StandardCharsets.UTF_8);\n\n}\n", "idx": 1825}
{"project": "cipher", "commit_id": "Snippet13581796_37116.java", "target": 1, "func": "import java.security.spec.KeySpec;\n\nimport javax.crypto.Cipher;\nimport javax.crypto.SecretKey;\nimport javax.crypto.SecretKeyFactory;\nimport javax.crypto.spec.IvParameterSpec;\nimport javax.crypto.spec.PBEKeySpec;\nimport javax.crypto.spec.SecretKeySpec;\n\nimport org.apache.commons.codec.binary.Base64;\n\n\npublic class AESEncrypt {\n    private static final byte[] SALT = {(byte) 0xA9, (byte) 0x9B, (byte) 0xC8, (byte) 0x32, (byte) 0x56, (byte) 0x35, (byte) 0xE3, (byte) 0x03};\n    private static final int ITERATION_COUNT = 65536;\n    private static final int KEY_LENGTH = 128;\n    private Cipher eCipher;\n    private Cipher dCipher;\n    private byte[] iv;\n\n    AESEncrypt(String passPhrase) throws Exception {\n        SecretKeyFactory secretKeyFactory = SecretKeyFactory.getInstance(\"PBKDF2WithHmacSHA1\");\n        KeySpec keySpec = new PBEKeySpec(passPhrase.toCharArray(), SALT, ITERATION_COUNT, KEY_LENGTH);\n        SecretKey secretKeyTemp = secretKeyFactory.generateSecret(keySpec);\n        SecretKey secretKey = new SecretKeySpec(secretKeyTemp.getEncoded(), \"AES\");\n\n        eCipher = Cipher.getInstance(\"AES/CBC/PKCS5Padding\");\n        eCipher.init(Cipher.ENCRYPT_MODE, secretKey);\n\n        dCipher = Cipher.getInstance(\"AES/CBC/PKCS5Padding\");\n        iv = eCipher.getParameters().getParameterSpec(IvParameterSpec.class).getIV();\n        dCipher.init(Cipher.DECRYPT_MODE, secretKey, new IvParameterSpec(iv));\n    }\n\n    public String encrypt(String encrypt) throws Exception {\n        byte[] bytes = encrypt.getBytes(\"UTF8\");\n        byte[] encrypted = encrypt(bytes);\n        byte[] cipherText = new byte[encrypted.length + iv.length];\n        System.arraycopy(iv, 0, cipherText, 0, iv.length);\n        System.arraycopy(encrypted, 0, cipherText, iv.length, encrypted.length);\n        return new String(Base64.encodeBase64(cipherText));\n    }\n\n    public byte[] encrypt(byte[] plain) throws Exception {\n        return eCipher.doFinal(plain);\n    }\n\n    public static void main(String[] args) throws Exception {\n        String passphrase = \"PASSWORDPASSPHRASE\";\n        String password = \"password123\";    \n        AESEncrypt aesEncrypt = new AESEncrypt(passphrase); \n        String encryptedPassword = aesEncrypt.encrypt(password);\n        System.out.println(\"encryptedPassword = \" + encryptedPassword);\n    }\n}\n", "idx": 2314}
{"project": "cipher", "commit_id": "Snippet37092963_19032.java", "target": 1, "func": "import java.nio.charset.StandardCharsets;\nimport java.security.InvalidAlgorithmParameterException;\nimport java.security.InvalidKeyException;\nimport java.security.MessageDigest;\nimport java.security.NoSuchAlgorithmException;\nimport java.security.SecureRandom;\nimport java.util.UUID;\n\nimport javax.crypto.BadPaddingException;\nimport javax.crypto.Cipher;\nimport javax.crypto.IllegalBlockSizeException;\nimport javax.crypto.NoSuchPaddingException;\nimport javax.crypto.spec.IvParameterSpec;\nimport javax.crypto.spec.SecretKeySpec;\n\npublic class CipherEncrypter extends Encrypter<SecretKeySpec> {\n\n    byte[] iv;\n    private Cipher cipher;\n    private IvParameterSpec ivSpec;\n\n\n\npublic CipherEncrypter() throws NoSuchAlgorithmException, NoSuchPaddingException {\n        cipher = Cipher.getInstance(\"AES/CBC/PKCS5Padding\");\n        generateKey();\n    }\n\n    public String encrypt(String input) throws InvalidKeyException, InvalidAlgorithmParameterException, IllegalBlockSizeException, BadPaddingException {\n        return new String(encrypt(input.getBytes(StandardCharsets.UTF_8)));\n    }\n    public byte[] encrypt(byte[] input) throws InvalidKeyException, InvalidAlgorithmParameterException, IllegalBlockSizeException, BadPaddingException {\n        byte[] iv = new byte[cipher.getBlockSize()];\n        new SecureRandom().nextBytes(iv);\n        ivSpec = new IvParameterSpec(iv);\n\n        cipher.init(Cipher.ENCRYPT_MODE, key, ivSpec);\n        byte[] encrypted = cipher.doFinal(input);\n\n        return encrypted;\n    }\n\n    public String decrypt(String encrypted) throws InvalidKeyException, InvalidAlgorithmParameterException, IllegalBlockSizeException, BadPaddingException {\n        return new String(decrypt(encrypted.getBytes(StandardCharsets.UTF_8)), StandardCharsets.UTF_8);\n    }\n    public byte[] decrypt(byte[] encrypted) throws InvalidKeyException, InvalidAlgorithmParameterException, IllegalBlockSizeException, BadPaddingException {\n        cipher.init(Cipher.DECRYPT_MODE, key, ivSpec);\n        byte[] decrypted = cipher.doFinal(encrypted);\n        System.out.println(\"decrypted: \" + new String(decrypted, StandardCharsets.UTF_8));\n\n        return decrypted;\n    }\n\n    public SecretKeySpec generateKey() throws NoSuchAlgorithmException {\n        return generateKey(UUID.randomUUID().toString());\n    }\n    public SecretKeySpec generateKey(String seed) throws NoSuchAlgorithmException {\n        MessageDigest digest = MessageDigest.getInstance(\"SHA-256\");\n        digest.update(seed.getBytes());\n        byte[] keyBytes = new byte[16];\n        System.arraycopy(digest.digest(), 0, keyBytes, 0, keyBytes.length);\n        key = new SecretKeySpec(keyBytes, \"AES\");\n        return key;\n    }\n\n}\n", "idx": 2088}
{"project": "cipher", "commit_id": "Snippet3873411_30922.java", "target": 1, "func": "public class AesFileIo {\n\n    private static final String EOL = \"\\n\";\n    private static final String AES_ALGORITHM = \"AES/CTR/NoPadding\";\n    private SecretKeySpec secretKeySpec;\n    private IvParameterSpec ivSpec;\n\n    AesFileIo(byte[] aesKey, byte[] iv) {\n        Security.addProvider(new org.bouncycastle.jce.provider\n                .BouncyCastleProvider());\n        ivSpec = new IvParameterSpec(iv);\n        secretKeySpec = new SecretKeySpec(aesKey, \"AES\");\n    }\n\n    public String readFile(String fileName) {\n        StringBuilder stringBuilder = new StringBuilder();\n        try {\n            FileInputStream fis = new FileInputStream(fileName);\n            Cipher cipher = Cipher.getInstance(AES_ALGORITHM);\n            cipher.init(Cipher.DECRYPT_MODE, secretKeySpec, ivSpec);\n            CipherInputStream cis = new CipherInputStream(fis, cipher);\n            InputStreamReader isr = new InputStreamReader(cis);\n            BufferedReader reader = new BufferedReader(isr);\n            String line;\n            while ((line = reader.readLine()) != null) {\n                stringBuilder.append(line).append(EOL);\n            }\n            fis.close();\n        } catch (java.io.FileNotFoundException e) {\n            System.out.println(\"FileNotFoundException: probably OK\");\n        } catch (Exception e) {\n            e.printStackTrace();\n        }\n        return stringBuilder.toString();\n    }\n\n    public void writeFile(String fileName, String theFile) {\n        try {\n            Cipher cipher = Cipher.getInstance(AES_ALGORITHM);\n            cipher.init(Cipher.ENCRYPT_MODE, secretKeySpec, ivSpec);\n            byte[] encrypted = cipher.doFinal(theFile.getBytes());\n            FileOutputStream fos = new FileOutputStream(fileName);\n            fos.write(encrypted);\n            fos.flush();\n            fos.close();\n        } catch (Exception e) {\n            e.printStackTrace();\n        }\n    }\n}\n", "idx": 1994}
{"project": "cipher", "commit_id": "Snippet34823196_16813.java", "target": 1, "func": "import java.nio.charset.Charset;\nimport java.security.MessageDigest;\nimport java.security.Security;\nimport javax.crypto.Cipher;\nimport javax.crypto.spec.IvParameterSpec;\nimport javax.crypto.spec.SecretKeySpec;\nimport org.apache.commons.codec.binary.Base64;\n\npublic class CryptoLib {\n\n    public CryptoLib() {\n        Security.addProvider(new org.bouncycastle.jce.provider.BouncyCastleProvider());\n    }\n\n    public String encrypt(String plainText, String key) throws Exception {\n\n        // convert key to bytes\n        MessageDigest md = MessageDigest.getInstance(\"MD5\");\n        md.update(key.getBytes(\"UTF-8\"));\n\n        byte[] keyBytes = md.digest();\n\n        // Use the first 16 bytes (or even less if key is shorter)\n        byte[] keyBytes16 = new byte[16];\n        System.arraycopy(keyBytes, 0, keyBytes16, 0, Math.min(keyBytes.length, 64));\n\n        System.arraycopy(keyBytes, 0, keyBytes16, 0,\n                Math.min(keyBytes.length, 16));\n\n        // convert plain text to bytes\n        byte[] plainBytes = plainText.getBytes(\"UTF-8\");\n\n        // setup cipher\n        SecretKeySpec skeySpec = new SecretKeySpec(keyBytes16, \"AES\");\n        Cipher cipher = Cipher.getInstance(\"AES/CBC/PKCS7Padding\");\n        byte[] iv = new byte[16]; // initialization vector with all 0\n        cipher.init(Cipher.ENCRYPT_MODE, skeySpec, new IvParameterSpec(iv));\n\n        // encrypt\n        byte[] encrypted = cipher.doFinal(plainBytes);\n        String encryptedString = new String(Base64.encodeBase64(cipher.doFinal(encrypted)));\n        // encryptedString\n\n        return encryptedString;\n    }\n\n    public String Decrypt(String EncryptedText, String key) throws Exception {\n        // convert key to bytes\n        MessageDigest md = MessageDigest.getInstance(\"MD5\");\n        md.update(key.getBytes(\"UTF-8\"));\n\n        byte[] keyBytes = md.digest();\n        // Use the first 16 bytes (or even less if key is shorter)\n        byte[] keyBytes16 = new byte[16];\n\n        System.arraycopy(keyBytes, 0, keyBytes16, 0, Math.min(keyBytes.length, 64));\n\n        // convert plain text to bytes\n        //  byte[] decodeBase64 = Base64.decodeBase64(EncryptedText);\n        byte[] plainBytes = Base64.decodeBase64(EncryptedText.getBytes(\"UTF-8\"));\n\n        // setup cipher\n        SecretKeySpec skeySpec = new SecretKeySpec(keyBytes16, \"AES\");\n        Cipher cipher = Cipher.getInstance(\"AES/CBC/PKCS7Padding\");\n        byte[] iv = new byte[16]; // initialization vector with all 0\n        cipher.init(Cipher.DECRYPT_MODE, skeySpec, new IvParameterSpec(iv));\n\n\n        byte[] decrypteed = cipher.doFinal(plainBytes);\n\n\n        return new String(decrypteed, \"UTF-8\");\n    }\n}\n", "idx": 2106}
{"project": "cipher", "commit_id": "Snippet26572261_8720.java", "target": 1, "func": "public class AES {\n\n    private static final String password = \"encrypt\";\n    private static String salt;\n    private static final int pswdIterations = 65536;\n    private static final int keySize = 128;\n    private byte[] ivBytes;\n\n    public String encrypt(String plainText) throws Exception {\n\n        //get salt\n        salt = generateSalt();\n        byte[] saltBytes = salt.getBytes(\"UTF-8\");\n\n        // Derive the key\n        SecretKeyFactory factory = SecretKeyFactory.getInstance(\"PBKDF2WithHmacSHA1\");\n        PBEKeySpec spec = new PBEKeySpec(\n                password.toCharArray(),\n                saltBytes,\n                pswdIterations,\n                keySize\n        );\n\n        SecretKey secretKey = factory.generateSecret(spec);\n        SecretKeySpec secret = new SecretKeySpec(secretKey.getEncoded(), \"AES\");\n\n        //encrypt the message\n        Cipher cipher = Cipher.getInstance(\"AES/CBC/PKCS5Padding\");\n        cipher.init(Cipher.ENCRYPT_MODE, secret);\n        AlgorithmParameters params = cipher.getParameters();\n        ivBytes = params.getParameterSpec(IvParameterSpec.class).getIV();\n        byte[] encryptedTextBytes = cipher.doFinal(plainText.getBytes(\"UTF-8\"));\n        return new Base64().encodeAsString(encryptedTextBytes);\n    }\n\n    @SuppressWarnings(\"static-access\")\n    public String decrypt(String encryptedText) throws Exception {\n\n        byte[] saltBytes = salt.getBytes(\"UTF-8\");\n        byte[] encryptedTextBytes = new Base64().decodeBase64(encryptedText);\n\n        // Derive the key\n        SecretKeyFactory factory = SecretKeyFactory.getInstance(\"PBKDF2WithHmacSHA1\");\n        PBEKeySpec spec = new PBEKeySpec(\n                password.toCharArray(),\n                saltBytes,\n                pswdIterations,\n                keySize\n        );\n\n        SecretKey secretKey = factory.generateSecret(spec);\n        SecretKeySpec secret = new SecretKeySpec(secretKey.getEncoded(), \"AES\");\n\n        // Decrypt the message\n        Cipher cipher = Cipher.getInstance(\"AES/CBC/PKCS5Padding\");\n        cipher.init(Cipher.DECRYPT_MODE, secret, new IvParameterSpec(ivBytes));\n\n        byte[] decryptedTextBytes = null;\n        try {\n            decryptedTextBytes = cipher.doFinal(encryptedTextBytes);\n        } catch (IllegalBlockSizeException | BadPaddingException e) {\n        }\n\n        return new String(decryptedTextBytes);\n    }\n\n    public String generateSalt() {\n        SecureRandom random = new SecureRandom();\n        byte bytes[] = new byte[20];\n        random.nextBytes(bytes);\n        String s = new String(bytes);\n        return s;\n    }\n}\n", "idx": 2316}
{"project": "cipher", "commit_id": "Snippet33035035_15053.java", "target": 0, "func": "import java.io.UnsupportedEncodingException;\nimport java.security.MessageDigest;\nimport java.security.NoSuchAlgorithmException;\nimport java.util.Arrays;\n\nimport javax.crypto.Cipher;\nimport javax.crypto.spec.SecretKeySpec;\n\nimport sun.misc.BASE64Decoder;\nimport sun.misc.BASE64Encoder;\n\npublic class AES\n{\npublic static SecretKeySpec makeKey(String schl\u00fcssel) throws NoSuchAlgorithmException, UnsupportedEncodingException\n{\n    byte[] key = (schl\u00fcssel).getBytes(\"UTF-8\");\n    MessageDigest sha = MessageDigest.getInstance(\"SHA\");\n    key = sha.digest(key);\n    key = Arrays.copyOf(key, 16);\n    return new SecretKeySpec(key, \"AES\");\n}\n\n\npublic static String encryptString(String text, SecretKeySpec schl\u00fcssel) throws Exception\n{\n    Cipher cipher = Cipher.getInstance(\"AES\");\n    cipher.init(Cipher.ENCRYPT_MODE, schl\u00fcssel);\n    byte[] encrypted = cipher.doFinal(text.getBytes());\n\n    BASE64Encoder myEncoder = new BASE64Encoder();\n    return myEncoder.encode(encrypted);\n}\n\n\npublic static String decryptString(String text, SecretKeySpec schl\u00fcssel) throws Exception\n{    \n    BASE64Decoder myDecoder2 = new BASE64Decoder();\n    byte[] crypted2 = myDecoder2.decodeBuffer(text);\n\n    Cipher cipher2 = Cipher.getInstance(\"AES\");\n    cipher2.init(Cipher.DECRYPT_MODE, schl\u00fcssel);\n    byte[] cipherData2 = cipher2.doFinal(crypted2);\n    return new String(cipherData2);\n}\n}\n", "idx": 1873}
{"project": "cipher", "commit_id": "Snippet45474725_27536.java", "target": 1, "func": "public class AesCbc {\n    private static String PLAIN = \"usr/passwd@bizdb:127.0.0.1:5432\";\n\n    public static void main(String[] args) throws Exception {\n        Cipher aesCipher = Cipher.getInstance(\"AES/CBC/NoPadding\");\n        SecretKeySpec keySpec = new SecretKeySpec(\"1234567890ABCDEF\".getBytes(), \"AES\");\n        IvParameterSpec iv = new IvParameterSpec(\"fedcba0987654321\".getBytes());\n\n        aesCipher.init(Cipher.ENCRYPT_MODE, keySpec, iv);\n        byte[] rawBytes = PLAIN.getBytes();\n        byte[] aligned;\n        int mod = rawBytes.length % 16; // prevent javax.crypto.IllegalBlockSizeException\n        if (mod == 0) {\n            aligned = new byte[rawBytes.length];\n        } else {\n            aligned = new byte[rawBytes.length + 16 - mod];\n        }\n        System.arraycopy(rawBytes, 0, aligned, 0, rawBytes.length);\n        byte[] cipherBytes = aesCipher.doFinal(aligned);\n        String base64Result = Base64.getEncoder().encodeToString(cipherBytes);\n        System.out.println(\"cipher:[\" + base64Result + \"], rawBytes.length=\" + rawBytes.length + \", mod=\" + mod);\n\n        aesCipher.init(Cipher.DECRYPT_MODE, keySpec, iv);\n        cipherBytes = Base64.getDecoder().decode(base64Result);\n        aligned = aesCipher.doFinal(cipherBytes);\n        int posNil;\n        for (posNil = 0; posNil < aligned.length; posNil++) {\n            if (aligned[posNil] == 0x00)\n                break;\n        }\n        rawBytes = new byte[posNil];\n        System.arraycopy(aligned, 0, rawBytes, 0, posNil);\n        String plain = new String(rawBytes);\n        System.out.println(\"plain:[\" + plain + \"], posNil=\" + posNil + \", aligned.length=\" + aligned.length);\n    }\n}\n", "idx": 2179}
{"project": "cipher", "commit_id": "Snippet11932162_35911.java", "target": 0, "func": " package encypt.com;\n\nimport java.io.BufferedReader;\nimport java.io.FileReader;\nimport java.security.*;\nimport java.security.spec.InvalidKeySpecException;\nimport javax.crypto.Cipher;\nimport javax.crypto.spec.SecretKeySpec;\nimport sun.misc.*;\n\npublic class Testing {\n\nprivate static final String ALGORITHM = \"AES\";\nprivate static final int ITERATIONS = 2;\nprivate static final byte[] keyValue = \n    new byte[] { 'T', 'h', 'i', 's', 'I', 's', 'A', 'S', 'e', 'c', 'r', 'e', 't', 'K', 'e', 'y'};\n\npublic static String encrypt(String value, String salt) throws Exception {\n    Key key = generateKey();\n    Cipher c = Cipher.getInstance(ALGORITHM);  \n    c.init(Cipher.ENCRYPT_MODE, key);\n\n    String valueToEnc = null;\n    String eValue = value;\n    for (int i = 0; i < ITERATIONS; i++) {\n        valueToEnc = salt + eValue;\n        byte[] encValue = c.doFinal(valueToEnc.getBytes());\n        eValue = new BASE64Encoder().encode(encValue);\n    }\n    return eValue;\n}\n\npublic static String decrypt(String value, String salt) throws Exception {\n    Key key = generateKey();\n    Cipher c = Cipher.getInstance(ALGORITHM);\n    c.init(Cipher.DECRYPT_MODE, key);\n\n    String dValue = null;\n    String valueToDecrypt = value;\n    for (int i = 0; i < ITERATIONS; i++) {\n        byte[] decordedValue = new BASE64Decoder().decodeBuffer(valueToDecrypt);\n        byte[] decValue = c.doFinal(decordedValue);\n        dValue = new String(decValue).substring(salt.length());\n        valueToDecrypt = dValue;\n    }\n    return dValue;\n}\n\nprivate static Key generateKey() throws Exception {\n    Key key = new SecretKeySpec(keyValue, ALGORITHM);\n    // SecretKeyFactory keyFactory = SecretKeyFactory.getInstance(ALGORITHM);\n    // key = keyFactory.generateSecret(new DESKeySpec(keyValue));\n    return key;\n}\n\n\npublic static void main(String[] args) throws Exception {\n\n\n    String password = \"mypassword\";\n    String salt = \"this is a simple clear salt\";\n    String passwordEnc = Testing.encrypt(password, salt);\n    String passwordDec = Testing.decrypt(passwordEnc, salt);\n\n   System.out.println(\"Salt Text : \" + salt);\n   System.out.println(\"Plain Text : \" + password);\n   System.out.println(\"Encrypted : \" + passwordEnc);\n   System.out.println(\"Decrypted : \" + passwordDec);\n}\n}\n", "idx": 1899}
{"project": "cipher", "commit_id": "Snippet30616578_12819.java", "target": 0, "func": "import javax.crypto.*;\nimport javax.crypto.spec.SecretKeySpec;\nimport java.io.UnsupportedEncodingException;\nimport java.security.InvalidKeyException;\nimport java.security.MessageDigest;\nimport java.security.NoSuchAlgorithmException;\nimport java.security.SecureRandom;\n\npublic class Main {\n\n\n    /**\n     * entry the content\n     *\n     * @param content  the content need to entry\n     * @param password the key\n     * @return\n     */\n    public static String md5Aessign(String content, String password) {\n\n        MessageDigest md;\n        try {\n\n            KeyGenerator kgen = KeyGenerator.getInstance(\"AES\");\n\n            SecureRandom random = SecureRandom.getInstance(\"SHA1PRNG\");\n            random.setSeed(password.getBytes());\n            kgen.init(128, random);\n\n            SecretKey secretKey = kgen.generateKey();\n            byte[] enCodeFormat = secretKey.getEncoded();\n            SecretKeySpec key = new SecretKeySpec(enCodeFormat, \"AES\");\n            Cipher cipher = Cipher.getInstance(\"AES\");\n            cipher.init(Cipher.ENCRYPT_MODE, key);\n\n\n            byte[] byteContent = content.getBytes(\"GBK\");\n\n            md = MessageDigest.getInstance(\"MD5\");\n            md.update(byteContent);\n            byte[] result = cipher.doFinal(md.digest());\n\n            return parseByte2HexStr(result);\n\n        } catch (NoSuchAlgorithmException e) {\n            e.printStackTrace();\n        } catch (NoSuchPaddingException e) {\n            e.printStackTrace();\n        } catch (InvalidKeyException e) {\n            e.printStackTrace();\n        } catch (UnsupportedEncodingException e) {\n            e.printStackTrace();\n        } catch (IllegalBlockSizeException e) {\n            e.printStackTrace();\n        } catch (BadPaddingException e) {\n            e.printStackTrace();\n        }\n        return null;\n    }\n\n    /**\n     *\n     *\n     * @param buf\n     * @return\n     */\n\n    public static String parseByte2HexStr(byte buf[]) {\n        StringBuffer sb = new StringBuffer();\n        for (int i = 0; i < buf.length; i++) {\n            String hex = Integer.toHexString(buf[i] & 0xFF);\n            if (hex.length() == 1) {\n                hex = '0' + hex;\n            }\n            sb.append(hex.toUpperCase());\n        }\n        return sb.toString();\n    }\n\n\n    public static void main(String[] args) {\n        System.out.println(\"Hello World!\");\n\n        String content = \"Hello World!\";\n        String key = \"1234567812345678\";\n\n        System.out.println(md5Aessign(content, key));\n    }\n}\n", "idx": 1700}
{"project": "cipher", "commit_id": "Snippet30613342_12818.java", "target": 1, "func": "public class AESDecryption\n{\nprivate final String ALGORITHM = \"AES\";\nprivate final String MAC_ALGORITHM = \"HmacSHA256\";\nprivate final String TRANSFORMATION = \"AES/CBC/PKCS5Padding\";\nprivate final String KEY_DERIVATION_FUNCTION = \"PBKDF2WithHmacSHA1\";\nprivate final String PLAINTEXT = \"/Volumes/CONNOR P/De-Encrypted.txt\";\nprivate final String ENCRYPTED = \"/Volumes/CONNOR P/Encrypted.txt\";\nprivate final String PASSWORD = \"javapapers\";\nprivate final String LOC = Paths.get(\".\").toAbsolutePath().normalize().toString();\nprivate final int SALT_SIZE = 64;\nprivate final int IV_SIZE = 16;\nprivate final int KEY_LENGTH = 128;\nprivate final int ITERATIONS = 100000;\n\npublic AESDecryption()\n{\n    try\n    {\n        decrypt();\n    }\n    catch(Exception ex)\n    {\n        JOptionPane.showMessageDialog(null, \"Error: \" + ex.getClass().getName(), \"Error\", JOptionPane.ERROR_MESSAGE);\n    }\n}\nprivate void decrypt() throws Exception\n{\n    File encrypted = new File(ENCRYPTED);\n    File plaintext = new File(PLAINTEXT);\n    int encryptedSize = (int)encrypted.length();\n    int plaintextSize = (int)plaintext.length();\n    BufferedInputStream bufferedInputStream = new BufferedInputStream(new FileInputStream(encrypted));\n    BufferedOutputStream bufferedOutputStream = new BufferedOutputStream(new FileOutputStream(plaintext));\n\n    //Read in the encrypted data\n    byte[] input = new byte[encryptedSize];\n    Path path = Paths.get(ENCRYPTED);\n    input = Files.readAllBytes(path);\n    int increment = (input.length-SALT_SIZE)/2;\n\n    if(input.length >= (SALT_SIZE + increment))\n    {\n        //Recover salt, MAC, and encrypted data and store in arrays\n        byte[] salt = Arrays.copyOfRange(input, 0, SALT_SIZE);\n        byte[] macBytes = Arrays.copyOfRange(input, SALT_SIZE, SALT_SIZE + increment);\n        byte[] crypt = Arrays.copyOfRange(input, SALT_SIZE + increment, input.length);\n\n        //Regenerate original MAC\n        KeyGenerator keyGenerator = KeyGenerator.getInstance(MAC_ALGORITHM);\n        SecretKey macKey = keyGenerator.generateKey();\n        Mac mac = Mac.getInstance(MAC_ALGORITHM);\n        mac.init(macKey);\n        byte[] hmac = mac.doFinal(crypt);        \n\n        if(Arrays.equals(macBytes, hmac)) //This is where it fails, never enters\n        {\n            //Regenerate cipher and decrypt data\n            SecretKeyFactory factory = SecretKeyFactory.getInstance(KEY_DERIVATION_FUNCTION);\n            KeySpec keySpec = new PBEKeySpec(PASSWORD.toCharArray(), salt, ITERATIONS, KEY_LENGTH);\n            SecretKey secret = new SecretKeySpec(factory.generateSecret(keySpec).getEncoded(), ALGORITHM);\n\n            Cipher cipher = Cipher.getInstance(TRANSFORMATION);\n            cipher.init(Cipher.DECRYPT_MODE, secret, new IvParameterSpec(new byte[16]));\n\n            //Write decrypted data to new text file\n            byte[] output = cipher.doFinal(crypt);\n            bufferedOutputStream.write(output);   \n            bufferedInputStream.close();\n            bufferedOutputStream.flush();\n            bufferedOutputStream.close();\n        }\n    }\n}\n", "idx": 2281}
{"project": "cipher", "commit_id": "Snippet27900193_10031.java", "target": 0, "func": " public class Encrypt{\n\n\npublic static void main(String[] args) throws Exception {\n\n   String FileName = \"D:/ashok/normal.txt\";\n    String FileName1 = \"D:/ashok/encrypted.txt\";\n\n\n    KeyGenerator KeyGen = KeyGenerator.getInstance(\"AES\");\n    KeyGen.init(128);\n\n    SecretKey SecKey = KeyGen.generateKey();\n\n    Cipher AesCipher = Cipher.getInstance(\"AES\");\n\n\n\n    byte[] cipherText = Files.readAllBytes(Paths.get(FileName));\n    AesCipher.init(Cipher.ENCRYPT_MODE, SecKey);\n    byte[] byteCipherText = AesCipher.doFinal(cipherText);\n    Files.write(Paths.get(FileName1), byteCipherText);\n }\n", "idx": 1803}
{"project": "cipher", "commit_id": "Snippet24121346_6420.java", "target": 1, "func": "class Crypto {\n\n\nString mPassword = null;\npublic final static int SALT_LEN = 8;\nbyte[] mInitVec = null;\nbyte[] mSalt = null;\nCipher mEcipher = null;\nCipher mDecipher = null;\nprivate final int KEYLEN_BITS = 128; // see notes below where this is used.\nprivate final int ITERATIONS = 65536;\nprivate final int MAX_FILE_BUF = 1024;\n\npublic Crypto(String password) {mPassword = password;}\npublic byte[] getSalt() {return (mSalt);}\npublic byte[] getInitVec() {return (mInitVec);}\n\npublic void setupEncrypt() throws Exception {\n    mSalt = new byte[SALT_LEN];\n    SecureRandom rnd = new SecureRandom();\n    rnd.nextBytes(mSalt);\n    SecretKeyFactory factory = SecretKeyFactory.getInstance(\"PBKDF2WithHmacSHA1\");\n    KeySpec spec = new PBEKeySpec(mPassword.toCharArray(), mSalt, ITERATIONS, KEYLEN_BITS);\n    SecretKey tmp = factory.generateSecret(spec);\n    SecretKey secret = new SecretKeySpec(tmp.getEncoded(), \"AES\");\n    mEcipher = Cipher.getInstance(\"AES/CBC/PKCS5Padding\");\n    mEcipher.init(Cipher.ENCRYPT_MODE, secret);\n    AlgorithmParameters params = mEcipher.getParameters();\n    mInitVec = params.getParameterSpec(IvParameterSpec.class).getIV();\n}\n\npublic void setupDecrypt(String initvec, String salt) throws Exception {\n    mSalt = decodeHex(salt.toCharArray());\n    mInitVec = decodeHex(initvec.toCharArray());\n    SecretKeyFactory factory = SecretKeyFactory.getInstance(\"PBKDF2WithHmacSHA1\");\n    KeySpec spec = new PBEKeySpec(mPassword.toCharArray(), mSalt, ITERATIONS, KEYLEN_BITS);\n    SecretKey tmp = factory.generateSecret(spec);\n    SecretKey secret = new SecretKeySpec(tmp.getEncoded(), \"AES\");\n    mDecipher = Cipher.getInstance(\"AES/CBC/PKCS5Padding\");\n    mDecipher.init(Cipher.DECRYPT_MODE, secret, new IvParameterSpec(mInitVec));\n}\n\npublic byte[] decrypt(byte[] data) throws IllegalBlockSizeException, BadPaddingException, IOException {\n    byte[] decdata = new byte[data.length];\n    int totalread = 0;\n    int nread = 0;\n    byte[] substr = new byte[16];\n    InputStream fin = new ByteArrayInputStream(data);\n    CipherInputStream cin = new CipherInputStream(fin, mDecipher);\n    while ((nread = cin.read(substr)) > 0) {\n        for (int i = 0; i < nread; i++) decdata[totalread+i] = substr[i];\n        totalread += nread;\n    }\n    fin.close();\n    return decdata;\n}\n\npublic byte[] encrypt(byte[] data) throws IllegalBlockSizeException, BadPaddingException, IOException {\n    System.out.println(\"data.length=\"+data.length);\n    byte[] encdata = new byte[data.length+15-(data.length-1)%16];\n    System.out.println(\"encdata.length=\"+encdata.length);\n    int totalread = 0;\n    int nread = 0;\n    byte[] substr = new byte[16];\n    InputStream fin = new ByteArrayInputStream(data);\n    CipherInputStream cin = new CipherInputStream(fin, mEcipher);\n    while ((nread = cin.read(substr)) > 0 && totalread<data.length) {\n        for (int i = 0; i < nread; i++) encdata[totalread+i] = substr[i];\n        totalread += nread;\n    }\n    fin.close();\n    return encdata;\n}\n\npublic static void main(String[] args) throws Exception {\n    String inpstr = \"Dit is een test.Zit if een mewt.\";\n\n    Crypto en = new Crypto(\"mypassword\");\n    en.setupEncrypt();\n    String iv = encodeHexString(en.getInitVec()).toUpperCase();\n    String salt = encodeHexString(en.getSalt()).toUpperCase();\n    byte[] inp = inpstr.getBytes();\n    byte[] enc = en.encrypt(inp);\n    System.out.println(\"In: \"+Arrays.toString(inp));\n    System.out.println(\"En: \"+Arrays.toString(enc));\n\n    Crypto dc = new Crypto(\"mypassword\");\n    dc.setupDecrypt(iv, salt);\n    byte[] oup = dc.decrypt(enc);\n    System.out.println(\"En: \"+Arrays.toString(enc));\n    System.out.println(\"Ou: \"+Arrays.toString(oup));\n}\n\npublic static final String DEFAULT_CHARSET_NAME = \"UTF_8\";\nprivate static final char[] DIGITS_LOWER = {'0', '1', '2', '3', '4', '5', '6', '7', '8', '9', 'a', 'b', 'c', 'd', 'e', 'f'};\nprivate static final char[] DIGITS_UPPER = {'0', '1', '2', '3', '4', '5', '6', '7', '8', '9', 'A', 'B', 'C', 'D', 'E', 'F'};\n\nprivate static byte[] decodeHex(char[] data) {\n    int len = data.length;\n    if ((len & 0x01) != 0) {\n        throw new UnsupportedOperationException(\"Odd number of characters.\");\n    }\n    byte[] out = new byte[len >> 1];\n\n    // two characters form the hex value.\n    for (int i = 0, j = 0; j < len; i++) {\n        int f = toDigit(data[j], j) << 4;\n        j++;\n        f = f | toDigit(data[j], j);\n        j++;\n        out[i] = (byte) (f & 0xFF);\n    }\n\n    return out;\n}\n\nprivate static char[] encodeHex(byte[] data) {\n    return encodeHex(data, true);\n}\n\nprivate static char[] encodeHex(byte[] data, boolean toLowerCase) {\n    return encodeHex(data, toLowerCase ? DIGITS_LOWER : DIGITS_UPPER);\n}\n\nprivate static char[] encodeHex(byte[] data, char[] toDigits) {\n    int l = data.length;\n    char[] out = new char[l << 1];\n    // two characters form the hex value.\n    for (int i = 0, j = 0; i < l; i++) {\n        out[j++] = toDigits[(0xF0 & data[i]) >>> 4];\n        out[j++] = toDigits[0x0F & data[i]];\n    }\n    return out;\n}\n\nprivate static String encodeHexString(byte[] data) {\n    return new String(encodeHex(data));\n}\n\nprivate static int toDigit(char ch, int index) {\n    int digit = Character.digit(ch, 16);\n    if (digit == -1) {\n        throw new UnsupportedOperationException(\"Illegal hexadecimal character \" + ch + \" at index \" + index);\n    }\n    return digit;\n}\n\n}\n", "idx": 2092}
{"project": "cipher", "commit_id": "Snippet12365481_36241.java", "target": 1, "func": "public void decrypt()\n{\ntry\n{\n    SecretKeySpec sk=new SecretKeySpec(rsa_priv,\"RSA/EBC/PKCS8\");\n    Cipher dec = Cipher.getInstance(\"RSA\");\n    dec.init(Cipher.DECRYPT_MODE, sk,new IvParameterSpec(iv));\n     //OAEPWithSHA-512AndMGF1Padding        \n     byte temp[];\n     temp=dec.doFinal(sess);\n     String t=temp.toString();\n     System.out.println(\"Session key is:\"+ t);\n     //session=dec(sess,rsa_priv);OAEPWithSHA-256AndMGF1Padding\n}\ncatch (Exception e)\n{\n    System.out.println(\"Exception occured:\"+ e);\n}\n}\n", "idx": 1949}
{"project": "cipher", "commit_id": "Snippet39750298_21670.java", "target": 0, "func": "import java.security.SecureRandom;\n\nimport javax.crypto.Cipher;\nimport javax.crypto.KeyGenerator;\nimport javax.crypto.SecretKey;\nimport javax.crypto.spec.SecretKeySpec;\n\npublic class AESHelper {\npublic static String encrypt(String seed, String cleartext)\n        throws Exception {\n    byte[] rawKey = getRawKey(seed.getBytes());\n    byte[] result = encrypt(rawKey, cleartext.getBytes());\n    return toHex(result);\n}\n\npublic static String decrypt(String seed, String encrypted)\n        throws Exception {\n    byte[] rawKey = getRawKey(seed.getBytes());\n    byte[] enc = toByte(encrypted);\n    byte[] result = decrypt(rawKey, enc);\n    return new String(result);\n}\n\nprivate static byte[] getRawKey(byte[] seed) throws Exception {\n    KeyGenerator kgen = KeyGenerator.getInstance(\"AES\");\n    SecureRandom sr = SecureRandom.getInstance(\"SHA1PRNG\");\n    sr.setSeed(seed);\n    kgen.init(128, sr); // 192 and 256 bits may not be available\n    SecretKey skey = kgen.generateKey();\n    byte[] raw = skey.getEncoded();\n    return raw;\n}\n\nprivate static byte[] encrypt(byte[] raw, byte[] clear) throws Exception {\n    SecretKeySpec skeySpec = new SecretKeySpec(raw, \"AES\");\n    Cipher cipher = Cipher.getInstance(\"AES\");\n    cipher.init(Cipher.ENCRYPT_MODE, skeySpec);\n    byte[] encrypted = cipher.doFinal(clear);\n    return encrypted;\n}\n\nprivate static byte[] decrypt(byte[] raw, byte[] encrypted)\n        throws Exception {\n    SecretKeySpec skeySpec = new SecretKeySpec(raw, \"AES\");\n    Cipher cipher = Cipher.getInstance(\"AES\");\n    cipher.init(Cipher.DECRYPT_MODE, skeySpec);\n    byte[] decrypted = cipher.doFinal(encrypted);\n    return decrypted;\n}\n\npublic static String toHex(String txt) {\n    return toHex(txt.getBytes());\n}\n\npublic static String fromHex(String hex) {\n    return new String(toByte(hex));\n}\n\npublic static byte[] toByte(String hexString) {\n    int len = hexString.length() / 2;\n    byte[] result = new byte[len];\n    for (int i = 0; i < len; i++)\n        result[i] = Integer.valueOf(hexString.substring(2 * i, 2 * i + 2),\n                16).byteValue();\n    return result;\n}\n\npublic static String toHex(byte[] buf) {\n    if (buf == null)\n        return \"\";\n    StringBuffer result = new StringBuffer(2 * buf.length);\n    for (int i = 0; i < buf.length; i++) {\n        appendHex(result, buf[i]);\n    }\n    return result.toString();\n}\n\nprivate final static String HEX = \"0123456789ABCDEF\";\n\nprivate static void appendHex(StringBuffer sb, byte b) {\n    sb.append(HEX.charAt((b >> 4) & 0x0f)).append(HEX.charAt(b & 0x0f));\n}\n\n}\n", "idx": 1807}
{"project": "cipher", "commit_id": "Snippet9381270_33862.java", "target": 1, "func": "cipher = Cipher.getInstance(\"AES/CBC/PKCS5Padding\");        \ncipher.init(Cipher.ENCRYPT_MODE, aesKey);\nbyte[] data = cipher.doFinal(stringDec.getBytes());\nbyte[] iv = cipher.getIV();\n", "idx": 2168}
{"project": "cipher", "commit_id": "Snippet41527728_23448.java", "target": 1, "func": "public String decrypt(String basetext) {\n\n        try {\n            FileInputStream iR = new FileInputStream(\"/sdcard/publickkey\");\n            ObjectInputStream inputStream = new ObjectInputStream(iR);\n            final PublicKey key = (PublicKey) inputStream.readObject();\n\n            byte[] text = Base64.decode(basetext, Base64.DEFAULT);\n\n            // get an RSA cipher object and print the provider\n            final Cipher cipher = Cipher.getInstance(\"RSA\");\n\n            // decrypt the text using the public key\n            cipher.init(Cipher.DECRYPT_MODE, key);\n            byte[] dectyptedText = cipher.doFinal(text);\n\n            iR.close();\n            return new String(dectyptedText,\"UTF-8\");\n\n        } catch (Exception ex) {\n            ex.printStackTrace();\n            return  null;\n        }\n    }\n", "idx": 2344}
{"project": "cipher", "commit_id": "Snippet32033937_14088.java", "target": 1, "func": "Cipher.getInstance(\"RSA/ECB/OAEPWithSHA-256AndMGF1Padding\");\n", "idx": 2075}
{"project": "cipher", "commit_id": "Snippet28273375_10495.java", "target": 1, "func": "final byte[] iv = new byte[16]; // random would be better\n\nOutputEncryptor encryptor = new OutputEncryptor() {\n    @Override\n    public OutputStream getOutputStream(OutputStream encOut) {\n        try {\n            Cipher cipher = Cipher.getInstance(\"AES/CBC/PKCS5Padding\");\n            cipher.init(Cipher.ENCRYPT_MODE, zmkKey, new IvParameterSpec(iv));\n            return new CipherOutputStream(encOut, cipher);\n        } catch (Exception e) {\n            throw new RuntimeException(e);\n        }\n    }\n\n    @Override\n    public GenericKey getKey() {\n        return new JceGenericKey(getAlgorithmIdentifier(), zmkKey);\n    }\n\n    @Override\n    public AlgorithmIdentifier getAlgorithmIdentifier() {\n        return new AlgorithmIdentifier(\n                NISTObjectIdentifiers.id_aes128_CBC,\n                // AES CBC mode requires an IV, specified as an octet string\n                new DEROctetString(iv));\n    }\n};\n\nPKCS8Generator pkcs8Generator = new JcaPKCS8Generator(keyPair.getPrivate(), encryptor);\nStringWriter sw = new StringWriter();\ntry (PemWriter writer = new PemWriter(sw)) {\n    writer.writeObject(pkcs8Generator);\n}\n\nString pemPKCS8 = sw.toString();\n", "idx": 2016}
{"project": "cipher", "commit_id": "Snippet47593118_29618.java", "target": 1, "func": "public static String decrypt(String encryptedSecretKeyString ,String encryptedTextString)\n{\n     try {\n\n          // 1. Get private key\n          PKCS8EncodedKeySpec privateSpec = new PKCS8EncodedKeySpec(Base64.decode(AppConstant.privateKey, Base64.DEFAULT));\n          KeyFactory keyFactory = KeyFactory.getInstance(\"RSA\");\n          PrivateKey privateKey = keyFactory.generatePrivate(privateSpec);\n\n          // 2. Decrypt encrypted secret key using private key\n          Cipher cipher1 = Cipher.getInstance(\"RSA/ECB/OAEPWithSHA1AndMGF1Padding\");   \n          cipher1.init(Cipher.DECRYPT_MODE, privateKey);  \n          byte[] secretKeyBytes = cipher1.doFinal(Base64.decode(encryptedSecretKeyString, Base64.DEFAULT));//here i am getting error.\n          SecretKey secretKey = new SecretKeySpec(secretKeyBytes, 0, secretKeyBytes.length, \"AES\");\n\n          // 3. Decrypt encrypted text using secret key\n          byte[] raw = secretKey.getEncoded();\n          SecretKeySpec skeySpec = new SecretKeySpec(raw, \"AES\");\n          Cipher cipher = Cipher.getInstance(\"AES/CBC/PKCS5Padding\");\n          cipher.init(Cipher.DECRYPT_MODE, skeySpec, new IvParameterSpec(new byte[16]));\n          byte[] original = cipher.doFinal(Base64.decode(encryptedTextString, Base64.DEFAULT));\n          String text = new String(original, Charset.forName(\"UTF-8\"));\n\n          // 4. Print the original text sent by client\n          System.out.println(\"text\\n\" + text + \"\\n\\n\");\n          return text;\n\n        } catch (NoSuchAlgorithmException | InvalidKeySpecException | InvalidKeyException | NoSuchPaddingException | IllegalBlockSizeException | BadPaddingException | InvalidAlgorithmParameterException e) {\n          e.printStackTrace();\n        }\n    return \"null\";\n}\n", "idx": 2277}
{"project": "cipher", "commit_id": "Snippet11337117_35479.java", "target": 1, "func": "import java.security.Key;\nimport javax.crypto.Cipher;\nimport javax.crypto.KeyGenerator;\nimport javax.crypto.spec.IvParameterSpec;\n\npublic class RandomKey\n{\n    public static void main(String[] args) throws Exception\n    {\n    byte[] input = new byte[] { \n                        0x00, 0x01, 0x02, 0x03, 0x04, 0x05, 0x06, 0x07, \n                        0x08, 0x09, 0x0a, 0x0b, 0x0c, 0x0d, 0x0e, 0x0f,\n                        0x00, 0x01, 0x02, 0x03, 0x04, 0x05, 0x06, 0x07 };\n\n\n    byte[] ivBytes = new byte[] { \n                        0x00, 0x00, 0x00, 0x01, 0x04, 0x05, 0x06, 0x07,\n                        0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x01 };\n\n    //initializing a new initialization vector  \n    IvParameterSpec ivSpec  = new IvParameterSpec(ivBytes);\n    //what does this actually do?\n    Cipher cipher = Cipher.getInstance(\"AES/CTR/NoPadding\", \"BC\");\n    //what does this do?\n    KeyGenerator generator = KeyGenerator.getInstance(\"AES\",\"BC\");\n    //I assume this generates a key size of 192 bits\n    generator.init(192);\n    //does this generate a random key?\n    Key encryptKey = generator.generateKey();\n\n    System.out.println(\"input: \" +toHex(input));\n\n    //encryption phase\n    cipher.init(Cipher.ENCRYPT_MODE, encryptKey, ivSpec);\n    //what is this doing?\n    byte[] cipherText = new byte[cipher.getOutputSize(input.length)];\n    //what is this doing?\n    int ctLength = cipher.update(input, 0, input.length, cipherText,0);\n\n    //getting the cipher text length i assume?\n    ctLength += cipher.doFinal (cipherText, ctLength );\n    System.out.println (\"Cipher: \" +toHex(cipherText) + \" bytes: \" + ctLength);\n\n\n    //decryption phase\n    cipher.init(Cipher.DECRYPT_MODE, encryptKey, ivSpec);\n    //storing the ciphertext in plaintext i'm assuming?\n    byte[] plainText = new byte[cipher.getOutputSize(ctLength)];\n    int ptLength = cipher.update(cipherText, 0, ctLength, plainText, 0);\n    //getting plaintextLength i think?\n    ptLength= cipher.doFinal (plainText, ptLength);\n    System.out.println(\"plain: \" + toHex(plainText, ptLength));  \n\n    }\n\nprivate static String digits = \"0123456789abcdef\";\n\npublic static String toHex(byte[] data, int length)\n{\n    StringBuffer buf = new StringBuffer();\n\n    for (int i=0; i!= length; i++)\n    {\n        int v = data[i] & 0xff;\n\n        buf.append(digits.charAt(v >>4));\n        buf.append(digits.charAt(v & 0xf));\n    }\n    return buf.toString();\n\n}\n\npublic static String toHex(byte[] data)\n{\n    return toHex(data, data.length);\n}\n}\n", "idx": 2085}
{"project": "cipher", "commit_id": "Snippet44156092_26227.java", "target": 0, "func": "byte[] decodeData(byte[] key, byte[] data)\n{\n    try {\n        SecretKeySpec skeySpec = new SecretKeySpec(key, \"AES\");\n        Cipher cipher = Cipher.getInstance(\"AES\");\n        cipher.init(Cipher.DECRYPT_MODE, skeySpec);\n\n        return cipher.doFinal(data);\n    } catch(Exception e) {\n        Log.e(\"Cryptography\", e.getMessage());\n    }\n    return new byte[0];\n}\n", "idx": 1684}
{"project": "cipher", "commit_id": "Snippet19517916_2268.java", "target": 1, "func": "public class AESencrypt {\n\n    private static final String ALGO = \"AES/CBC/PKCS5Padding\";\n    private static final byte[] keyValue = new byte[]{'T', 'h', 'e', 'B', 'e', 's', 't', 'S', 'e', 'c', 'r', 'e', 't', 'K', 'e', 'y'};\n    private static byte[] iv = { 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0 };\n\n    public void String encryptToFile(String filename, String data) throws Exception {\n        Key key = new SecretKeySpec(keyValue, \"AES\");\n        Cipher c = Cipher.getInstance(ALGO);\n        IvParameterSpec ivspec = new IvParameterSpec(iv);\n        c.init(Cipher.ENCRYPT_MODE, key, ivspec);\n        byte[] encVal = c.doFinal(data.getBytes());\n        FileOutputStream fileOutputStream = new FileOutputStream(filename);\n        fileOutputStream.write(encVal);\n        fileOutputStream.close();\n    }\n\n    public static void main(String[] args) throws Exception {\n        encryptToFile(\"foo.aes\", \"hellothere\");\n    }\n}\n", "idx": 2185}
{"project": "cipher", "commit_id": "Snippet22109799_4535.java", "target": 0, "func": " public static void desdecrypt(IOLogger log, byte[] datablock, String grouppw, ArrayList<byte[]> resp)\n      {\n        try\n          {\n            SecretKey ks = generatedessecretkey(grouppw);\n            Cipher cipher = Cipher.getInstance(\"DES\");\n            cipher.init(Cipher.DECRYPT_MODE, ks);\n            byte[] b = cipher.doFinal(datablock);\n            resp.clear();\n            resp.add(b);\n            return;\n          }\n        catch (Exception e)\n          {\n          }\n      }\n", "idx": 1895}
{"project": "cipher", "commit_id": "Snippet35070533_17015.java", "target": 1, "func": "package scsc;\n\nimport javax.crypto.Cipher;\nimport javax.crypto.spec.IvParameterSpec;\nimport javax.crypto.spec.SecretKeySpec;\nimport java.io.*;\nimport java.lang.reflect.Field;\nimport java.nio.charset.Charset;\nimport java.nio.file.Files;\nimport java.nio.file.StandardCopyOption;\nimport java.security.Permission;\nimport java.security.PermissionCollection;\nimport java.util.Map;\nimport java.util.zip.InflaterInputStream;\n\n/*\n * Published under the Do What the Fuck You Want to Public License (       http://www.wtfpl.net/ )\n */\npublic class ScsC {\nprivate static byte[] AES_KEY = new byte[]{\n        (byte) 0x2a, (byte) 0x5f, (byte) 0xcb, (byte) 0x17,\n        (byte) 0x91, (byte) 0xd2, (byte) 0x2f, (byte) 0xb6,\n        (byte) 0x02, (byte) 0x45, (byte) 0xb3, (byte) 0xd8,\n        (byte) 0x36, (byte) 0x9e, (byte) 0xd0, (byte) 0xb2,\n        (byte) 0xc2, (byte) 0x73, (byte) 0x71, (byte) 0x56,\n        (byte) 0x3f, (byte) 0xbf, (byte) 0x1f, (byte) 0x3c,\n        (byte) 0x9e, (byte) 0xdf, (byte) 0x6b, (byte) 0x11,\n        (byte) 0x82, (byte) 0x5a, (byte) 0x5d, (byte) 0x0a,\n};\n\npublic static void main(String[] args) throws Exception {\n    if (args.length < 1) {\n        System.out.println(\"ERROR: expecting at least one file.\");\n    } else {\n        removeCryptographyRestrictions();\n        for (String filename : args) {\n            decrypt(filename);\n        }\n    }\n}\n\nprivate static void decrypt(String filename) throws Exception {\n    File scsc = new File(filename);\n    if (!scsc.isFile() || !scsc.canWrite()) {\n        throw new IllegalArgumentException(filename + \" is not a writable file.\");\n    }\n    boolean encrypted = isEncrypted(scsc);\n    if (!encrypted) {\n        System.out.println(scsc + \" does not seem to be encrypted.\");\n    } else {\n        File decrypted = decrypt(scsc);\n        Files.copy(decrypted.toPath(), scsc.toPath(), StandardCopyOption.REPLACE_EXISTING);\n        System.out.println(\"decrypted: \" + scsc);\n    }\n}\n\nprivate static boolean isEncrypted(File file) throws Exception {\n    byte[] header = new byte[4];\n    FileInputStream fis = new FileInputStream(file);\n    if (fis.read(header) != header.length) {\n        throw new RuntimeException(\"could not read header of \" + file);\n    }\n    fis.close();\n    String headerAsString = new String(header, Charset.forName(\"UTF-8\"));\n    return \"ScsC\".equals(headerAsString);\n}\n\nprivate static File decrypt(File input) throws Exception {\n    File out = File.createTempFile(\"scsc-\", \".tmp\");\n    out.deleteOnExit();\n\n    byte[] data = new byte[(int) (input.length())];\n    FileInputStream fis = new FileInputStream(input);\n    if (fis.read(data) != data.length) {\n        throw new RuntimeException(\"Could not read \" + input + \" into memory\");\n    }\n    fis.close();\n\n    byte[] cipherText = new byte[data.length - 0x38];\n    byte[] iv = new byte[0x10];\n    System.arraycopy(data, 0x38, cipherText, 0, cipherText.length);\n    System.arraycopy(data, 0x24, iv, 0, iv.length);\n    byte[] decrypted = decrypt(cipherText, AES_KEY, iv);\n\n    ByteArrayInputStream bis = new ByteArrayInputStream(decrypted);\n    InflaterInputStream iis = new InflaterInputStream(bis);\n    InputStreamReader ir = new InputStreamReader(iis);\n    BufferedReader br = new BufferedReader(ir);\n\n    FileOutputStream fos = new FileOutputStream(out);\n    OutputStreamWriter osw = new OutputStreamWriter(fos);\n    PrintWriter pw = new PrintWriter(osw);\n\n    for (String line = br.readLine(); line != null; line = br.readLine()) {\n        pw.println(line);\n    }\n    pw.close();\n    br.close();\n\n    return out;\n}\n\nprivate static byte[] decrypt(byte[] cipherText, byte[] keyBytes, byte[] iv) throws Exception {\n    Cipher cipher = Cipher.getInstance(\"AES/CBC/NoPadding\");\n    SecretKeySpec key = new SecretKeySpec(keyBytes, \"AES\");\n    cipher.init(Cipher.DECRYPT_MODE, key, new IvParameterSpec(iv));\n    return cipher.doFinal(cipherText);\n}\n\nprivate static void removeCryptographyRestrictions() throws Exception {\n    // taken from http://stackoverflow.com/questions/1179672/unlimited-strength-jce-policy-files\n    final Class<?> jceSecurity = Class.forName(\"javax.crypto.JceSecurity\");\n    final Class<?> cryptoPermissions = Class.forName(\"javax.crypto.CryptoPermissions\");\n    final Class<?> cryptoAllPermission = Class.forName(\"javax.crypto.CryptoAllPermission\");\n\n    final Field isRestrictedField = jceSecurity.getDeclaredField(\"isRestricted\");\n    isRestrictedField.setAccessible(true);\n    isRestrictedField.set(null, false);\n\n    final Field defaultPolicyField = jceSecurity.getDeclaredField(\"defaultPolicy\");\n    defaultPolicyField.setAccessible(true);\n    final PermissionCollection defaultPolicy = (PermissionCollection) defaultPolicyField.get(null);\n\n    final Field perms = cryptoPermissions.getDeclaredField(\"perms\");\n    perms.setAccessible(true);\n    ((Map<?, ?>) perms.get(defaultPolicy)).clear();\n\n    final Field instance = cryptoAllPermission.getDeclaredField(\"INSTANCE\");\n    instance.setAccessible(true);\n    defaultPolicy.add((Permission) instance.get(null));\n}\n}\n", "idx": 2294}
{"project": "cipher", "commit_id": "Snippet24396870_6708.java", "target": 1, "func": "public class crypto {\n    public static void main(String [] args) {\n        String s = args[0];\n        String s1 = args[1];\n        String ivkey = \"thisisasecretkey\";\n        byte[] ivraw = ivkey.getBytes();\n        SecretKeySpec skeySpec = new SecretKeySpec(ivraw, \"AES\");\n\n        if (s.equalsIgnoreCase(\"ENCRYPT\")) {\n            try {\n                Cipher cipher = Cipher.getInstance(\"AES/CBC/PKCS5Padding\");\n                cipher.init(Cipher.ENCRYPT_MODE, skeySpec);\n                byte[] encrypted = cipher.doFinal(s1.getBytes());\n                System.out.println(new String(Base64.encodeBase64(encrypted)));\n\n            } catch (Exception e) {\n                throw new RuntimeException(e);\n            }\n        } else {\n            try {\n                Cipher cipher = Cipher.getInstance(\"AES/CBC/PKCS5Padding\");\n                cipher.init(Cipher.DECRYPT_MODE, skeySpec);\n                byte[] encrypted = cipher.doFinal(s1.getBytes());\n                System.out.println(new String(Base64.decodeBase64(encrypted)));\n\n            } catch (Exception e) {\n                e.printStackTrace();\n            }\n\n        }\n        return;\n    };\n}\n", "idx": 2044}
{"project": "cipher", "commit_id": "Snippet4806623_31315.java", "target": 1, "func": "MessageDigest sha1 = MessageDigest.getInstance(\"SHA1\", BOUNCY_CASTLE_PROVIDER);\nbyte[] digest = sha1.digest(content);\nDERObjectIdentifier sha1oid_ = new DERObjectIdentifier(\"1.3.14.3.2.26\");\n\nAlgorithmIdentifier sha1aid_ = new AlgorithmIdentifier(sha1oid_, null);\nDigestInfo di = new DigestInfo(sha1aid_, digest);\n\nbyte[] plainSig = di.getDEREncoded();\nCipher cipher = Cipher.getInstance(\"RSA/ECB/PKCS1Padding\", BOUNCY_CASTLE_PROVIDER);\ncipher.init(Cipher.ENCRYPT_MODE, privateKey);\nbyte[] signature = cipher.doFinal(plainSig);\n", "idx": 2270}
{"project": "cipher", "commit_id": "Snippet20531474_3126.java", "target": 1, "func": "pubEncryptCipher = Cipher.getInstance(\"RSA\");\npubDecryptCipher = Cipher.getInstance(\"RSA\");\n", "idx": 2050}
{"project": "cipher", "commit_id": "Snippet46574112_28704.java", "target": 0, "func": "public class Blowfish {\n    static SecretKey key = null;\n    static String IV = \"AAAAAAAA\";\n\n    public Blowfish(int bits, InetAddress ip) throws UnknownHostException, IOException, NoSuchAlgorithmException {\n\n        KeyGenerator keyGenerator = KeyGenerator.getInstance(\"Blowfish\");\n        keyGenerator.init(bits); // 32 a 448 (default 128)\n        key = keyGenerator.generateKey();\n        String encodedKey = Base64.getEncoder().encodeToString(key.getEncoded());\n        RSA.exchangeKey(encodedKey, ip);\n\n    }\n\n    public static byte[] encrypt(byte[] plainData, int offset, int length) throws Exception {\n        Cipher cipher = Cipher.getInstance(\"Blowfish/OFB/PKCS5Padding\");\n        cipher.init(Cipher.ENCRYPT_MODE, key, new IvParameterSpec(IV.getBytes(\"UTF-8\")));\n        return cipher.doFinal(plainData, offset, length);\n\n    }\n\n    public static byte[] decrypt(byte[] cipherSound, int offset, int length) throws Exception {\n        Cipher cipher = Cipher.getInstance(\"Blowfish/OFB/PKCS5Padding\");\n        cipher.init(Cipher.DECRYPT_MODE, key, new IvParameterSpec(IV.getBytes(\"UTF-8\")));\n        return cipher.doFinal(cipherSound, offset, length);\n    }\n\n}\n", "idx": 1859}
{"project": "cipher", "commit_id": "Snippet22589960_4995.java", "target": 1, "func": "try {\n    Cipher cipher = Cipher.getInstance(\"AES/CBC/PKCS5Padding\");\n} catch(GeneralSecurityException e) {\n    throw new IllegalStateException(\"Could not retrieve AES cipher\", e);\n} \n", "idx": 2256}
{"project": "cipher", "commit_id": "Snippet39579865_21518.java", "target": 1, "func": "byte[] keyByte = DatatypeConverter.parseHexBinary(\"007e151628aed2a6abf7158809cf4f3c\");\nCipher aesCipher = Cipher.getInstance(transformation);\nbyte[] buf = new byte[1024];\n\nfor(int i = 0; i < 256; i++){\n    keyByte[0] = (byte)i;\n\n    FileInputStream inFileStream = new FileInputStream(path);\n    File outFile = new File(\"AESencrypt_view\" + String.valueOf(i)+\".jpg\");\n    FileOutputStream outFileStream = new FileOutputStream(outFile);\n\n    SecretKeySpec keySpec = new SecretKeySpec(keyByte, \"AES\");\n    aesCipher.init(Cipher.DECRYPT_MODE, keySpec);\n\n    int read;\n    while((read = inFileStream.read(buf)) != -1){\n        outFileStream.write(aesCipher.update(buf, 0, read));\n    }\n    inFileStream.close();\n\n    try {\n        outFileStream.write(aesCipher.doFinal());\n        outFileStream.close();\n    }\n    catch(BadPaddingException e) {\n        // obviously a wrong key or broken ciphertext\n        outFileStream.close();\n        outFile.delete();\n    }\n}\n", "idx": 2336}
{"project": "cipher", "commit_id": "Snippet40575847_22438.java", "target": 1, "func": "private SecretKeySpec secretKey;\nprivate IvParameterSpec ivSpec;\n\npublic void setKey(String myKey) {\n    MessageDigest sha = null;\n    try {\n        byte[] key = myKey.getBytes(\"UTF-8\");\n        sha = MessageDigest.getInstance(\"SHA-1\");\n        key = sha.digest(key);\n        key = Arrays.copyOf(key, 16);\n        secretKey = new SecretKeySpec(key, \"AES\");\n\n        byte[] iv = new String(\"1010101010101010\").getBytes(\"UTF-8\");\n        ivSpec = new IvParameterSpec(iv);\n\n    } catch (NoSuchAlgorithmException e) {\n        e.printStackTrace();\n    } catch (UnsupportedEncodingException e) {\n        e.printStackTrace();\n    }\n}\n\npublic String encrypt(String strToEncrypt) {\n    try {\n        Cipher cipher = Cipher.getInstance(\"AES/CBC/PKCS5Padding\");\n        cipher.init(Cipher.ENCRYPT_MODE, secretKey, ivSpec);\n        return Base64.encode(cipher.doFinal(strToEncrypt.getBytes(\"UTF-8\")));\n    } catch (Exception e) {\n        e.printStackTrace();\n    }\n    return null;\n}\n\npublic String decrypt(String strToDecrypt) {\n    try {\n        Cipher cipher = Cipher.getInstance(\"AES/CBC/PKCS5Padding\");\n        cipher.init(Cipher.DECRYPT_MODE, secretKey, ivSpec);\n        return new String(cipher.doFinal(Base64.decode(strToDecrypt)));\n    } catch (Exception e) {\n        e.printStackTrace();\n    }\n    return null;\n}\n\npublic static void main(String[] args) {\n\n    AESText aes = new AESText();\n    final String secretKey = \"com.secure.test.projectjasdS/FjkGkGhkGjhG786Vjfg=tjGFGH\";\n    aes.setKey(secretKey);\n\n    String originalString = \"test set se ts et set s et se\";\n    String encryptedString = aes.encrypt(originalString);\n    String decryptedString = aes.decrypt(encryptedString);\n\n    System.out.println(\"origin: \" + originalString);\n    System.out.println(\"encrypted: \" + encryptedString);\n    System.out.println(\"decrypted: \" + decryptedString);\n}\n", "idx": 2030}
{"project": "cipher", "commit_id": "Snippet23486896_5824.java", "target": 1, "func": "private void decryptData(String PrivateK,byte[] data) throws IOException {\n        System.out.println(\"\\n-------DECRYPTION STARTED----\");\n        byte[] descryptedData = null;\n\n        try {\n            PrivateKey privateKey = readPrivateKeyFromFile(PrivateK);\n            Cipher cipher = Cipher.getInstance(\"RSA\");\n            cipher.init(Cipher.DECRYPT_MODE, privateKey);\n            descryptedData = cipher.doFinal(data);\n            System.out.println(\"Decrypted Data: \" + new String(descryptedData));\n\n        } catch (Exception e) {\n            e.printStackTrace();\n        }   \n\n        System.out.println(\"------DECRYPTION COMPLETED-----\");      \n    }\n", "idx": 2211}
{"project": "cipher", "commit_id": "Snippet24231213_6515.java", "target": 0, "func": "try {\n                        KeyStore keyStore=null;\n                        keyStore= KeyStore.getInstance(KeyStore.getDefaultType());\n                        char[] passwordKS=\"network\".toCharArray();\n\n                             SecureRandom sr = SecureRandom.getInstance(\"SHA1PRNG\");\n                             sr.setSeed(\"any data used as random seed\".getBytes());\n                             KeyGenerator kg = KeyGenerator.getInstance(\"AES\");\n                             kg.init(128, sr);\n                             key= kg.generateKey();\n                             keyToSave=key.getEncoded();\n                             sks = new SecretKeySpec(keyToSave, \"AES\");\n\n                             try\n                             {\n                             keyStore.load(null,null);\n                             keyStore.setKeyEntry(\"aliasKey\",key,passwordKS, null);\n\n                             }\n                             catch(Exception ex)\n                             {\n\n                             }\n                             FileOutputStream ksout=openFileOutput(\"keyStoreName\", Context.MODE_PRIVATE);\n                             keyStore.store(ksout, passwordKS);\n                             ksout.close();\n                         }\n\n\n                     } catch (Exception e) {\n                     }\n                byte[] userLongENC = null;\n                byte[] userLatENC=null;\n                try {\n                    Cipher c = Cipher.getInstance(\"AES\");\n                    c.init(Cipher.ENCRYPT_MODE,sks ); \n                    userLatENC = c.doFinal(userLat.getBytes());\n                    userLongENC = c.doFinal(userLong.getBytes());\n                } catch (Exception e) {\n                 }\n", "idx": 1887}
{"project": "cipher", "commit_id": "Snippet8049872_33047.java", "target": 0, "func": "public class PasswordCrypter {\n\n    private Key key;\n    public PasswordCrypter(String password)  {\n\n              try{\n                    KeyGenerator generator;\n                    generator = KeyGenerator.getInstance(\"DES\");\n                    SecureRandom sec = new SecureRandom(password.getBytes());\n                    generator.init(sec);\n                    key = generator.generateKey();\n              }\n        catch (Exception e) {\n            e.printStackTrace();\n        }\n\n    }\n\n\n    public byte[] encrypt(byte[] array) throws CrypterException {\n\n        try{\n            Cipher cipher = Cipher.getInstance(\"DES/ECB/PKCS5Padding\");\n            cipher.init(Cipher.ENCRYPT_MODE, key);\n\n                return cipher.doFinal(array);\n        }catch (Exception e) {  \n            e.printStackTrace();\n        }\n        return null;\n    }\n\n    public byte[] decrypt(byte[] array) throws CrypterException{\n\n        try{\n            Cipher cipher = Cipher.getInstance(\"DES/ECB/PKCS5Padding\");\n            cipher.init(Cipher.DECRYPT_MODE, key);\n\n            return cipher.doFinal(array);\n        }catch(Exception e ){\n            e.printStackTrace();\n        }\n\n\n        return null;\n    }\n}\n", "idx": 1697}
{"project": "cipher", "commit_id": "Snippet35443291_17346.java", "target": 1, "func": "  int length = dis.readInt();//recieve length of byte array for incoming message\n        byte[] encryptedMessage = new byte[length];//create a byte array to the length recieved\n        dis.readFully(encryptedMessage);//fill the byte array with incoming data\n\n        //decrypt using AES\n\n        Cipher aesCipher = Cipher.getInstance(\"AES/CBC/PKCS5PADDING\");//create a cipher with correct parameters\n        IvParameterSpec ivParaSpec = new IvParameterSpec(iv);//create IvParameter spec using IV provided in assignment brief\n\n        aesCipher.init(Cipher.DECRYPT_MODE,key,ivParaSpec);//initialise the Cipher in DECRYPT mode\n        byte[] decryptedMessage = aesCipher.doFinal(encryptedMessage);//create decryptedMessage and put in byte array\n\n        String decMess = new String(decryptedMessage,\"UTF-8\");\n\n        System.out.println(\"User ID:\");\n        System.out.println(uid);\n\n        System.out.println(\"Decrypted Message:\");\n        System.out.println(decMess);\n", "idx": 1958}
{"project": "cipher", "commit_id": "Snippet11393397_35554.java", "target": 0, "func": "<%@ page import=\"java.sql.*\" %>\n<%@ page import=\"java.security.*\" %>\n<%@ page import=\"javax.crypto.*\" %>\n<%@ page import=\"javax.crypto.spec.*\" %>\n\n<HTML>\n<HEAD>\n<TITLE>Simple JSP/Oracle Query Example</TITLE>\n</HEAD>\n<BODY>\n\n<%\n   Class.forName(\"oracle.jdbc.OracleDriver\");\n\n   Connection conn = DriverManager.getConnection(\"jdbc:oracle:thin:@xxx:xxxx:xxxx\",\"ixxxer\",\"ixxxer\");\n                        // @//machineName:port:SID,   userid,  password\n\n    Statement st=conn.createStatement();\n\n    ResultSet rs=st.executeQuery(\"Select * from Cusxxxxer\");\n\n    while(rs.next()){\n        String name=rs.getString(\"user_id\");\n        String p=rs.getString(\"password\");\n        out.println(name+\":\"+p);\n        out.println(\"</br>\");\n\n\n    String algorithm1 = \"DES\";//magical mystery constant\n    String algorithm2 = \"DES/CBC/NoPadding\";//magical mystery constant\n    IvParameterSpec iv = new IvParameterSpec( new byte [] { 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00 } );//magical mystery constant\n    Cipher cipher;\n    SecretKey key;\n    String k=\"12345abc\";\n    key = new SecretKeySpec( k.getBytes( ), algorithm1 );\n    cipher = Cipher.getInstance( algorithm2 );\n\n    String str=\"test1234abc\";\n\n    cipher.init( Cipher.ENCRYPT_MODE, key, iv ); //normally you could leave out the IvParameterSpec argument, but not with Oracle\n\n    byte[] bytes=str.getBytes(\"UTF-8\");\n\n    byte[] encrypted = cipher.doFinal( bytes );\n\n    }\n%>  \n</BODY>\n</HTML>\n", "idx": 1581}
{"project": "cipher", "commit_id": "Snippet28455785_10600.java", "target": 1, "func": " import java.io.File;\nimport java.io.FileInputStream;\nimport java.io.FileNotFoundException;\nimport java.io.FileOutputStream;\nimport java.io.IOException;\nimport java.io.InputStream;\nimport java.io.OutputStream;\nimport java.security.InvalidAlgorithmParameterException;\nimport java.security.InvalidKeyException;\nimport java.security.NoSuchAlgorithmException;\nimport java.security.SecureRandom;\n\nimport javax.crypto.Cipher;\nimport javax.crypto.CipherInputStream;\nimport javax.crypto.CipherOutputStream;\nimport javax.crypto.NoSuchPaddingException;\nimport javax.crypto.spec.IvParameterSpec;\nimport javax.crypto.spec.SecretKeySpec;\n\n\n    class MyTest{\n     public static OutputStream aes256CBCEncrypt(OutputStream os, String passPhrase) throws NoSuchAlgorithmException, NoSuchPaddingException, IOException, InvalidKeyException, InvalidAlgorithmParameterException\n    {\n\n        //  MessageDigest md = MessageDigest.getInstance(\"SHA-256\");\n        //  md.update(passPhrase.getBytes());\n        //  byte[] key = md.digest();\n\n            Cipher aesCipher = Cipher.getInstance(\"AES/CBC/ISO10126Padding\");\n\n            SecureRandom secureRandom = new SecureRandom();\n            secureRandom.setSeed(System.currentTimeMillis());\n            byte[] bb = new byte[16];\n            secureRandom.nextBytes(bb);\n            os.write(bb);\n\n            aesCipher.init(Cipher.ENCRYPT_MODE, new SecretKeySpec(passPhrase.getBytes(), \"AES\"), new IvParameterSpec(\n                    bb));\n            return new CipherOutputStream(os, aesCipher);\n\n\n    }\n\n    public static InputStream aes256CBCDecrypt(File f, String passPhrase)\n            throws FileNotFoundException\n    {\n        FileInputStream fis = null;\n        try\n        {\n            //MessageDigest md = MessageDigest.getInstance(\"SHA-256\");\n        //  md.update(passPhrase.getBytes());\n        //  byte[] key = md.digest();\n\n            Cipher aesCipher = Cipher.getInstance(\"AES/CBC/ISO10126Padding\");\n            fis = new FileInputStream(f);\n            byte[] bb = new byte[16];\n            fis.read(bb);\n            aesCipher.init(Cipher.DECRYPT_MODE, new SecretKeySpec(passPhrase.getBytes(), \"AES\"), new IvParameterSpec(\n                    bb));\n            return new CipherInputStream(fis, aesCipher);\n        }\n        catch (final Exception e)\n        {\n\n\n        }\n        return null;\n    }\n\n    public static void main(String args[]) throws InvalidKeyException, NoSuchAlgorithmException, NoSuchPaddingException, InvalidAlgorithmParameterException, IOException{\n    String keyFile = \"C:\\\\contentProducer\" + File.separator + \"test\";\n        String encryptedFile = \"C:\\\\contentProducer\" + File.separator + \"encryptedtest\";\n        String decryptedFile = \"C:\\\\contentProducer\" + File.separator + \"decryptedtest\";\n\n        FileInputStream in = new FileInputStream(keyFile);\n        FileOutputStream bos = new FileOutputStream(new File(encryptedFile));\n\n    //Call method for Encryption\n        OutputStream encryptedBos = aes256CBCEncrypt(bos,\"0123456789abcdef\");\n        int inByte;\n        while ((inByte = in.read()) != -1 ) {\n            encryptedBos.write(inByte);\n        }\n        in.close();\n        bos.close();\n        encryptedBos.close();\n\n    //Call Method for Decryption\n\n        InputStream inputStream = aes256CBCDecrypt(new File(encryptedFile), \"0123456789abcdef\");\n\n        FileOutputStream deos = new FileOutputStream(new File(decryptedFile));\n        while ((inByte = inputStream.read()) != -1 ) {\n            deos.write(inByte);\n        }\n        inputStream.close();\n        deos.close();\n\n        }\n\n}\n", "idx": 2315}
{"project": "cipher", "commit_id": "Snippet22694767_5105.java", "target": 1, "func": "import java.io.File;\nimport java.io.FileWriter;\nimport java.io.IOException;\nimport java.nio.ByteBuffer;\nimport java.nio.charset.Charset;\nimport java.nio.charset.StandardCharsets;\nimport java.nio.file.Files;\nimport java.nio.file.Paths;\nimport java.security.MessageDigest;\nimport java.security.SecureRandom;\nimport javax.crypto.Cipher;\nimport javax.crypto.spec.IvParameterSpec;\nimport javax.crypto.spec.SecretKeySpec;\n\npublic class crypt {\n\n    public static void main(String args[]) throws Exception {\n\n\n        String keyString = \"averylongtext!@$@#$#@$#&(&}{23432432432dsfsdf\";\n        FileWriter fileWriter = null, fileWriter1 = null;\n        File enc = new File(\"C:\\\\test\\\\encrypted.txt\");\n        File dec = new File(\"C:\\\\test\\\\decrypted.txt\");\n        String path = \"C:\\\\test\\\\normal_file.txt\";\n        String path2 = \"C:\\\\test\\\\encrypted.txt\";\n        fileWriter = new FileWriter(enc);\n        fileWriter1 = new FileWriter(dec);\n\n\n        String input = readFile(path, StandardCharsets.UTF_8);\n        Cipher cipher = Cipher.getInstance(\"AES/CBC/PKCS5Padding\");\n        byte[] iv = new byte[cipher.getBlockSize()];\n        new SecureRandom().nextBytes(iv);\n        IvParameterSpec ivSpec = new IvParameterSpec(iv);\n        MessageDigest digest = MessageDigest.getInstance(\"SHA-256\");\n        digest.update(keyString.getBytes());\n        byte[] key = new byte[16];\n        System.arraycopy(digest.digest(), 0, key, 0, key.length);\n        SecretKeySpec keySpec = new SecretKeySpec(key, \"AES\");\n        cipher.init(Cipher.ENCRYPT_MODE, keySpec, ivSpec);\n        byte[] encrypted = cipher.doFinal(input.getBytes());\n        System.out.println(new String(encrypted));\n\n   //writing encrypted information to a new file encrypted.txt\n        fileWriter.write(new String(encrypted));\n        fileWriter.close();\n\n  //reading encrypted information from the file encrypted.txt\n  //This part is where the error is\n        encrypted = readFile(path2, StandardCharsets.UTF_8).getBytes();\n        cipher.init(Cipher.DECRYPT_MODE, keySpec, ivSpec);\n        byte[] decrypted = cipher.doFinal(encrypted);\n        System.out.println(\"decrypted: \\n\" + new String(decrypted, \"UTF-8\"));\n\n  //writing the decrypted information to the file decrypted.txt\n        fileWriter1.write(new String(decrypted));\n        fileWriter1.close();\n\n    }\n\n //method to read a file\n    static String readFile(String path, Charset encoding) throws IOException {\n        byte[] encoded = Files.readAllBytes(Paths.get(path));\n        return encoding.decode(ByteBuffer.wrap(encoded)).toString();\n    }\n\n}\n", "idx": 2194}
{"project": "cipher", "commit_id": "Snippet31560545_13702.java", "target": 0, "func": "private String DEFAULT_KEY = \"abcdwAYserXbzcSeqL/zPg==\";\nprivate String text = \"abc\";\nBase64 base64decoder = new Base64();\nbyte[] raw = base64decoder.decode(key);\n\nSecretKeySpec fSecretKeySpec = new SecretKeySpec(raw, \"AES\");\n\nCipher cipher = Cipher.getInstance(\"AES\");\ncipher.init(Cipher.ENCRYPT_MODE, fSecretKeySpec);\nbyte[] encrypted = cipher.doFinal(text.getBytes());\n\nBase64 base64encoder = new Base64();\nresult = base64encoder.encodeToString(encrypted);\nSystem.out.println(\"result: \"+ result);\n", "idx": 1801}
{"project": "cipher", "commit_id": "Snippet9461115_33944.java", "target": 0, "func": "EncrypterDecrypter(SecretKey key)\n{\n    try {\n        ecipher = Cipher.getInstance(\"DES\");\n        dcipher = Cipher.getInstance(\"DES\");\n        ecipher.init(Cipher.ENCRYPT_MODE, key);\n        dcipher.init(Cipher.DECRYPT_MODE, key);\n\n    } catch (javax.crypto.NoSuchPaddingException e) {\n    } catch (java.security.NoSuchAlgorithmException e) {\n    } catch (java.security.InvalidKeyException e) {\n    }\n}   \n", "idx": 1820}
{"project": "cipher", "commit_id": "Snippet31022756_13205.java", "target": 0, "func": "public static void encryptAndClose(FileInputStream fis, FileOutputStream fos) \n        throws IOException, NoSuchAlgorithmException, NoSuchPaddingException, InvalidKeyException {\n\n    // Length is 16 byte\n    SecretKeySpec sks = new SecretKeySpec(\"1234567890123456\".getBytes(), \"AES\");\n    // Create cipher\n    Cipher cipher = Cipher.getInstance(\"AES\");\n    cipher.init(Cipher.ENCRYPT_MODE, sks);      \n\n    // Wrap the output stream for encoding\n    CipherOutputStream cos = new CipherOutputStream(fos, cipher);       \n\n    //wrap output with buffer stream\n    BufferedOutputStream bos = new BufferedOutputStream(cos);     \n\n    //wrap input with buffer stream\n    BufferedInputStream bis = new BufferedInputStream(fis); \n\n    // Write bytes\n    int b;\n    byte[] d = new byte[8];\n    while((b = bis.read(d)) != -1) {\n        bos.write(d, 0, b);\n    }\n    // Flush and close streams.\n    bos.flush();\n    bos.close();\n    bis.close();\n}\n\n\npublic static void decryptAndClose(FileInputStream fis, FileOutputStream fos) \n        throws IOException, NoSuchAlgorithmException, NoSuchPaddingException, InvalidKeyException {\n\n    SecretKeySpec sks = new SecretKeySpec(\"1234567890123456\".getBytes(), \"AES\");\n    Cipher cipher = Cipher.getInstance(\"AES\");\n    cipher.init(Cipher.DECRYPT_MODE, sks);\n\n    CipherInputStream cis = new CipherInputStream(fis, cipher);\n\n    //wrap input with buffer stream\n    BufferedInputStream bis = new BufferedInputStream(cis); \n\n    //wrap output with buffer stream\n    BufferedOutputStream bos = new BufferedOutputStream(fos);       \n\n    int b;\n    byte[] d = new byte[8];\n    while((b = bis.read(d)) != -1) {\n        bos.write(d, 0, b);\n    }\n    bos.flush();\n    bos.close();\n    bis.close();\n}\n", "idx": 1676}
{"project": "cipher", "commit_id": "Snippet22034269_4443.java", "target": 0, "func": "private String decrypt_data(String encData) \n                throws NoSuchAlgorithmException, NoSuchPaddingException, InvalidKeyException, IllegalBlockSizeException, BadPaddingException\n    {\n        String key = \"bad8deadcafef00d\";\n        SecretKeySpec skeySpec = new SecretKeySpec(key.getBytes(), \"AES\");\n        Cipher cipher = Cipher.getInstance(\"AES/ECB/NoPadding\");\n\n        cipher.init(Cipher.DECRYPT_MODE, skeySpec);\n\n        System.out.println(\"Base64 decoded: \"+Base64.decode(encData.getBytes()).length);\n        byte[] original = cipher.doFinal(Base64.decode(encData.getBytes()));\n        return new String(original).trim();     \n    }\n\n    private String encrypt_data(String data) \n                throws NoSuchAlgorithmException, NoSuchPaddingException, InvalidKeyException, IllegalBlockSizeException, BadPaddingException\n    {\n        String key = \"bad8deadcafef00d\";\n        SecretKeySpec skeySpec = new SecretKeySpec(key.getBytes(), \"AES\");\n        Cipher cipher = Cipher.getInstance(\"AES/ECB/NoPadding\");\n\n        cipher.init(Cipher.ENCRYPT_MODE, skeySpec);\n\n        System.out.println(\"Base64 encoded: \"+ Base64.encode(data.getBytes()).length);\n\n        byte[] original = cipher.doFinal(Base64.encode(data.getBytes()));\n        return new String(original);\n    }\n", "idx": 1835}
{"project": "cipher", "commit_id": "Snippet18358247_1405.java", "target": 1, "func": "import java.security.GeneralSecurityException;\nimport javax.crypto.Cipher;\nimport javax.crypto.spec.IvParameterSpec;\nimport javax.crypto.spec.SecretKeySpec;\nimport android.util.Log;\n\npublic class EncodeDecodeAES {\n\n\n    private static final String TAG_DEBUG = \"TAG\";\n    private IvParameterSpec ivspec;\n    private SecretKeySpec keyspec;\n    private Cipher cipher;\n\n    private String iv = \"fedcba9876543210\";//Dummy iv (CHANGE IT!)\n    private String SecretKey = \"0123456789abcdef\";//Dummy secretKey (CHANGE IT!)\n\n    public EncodeDecodeAES() {\n        ivspec = new IvParameterSpec(iv.getBytes());\n\n        keyspec = new SecretKeySpec(SecretKey.getBytes(), \"AES\");\n\n        try {\n            cipher = Cipher.getInstance(\"AES/CBC/NoPadding\");\n        } catch (GeneralSecurityException e) {\n            Log.d(TAG_DEBUG, e.getMessage());\n        }\n    }\n\n    public byte[] encrypt(String text) throws Exception {\n        if (text == null || text.length() == 0)\n            throw new Exception(\"Empty string\");\n\n        byte[] encrypted = null;\n\n        try {\n            cipher.init(Cipher.ENCRYPT_MODE, keyspec, ivspec);\n\n            encrypted = cipher.doFinal(padString(text).getBytes());\n        } catch (Exception e) {\n            Log.d(TAG_DEBUG, e.getMessage());\n            throw new Exception(\"[encrypt] \" + e.getMessage());\n        }\n\n        return encrypted;\n    }\n\n    public byte[] decrypt(String code) throws Exception {\n        if (code == null || code.length() == 0)\n            throw new Exception(\"Empty string\");\n\n        byte[] decrypted = null;\n\n        try {\n            cipher.init(Cipher.DECRYPT_MODE, keyspec, ivspec);\n\n            decrypted = cipher.doFinal(hexToBytes(code));\n        } catch (Exception e) {\n            Log.d(TAG_DEBUG, e.getMessage());\n            throw new Exception(\"[decrypt] \" + e.getMessage());\n        }\n        return decrypted;\n    }\n\n    public static String bytesToHex(byte[] data) {\n        if (data == null) {\n            return null;\n        }\n\n        int len = data.length;\n        String str = \"\";\n        for (int i = 0; i < len; i++) {\n            if ((data[i] & 0xFF) < 16)\n                str = str + \"0\" + java.lang.Integer.toHexString(data[i] & 0xFF);\n            else\n                str = str + java.lang.Integer.toHexString(data[i] & 0xFF);\n        }\n        return str;\n    }\n\n    public static byte[] hexToBytes(String str) {\n        if (str == null) {\n            return null;\n        } else if (str.length() < 2) {\n            return null;\n        } else {\n            int len = str.length() / 2;\n            byte[] buffer = new byte[len];\n            for (int i = 0; i < len; i++) {\n                buffer[i] = (byte) Integer.parseInt(str.substring(i * 2, i * 2 + 2), 16);\n            }\n            return buffer;\n        }\n    }\n\n    private static String padString(String source) {\n        char paddingChar = ' ';\n        int size = 16;\n        int x = source.length() % size;\n        int padLength = size - x;\n\n        for (int i = 0; i < padLength; i++) {\n            source += paddingChar;\n        }\n\n        return source;\n    }\n}\n", "idx": 2300}
{"project": "cipher", "commit_id": "Snippet26611703_8736.java", "target": 1, "func": "SecretKey keySpec = new SecretKeySpec(keyBytes, \"AES\");\nAlgorithmParameterSpec ivSpec = new IvParameterSpec(ivBytes);\nCipher aesCbc = Cipher.getInstance(\"AES/CBC/NoPadding\");\naesCbc.init(Cipher.ENCRYPT_MODE, keySpec, ivSpec);\nbyte[] encryptedBytes = aesCbc.doFinal(plainTextBytes);\nreturn Base64.encodeBase64String(encryptedBytes); \n", "idx": 2033}
{"project": "cipher", "commit_id": "Snippet38340451_20300.java", "target": 1, "func": "    public String aesEncrypt(String key, String data) throws InvalidKeyException, BadPaddingException, IllegalBlockSizeException, NoSuchPaddingException, NoSuchAlgorithmException, UnsupportedEncodingException, InvalidAlgorithmParameterException {\n          SecretKey secKey = new SecretKeySpec(key.getBytes(), \"AES\");\n          KeyGenerator KeyGen = KeyGenerator.getInstance(\"AES\");\n          KeyGen.init(256);\n          Cipher AesCipher = Cipher.getInstance(\"AES/CBC/PKCS7Padding\");\n          AesCipher.init(Cipher.ENCRYPT_MODE, secKey, new IvParameterSpec(IV.getBytes(\"UTF-8\")));\n          byte[] byteCipherText = AesCipher.doFinal(data.getBytes());\n          return Base64.encodeToString(byteCipherText, 0).trim();\n    }\n", "idx": 2079}
{"project": "cipher", "commit_id": "Snippet38007478_20033.java", "target": 1, "func": "public class PBE extends AppCompatActivity {\n\n    private static final String salt = \"A long, but constant phrase that will be used each time as the salt.\";\n    private static final int iterations = 2000;\n    private static final int keyLength = 256;\n    private static final SecureRandom random = new SecureRandom();\n\n    @Override\n    protected void onCreate(@Nullable Bundle savedInstanceState) {\n        super.onCreate(savedInstanceState);\n        setContentView(R.layout.pbe);\n\n        try {\n            Security.insertProviderAt(new BouncyCastleProvider(), 1);\n            //Security.addProvider(new BouncyCastleProvider());\n\n            String passphrase = \"The quick brown fox jumped over the lazy brown dog\";\n            String plaintext = \"Hello\";\n            byte [] ciphertext = encrypt(passphrase, plaintext);\n            String recoveredPlaintext = decrypt(passphrase, ciphertext);\n\n            TextView decryptedTv = (TextView) findViewById(R.id.tv_decrypt);\n\n            decryptedTv.setText(recoveredPlaintext);\n\n            System.out.println(recoveredPlaintext);\n        }catch (Exception e){\n            e.printStackTrace();\n        }\n\n    }\n\n    private static byte [] encrypt(String passphrase, String plaintext) throws Exception {\n        SecretKey key = generateKey(passphrase);\n\n        Cipher cipher = Cipher.getInstance(\"AES/CTR/NOPADDING\");//,new BouncyCastleProvider());\n        cipher.init(Cipher.ENCRYPT_MODE, key, generateIV(cipher), random);\n        return cipher.doFinal(plaintext.getBytes());\n    }\n\n    private static String decrypt(String passphrase, byte [] ciphertext) throws Exception {\n        SecretKey key = generateKey(passphrase);\n\n        Cipher cipher = Cipher.getInstance(\"AES/CTR/NOPADDING\");// , new BouncyCastleProvider());\n        cipher.init(Cipher.DECRYPT_MODE, key, generateIV(cipher), random);\n        return new String(cipher.doFinal(ciphertext));\n    }\n\n    private static SecretKey generateKey(String passphrase) throws Exception {\n        PBEKeySpec keySpec = new PBEKeySpec(passphrase.toCharArray(), salt.getBytes(), iterations, keyLength);\n        SecretKeyFactory keyFactory = SecretKeyFactory.getInstance(\"PBEWITHSHA256AND256BITAES-CBC-BC\");\n        return keyFactory.generateSecret(keySpec);\n    }\n\n    private static IvParameterSpec generateIV(Cipher cipher) throws Exception {\n        byte [] ivBytes = new byte[cipher.getBlockSize()];\n        random.nextBytes(ivBytes);\n        return new IvParameterSpec(ivBytes);\n    }\n\n}\n", "idx": 2318}
{"project": "cipher", "commit_id": "Snippet34663554_16647.java", "target": 0, "func": "/** encrypt cipher */\nprivate static final Cipher ENCRYPT_CIPHER = generateCipher(Cipher.ENCRYPT_MODE);\n\nprivate static String ENCRYPT_KEY = \"key\";\n\n/**\n * @param val\n * @return encrypted value\n * @throws Exception\n */\npublic String encrypt(final String val) throws Exception {\n    return new String(Base64.encodeBase64(ENCRYPT_CIPHER.doFinal(val.getBytes()), true)).toString();\n}\n\n/**\n * @param encrypt\n * @return cipher\n */\nprotected static Cipher generateCipher(final int encrypt) {\n    try {\n        final Cipher cipher = Cipher.getInstance(\"AES\");\n        cipher.init(encrypt, SecretKeyFactory.getInstance(\"AES\").generateSecret(new IBMAESKeySpec(Base64.decodeBase64(ENCRYPT_KEY.getBytes()))));\n        return cipher;\n    } catch (final Exception e) {\n        return null;\n    }\n}\n", "idx": 1836}
{"project": "cipher", "commit_id": "Snippet19172479_2018.java", "target": 0, "func": "//Encryption \nCipher cipher = Cipher.getInstance(\"AES/ECB/PKCS5Padding\");  \nSecretKeySpec secretKey = new SecretKeySpec(key, \"AES\");\ncipher.init(Cipher.ENCRYPT_MODE, secretKey);\n String encryptedString = Base64.encodeBase64String(cipher.doFinal(strToEncrypt.getBytes()));\nreturn encryptedString;\n\n//Decryption\nCipher cipher = Cipher.getInstance(\"AES/ECB/PKCS5PADDING\");\nSecretKeySpec secretKey = new SecretKeySpec(key, \"AES\");\ncipher.init(Cipher.DECRYPT_MODE, secretKey);\nString decryptedString = new String(cipher.doFinal(Base64.decodeBase64(strToDecrypt)));\nreturn decryptedString;\n", "idx": 1786}
{"project": "cipher", "commit_id": "Snippet26412089_8559.java", "target": 1, "func": "public static String encrypt(String value) {\n        byte[] encrypted = null;\n        String encrypted_string = null;\n        try {\n\n            byte[] raw = new byte[]{'T', 'h', 'i', 's', 'I', 's', 'A', 'S', 'e', 'c', 'r', 'e', 't', 'K', 'e', 'y'};\n            Key skeySpec = new SecretKeySpec(raw, \"AES\");\n            Cipher cipher = Cipher.getInstance(\"AES/CBC/PKCS5Padding\");\n            byte[] iv = new byte[cipher.getBlockSize()];\n\n            IvParameterSpec ivParams = new IvParameterSpec(iv);\n            cipher.init(Cipher.ENCRYPT_MODE, skeySpec,ivParams);\n            encrypted  = cipher.doFinal(value.getBytes());\n            System.out.println(\"encrypted string:\" + encrypted.length);\n\n            //Encrypted byte array\n            System.out.println(\"encrypted byte array:\" + encrypted);\n\n            //Encrypted string\n            encrypted_string = new String(encrypted);\n            System.out.println(\"encrypted string: \" + encrypted_string);\n\n        } catch (Exception ex) {\n            ex.printStackTrace();\n        }\n        return encrypted_string;\n    }\n\n    public static String decrypt(String encrypted_string) {\n        byte[] original = null;\n        Cipher cipher = null;\n        String decrypted_string = null;\n        try {\n            byte[] raw = new byte[]{'T', 'h', 'i', 's', 'I', 's', 'A', 'S', 'e', 'c', 'r', 'e', 't', 'K', 'e', 'y'};\n            Key key = new SecretKeySpec(raw, \"AES\");\n            cipher = Cipher.getInstance(\"AES/CBC/PKCS5Padding\");\n            //the block size (in bytes), or 0 if the underlying algorithm is not a block cipher\n            byte[] ivByte = new byte[cipher.getBlockSize()];\n            //This class specifies an initialization vector (IV). Examples which use\n            //IVs are ciphers in feedback mode, e.g., DES in CBC mode and RSA ciphers with OAEP encoding operation.\n            IvParameterSpec ivParamsSpec = new IvParameterSpec(ivByte);\n            cipher.init(Cipher.DECRYPT_MODE, key, ivParamsSpec);\n            original= cipher.doFinal(encrypted_string.getBytes());\n\n            //Converts byte array to String\n            decrypted_string = new String(original);\n            System.out.println(\"Text Decrypted : \" + decrypted_string);\n        } catch (Exception ex) {\n            ex.printStackTrace();\n        }\n        return decrypted_string;\n    }\n", "idx": 2193}
{"project": "cipher", "commit_id": "Snippet9466307_33919.java", "target": 0, "func": " package com.acc;\n\nimport java.io.FileInputStream;\nimport java.io.FileOutputStream;\nimport java.security.KeyPair;\nimport java.security.KeyPairGenerator;\nimport java.security.PrivateKey;\nimport java.security.Provider;\nimport java.security.PublicKey;\nimport java.security.SecureRandom;\nimport java.security.Security;\nimport java.security.Signature;\nimport java.security.spec.ECGenParameterSpec;\nimport java.security.spec.ECParameterSpec;\nimport java.security.spec.EllipticCurve;\n\nimport javax.crypto.Cipher;\nimport javax.crypto.CipherInputStream;\nimport javax.crypto.CipherOutputStream;\nimport javax.crypto.spec.DESKeySpec;\n\n\npublic class TestECC {\n\n    public static void main(String args[]) {\n        try {\n            Provider p[] = Security.getProviders();\n            Provider p1 = Security.getProvider(\"SunEC\");\n            System.out.println(p1.getName());\n            KeyPairGenerator kpg = KeyPairGenerator.getInstance(\"EC\", \"SunEC\");\n            System.out.println(kpg.getAlgorithm());\n\n            Cipher cipher = Cipher.getInstance(\"DES\");\n            System.out.println(\"provider=\" + cipher.getProvider());\n\n            ECGenParameterSpec ecsp = new ECGenParameterSpec(\"sect163r2\");\n\n            kpg.initialize(ecsp);\n            KeyPair kyp = kpg.genKeyPair();\n            PublicKey pubKey = kyp.getPublic();\n\n            PrivateKey privKey = kyp.getPrivate();\n            System.out.println(cipher.getProvider());\n\n            cipher.init(Cipher.ENCRYPT_MODE, pubKey);\n\n            String cleartextFile = \"cleartext.txt\";\n            String ciphertextFile = \"ciphertextECIES.txt\";\n\n            byte[] block = new byte[64];\n            FileInputStream fis = new FileInputStream(cleartextFile);\n            FileOutputStream fos = new FileOutputStream(ciphertextFile);\n            CipherOutputStream cos = new CipherOutputStream(fos, cipher);\n\n            int i;\n            while ((i = fis.read(block)) != -1) {\n                cos.write(block, 0, i);\n            }\n            cos.close();\n\n            // Decrypt\n\n            String cleartextAgainFile = \"cleartextAgainECIES.txt\";\n\n            cipher.init(Cipher.DECRYPT_MODE, privKey, ecsp);\n\n            fis = new FileInputStream(ciphertextFile);\n            CipherInputStream cis = new CipherInputStream(fis, cipher);\n            fos = new FileOutputStream(cleartextAgainFile);\n\n            while ((i = cis.read(block)) != -1) {\n                fos.write(block, 0, i);\n            }\n            fos.close();\n\n        } catch (Exception e) {\n            System.out.println(e);\n        }\n    }\n\n}\n", "idx": 1863}
{"project": "cipher", "commit_id": "Snippet33640751_15705.java", "target": 0, "func": "public class PasswordEncryption {\n\n    public static final String AES = \"AES\";\n\n    public static String encrypt(String value, File keyFile)\n            throws GeneralSecurityException, IOException {\n        if (!keyFile.exists()) {\n            KeyGenerator keyGen = KeyGenerator\n                    .getInstance(PasswordEncryption.AES);\n\n            keyGen.init(128);\n            SecretKey sk = keyGen.generateKey();\n            FileWriter fw = new FileWriter(keyFile);\n            fw.write(byteArrayToHexString(sk.getEncoded()));\n            fw.flush();\n            fw.close();\n        }\n\n        SecretKeySpec sks = getSecretKeySpec(keyFile);\n        Cipher cipher = Cipher.getInstance(PasswordEncryption.AES);\n        cipher.init(Cipher.ENCRYPT_MODE, sks, cipher.getParameters());\n        byte[] encrypted = cipher.doFinal(value.getBytes());\n        return byteArrayToHexString(encrypted);\n    }\n\n    public static String decrypt(String message, File keyFile)\n            throws GeneralSecurityException, IOException {\n        SecretKeySpec sks = getSecretKeySpec(keyFile);\n        Cipher cipher = Cipher.getInstance(PasswordEncryption.AES);\n        cipher.init(Cipher.DECRYPT_MODE, sks);\n        byte[] decrypted = cipher.doFinal(hexStringToByteArray(message));\n        return new String(decrypted);\n    }\n\n    private static SecretKeySpec getSecretKeySpec(File keyFile)\n            throws NoSuchAlgorithmException, IOException {\n        byte[] key = readKeyFile(keyFile);\n        SecretKeySpec sks = new SecretKeySpec(key, PasswordEncryption.AES);\n        return sks;\n    }\n\n    private static byte[] readKeyFile(File keyFile)\n            throws FileNotFoundException {\n        @SuppressWarnings(\"resource\")\n        Scanner scanner = new Scanner(keyFile).useDelimiter(\"\\\\Z\");\n        String keyValue = scanner.next();\n        scanner.close();\n        return hexStringToByteArray(keyValue);\n    }\n\n    private static String byteArrayToHexString(byte[] b) {\n        StringBuffer sb = new StringBuffer(b.length * 2);\n        for (int i = 0; i < b.length; i++) {\n            int v = b[i] & 0xff;\n            if (v < 16) {\n                sb.append('0');\n            }\n            sb.append(Integer.toHexString(v));\n        }\n        return sb.toString().toUpperCase();\n    }\n\n    private static byte[] hexStringToByteArray(String s) {\n        byte[] b = new byte[s.length() / 2];\n        for (int i = 0; i < b.length; i++) {\n            int index = i * 2;\n            int v = Integer.parseInt(s.substring(index, index + 2), 16);\n            b[i] = (byte) v;\n        }\n        return b;\n    }\n\n    public static void main(String[] args) throws Exception {\n        final String KEY_FILE = \"/Users/xxx/key\";\n        final String PASSWORD_FILE = \"/Users/xxx/properties\";\n\n        String openPwd = \"my password is datasecurity\";\n        String openUser = \"a user is ME\";\n\n        Properties p1 = new Properties();\n\n        String encryptedPwd = PasswordEncryption.encrypt(openPwd, new File(\n                KEY_FILE));\n        String encryptedUser = PasswordEncryption.encrypt(openUser, new File(\n                KEY_FILE));\n        p1.put(\"password\",encryptedPwd);\n        p1.put(\"user\",encryptedUser);\n        p1.store(new FileWriter(PASSWORD_FILE),\"\");\n\n        // ==================\n        Properties p2 = new Properties();\n\n        p2.load(new FileReader(PASSWORD_FILE));\n        encryptedPwd = p2.getProperty(\"password\");\n        encryptedUser = p2.getProperty(\"user\");\n        System.out.println(encryptedPwd);\n        System.out.println(encryptedUser);\n        System.out.println(PasswordEncryption.decrypt(encryptedPwd, new File(\n                KEY_FILE)));\n        System.out.println(PasswordEncryption.decrypt(encryptedUser, new File(\n                KEY_FILE)));\n    }\n}\n", "idx": 1906}
{"project": "cipher", "commit_id": "Snippet7094777_32565.java", "target": 1, "func": "package com.emap.services;\nimport com.sun.org.apache.xerces.internal.impl.dv.util.Base64;\nimport java.security.InvalidAlgorithmParameterException;\nimport java.security.InvalidKeyException;\nimport java.security.NoSuchAlgorithmException;\nimport javax.crypto.BadPaddingException;\nimport javax.crypto.Cipher;\nimport javax.crypto.IllegalBlockSizeException;\nimport javax.crypto.NoSuchPaddingException;\nimport javax.crypto.spec.IvParameterSpec;\nimport javax.crypto.spec.SecretKeySpec;\n\npublic class AESEcrypt1 {\n\n    static byte[] ibv = new byte[]{0x01, 0x02, 0x03, 0x04, 0x05, 0x06, 0x07, 0x08, 0x09, 0x0a,\n        0x0b, 0x0c, 0x0d, 0x0e, 0x0f, 0x10};\n\n    public String encryptData() {\n        String message = \"Testing AES encryption-decryption amlgorithm for WP7.\";\n        String encryptedStr = \"\";\n        try {\n            SecretKeySpec skeySpec = new SecretKeySpec(\"Passkey\".getBytes(), \"AES\");\n            IvParameterSpec iv = new IvParameterSpec(ibv);\n            // Instantiate the cipher\n            Cipher cipher = Cipher.getInstance(\"AES/CBC/PKCS5Padding\");\n            cipher.init(Cipher.ENCRYPT_MODE, skeySpec, iv);\n            byte[] encrypted = cipher.doFinal(message.getBytes());\n            encryptedStr = Base64.encode(encrypted);\n        } catch (BadPaddingException ex) {\n            System.out.println(\"Error: \" + ex.getMessage());\n            encryptedStr = \"error\";\n        } catch (IllegalBlockSizeException ex) {\n            System.out.println(\"Error: \" + ex.getMessage());\n            encryptedStr = \"error\";\n        } catch (InvalidAlgorithmParameterException ex) {\n            System.out.println(\"Error: \" + ex.getMessage());\n            encryptedStr = \"error\";\n        } catch (InvalidKeyException ex) {\n            System.out.println(\"Error: \" + ex.getMessage());\n            encryptedStr = \"error\";\n        } catch (NoSuchAlgorithmException ex) {\n            System.out.println(\"Error: \" + ex.getMessage());\n            encryptedStr = \"error\";\n        } catch (NoSuchPaddingException ex) {\n            System.out.println(\"Error: \" + ex.getMessage());\n            encryptedStr = \"error\";\n        } catch (Exception ex) {\n            System.out.println(\"Error: \" + ex.getMessage());\n            encryptedStr = \"error\";\n        }\n        System.out.println(\"Encrypted: \" + encryptedStr);\n        return encryptedStr;\n    }\n}\n", "idx": 1968}
{"project": "cipher", "commit_id": "Snippet41047253_22989.java", "target": 1, "func": "public class AES{\n\nprivate String SecretKey = \"89432hjfsd891787\";\nprivate String iv = \"fedcba9876543210\";\nprivate IvParameterSpec ivspec;\nprivate SecretKeySpec keyspec;\nprivate Cipher cipher;\n\npublic AES()\n{\n    ivspec = new IvParameterSpec(iv.getBytes());\n    keyspec = new SecretKeySpec(SecretKey.getBytes(), \"AES\");\n    try {\n        cipher = Cipher.getInstance(\"AES/CBC/NoPadding\");\n    } catch (NoSuchAlgorithmException e) {\n        // TODO Auto-generated catch block\n        e.printStackTrace();\n    } catch (NoSuchPaddingException e) {\n        // TODO Auto-generated catch block\n        e.printStackTrace();\n    }\n}\n\npublic byte[] encrypt(String text) throws Exception\n{\n    if(text == null || text.length() == 0)\n        throw new Exception(\"Empty string\");\n\n    byte[] encrypted = null;\n\n    try {\n        cipher.init(Cipher.ENCRYPT_MODE, keyspec, ivspec);\n\n        encrypted = cipher.doFinal(padString(text).getBytes());\n    } catch (Exception e)\n    {\n        throw new Exception(\"[encrypt] \" + e.getMessage());\n    }\n\n    return encrypted;\n}\n\npublic byte[] decrypt(String code) throws Exception\n{\n    if(code == null || code.length() == 0)\n        throw new Exception(\"Empty string\");\n\n    byte[] decrypted = null;\n\n    try {\n        cipher.init(Cipher.DECRYPT_MODE, keyspec, ivspec);\n\n        decrypted = cipher.doFinal(hexToBytes(code));\n    } catch (Exception e)\n    {\n        throw new Exception(\"[decrypt] \" + e.getMessage());\n    }\n    return decrypted;\n}\n\n\n\npublic static String bytesToHex(byte[] data)\n{\n    if (data==null)\n    {\n        return null;\n    }\n    int len = data.length;\n    String str = \"\";\n    for (int i=0; i<len; i++) {\n        if ((data[i]&0xFF)<16)\n            str = str + \"0\" + java.lang.Integer.toHexString(data[i]&0xFF);\n        else\n            str = str + java.lang.Integer.toHexString(data[i]&0xFF);\n    }\n    return str;\n}\n\n\npublic static byte[] hexToBytes(String str) {\n    if (str==null) {\n        return null;\n    } else if (str.length() < 2) {\n        return null;\n    } else {\n        int len = str.length() / 2;\n        byte[] buffer = new byte[len];\n        for (int i=0; i<len; i++) {\n            buffer[i] = (byte) Integer.parseInt(str.substring(i*2,i*2+2),16);\n        }\n        return buffer;\n    }\n}\n\nprivate static String padString(String source)\n{\n    char paddingChar = ' ';\n    int size = 16;\n    int x = source.length() % size;\n    int padLength = size - x;\n    for (int i = 0; i < padLength; i++) {\n        source += paddingChar;\n    }\n    return source;\n}\n}\n", "idx": 2218}
{"project": "cipher", "commit_id": "Snippet10842509_35116.java", "target": 1, "func": "public static String encrypt() throws Exception{\ntry{\n    String data = \"Test string\";\n    String key = \"1234567812345678\";\n    String iv = \"1234567812345678\";\n\n    javax.crypto.spec.SecretKeySpec keyspec = new javax.crypto.spec.SecretKeySpec(key.getBytes(), \"AES\");\n    javax.crypto.spec.IvParameterSpec ivspec = new javax.crypto.spec.IvParameterSpec(iv.getBytes());\n\n    javax.crypto.Cipher cipher = javax.crypto.Cipher.getInstance(\"AES/CBC/NoPadding\");\n    cipher.init(javax.crypto.Cipher.ENCRYPT_MODE, keyspec, ivspec);\n    byte[] encrypted = cipher.doFinal(data.getBytes());\n\n    return new sun.misc.BASE64Encoder().encode(encrypted);\n\n}catch(Exception e){\n    return null;\n}\n", "idx": 2275}
{"project": "cipher", "commit_id": "Snippet39718017_21622.java", "target": 1, "func": "GCMParameterSpec gcmParameterSpec = new GCMParameterSpec(16 * 8, iv);\nCipher cipher = Cipher.getInstance(\"AES/GCM/NoPadding\");\ncipher.init(Cipher.DECRYPT_MODE, skeySpec, gcmParameterSpec);\n", "idx": 2246}
{"project": "cipher", "commit_id": "Snippet12543933_36323.java", "target": 1, "func": "   public static void doDecrypt( BigInteger  modules, BigInteger  d , String encrypted )\n    {\n            try {\n                    byte[] decodedBytes = Base64.decodeBase64( encrypted );\n                    KeyFactory factory = KeyFactory.getInstance(\"RSA\");\n                    Cipher cipher = Cipher.getInstance(\"RSA\");\n\n                    RSAPrivateKeySpec privSpec = new RSAPrivateKeySpec(modules, d);\n                    PrivateKey privKey = factory.generatePrivate(privSpec);\n\n                    cipher.init(Cipher.DECRYPT_MODE, privKey);\n                    byte[] decrypted = cipher.doFinal(decodedBytes) ;\n                    System.out.println(\"decrypted: \" + new String(decrypted));\n            }\n            catch (Exception e) {\n                    e.printStackTrace();\n            }\n\n    }\n", "idx": 2148}
{"project": "cipher", "commit_id": "Snippet17112998_386.java", "target": 1, "func": "   public static String encrypt(String text, String key){\n        String mess=\"error\";\n        try{\n\n            byte[] encodedText=text.getBytes(Charset.forName(\"UTF-8\"));\n            byte[] keyData=hexStringToByte(key);\n\n            SecretKeySpec sKey=new SecretKeySpec(keyData, \"AES\");\n\n            Cipher encryptionCypher=Cipher.getInstance(\"AES/CBC/PKCS5Padding\");\n\n            final int blocks=encryptionCypher.getBlockSize();\n\n            final byte[] ivData=new byte[blocks];\n\n            final SecureRandom rnd=new SecureRandom();\n\n            rnd.nextBytes(ivData);\n\n            final IvParameterSpec iv=new IvParameterSpec(ivData);\n            encryptionCypher.init(Cipher.ENCRYPT_MODE, sKey,iv);\n\n            final byte[] encryptedMessage=encryptionCypher.doFinal(encodedText);\n            final byte[] ivAndMessage=new byte[ivData.length+encryptedMessage.length];\n            System.arraycopy(ivData, 0, ivAndMessage, 0, blocks);\n            System.arraycopy(encryptedMessage, 0, ivAndMessage, blocks, encryptedMessage.length);\n            final String finalMessage=Base64.encodeToString(ivAndMessage, 0);\n\n            mess=finalMessage;  \n\n\n            } catch (IllegalBlockSizeException e) {\n                // TODO Auto-generated catch block\n                e.printStackTrace();\n            } catch (BadPaddingException e) {\n                // TODO Auto-generated catch block\n                e.printStackTrace();\n            } catch (InvalidKeyException e) {\n                e.printStackTrace();\n\n            } catch (InvalidAlgorithmParameterException e) {\n                // TODO Auto-generated catch block\n                e.printStackTrace();\n            } catch (NoSuchAlgorithmException e) {\n                // TODO Auto-generated catch block\n                e.printStackTrace();\n            } catch (NoSuchPaddingException e) {\n                // TODO Auto-generated catch block\n                e.printStackTrace();\n            }\n        return mess;\n    }\n", "idx": 2263}
{"project": "cipher", "commit_id": "Snippet10322343_34684.java", "target": 0, "func": "public static String aes_decrypt (String text, String key) \n{\n\n    SecretKey skey = new SecretKeySpec(key.getBytes(), \"AES\"); \n    Cipher cipher = Cipher.getInstance(\"AES/ECB/PKCS5Padding\", \"SunJCE\");\n    cipher.init(Cipher.DECRYPT_MODE, skey);\n\n    return new String((cipher.doFinal(text.getBytes())));\n}\n", "idx": 1668}
{"project": "cipher", "commit_id": "Snippet8480918_33274.java", "target": 1, "func": "byte[] keyBytes = Base64.decodeBase64(rsa_1024_public_key);\n      // rsa_1024_public key is a constant String\n\nCipher c = Cipher.getInstance(\"RSA\");\n\nPublicKey publicKey =\n   KeyFactory.getInstance(\"RSA\").generatePublic(new X509EncodedKeySpec(keyBytes));\n\nc.init(Cipher.ENCRYPT_MODE, publicKey);\n\nreturn c.doFinal(password.getBytes());\n", "idx": 2049}
{"project": "cipher", "commit_id": "Snippet29508467_11546.java", "target": 0, "func": "  String strDecriptedValue = decrypt(passkey, responseBase64);\n\npublic static String decrypt(String seed, String encrypted)\n            throws Exception {\n        byte[] rawKey = getRawKey(seed.getBytes());\n        byte[] enc = Base64.decode(encrypted.getBytes(), Base64.DEFAULT);\n        byte[] result = decrypt(rawKey, enc);\n        return new String(result);\n    }\n\nprivate static byte[] getRawKey(byte[] seed) throws Exception {\n        KeyGenerator keygen = KeyGenerator.getInstance(\"AES\");\n        SecureRandom random = SecureRandom.getInstance(\"SHA1PRNG\");\n        random.setSeed(seed);\n        keygen.init(128, random); \n        SecretKey key = keygen.generateKey();\n        byte[] raw = key.getEncoded();\n        return raw;\n    }\n\nprivate static byte[] decrypt(byte[] raw, byte[] encrypted)\n            throws Exception {\n        SecretKeySpec keySpec = new SecretKeySpec(raw, \"AES\");\n        Cipher cipher = Cipher.getInstance(\"AES/ECB/NoPadding\");\n        cipher.init(Cipher.DECRYPT_MODE, keySpec);\n        byte[] decrypted = cipher.doFinal(encrypted);\n        return decrypted;\n    }\n", "idx": 1717}
{"project": "cipher", "commit_id": "Snippet2278267_27920.java", "target": 1, "func": "Cipher.getInstance(\"AES/CBC16/PKCS5Padding\");\n", "idx": 2145}
{"project": "cipher", "commit_id": "Snippet32331503_14396.java", "target": 1, "func": "public static byte[] decodeFile(String key, byte[] fileData) throws Exception\n{\n    Cipher cipher = Cipher.getInstance(\"AES/CBC/PKCS5Padding\"); //this parameters should not be changed\n    byte[] keyBytes = new byte[16];\n    byte[] b = key.getBytes(\"UTF-16\");\n    System.out.println(\"RAM\"+b);\n    int len = b.length;\n    if (len > keyBytes.length)\n        len = keyBytes.length;\n    System.arraycopy(b, 0, keyBytes, 0, len);\n    SecretKeySpec keySpec = new SecretKeySpec(keyBytes, \"AES\");\n    IvParameterSpec ivSpec = new IvParameterSpec(keyBytes);\n    cipher.init(Cipher.DECRYPT_MODE, keySpec, ivSpec);\n    byte[] decrypted = cipher.doFinal(fileData);\n    return decrypted;\n}\n", "idx": 2297}
{"project": "cipher", "commit_id": "Snippet47076189_29073.java", "target": 1, "func": "public static String encryptAES(byte[] data, byte[] key, byte[] iv) throws Exception {\n    Key k = new SecretKeySpec(key, \"AES\");\n    System.out.println(\"key set\");\n\n    Cipher c = Cipher.getInstance(\"AES/CBC/PKCS5PADDING\");\n    System.out.println(\"cipher created\");\n\n    c.init(Cipher.ENCRYPT_MODE, k, new IvParameterSpec(iv));\n    System.out.println(\"cipher initialised\");\n\n    byte[] encryptedDataBytes = c.doFinal(data);\n    String encryptedData = Base64.getEncoder().encodeToString(encryptedDataBytes);\n    return encryptedData;\n}\n", "idx": 2069}
{"project": "cipher", "commit_id": "Snippet42537827_24578.java", "target": 0, "func": "private BufferedImage load(String s){\nBufferedImage image;\n        try{\n            image = ImageIO.read(getDecryptedStream(Buffers.class.getResourceAsStream(s)));\n            return image;\n        }catch(Exception e){\n            e.printStackTrace();\n        }\n        return null;\n}\n\nprivate InputStream getDecryptedStream(InputStream inputStream) throws NoSuchAlgorithmException, NoSuchPaddingException, InvalidKeyException{\n    Cipher cipher = Cipher.getInstance(\"DES/CBC/PKCS5Padding\");\n    cipher.init(Cipher.DECRYPT_MODE, this.key);\n    CipherInputStream input = new CipherInputStream(inputStream, cipher);\n\n    return input;\n}\n", "idx": 1688}
{"project": "cipher", "commit_id": "Snippet25127629_7475.java", "target": 1, "func": "private static byte[] decrypt(SecretKey key, byte[] encrypted, byte[] iv) throws Exception {\n    IvParameterSpec ivSpec = new IvParameterSpec(iv);\n    Cipher cipher = Cipher.getInstance(\"AES/CCM/NoPadding\");\n    cipher.init(Cipher.DECRYPT_MODE, key, ivSpec);\n    byte[] decrypted = cipher.doFinal(encrypted);\n    return decrypted;\n}\n\npublic static SecretKey generateKey(char[] passphraseOrPin, byte[] salt) throws NoSuchAlgorithmException, InvalidKeySpecException {\n    // Number of PBKDF2 hardening rounds to use. Larger values increase\n    // computation time. You should select a value that causes computation\n    // to take >100ms.\n    final int iterations = 1000;\n\n    // Generate a 128-bit key\n    final int outputKeyLength = 128;\n\n    /*SecretKeyFactory secretKeyFactory = SecretKeyFactory.getInstance(\"PBKDF2WithHmacSHA256\");\n    KeySpec keySpec = new PBEKeySpec(passphraseOrPin, salt, iterations, outputKeyLength);\n    SecretKey secretKey = secretKeyFactory.generateSecret(keySpec);*/\n\n    PKCS5S2ParametersGenerator generator = new PKCS5S2ParametersGenerator(new SHA256Digest());\n    generator.init(PBEParametersGenerator.PKCS5PasswordToBytes(passphraseOrPin), salt, iterations);\n    KeyParameter key = (KeyParameter) generator.generateDerivedMacParameters(outputKeyLength);\n    SecretKey secretKey = new SecretKeySpec(key.getKey(), \"AES\");\n    return secretKey;\n}\n", "idx": 2073}
{"project": "cipher", "commit_id": "Snippet25584982_7894.java", "target": 1, "func": "public static void main(String[] args) throws Exception {\n    Security.addProvider(new BouncyCastleProvider());\n\n    KeyPairGenerator kpg = KeyPairGenerator.getInstance(\"ECIES\");\n    ECGenParameterSpec brainpoolP256R1 = new ECGenParameterSpec(\n            \"brainpoolP256R1\");\n    kpg.initialize(brainpoolP256R1);\n    KeyPair kp = kpg.generateKeyPair();\n\n    Cipher c = Cipher.getInstance(\"ECIES\");\n    c.init(Cipher.ENCRYPT_MODE, kp.getPublic());\n\n    final byte[] aesKeyData = new byte[16];\n    SecureRandom rng = new SecureRandom();\n    rng.nextBytes(aesKeyData);\n\n    byte[] wrappedKey = c.doFinal(aesKeyData);\n    SecretKey aesKey = new SecretKeySpec(aesKeyData, \"AES\");\n    Arrays.fill(aesKeyData, (byte) 0);\n}\n", "idx": 1937}
{"project": "cipher", "commit_id": "Snippet24701068_7054.java", "target": 1, "func": "    public static String encryptMessage(final String plainMessage, final String symKeyHex) \n{\n    final byte[] symKeyData = DatatypeConverter.parseHexBinary(symKeyHex);\n    final byte[] encodedMessage = plainMessage.getBytes(Charset.forName(\"UTF-8\"));\n\n    try {\n\n        final Cipher cipher = Cipher.getInstance(\"AES/CBC/PKCS5Padding\");\n        final int blockSize = cipher.getBlockSize();\n\n        // create the key\n        final SecretKeySpec symKey = new SecretKeySpec(symKeyData, \"AES\");\n\n        // generate random IV using block size (possibly create a method for\n        // this)\n        final byte[] ivData = new byte[blockSize];\n        final SecureRandom rnd = SecureRandom.getInstance(\"SHA1PRNG\");\n        rnd.nextBytes(ivData);\n        final IvParameterSpec iv = new IvParameterSpec(ivData);\n\n        cipher.init(Cipher.ENCRYPT_MODE, symKey, iv);\n\n        final byte[] encryptedMessage = cipher.doFinal(encodedMessage);\n\n        // concatenate IV and encrypted message\n        final byte[] ivAndEncryptedMessage = new byte[ivData.length + encryptedMessage.length];\n        System.arraycopy(ivData, 0, ivAndEncryptedMessage, 0, blockSize);\n        System.arraycopy(encryptedMessage, 0, ivAndEncryptedMessage, blockSize, encryptedMessage.length);\n\n        final String ivAndEncryptedMessageBase64 = DatatypeConverter.printBase64Binary(ivAndEncryptedMessage);\n        return ivAndEncryptedMessageBase64;\n\n\n    }catch (InvalidKeyException e) \n    {\n        throw new IllegalArgumentException(\"key argument does not contain a valid AES key\");\n\n    }catch (GeneralSecurityException e) \n    {\n        throw new IllegalStateException(\"Unexpected exception during encryption\", e);\n    }\n}\n", "idx": 2097}
{"project": "cipher", "commit_id": "Snippet13869034_37321.java", "target": 0, "func": "/* class for crypting and decrypting a file */\nclass DESEncrypter\n{\nprivate Cipher encryptionCipher;\nprivate Cipher decryptionCipher;\n\npublic DESEncrypter (SecretKey key) throws Exception\n{\nencryptionCipher = Cipher.getInstance(\"DES/ECB/PKCS5Padding\");\nencryptionCipher.init(Cipher.ENCRYPT_MODE, key);\ndecryptionCipher = Cipher.getInstance(\"DES/ECB/PKCS5Padding\");\ndecryptionCipher.init(Cipher.DECRYPT_MODE, key);\n}\n\n/* write to 'out' the encryption of the information read from 'in' */\npublic String encrypt(String unencryptedString)\n{\n    String encryptedString = \"\";\n\n    try {\n        byte[] unencryptedByteArray = unencryptedString.getBytes(\"UTF8\");\n\n        byte[] encryptedBytes = this.encryptionCipher.doFinal(unencryptedByteArray);\n\n        encryptedString = new sun.misc.BASE64Encoder().encode(encryptedBytes);\n\n    } catch (Exception ex) {\n        Logger.getLogger(DESEncrypter.class.getName()).log(Level.SEVERE, null, ex);\n    }\n\n    return encryptedString;\n}\n\nprivate static String bytes2String(byte[] bytes)\n{\n\n    StringBuffer stringBuffer = new StringBuffer();\n    for (int i = 0; i < bytes.length; i++) \n    {\n        stringBuffer.append((char) bytes[i]);\n    }\n\n    return stringBuffer.toString();\n}\n\n/* write to 'out' the information obtained by decrypting the information read from 'in' */\npublic String decrypt (String encryptedString) throws UnsupportedEncodingException\n{\n    byte[] unencryptedByteArray = new byte[4096];\n\n    try {\n        // Encode bytes to base64 to get a string\n        byte[] decodedBytes = new sun.misc.BASE64Decoder().decodeBuffer(encryptedString);\n\n       // Decrypt\n       unencryptedByteArray = this.decryptionCipher.doFinal(decodedBytes);     \n    } catch (Exception ex) {\n        Logger.getLogger(DESEncrypter.class.getName()).log(Level.SEVERE, null, ex);\n    }\n\n    return bytes2String(unencryptedByteArray);\n}\n} \n", "idx": 1912}
{"project": "cipher", "commit_id": "Snippet34425494_16411.java", "target": 0, "func": "public class MyDES {\nprivate static String ENCRYPTION_KEY_TYPE = \"DESede\";\nprivate static String ENCRYPTION_ALGORITHM = \"DESede/CBC/NoPadding\";\n\nprivate static byte[] key = new byte[]{\n        (byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x00,\n        (byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x00};\n\nprivate static byte[] iv = new byte[]{\n        (byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x00};\n\npublic static byte[] encrypt(byte[] plainText) {\n    try {\n        IvParameterSpec ivSpec = new IvParameterSpec(iv);\n        SecretKey secretKey = new SecretKeySpec(key, ENCRYPTION_KEY_TYPE);\n        Cipher cipher = Cipher.getInstance(ENCRYPTION_ALGORITHM);\n        cipher.init(Cipher.ENCRYPT_MODE, secretKey, ivSpec);\n        byte[] encrypted = cipher.doFinal(plainText);\n        return encrypted;\n    } catch (InvalidKeyException e) {\n        e.printStackTrace();\n    } catch (InvalidAlgorithmParameterException e) {\n        e.printStackTrace();\n    } catch (NoSuchAlgorithmException e) {\n        e.printStackTrace();\n    } catch (NoSuchPaddingException e) {\n        e.printStackTrace();\n    } catch (BadPaddingException e) {\n        e.printStackTrace();\n    } catch (IllegalBlockSizeException e) {\n        e.printStackTrace();\n    }\n    return null;\n}\n\npublic static byte[] decrypt(byte[] cipherText) {\n    try {\n        IvParameterSpec ivSpec = new IvParameterSpec(iv);\n        SecretKey secretKey = new SecretKeySpec(key, ENCRYPTION_KEY_TYPE);\n        Cipher cipher = Cipher.getInstance(ENCRYPTION_ALGORITHM);\n        cipher.init(Cipher.DECRYPT_MODE, secretKey, ivSpec);\n        byte[] decrypted = cipher.doFinal(cipherText);\n        return decrypted;\n    } catch (InvalidKeyException e) {\n        e.printStackTrace();\n    } catch (InvalidAlgorithmParameterException e) {\n        e.printStackTrace();\n    } catch (NoSuchAlgorithmException e) {\n        e.printStackTrace();\n    } catch (NoSuchPaddingException e) {\n        e.printStackTrace();\n    } catch (BadPaddingException e) {\n        e.printStackTrace();\n    } catch (IllegalBlockSizeException e) {\n        e.printStackTrace();\n    }\n    return null;\n}\n", "idx": 1612}
{"project": "cipher", "commit_id": "Snippet17197446_442.java", "target": 0, "func": "private static final String ALGO = \"AES\";\n\n\n\npublic static String encrypt(String Data) throws Exception {\n        Key key = generateKey();\n        Cipher c = Cipher.getInstance(ALGO);\n        c.init(Cipher.ENCRYPT_MODE, key);\n        byte[] encVal = c.doFinal(Data.getBytes());\n     //   String encryptedValue = new BASE64Encoder().encode(encVal);\n\n        byte[] decoded = Base64.encodeBase64(encVal);\n\n        return (new String(decoded, \"UTF-8\") + \"\\n\");\n    }\n\npublic static String decrypt(String encryptedData) throws Exception {\n        Key key = generateKey();\n        Cipher c = Cipher.getInstance(ALGO);\n        c.init(Cipher.DECRYPT_MODE, key);\n        byte[] decordedValue =Base64.decodeBase64(encryptedData);\n        byte[] decValue = c.doFinal(decordedValue);\n        String decryptedValue = new String(decValue);\n\n        return decryptedValue;\n\n    }\n\n    private static Key generateKey() throws Exception {\n        Key key = new SecretKeySpec(Constant.keyValue, ALGO);\n        return key;\n    }\n", "idx": 1724}
{"project": "cipher", "commit_id": "Snippet45636379_27698.java", "target": 1, "func": " <Resource name=\"jdbc/HasanDB\" auth=\"Container\" type=\"javax.sql.DataSource\"\n              maxTotal=\"10\" maxIdle=\"15\" minIdle=\"3\" initialSize=\"2\" maxWaitMillis=\"10000\"\n              removeAbondend=\"true\" removeAbondendTimeout=\"300\"\n              username=\"hasan\" password=\"<encryptedpass>\" driverClassName=\"com.mysql.jdbc.Driver\"\n              url=\"jdbc:mysql://localhost:3306/HasanDB\"/>\n\npackage hasan;\npublic class Http11Nio2Protocol extends org.apache.coyote.http11.Http11Nio2Protocol  {\n    @Override\n    public void setKeystorePass(String certificateKeystorePassword) {\n        try {\n            System.out.println(\"..............===============certificateKeystorePassword===========................\");\n            super.setKeystorePass(EncryptService.decrypt(certificateKeystorePassword));\n        } catch (final Exception e){\n            super.setKeystorePass(\"\");\n        }\n    }\n}\n\npackage hasan;\nimport java.io.IOException;\nimport java.security.GeneralSecurityException;\nimport java.security.NoSuchAlgorithmException;\nimport java.security.spec.InvalidKeySpecException;\nimport java.util.Base64;\nimport javax.crypto.Cipher;\nimport javax.crypto.SecretKey;\nimport javax.crypto.SecretKeyFactory;\nimport javax.crypto.spec.IvParameterSpec;\nimport javax.crypto.spec.PBEKeySpec;\nimport javax.crypto.spec.SecretKeySpec;\n\npublic class EncryptService {\n    private static SecretKeySpec createSecretKey(char[] password, byte[] salt, int iterationCount, int keyLength) throws NoSuchAlgorithmException, InvalidKeySpecException {\n        SecretKeyFactory keyFactory = SecretKeyFactory.getInstance(\"PBKDF2WithHmacSHA512\");\n        PBEKeySpec keySpec = new PBEKeySpec(password, salt, iterationCount, keyLength);\n        SecretKey keyTmp = keyFactory.generateSecret(keySpec);\n        return new SecretKeySpec(keyTmp.getEncoded(), \"AES\");\n    }\n    private static byte[] base64Decode(String property) throws IOException {\n        return Base64.getDecoder().decode(property);\n    }\n    static String decrypt(String string) throws GeneralSecurityException, IOException {\n        String password = \"password\";\n        byte[] salt = new String(\"salt\").getBytes();\n        int iterationCount = 100;\n        int keyLength = 128;\n        SecretKeySpec key = createSecretKey(password.toCharArray(),\n                salt, iterationCount, keyLength);\n        String iv = string.split(\":\")[0];\n        String property = string.split(\":\")[1];\n        Cipher pbeCipher = Cipher.getInstance(\"AES/CBC/PKCS5Padding\");\n        pbeCipher.init(Cipher.DECRYPT_MODE, key, new IvParameterSpec(base64Decode(iv)));\n        return new String(pbeCipher.doFinal(base64Decode(property)), \"UTF-8\");\n    }\n}\n", "idx": 2047}
{"project": "cipher", "commit_id": "Snippet11391249_35548.java", "target": 0, "func": "<HTML>\n<BODY>\n\n<%\n    Class.forName(\"oracle.jdbc.OracleDriver\");\n\n        Connection conn =     DriverManager.getConnection(\"jdbc:oracle:thin:@xxx:xxxx:xxxx\",\"i----r\",\"i-----r\");\n                        // @//machineName:port:SID,   userid,  password\n\n    Statement st=conn.createStatement();\n\n    ResultSet rs=st.executeQuery(\"Select * from xxxxxxx\");\n\n    //Just testing now, for decryption\n\n    String algorithm1 = \"DES\";//magical mystery constant\n    String algorithm2 = \"DES/CBC/NoPadding\";//magical mystery constant\n    IvParameterSpec iv = new IvParameterSpec( new byte [] { 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00 } );//magical mystery constant\n    Cipher cipher;\n    SecretKey key;\n    String k=\"12345abc\";\n    key = new SecretKeySpec( k.getBytes( ), algorithm1 );\n    cipher = Cipher.getInstance( algorithm2 );\n\n    String str=\"test1234abc\";\n\n    cipher.init( Cipher.ENCRYPT_MODE, key, iv ); //normally you could leave out the IvParameterSpec argument, but not with Oracle\n\n    byte[] bytes=str.getBytes(\"UTF-8\");\n\n    byte[] encrypted = cipher.doFinal( bytes );\n\n\n%>\n</BODY>\n</HTML>\n", "idx": 1641}
{"project": "cipher", "commit_id": "Snippet35082426_17035.java", "target": 0, "func": "private static byte[] encrypt(byte[] raw, byte[] clear) throws Exception \n{\n    SecretKeySpec skeySpec = new SecretKeySpec(raw, \"AES\");\n    Cipher cipher = Cipher.getInstance(\"AES\");\n    cipher.init(Cipher.ENCRYPT_MODE, skeySpec);\n    byte[] encrypted = cipher.doFinal(clear);\n    return encrypted;\n}\n\nprivate static byte[] decrypt(byte[] raw, byte[] encrypted) throws Exception     \n{\n    SecretKeySpec skeySpec = new SecretKeySpec(raw, \"AES\");\n    Cipher cipher = Cipher.getInstance(\"AES\");\n    cipher.init(Cipher.DECRYPT_MODE, skeySpec);\n    byte[] decrypted = cipher.doFinal(encrypted);\n    return decrypted;\n}\n", "idx": 1861}
{"project": "cipher", "commit_id": "Snippet44343381_26398.java", "target": 1, "func": "    public static void DecryptFile(String inFile, String outFile,\n        PrivateKey rsaPrivateKey) {\n\n    FileOutputStream outFs = null;\n\n    try {\n        // Create instance of AesManaged for\n        // symetric decryption of the data.\n        AesManaged aesManaged = new AesManaged();\n        {\n            aesManaged.keySize = 256;\n            aesManaged.blockSize = 128;\n            aesManaged.mode = \"AES/CBC/PKCS5Padding\";\n\n            // Create byte arrays to get the length of\n            // the encrypted key and IV.\n            // These values were stored as 4 bytes each\n            // at the beginning of the encrypted package.\n            byte[] LenK = new byte[4];\n            byte[] LenIV = new byte[4];\n\n            // Use FileStream objects to read the encrypted\n            // file (inFs) and save the decrypted file (outFs).\n            {\n                byte[] fileBytes = FileUtils.readFileToByteArray(new File(inFile));\n\n                ByteArrayInputStream inFs = new ByteArrayInputStream(\n                        fileBytes);\n                ;\n                for (int i = 0; i < LenK.length; i++) {\n                    LenK[i] = (byte) inFs.read();\n                }\n                for(int i = 0; i< LenIV.length;i++){\n                    LenIV[i] = (byte)inFs.read();\n                }\n\n                // Convert the lengths to integer values.\n                int lenK = BitConverter.ToInt32(LenK, 0);\n                int lenIV = BitConverter.ToInt32(LenIV, 0);\n\n                //int startC = lenK + lenIV + 8;\n                //int lenC = (int) fileBytes.length - startC;\n\n                // Create the byte arrays for\n                // the encrypted AesManaged key,\n                // the IV, and the cipher text.\n                byte[] KeyEncrypted = new byte[lenK];\n                byte[] IV = new byte[lenIV];\n\n                // Extract the key and IV\n                for(int i = 0;i<lenK;i++){\n                    KeyEncrypted[i] = (byte)inFs.read();\n                }\n                for(int i =0;i<lenIV;i++){\n                    IV[i] = (byte)inFs.read();\n                }\n                // to decrypt the AesManaged key.\n                byte[] KeyDecrypted = decryptKey(KeyEncrypted,rsaPrivateKey);\n\n                Cipher transform = Cipher.getInstance(\"AES/CBC/PKCS5Padding\");\n                IvParameterSpec ivspec = new IvParameterSpec(IV);\n\n                SecretKeySpec secretKeySpec = new SecretKeySpec(KeyDecrypted, \"AES\");\n\n                transform.init(Cipher.DECRYPT_MODE, secretKeySpec, ivspec);\n                // Decrypt the key.\n\n                outFs = new FileOutputStream(outFile);\n\n                int count = 0;\n                int offset = 0;\n                int blockSizeBytes = aesManaged.blockSize / 8;\n                byte[] data = new byte[blockSizeBytes];\n\n                CipherInputStream cipherIn = new CipherInputStream(\n                        inFs, transform);\n                while ((count = cipherIn.read(data, 0, blockSizeBytes)) != -1) {\n                    outFs.write(data, 0, count);\n                }\n\n                inFs.close();\n                cipherIn.close();\n            }\n\n        }\n    } catch (Exception e) {\n        e.printStackTrace();\n    }\n}\n", "idx": 1993}
{"project": "cipher", "commit_id": "Snippet41673845_23616.java", "target": 0, "func": "Cipher c = Cipher.getInstance(\"AES\");", "idx": 1831}
{"project": "cipher", "commit_id": "Snippet35215385_17146.java", "target": 1, "func": "    import java.security.NoSuchAlgorithmException;\n\n    import javax.crypto.Cipher;\n    import javax.crypto.NoSuchPaddingException;\n    import javax.crypto.spec.IvParameterSpec;\n    import javax.crypto.spec.SecretKeySpec;\n\n    public class MCrypt {\n\n            private String iv = \"fedcba9876543210\";//Dummy iv (CHANGE IT!)\n            private IvParameterSpec ivspec;\n            private SecretKeySpec keyspec;\n            private Cipher cipher;\n\n            private String SecretKey = \"0123456789abcdef\";//Dummy secretKey (CHANGE IT!)\n\n            public MCrypt()\n            {\n                    ivspec = new IvParameterSpec(iv.getBytes());\n\n                    keyspec = new SecretKeySpec(SecretKey.getBytes(), \"AES\");\n\n                    try {\n                            cipher = Cipher.getInstance(\"AES/CBC/NoPadding\");\n                    } catch (NoSuchAlgorithmException e) {\n                            // TODO Auto-generated catch block\n                            e.printStackTrace();\n                    } catch (NoSuchPaddingException e) {\n                            // TODO Auto-generated catch block\n                            e.printStackTrace();\n                    }\n            }\n\n            public byte[] encrypt(String text) throws Exception\n            {\n                    if(text == null || text.length() == 0)\n                            throw new Exception(\"Empty string\");\n\n                    byte[] encrypted = null;\n\n                    try {\n                            cipher.init(Cipher.ENCRYPT_MODE, keyspec, ivspec);\n\n                            encrypted = cipher.doFinal(padString(text).getBytes());\n                    } catch (Exception e)\n                    {                       \n                            throw new Exception(\"[encrypt] \" + e.getMessage());\n                    }\n\n                    return encrypted;\n            }\n\n            public byte[] decrypt(String code) throws Exception\n            {\n                    if(code == null || code.length() == 0)\n                            throw new Exception(\"Empty string\");\n\n                    byte[] decrypted = null;\n\n                    try {\n                            cipher.init(Cipher.DECRYPT_MODE, keyspec, ivspec);\n\n                            decrypted = cipher.doFinal(hexToBytes(code));\n                    } catch (Exception e)\n                    {\n                            throw new Exception(\"[decrypt] \" + e.getMessage());\n                    }\n                    return decrypted;\n            }\n\n\n\n            public static String bytesToHex(byte[] data)\n            {\n                    if (data==null)\n                    {\n                            return null;\n                    }\n\n                    int len = data.length;\n                    String str = \"\";\n                    for (int i=0; i<len; i++) {\n                            if ((data[i]&0xFF)<16)\n                                    str = str + \"0\" + java.lang.Integer.toHexString(data[i]&0xFF);\n                            else\n                                    str = str + java.lang.Integer.toHexString(data[i]&0xFF);\n                    }\n                    return str;\n            }\n\n\n            public static byte[] hexToBytes(String str) {\n                    if (str==null) {\n                            return null;\n                    } else if (str.length() < 2) {\n                            return null;\n                    } else {\n                            int len = str.length() / 2;\n                            byte[] buffer = new byte[len];\n                            for (int i=0; i<len; i++) {\n                                    buffer[i] = (byte) Integer.parseInt(str.substring(i*2,i*2+2),16);\n                            }\n                            return buffer;\n                    }\n            }\n\n\n\n            private static String padString(String source)\n            {\n              char paddingChar = ' ';\n              int size = 16;\n              int x = source.length() % size;\n              int padLength = size - x;\n\n              for (int i = 0; i < padLength; i++)\n              {\n                      source += paddingChar;\n              }\n\n              return source;\n            }\n    }\n", "idx": 2288}
{"project": "cipher", "commit_id": "Snippet18999469_1887.java", "target": 1, "func": "byte[] dectyptedText = null;\nCipher cipher = Cipher.getInstance(\"RSA/ECB/PKCS1Padding\");\ncipher.init(Cipher.DECRYPT_MODE, key);\ndectyptedText = cipher.doFinal(text);\nreturn dectyptedText;\n", "idx": 2123}
{"project": "cipher", "commit_id": "Snippet4894882_31368.java", "target": 1, "func": "   public static byte[] decrypt(byte[] text, PrivateKey key) throws Exception\n    {\n        byte[] dectyptedText = null;\n        try\n        {\n            // decrypt the text using the private key\n            Cipher cipher = Cipher.getInstance(\"ElGamal/None/NoPadding\", \"BC\"\");\n              cipher.init(Cipher.DECRYPT_MODE, key);\n            dectyptedText = cipher.doFinal(text);\n        }\n        catch (Exception e)\n        {\n            _log.error(e, e);\n            throw e;\n        }\n        return dectyptedText;\n\n    }\n", "idx": 1995}
{"project": "cipher", "commit_id": "Snippet37173777_19103.java", "target": 1, "func": "public static void lock(String secret, String textToEncrypt) {\n    try {\n        //Convert the public key string into a key\n        byte[] encodedPublicKey = Base64.decode(secret.getBytes(\"utf-8\"),Base64.DEFAULT);\n        X509EncodedKeySpec spec = new X509EncodedKeySpec(encodedPublicKey);\n        KeyFactory keyFactory = KeyFactory.getInstance(\"RSA\");\n        PublicKey publickey = keyFactory.generatePublic(spec); //Crash Here\n        PrivateKey privateKey = keyFactory.generatePrivate(spec);\n\n        //Encrypt Message\n        Cipher cipher = Cipher.getInstance(\"RSA\");\n        cipher.init(Cipher.ENCRYPT_MODE, publickey);\n        byte[] encryptedBytes = cipher.doFinal(textToEncrypt.getBytes());\n        Log.d(TAG,\"Encrypted: \"+new String(encryptedBytes));\n    } catch (Exception e) {\n        e.printStackTrace();\n    }\n}\n", "idx": 2197}
{"project": "cipher", "commit_id": "Snippet33272130_15314.java", "target": 1, "func": "import javax.crypto.Cipher;\nimport javax.crypto.SecretKey;\nimport javax.crypto.spec.SecretKeySpec;\n\nimport org.apache.commons.codec.binary.Base64;\n\nimport **.CryptoService;\nimport **.CryptoServiceException;\n\n\npublic class CryptoServiceImpl implements CryptoService {\n\npublic byte[] encrypt(byte[] data, String key) throws Exception {\n        try {\n            Cipher cipher = Cipher.getInstance(\"RSA\");\n            Base64 decoder = new Base64(64);\n\n            // decode the base64 encoded string\n            byte[] decodedKey = decoder.decode(key);\n            // rebuild key using SecretKeySpec\n            final SecretKeySpec originalKey = new SecretKeySpec(decodedKey, 0, decodedKey.length, \"RSA\");\n\n            cipher.init(Cipher.ENCRYPT_MODE, originalKey);\n            final String encryptedString = Base64.encodeBase64String(cipher.doFinal(data));\n            return encryptedString.getBytes();\n        } catch (Exception e) {\n            throw new CryptoServiceException(\"Cannot encrypt data using key '\", e);\n        }\n\n    }\n\n    public byte[] decrypt(byte[] data, String key) throws Exception {\n        try {\n            Cipher cipher = Cipher.getInstance(\"RSA\");\n            Base64 decoder = new Base64(64);\n\n            // decode the base64 encoded string\n            byte[] decodedKey = decoder.decode(key);\n            // rebuild key using SecretKeySpec\n            final SecretKeySpec originalKey = new SecretKeySpec(decodedKey, 0, decodedKey.length, \"RSA\");\n\n            cipher.init(Cipher.DECRYPT_MODE, originalKey);\n            final String decryptedString = new String(cipher.doFinal(Base64.decodeBase64(new String(data))));\n            return decryptedString.getBytes();\n        } catch (Exception e) {\n            throw new CryptoServiceException(\"Cannot decrypt data using key '\", e);\n\n        }\n    }\n}\n", "idx": 2031}
{"project": "cipher", "commit_id": "Snippet28394323_10559.java", "target": 1, "func": "Cipher CheckCipher = Cipher.getInstance(\"RSA/ECB/PKCS1Padding\");\n", "idx": 2152}
{"project": "cipher", "commit_id": "Snippet26722584_8841.java", "target": 0, "func": "private static String rc4(String plaintext, int mode, Key key) throws Exception {\n    Cipher cipher = Cipher.getInstance(\"RC4\");\n    cipher.init(mode, (java.security.Key) key);\n    return new String(cipher.doFinal(plaintext.getBytes()));\n}\n\npublic static String encrypt(String plaintext, Key key) throws Exception {\n    return rc4(plaintext, Cipher.ENCRYPT_MODE, key);\n}\n", "idx": 1711}
{"project": "cipher", "commit_id": "Snippet13002029_36636.java", "target": 0, "func": "cipher = Cipher.getInstance(\"DES/ECB/PKCS5Padding\");\n", "idx": 1757}
{"project": "cipher", "commit_id": "Snippet11601201_35644.java", "target": 0, "func": "Cipher cipher = Cipher.getInstance(\"AES\");\ncipher.init(Cipher.ENCRYPT_MODE, new SecretKeySpec(Hex.decodeHex(encryptionKey.toCharArray()), \"AES\"));\nencrypted = Hex.encodeHexString(cipher.doFinal((sampleText.toString()).getBytes()));\n", "idx": 1661}
{"project": "cipher", "commit_id": "Snippet22842235_5240.java", "target": 1, "func": "public static String decryptRSA(Context mContext, byte[] message) throws Exception { \n\n\n    InputStream in = mContext.getResources().openRawResource(R.raw.publicrsakey);\n    X509EncodedKeySpec x509EncodedKeySpec = new X509EncodedKeySpec(org.apache.commons.io.IOUtils.toByteArray(in));\n\n    PublicKey publicKey = \n            KeyFactory.getInstance(\"RSA\").generatePublic(x509EncodedKeySpec);\n\n    Cipher cipher = Cipher.getInstance(\"RSA\");\n    cipher.init(Cipher.ENCRYPT_MODE, publicKey);\n    final String encryptedString = Base64.encode(cipher.doFinal(message));\n\n    return encryptedString;\n\n\n}   \n", "idx": 2335}
{"project": "cipher", "commit_id": "Snippet38176020_20151.java", "target": 1, "func": "private Cipher getCipher() {\n    try {\n        if (Build.VERSION.SDK_INT < Build.VERSION_CODES.M) { // below android m\n            return Cipher.getInstance(\"RSA/ECB/PKCS1Padding\", \"AndroidOpenSSL\"); // error in android 6: InvalidKeyException: Need RSA private or public key\n        }\n        else { // android m and above\n            return Cipher.getInstance(\"RSA/ECB/PKCS1Padding\", \"AndroidKeyStoreBCWorkaround\"); // error in android 5: NoSuchProviderException: Provider not available: AndroidKeyStoreBCWorkaround\n        }\n    } catch(Exception exception) {\n        throw new RuntimeException(\"getCipher: Failed to get an instance of Cipher\", exception);\n    }\n}\n", "idx": 2010}
{"project": "cipher", "commit_id": "Snippet35907877_17762.java", "target": 1, "func": "    byte[] key = \"mykey\".getBytes(\"UTF-8\");\n\n    private byte[] getKeyBytes(final byte[] key) throws Exception {\n        byte[] keyBytes = new byte[16];\n        System.arraycopy(key, 0, keyBytes, 0, Math.min(key.length, keyBytes.length));\n        return keyBytes;\n    }\n\n    public Cipher getCipherEncrypt(final byte[] key) throws Exception {\n        byte[] keyBytes = getKeyBytes(key);\n        Cipher cipher = Cipher.getInstance(\"AES/CBC/PKCS5Padding\");\n        SecretKeySpec secretKeySpec = new SecretKeySpec(keyBytes, \"AES\");\n        IvParameterSpec ivParameterSpec = new IvParameterSpec(keyBytes);\n        cipher.init(Cipher.ENCRYPT_MODE, secretKeySpec, ivParameterSpec);\n        return cipher;\n    }\n\n    public void encrypt(File in, File output, byte[] key) throws Exception {\n\n        Cipher cipher = getCipherEncrypt(key);\n        FileOutputStream fos = null;\n        CipherOutputStream cos = null;\n        FileInputStream fis = null;\n        try {\n            fis = new FileInputStream(in);\n            fos = new FileOutputStream(output);\n            cos = new CipherOutputStream(fos, cipher);\n            byte[] data = new byte[1024];\n            int read = fis.read(data);\n            while (read != -1) {\n                cos.write(data, 0, read);\n                read = fis.read(data);\n             System.out.println(new String(data, \"UTF-8\").trim());\n\n            }\n            cos.flush();\n\n        } finally {\n\n            System.out.println(\"performed encrypt method now closing streams:\\n\" + output.toString());\n            cos.close();\n            fos.close();\n            fis.close();\n\n\n        }\n    }\n\n\npublic void watchMeEncrypt(){\n\nencrypt(file, new File (\"example.txt),key);\n", "idx": 2339}
{"project": "cipher", "commit_id": "Snippet41872614_23896.java", "target": 1, "func": "public class RSAEncDecDemo {\n\n    private static final String PUBLIC_KEY_FILE = \"lk.public.key\";\n    private static final String PRIVATE_KEY_FILE = \"lk.private.key\";\n\n    @SuppressWarnings(\"restriction\")\n    public static void main(String[] args) throws IOException {\n\n        try {\n            KeyPairGenerator keyPairGenerator = KeyPairGenerator.getInstance(\"RSA\");\n            keyPairGenerator.initialize(2048);\n            KeyPair keyPair = keyPairGenerator.generateKeyPair();\n            PublicKey publicKey = keyPair.getPublic();\n            PrivateKey privateKey = keyPair.getPrivate();\n\n            writeStringkey(PUBLIC_KEY_FILE,new BASE64Encoder().encode(publicKey.getEncoded()));\n            writeStringkey(PRIVATE_KEY_FILE,new BASE64Encoder().encode(privateKey.getEncoded()));\n\n            String demoString = \"123346\"; \n            RSAEncDecDemo rsa = new RSAEncDecDemo();\n            String decrypted = rsa.decryptData(demoString);\n            String msisdn = decrypted.substring(0,decrypted.indexOf(\"|\"));\n\n        } catch (Exception e) {\n            e.printStackTrace();\n\n        }\n    }\n\n    private String decryptData(String strData) throws IOException {\n        byte[] data = DatatypeConverter.parseHexBinary(strData);\n        byte[] descryptedData = null;\n\n        try {\n            PrivateKey privateKey = readPrivateKeyFromFile(PRIVATE_KEY_FILE);\n            Cipher cipher = Cipher.getInstance(\"RSA\");\n            cipher.init(Cipher.DECRYPT_MODE, privateKey);\n            descryptedData = cipher.doFinal(data);\n\n        } catch (Exception e) {\n            e.printStackTrace();\n        }\n\n        return new String(descryptedData);\n    }\n\n\n    @SuppressWarnings(\"restriction\")\n    public PrivateKey readPrivateKeyFromFile(String fileName)throws IOException, NoSuchAlgorithmException,InvalidKeySpecException {\n\n        String publicK = readStringKey(fileName);\n        byte[] keyBytes = new BASE64Decoder().decodeBuffer(publicK);\n        PKCS8EncodedKeySpec keySpec = new PKCS8EncodedKeySpec(keyBytes);\n        KeyFactory fact = KeyFactory.getInstance(\"RSA\");\n        return fact.generatePrivate(keySpec);\n    }\n\n    public PrivateKey readPrivateKeyFromFileold(String fileName)throws IOException {\n        FileInputStream fis = null;\n        ObjectInputStream ois = null;\n        try {\n            fis = new FileInputStream(new File(fileName));\n            ois = new ObjectInputStream(fis);\n\n            BigInteger modulus = (BigInteger) ois.readObject();\n            BigInteger exponent = (BigInteger) ois.readObject();\n\n            RSAPrivateKeySpec rsaPrivateKeySpec = new RSAPrivateKeySpec(modulus, exponent);\n            KeyFactory fact = KeyFactory.getInstance(\"RSA\");\n            PrivateKey privateKey = fact.generatePrivate(rsaPrivateKeySpec);\n\n            return privateKey;\n\n        } catch (Exception e) {\n            e.printStackTrace();\n        } finally {\n            if (ois != null) {\n                ois.close();\n                if (fis != null) {\n                    fis.close();\n                }\n            }\n        }\n        return null;\n    }\n\n    public static void writeStringkey(String fileName, String data) {\n        try {\n            FileWriter out = new FileWriter(new File(fileName));\n            out.write(data);\n            out.close();\n        } catch (IOException e) {\n        }\n    }\n\n    public static String readStringKey(String fileName) {\n\n        BufferedReader reader = null;\n        StringBuffer fileData = null;\n        try {\n\n            fileData = new StringBuffer(2048);\n            reader = new BufferedReader(new FileReader(fileName));\n            char[] buf = new char[1024];\n            int numRead = 0;\n            while ((numRead = reader.read(buf)) != -1) {\n                String readData = String.valueOf(buf, 0, numRead);\n                fileData.append(readData);\n                buf = new char[1024];\n            }\n\n            reader.close();\n\n        } catch (Exception e) {\n        } finally {\n            if (reader != null) {\n                reader = null;\n            }\n        }\n        return fileData.toString();\n\n    }\n}\n", "idx": 2113}
{"project": "cipher", "commit_id": "Snippet15147738_38233.java", "target": 0, "func": "this.encrypter = Cipher.getInstance(\"DESede/ECB/PKCS5Padding\", \"BC\");", "idx": 1777}
{"project": "cipher", "commit_id": "Snippet25841512_8080.java", "target": 1, "func": "RSAPublicKeySpec rsaPublicKeySpec = new RSAPublicKeySpec(mod,exp);\nKeyFactory keyFactory = KeyFactory.getInstance(\"RSA\",\"BS\");\nPublicKey publicKey = keyFactory.generatePublic(rsaPublicKeySpec);\nCipher cipher = Cipher.getInstance(\"RSA/None/PKCS1Padding\", \"BS\");\ncipher.init(Cipher.ENCRYPT_MODE, publicKey);\nbyte[] encryptedBytes = cipher.doFinal(plaintText.getBytes());\nbyte[] encodedBytes = org.bouncycastle.util.encoders.Base64.encode(encryptedBytes);\nString encryptedData = new String(encodedBytes);\n", "idx": 1944}
{"project": "cipher", "commit_id": "Snippet27750441_9920.java", "target": 1, "func": "Cipher.getInstance(\"RSA/ECB/OAEPWithSHA1AndMGF1Padding\");", "idx": 2142}
{"project": "cipher", "commit_id": "Snippet46306052_28410.java", "target": 1, "func": "Security.addProvider(new BouncyCastleProvider());\n    ECNamedCurveParameterSpec spec = ECNamedCurveTable.getParameterSpec(\"prime256v1\");\n    try \n    {\n        KeyPairGenerator g = KeyPairGenerator.getInstance(\"ECDSA\",\"BC\");\n        g.initialize(spec, new SecureRandom());\n        KeyPair keyPair = g.generateKeyPair();\n        privateKey = keyPair.getPrivate();\n        publicKey = keyPair.getPublic();\n        System.out.println(\"PublicKey:\"+publicKey+\"\\n\");\n        System.out.println(\"PrivateKey:\"+privateKey+\"\\n\");\n\n    } \n    catch (Exception e) \n    {\n        e.printStackTrace();\n    }\n    String origin = \"This is origin string\";\n    try {\n        Cipher c = Cipher.getInstance(\"ECIES\",\"BC\");\n        c.init(Cipher.ENCRYPT_MODE,publicKey);\n        encodeBytes = c.doFinal(origin.getBytes());\n\n        String encrypt = encodeBytes.toString();\n        System.out.println(\"Encrypt:\"+ encrypt+\"\\n\");\n    } catch (Exception e) {\n        e.printStackTrace();\n    }\n", "idx": 2243}
{"project": "cipher", "commit_id": "Snippet32156462_14253.java", "target": 1, "func": "Cipher.getInstance(\"AES/CBC/PKCS5Padding\")", "idx": 2317}
{"project": "cipher", "commit_id": "Snippet46486613_28615.java", "target": 1, "func": "val iv = Array(0x30,0xd2,0xff,0x5d,0x08,0xac,0x83,0x95,0x02,0x0f,0x23,0x20,0x81,0xc9,0xc1,0xe4).map { _.toByte }\nval message = Array(0xb8,0x9f,0x27,0x30,0xe5,0x4d,0x81,0xf3,0xa9,0x3d,0x0b,0xe3,0xaa,0x52,0x50,0x15).map { _.toByte }\nval key = new SecretKeySpec(keyBytes, \"AES\")\nval cipher = Cipher.getInstance(\"AES/CBC/NoPadding\")\ncipher.init(Cipher.DECRYPT_MODE, key, new IvParameterSpec(iv))\nval result = cipher.doFinal(message)\nprintln(new String(result, \"UTF-8\"))\n", "idx": 2271}
{"project": "cipher", "commit_id": "Snippet13508131_37064.java", "target": 1, "func": "Cipher cipher = Cipher.getInstance(\"RSA/ECB/PKCS1Padding\");\n", "idx": 1948}
{"project": "cipher", "commit_id": "Snippet11786924_35791.java", "target": 1, "func": "import java.io.File;\nimport java.io.IOException;\nimport java.nio.charset.Charset;\nimport java.nio.file.Files;\nimport java.security.GeneralSecurityException;\nimport java.security.MessageDigest;\nimport java.util.Arrays;\nimport java.util.List;\n\nimport javax.crypto.BadPaddingException;\nimport javax.crypto.Cipher;\nimport javax.crypto.IllegalBlockSizeException;\nimport javax.crypto.spec.IvParameterSpec;\nimport javax.crypto.spec.SecretKeySpec;\n\nimport org.bouncycastle.util.encoders.Base64;\n\n/**\n * Class created for StackOverflow by owlstead.\n * This is open source, you are free to copy and use for any purpose.\n */\npublic class OpenSSLDecryptor {\n    private static final Charset ASCII = Charset.forName(\"ASCII\");\n    private static final int INDEX_KEY = 0;\n    private static final int INDEX_IV = 1;\n    private static final int ITERATIONS = 1;\n\n    private static final int ARG_INDEX_FILENAME = 0;\n    private static final int ARG_INDEX_PASSWORD = 1;\n\n    private static final int SALT_OFFSET = 8;\n    private static final int SALT_SIZE = 8;\n    private static final int CIPHERTEXT_OFFSET = SALT_OFFSET + SALT_SIZE;\n\n    private static final int KEY_SIZE_BITS = 256;\n\n    /**\n     * Thanks go to Ola Bini for releasing this source on his blog.\n     * The source was obtained from <a href=\"http://olabini.com/blog/tag/evp_bytestokey/\">here</a> .\n     */\n    public static byte[][] EVP_BytesToKey(int key_len, int iv_len, MessageDigest md,\n            byte[] salt, byte[] data, int count) {\n        byte[][] both = new byte[2][];\n        byte[] key = new byte[key_len];\n        int key_ix = 0;\n        byte[] iv = new byte[iv_len];\n        int iv_ix = 0;\n        both[0] = key;\n        both[1] = iv;\n        byte[] md_buf = null;\n        int nkey = key_len;\n        int niv = iv_len;\n        int i = 0;\n        if (data == null) {\n            return both;\n        }\n        int addmd = 0;\n        for (;;) {\n            md.reset();\n            if (addmd++ > 0) {\n                md.update(md_buf);\n            }\n            md.update(data);\n            if (null != salt) {\n                md.update(salt, 0, 8);\n            }\n            md_buf = md.digest();\n            for (i = 1; i < count; i++) {\n                md.reset();\n                md.update(md_buf);\n                md_buf = md.digest();\n            }\n            i = 0;\n            if (nkey > 0) {\n                for (;;) {\n                    if (nkey == 0)\n                        break;\n                    if (i == md_buf.length)\n                        break;\n                    key[key_ix++] = md_buf[i];\n                    nkey--;\n                    i++;\n                }\n            }\n            if (niv > 0 && i != md_buf.length) {\n                for (;;) {\n                    if (niv == 0)\n                        break;\n                    if (i == md_buf.length)\n                        break;\n                    iv[iv_ix++] = md_buf[i];\n                    niv--;\n                    i++;\n                }\n            }\n            if (nkey == 0 && niv == 0) {\n                break;\n            }\n        }\n        for (i = 0; i < md_buf.length; i++) {\n            md_buf[i] = 0;\n        }\n        return both;\n    }\n\n\n    public static void main(String[] args) {\n        try {\n            // --- read base 64 encoded file ---\n\n            File f = new File(args[ARG_INDEX_FILENAME]);\n            List<String> lines = Files.readAllLines(f.toPath(), ASCII);\n            StringBuilder sb = new StringBuilder();\n            for (String line : lines) {\n                sb.append(line.trim());\n            }\n            String dataBase64 = sb.toString();\n            byte[] headerSaltAndCipherText = Base64.decode(dataBase64);\n\n            // --- extract salt & encrypted ---\n\n            // header is \"Salted__\", ASCII encoded, if salt is being used (the default)\n            byte[] salt = Arrays.copyOfRange(\n                    headerSaltAndCipherText, SALT_OFFSET, SALT_OFFSET + SALT_SIZE);\n            byte[] encrypted = Arrays.copyOfRange(\n                    headerSaltAndCipherText, CIPHERTEXT_OFFSET, headerSaltAndCipherText.length);\n\n            // --- specify cipher and digest for EVP_BytesToKey method ---\n\n            Cipher aesCBC = Cipher.getInstance(\"AES/CBC/PKCS5Padding\");\n            MessageDigest md5 = MessageDigest.getInstance(\"MD5\");\n\n            // --- create key and IV  ---\n\n            // the IV is useless, OpenSSL might as well have use zero's\n            final byte[][] keyAndIV = EVP_BytesToKey(\n                    KEY_SIZE_BITS / Byte.SIZE,\n                    aesCBC.getBlockSize(),\n                    md5,\n                    salt,\n                    args[ARG_INDEX_PASSWORD].getBytes(ASCII),\n                    ITERATIONS);\n            SecretKeySpec key = new SecretKeySpec(keyAndIV[INDEX_KEY], \"AES\");\n            IvParameterSpec iv = new IvParameterSpec(keyAndIV[INDEX_IV]);\n\n            // --- initialize cipher instance and decrypt ---\n\n            aesCBC.init(Cipher.DECRYPT_MODE, key, iv);\n            byte[] decrypted = aesCBC.doFinal(encrypted);\n\n            String answer = new String(decrypted, ASCII);\n            System.out.println(answer);\n        } catch (BadPaddingException e) {\n            // AKA \"something went wrong\"\n            throw new IllegalStateException(\n                    \"Bad password, algorithm, mode or padding;\" +\n                    \" no salt, wrong number of iterations or corrupted ciphertext.\");\n        } catch (IllegalBlockSizeException e) {\n            throw new IllegalStateException(\n                    \"Bad algorithm, mode or corrupted (resized) ciphertext.\");\n        } catch (GeneralSecurityException e) {\n            throw new IllegalStateException(e);\n        } catch (IOException e) {\n            throw new IllegalStateException(e);\n        }\n    }        \n}\n", "idx": 1972}
{"project": "cipher", "commit_id": "Snippet47210081_29207.java", "target": 1, "func": "public class Encryptor{\nprivate static String key=\"asdfghjklqwe@321\" ;\nprivate static String initVector = \"RandomInitVector\";\n\npublic static void encryptFile(File inputFile, String outputFolderPath) {\n    try {\n        Key secretKey = new SecretKeySpec(key.getBytes(\"UTF-8\"),\"AES\");\n        Cipher cipher = Cipher.getInstance(\"AES/CBC/PKCS5Padding\");\n        cipher.init(Cipher.ENCRYPT_MODE, secretKey,new IvParameterSpec(initVector.getBytes(\"UTF-8\")));\n\n        FileInputStream inputStream = new FileInputStream(inputFile);\n        byte[] inputBytes = new byte[(int) inputFile.length()];\n        inputStream.read(inputBytes);\n\n        byte[] outputBytes = cipher.doFinal(inputBytes);\n\n        File encryptedFile = new File(outputFolderPath,inputFile.getName());\n        encryptedFile.getParentFile().mkdirs();\n        encryptedFile.createNewFile();\n        FileOutputStream outputStream = new FileOutputStream(encryptedFile);\n        outputStream.write(outputBytes);\n\n        inputStream.close();\n        outputStream.close();\n        System.out.println(\"File encryption completed successfully.\");\n        inputFile.delete();\n        System.out.println(\"File deleted from the original location.\");\n    } catch (Exception e) {\n        e.printStackTrace();\n    }\n}\n}\n", "idx": 2229}
{"project": "cipher", "commit_id": "Snippet33999427_16059.java", "target": 0, "func": "ERROR: java.security.InvalidAlgorithmParameterException: expected IV length of 0\n\n\nimport java.io.UnsupportedEncodingException;\nimport java.security.GeneralSecurityException;\n\nimport javax.crypto.Cipher;\nimport javax.crypto.spec.DESedeKeySpec;\nimport javax.crypto.spec.IvParameterSpec;\nimport javax.crypto.spec.SecretKeySpec;\n\npublic class Encryption {\n\npublic static int MAX_KEY_LENGTH = DESedeKeySpec.DES_EDE_KEY_LEN;\nprivate static String ENCRYPTION_KEY_TYPE = \"DESede\";\nprivate static String ENCRYPTION_ALGORITHM = \"DESede/ECB/PKCS5Padding\";\nprivate final SecretKeySpec keySpec;\n\npublic Encryption(String passphrase) {\n    byte[] key;\n    try {\n        // get bytes representation of the password\n        key = passphrase.getBytes(\"UTF8\");\n    } catch (UnsupportedEncodingException e) {\n        throw new IllegalArgumentException(e);\n    }\n\n    key = padKeyToLength(key, MAX_KEY_LENGTH);\n    keySpec = new SecretKeySpec(key, ENCRYPTION_KEY_TYPE);\n}\n\n// !!! - see post below\nprivate byte[] padKeyToLength(byte[] key, int len) {\n    byte[] newKey = new byte[len];\n    System.arraycopy(key, 0, newKey, 0, Math.min(key.length, len));\n    return newKey;\n}\n\n// standard stuff\npublic byte[] encrypt(byte[] unencrypted) throws GeneralSecurityException {\n    return doCipher(unencrypted, Cipher.ENCRYPT_MODE);\n}\n\npublic byte[] decrypt(byte[] encrypted) throws GeneralSecurityException {\n    return doCipher(encrypted, Cipher.DECRYPT_MODE);\n}\n\nprivate byte[] doCipher(byte[] original, int mode) throws GeneralSecurityException {\n    Cipher cipher = Cipher.getInstance(ENCRYPTION_ALGORITHM);\n    // IV = 0 is yet another issue, we'll ignore it here\n    IvParameterSpec iv = new IvParameterSpec(new byte[] { 0, 0, 0, 0, 0, 0, 0, 0 });\n    cipher.init(mode, keySpec, iv);\n    return cipher.doFinal(original);\n}\n}\n", "idx": 1600}
{"project": "cipher", "commit_id": "Snippet2221730_30262.java", "target": 1, "func": "public class Rsa {\n\n    public static void main(String[] args) throws Exception, IOException {\n        File keyFile = new File(\"public.der\");\n        byte[] encodedKey = new byte[(int) keyFile.length()];\n\n        new FileInputStream(keyFile).read(encodedKey);\n\n        X509EncodedKeySpec publicKeySpec = new X509EncodedKeySpec(encodedKey);\n\n        KeyFactory kf = KeyFactory.getInstance(\"RSA\");\n        PublicKey pk = kf.generatePublic(publicKeySpec);\n\n        Cipher rsa = Cipher.getInstance(\"RSA\");\n\n        rsa.init(Cipher.ENCRYPT_MODE, pk);\n\n        FileOutputStream fileOutputStream = new FileOutputStream(\n                \"encrypted.rsa\");\n        OutputStream os = new CipherOutputStream(fileOutputStream, rsa);\n\n        byte[] raw = new byte[245];\n        raw[0] = 4;\n\n        os.write(raw);\n        os.flush();\n        os.close();\n\n\n    }\n}\n", "idx": 1967}
{"project": "cipher", "commit_id": "Snippet40330822_22199.java", "target": 1, "func": "public static String decryptString(String alias,String cipherText) {\n        try {\n            KeyStore.PrivateKeyEntry privateKeyEntry = (KeyStore.PrivateKeyEntry)keyStore.getEntry(alias, null);\n           // RSAPrivateKey privateKey = (RSAPrivateKey) privateKeyEntry.getPrivateKey();\n\n        Cipher output = Cipher.getInstance(\"RSA/ECB/PKCS1Padding\");\n        output.init(Cipher.DECRYPT_MODE,  privateKeyEntry.getPrivateKey());\n\n        CipherInputStream cipherInputStream = new CipherInputStream(\n                new ByteArrayInputStream(Base64.decode(cipherText, Base64.DEFAULT)), output);\n        ArrayList<Byte> values = new ArrayList<>();\n        int nextByte;\n        while ((nextByte = cipherInputStream.read()) != -1) {\n            values.add((byte)nextByte);\n        }\n\n        byte[] bytes = new byte[values.size()];\n        for(int i = 0; i < bytes.length; i++) {\n            bytes[i] = values.get(i).byteValue();\n        }\n\n        String finalText = new String(bytes, 0, bytes.length, \"UTF-8\");\n        return finalText;\n        //decryptedText.setText(finalText);\n\n    } catch (Exception e) {\n        Toast.makeText(context, \"Exception \" + e.getMessage() + \" occured\", Toast.LENGTH_LONG).show();\n        Log.e(\"DecryptStringTAG\", Log.getStackTraceString(e));\n    }\n    return \"EMPTY\";\n}\n", "idx": 2206}
{"project": "cipher", "commit_id": "Snippet30959980_13127.java", "target": 0, "func": "public void test() {\n    String sKSN = \"ffff1234560006800010\";\n    String sBDK = \"E08A46B616230152230DB9C8DF94C75E\";\n    byte[] dikKSN = new byte[10];\n    byte[] KSN8 = new byte[8];\n    byte[] BDK = new byte[16];\n    byte[] lKey = new byte[8];\n    byte[] rKey = new byte[8];\n    String retKey = \"\";\n    String lgTxt = \"\";\n    dikKSN = this.fromHex(sKSN);  // convert hex to byte array\n    BDK = this.fromHex(sBDK); // convert hex to byte array\n    KSN8 = this.copyByte8(dikKSN); //use the first 8 values\n    lKey = this.tDESEncrypt(KSN8, BDK);\n}\nprivate byte[] tDESEncrypt(byte[] plainTextBytes, byte[] kb) {\n  byte[] cipherText = null;\n  try {\n    final MessageDigest md = MessageDigest.getInstance(\"md5\");\n    final byte[] digestOfPassword = md.digest(kb);\n    final byte[] keyBytes = Arrays.copyOf(digestOfPassword, 24);\n    for (int j = 0, k = 16; j < 8;) {\n      keyBytes[k++] = keyBytes[j++];\n    }\n    final SecretKey key = new SecretKeySpec(keyBytes, \"DESede\");\n    final Cipher cipher = Cipher.getInstance(\"DESede/CBC/NoPadding\"); \n    final IvParameterSpec iv = new IvParameterSpec(new byte[8]);\n    cipher.init(Cipher.ENCRYPT_MODE, key, iv);\n    cipherText = cipher.doFinal(plainTextBytes);\n  } catch (Exception ex) {\n    ex.printStackTrace();\n  }\n  return cipherText;\n}\n", "idx": 1710}
{"project": "cipher", "commit_id": "Snippet21553019_4022.java", "target": 1, "func": "javax.crypto.Cipher.getInstance(\"RSA\");\n", "idx": 2346}
{"project": "cipher", "commit_id": "Snippet6907822_32448.java", "target": 0, "func": "import java.security.SecureRandom;\n\nimport javax.crypto.Cipher;\nimport javax.crypto.KeyGenerator;\nimport javax.crypto.SecretKey;\nimport javax.crypto.spec.SecretKeySpec;\n\npublic class AES128 \n{\n    private byte[] getRawKey(byte[] seed) throws Exception \n    {\n        KeyGenerator kgen = KeyGenerator.getInstance(\"AES\");\n        SecureRandom sr = SecureRandom.getInstance(\"SHA1PRNG\");\n        sr.setSeed(seed);\n        kgen.init(128, sr); // 192 and 256 bits may not be available\n        SecretKey skey = kgen.generateKey();\n        byte[] raw = skey.getEncoded();\n        return raw;\n    }\n\n    public byte[] encrypt(byte[] raw, byte[] clear) throws Exception \n    {\n        SecretKeySpec skeySpec = new SecretKeySpec(getRawKey(raw), \"AES\");\n        Cipher cipher = Cipher.getInstance(\"AES\");\n        cipher.init(Cipher.ENCRYPT_MODE, skeySpec);\n        byte[] encrypted = cipher.doFinal(clear);\n        return encrypted;\n    }\n\n    public byte[] decrypt(byte[] raw, byte[] encrypted) throws Exception \n    {\n        SecretKeySpec skeySpec = new SecretKeySpec(getRawKey(raw), \"AES\");\n        Cipher cipher = Cipher.getInstance(\"AES\");\n        cipher.init(Cipher.DECRYPT_MODE, skeySpec);\n        byte[] decrypted = cipher.doFinal(encrypted);\n        return decrypted;\n    }\n}\n", "idx": 1675}
{"project": "cipher", "commit_id": "Snippet38828807_20728.java", "target": 0, "func": "Cipher.getInstance(\"AES\");", "idx": 1747}
{"project": "cipher", "commit_id": "Snippet7781409_32921.java", "target": 0, "func": "public static byte[] encrypt(String message) throws Exception\n{\n    String salt = \"1111111111111111\";\n    SecretKeySpec key = new SecretKeySpec(salt.getBytes(), \"AES\");\n    Cipher cipher = Cipher.getInstance(\"AES/ECB/PKCS5Padding\", \"SunJCE\");\n    cipher.init(Cipher.ENCRYPT_MODE, key);\n    return cipher.doFinal(message.getBytes());\n}\n\npublic static void main (String[] args) throws Exception\n{\n    String hello = Arrays.toString(encrypt(\"hello\"));\n    System.out.println(\"hello:\" + hello);\n    String helloWorld = Arrays.toString(encrypt(\"hello world\"));\n    System.out.println(\"hello world:\" + helloWorld);\n}\n", "idx": 1743}
{"project": "cipher", "commit_id": "Snippet22923586_5315.java", "target": 0, "func": "import java.security.InvalidKeyException;\nimport java.security.NoSuchAlgorithmException;\nimport java.security.spec.InvalidKeySpecException;\n\nimport javax.crypto.BadPaddingException;\nimport javax.crypto.Cipher;\nimport javax.crypto.IllegalBlockSizeException;\nimport javax.crypto.SecretKeyFactory;\nimport javax.crypto.NoSuchPaddingException;\nimport javax.crypto.SecretKey;\nimport javax.crypto.spec.DESKeySpec;\nimport javax.xml.bind.DatatypeConverter;\npublic class DESEncryptionDecryption {\n\nprivate static Cipher encryptCipher;\nprivate static Cipher decryptCipher;\n\npublic static void main(String[] args) throws InvalidKeySpecException {\ntry {\n\nString desKey = \"0123456789abcdef\"; // value from user\nbyte[] keyBytes = DatatypeConverter.parseHexBinary(desKey);\nSystem.out.println(keyBytes);\n\nSecretKeyFactory factory = SecretKeyFactory.getInstance(\"DES\");\nSecretKey key = factory.generateSecret(new DESKeySpec(keyBytes));\n\nencryptCipher = Cipher.getInstance(\"DES/ECB/PKCS5Padding\");\nencryptCipher.init(Cipher.ENCRYPT_MODE, key);\nbyte[] encryptedData = encryptData(\"Confidential data\"); //String from user\n\nString s=encryptedData.toString();//String input to decrypt From user\nbyte[] bb=s.getBytes();\n\ndecryptCipher = Cipher.getInstance(\"DES/ECB/PKCS5Padding\");\ndecryptCipher.init(Cipher.DECRYPT_MODE, key);\ndecryptData(bb); //Exception\n\n}catch (NoSuchAlgorithmException e) {\n       e.printStackTrace();\n      } catch (NoSuchPaddingException e) {\n       e.printStackTrace();\n      } catch (InvalidKeyException e) {\n       e.printStackTrace();\n      } catch (IllegalBlockSizeException e) {\n       e.printStackTrace();\n      } catch (BadPaddingException e) {\n       e.printStackTrace();\n      }}\n//method for encryption\nprivate static byte[] encryptData(String data)\n       throws IllegalBlockSizeException, BadPaddingException {\n      System.out.println(\"Data Before Encryption :\" + data);\n      byte[] dataToEncrypt = data.getBytes();\n      byte[] encryptedData = encryptCipher.doFinal(dataToEncrypt);\n      System.out.println(\"Encryted Data: \" + encryptedData);\n\n      return encryptedData;\n     }\n\n//method for decryption\n\nprivate static void decryptData(byte[] data)\nthrows IllegalBlockSizeException, BadPaddingException {\nbyte[] textDecrypted = decryptCipher.doFinal(data); //Exception trigered here\nSystem.out.println(\"Decryted Data: \" + new String(textDecrypted));\n}}\n", "idx": 1881}
{"project": "cipher", "commit_id": "Snippet36939277_18906.java", "target": 0, "func": "import java.util.Base64;\nimport java.io.BufferedReader;\nimport java.io.DataOutputStream;\nimport java.io.InputStream;\nimport java.io.InputStreamReader;\nimport java.net.URL;\nimport java.net.URLDecoder;\nimport java.net.URLEncoder;\nimport java.security.Key;\nimport java.security.KeyManagementException;\nimport java.security.NoSuchAlgorithmException;\nimport java.security.cert.X509Certificate;\nimport javax.crypto.Cipher;\nimport javax.crypto.spec.SecretKeySpec;\nimport javax.net.ssl.HostnameVerifier;\nimport javax.net.ssl.HttpsURLConnection;\nimport javax.net.ssl.SSLContext;\nimport java.util.Arrays;\nimport javax.net.ssl.SSLSession;\nimport javax.net.ssl.TrustManager;\nimport javax.net.ssl.X509TrustManager;\n\npublic class HelloWorld {\n    public static final String PHONENUMBER_PARAM = \"phoneNumber\";\n    public static final String PIN_PARAM =\"pin\";\n\n    public static final String MERCHANTID_PARAM = \"merchantId\";\n\n    public static void main(String args[]) throws Exception {\n\n    String phoneNumber =\"+917738995286\";\n    String pin =\"5577\";\n\n    String merchantId =\"527425858\";\n    String encodedKey =\"vPDkdTDrcygLPROzd1829A==\";\n\n    String payLoad = PHONENUMBER_PARAM + \"=\" +         URLEncoder.encode(phoneNumber, \"UTF-8\")+ \"&\" + PIN_PARAM + \"=\" + URLEncoder.encode(pin, \"UTF-8\") ;\n\n    byte[] decodedKey = Base64.getDecoder().decode(encodedKey.getBytes());\n\n    Key encryptionKey = new SecretKeySpec(decodedKey, \"AES\");\n\n    byte[] utf8Bytes = payLoad.getBytes(\"utf-8\");\n\n    byte[] encryptedBody = encrypt(encryptionKey, utf8Bytes);\n    String encryptedData = new  String(Base64.getEncoder().encode(encryptedBody));\n\n    System.out.println(\"encryptedData:\" + encryptedData);\n }\nprivate static byte[] encrypt(Key encryptionKey, byte[] data) throws Exception {\n    Cipher c = Cipher.getInstance(\"AES\");\n    c.init(1, encryptionKey);\n    return c.doFinal(data);\n}\n}\n", "idx": 1759}
{"project": "cipher", "commit_id": "Snippet46445083_28555.java", "target": 1, "func": "String encryptionKey = null;\nCipher cipher = null;\nSecretKeySpec key = null;\nbyte[] enc1;\nbyte[] dec1;\n\npath = FileSystems.getDefault().getPath(\"c:\\\\temp\\\\encryption\\\\SakisEnc.txt\", \"\");\ncipherText = Files.readAllBytes(path);\n\nencryptionKey = \"0123456789012345\";\ncipher = Cipher.getInstance(\"AES/CBC/PKCS5Padding\") ;\nkey = new SecretKeySpec(encryptionKey.getBytes(\"UTF-8\"), \"AES\");\ncipher.init(Cipher.DECRYPT_MODE, key, new IvParameterSpec(encryptionKey.getBytes(\"UTF-8\")));\ndec1 = cipher.doFinal(cipherText);\n", "idx": 1983}
{"project": "cipher", "commit_id": "Snippet36394097_18230.java", "target": 1, "func": "Cipher.getInstance(\"RSA/ECB/PKCS1Padding\", \"AndroidKeyStoreBCWorkaround\");\n", "idx": 2018}
{"project": "cipher", "commit_id": "Snippet22427479_4817.java", "target": 1, "func": "private static byte[] password = null; //  this.password = editText.getBytes();\nstatic final byte[] ivBytes = {'6','g','6','o','d','a','0','u','4','n','w','i','6','9','i','j'};\n\npublic static byte[] encrypt(String text) throws Exception {\n    byte[] clear = text.getBytes(\"UTF-8\");\n    IvParameterSpec ivSpec = new IvParameterSpec(ivBytes);\n\n    KeyGenerator kgen = KeyGenerator.getInstance(\"AES\");\n    SecureRandom sr = SecureRandom.getInstance(\"SHA1PRNG\");\n    sr.setSeed(password);\n    kgen.init(256, sr); // 192 and 256 bits may not be available\n    SecretKey skey = kgen.generateKey();\n    byte[] key = skey.getEncoded();\n\n    SecretKeySpec skeySpec = new SecretKeySpec(key, \"AES\");\n    Cipher cipher = Cipher.getInstance(\"AES/CBC/PKCS5Padding\");\n    cipher.init(Cipher.ENCRYPT_MODE, skeySpec, ivSpec);\n    byte[] encrypted = cipher.doFinal(clear);\n    return encrypted;\n}\n\npublic static String decrypt(byte[] encrypted) throws Exception {\n    IvParameterSpec ivSpec = new IvParameterSpec(ivBytes);\n\n    KeyGenerator kgen = KeyGenerator.getInstance(\"AES\");\n    SecureRandom sr = SecureRandom.getInstance(\"SHA1PRNG\");\n    sr.setSeed(password);\n    kgen.init(256, sr); // 192 and 256 bits may not be available\n    SecretKey skey = kgen.generateKey();\n    byte[] key = skey.getEncoded();\n\n    SecretKeySpec skeySpec = new SecretKeySpec(key, \"AES\");\n    Cipher cipher = Cipher.getInstance(\"AES/CBC/PKCS5Padding\");\n    cipher.init(Cipher.DECRYPT_MODE, skeySpec, ivSpec);\n    String decrypted = new String(cipher.doFinal(encrypted));\n    return decrypted;\n}\n", "idx": 2262}
{"project": "cipher", "commit_id": "Snippet43684021_25818.java", "target": 1, "func": "Cipher cipher = Cipher.getInstance(\"RSA\");\n", "idx": 2230}
{"project": "cipher", "commit_id": "Snippet30933692_13084.java", "target": 1, "func": "public byte[] encrypt(byte[] data, byte[] key) {\n  Cipher cipher = Cipher.getInstance(\"AES/CBC/PKCS5Padding\");\n  cipher.init(Cipher.ENCRYPT_MODE, new SecretKeySpec(key, \"AES\"));\n  return cipher.doFinal(data);\n}\n", "idx": 2221}
{"project": "cipher", "commit_id": "Snippet24322564_6600.java", "target": 1, "func": "import java.security.NoSuchAlgorithmException;\n\nimport javax.crypto.Cipher;\nimport javax.crypto.NoSuchPaddingException;\nimport javax.crypto.spec.IvParameterSpec;\nimport javax.crypto.spec.SecretKeySpec;\n\npublic class MCrypt {\n\n        static char[] HEX_CHARS = {'0','1','2','3','4','5','6','7','8','9','a','b','c','d','e','f'};\n\n        private String iv = \"fedcba9876543210\";//Dummy iv (CHANGE IT!)\n        private IvParameterSpec ivspec;\n        private SecretKeySpec keyspec;\n        private Cipher cipher;\n\n        private String SecretKey = \"0123456789abcdef\";//Dummy secretKey (CHANGE IT!)\n\n        public MCrypt()\n        {\n                ivspec = new IvParameterSpec(iv.getBytes());\n\n                keyspec = new SecretKeySpec(SecretKey.getBytes(), \"AES\");\n\n                try {\n                        cipher = Cipher.getInstance(\"AES/CBC/NoPadding\");\n                } catch (NoSuchAlgorithmException e) {\n                        // TODO Auto-generated catch block\n                        e.printStackTrace();\n                } catch (NoSuchPaddingException e) {\n                        // TODO Auto-generated catch block\n                        e.printStackTrace();\n                }\n        }\n\n        public byte[] encrypt(String text) throws Exception\n        {\n                if(text == null || text.length() == 0)\n                        throw new Exception(\"Empty string\");\n\n                byte[] encrypted = null;\n\n                try {\n                        cipher.init(Cipher.ENCRYPT_MODE, keyspec, ivspec);\n\n                        encrypted = cipher.doFinal(padString(text).getBytes());\n                } catch (Exception e)\n                {                       \n                        throw new Exception(\"[encrypt] \" + e.getMessage());\n                }\n\n                return encrypted;\n        }\n\n        public byte[] decrypt(String code) throws Exception\n        {\n                if(code == null || code.length() == 0)\n                        throw new Exception(\"Empty string\");\n\n            System.out.println(\"after if\");\n\n                byte[] decrypted = null;\n\n                try {\n                    System.out.println(\"in try\");\n                        cipher.init(Cipher.DECRYPT_MODE, keyspec, ivspec);\n                    System.out.println(\"2\");\n\n                        decrypted = cipher.doFinal(hexToBytes(code));\n                    System.out.println(\"3\");\n                        //Remove trailing zeroes\n                        if( decrypted.length > 0)\n                        {\n                            System.out.println(\"in if\");\n                            int trim = 0;\n                            for( int i = decrypted.length - 1; i >= 0; i-- ) if( decrypted[i] == 0 ) trim++;\n\n                            if( trim > 0 )\n                            {\n                                byte[] newArray = new byte[decrypted.length - trim];\n                                System.arraycopy(decrypted, 0, newArray, 0, decrypted.length - trim);\n                                decrypted = newArray;\n                            }\n                        }\n                    System.out.println(\"after if\");\n                } catch (Exception e)\n                {\n                        throw new Exception(\"[decrypt] \" + e.getMessage());\n                }\n                return decrypted;\n        }      \n\n\n        public static String bytesToHex(byte[] buf)\n        {\n            char[] chars = new char[2 * buf.length];\n            for (int i = 0; i < buf.length; ++i)\n            {\n                chars[2 * i] = HEX_CHARS[(buf[i] & 0xF0) >>> 4];\n                chars[2 * i + 1] = HEX_CHARS[buf[i] & 0x0F];\n            }\n            return new String(chars);\n        }\n\n\n        public static byte[] hexToBytes(String str) {\n                if (str==null) {\n                        return null;\n                } else if (str.length() < 2) {\n                        return null;\n                } else {\n                    System.out.println(\"else\");\n                        int len = str.length() / 2;\n                    System.out.println(len);\n                        byte[] buffer = new byte[len];\n                        for (int i=0; i<len; i++) {\n                            System.out.println(str.substring(i*2,i*2+2));\n                                buffer[i] = (byte) Integer.parseInt(str.substring(i*2,i*2+2),16);\n                            System.out.println(\"in for\");\n                        }\n                        return buffer;\n                }\n        }\n\n\n\n        private static String padString(String source)\n        {\n          char paddingChar = 0;\n          int size = 16;\n          int x = source.length() % size;\n          int padLength = size - x;\n\n          for (int i = 0; i < padLength; i++)\n          {\n                  source += paddingChar;\n          }\n\n          return source;\n        }\n}\n", "idx": 2207}
{"project": "cipher", "commit_id": "Snippet33824005_15903.java", "target": 0, "func": "public ArrayList<FootballClub> FootBallInputStream() throws FileNotFoundException, IOException, ClassNotFoundException, NoSuchAlgorithmException, NoSuchPaddingException, InvalidKeyException, IllegalBlockSizeException, BadPaddingException {\nFile file = new File(\"FootballClub.ser\");\nfileIn = new FileInputStream(file);\n\nSecretKey key = KeyGenerator.getInstance(\"AES\").generateKey();\nCipher cipher = Cipher.getInstance(\"AES\");\ncipher.init(Cipher.DECRYPT_MODE, key);\n\nCipherInputStream cipherIn = new CipherInputStream(fileIn, cipher);\nin = new ObjectInputStream(cipherIn);\n\nSealedObject sealed = (SealedObject) in.readObject();\n\nArrayList<FootballClub> e = (ArrayList<FootballClub>) sealed.getObject(cipher);\n\nin.close();\n\nfileIn.close();\n\nreturn e;\n\n}\npublic void FootBallOutputStream(ArrayList<FootballClub> e) throws FileNotFoundException, IOException, NoSuchAlgorithmException, NoSuchPaddingException, InvalidKeyException, IllegalBlockSizeException {\n\nFile file = new File(\"FootballClub.ser\");\nfileOut = new FileOutputStream(file);\n\n\nSecretKey key = KeyGenerator.getInstance(\"AES\").generateKey();\nCipher cipher = (Cipher.getInstance(\"AES\"));\ncipher.init(Cipher.ENCRYPT_MODE, key);\nSealedObject sealed = new SealedObject(e, cipher);\n\nCipherOutputStream cipherOut = new CipherOutputStream(fileOut, cipher);\nout = new ObjectOutputStream(cipherOut);\nout.writeObject(sealed);\nout.close();\nfileOut.close();\n}\n", "idx": 1680}
{"project": "cipher", "commit_id": "Snippet24119055_6415.java", "target": 0, "func": "import javax.crypto.Cipher;         \nimport javax.crypto.spec.SecretKeySpec;         \n\nimport org.apache.commons.codec.DecoderException;           \nimport org.apache.commons.codec.binary.Hex;         \n\nimport sun.misc.BASE64Decoder;          \nimport sun.misc.BASE64Encoder;          \n\n\npublic class AESTest {          \n    private static String sKeyString = \"29c4e20e74dce74f44464e814529203a\";      \n    private static SecretKeySpec skeySpec = null;       \n\n    static {        \n        try {   \n            skeySpec = new SecretKeySpec(Hex.decodeHex(sKeyString.toCharArray()), \"AES\");\n        } catch (DecoderException e) {  \n            e.printStackTrace();\n        }   \n    }       \n\n    public static String encode(String message) {       \n        String result = \"\"; \n\n        try {   \n            Cipher cipher = Cipher.getInstance(\"AES\");\n            cipher.init(Cipher.ENCRYPT_MODE, skeySpec);\n            byte[] encrypted = cipher.doFinal(message.getBytes(\"UTF-8\"));\n            result =  (new BASE64Encoder()).encode(encrypted);\n        } catch (Exception e) { \n            e.printStackTrace();\n        }   \n\n        return result;  \n    }       \n\n    public static String decode(String message){        \n        String result = \"\"; \n        try {   \n            Cipher cipher = Cipher.getInstance(\"AES\");\n            cipher.init(Cipher.DECRYPT_MODE, skeySpec);\n            byte[] encrypted = (new BASE64Decoder()).decodeBuffer(message);\n            byte[] original = cipher.doFinal(encrypted);\n            result = new String(original,\"UTF-8\");\n        } catch (Exception e) { \n            e.printStackTrace();\n        }   \n\n        return result;  \n    }       \n\n    public static void main(String[] args) {        \n        String message = \"SOME TEST\";   \n        System.out.println(\"message : \"+message);   \n        String encodeString = encode(message);  \n        System.out.println(\"encrypted string: \" + encodeString);    \n        String original = decode(encodeString); \n        System.out.println(\"Original string: \" + original); \n    }       \n}           \n", "idx": 1705}
{"project": "cipher", "commit_id": "Snippet36710344_18602.java", "target": 1, "func": "public class AES {\n    public static byte[] encrypt(String key, String initVector, String value) {\n        try {\n            IvParameterSpec vector = new IvParameterSpec(initVector.getBytes(\"UTF-8\"));\n            SecretKeySpec secretKey = new SecretKeySpec(key.getBytes(\"UTF-8\"), \"AES\");\n\n            Cipher cipher = Cipher.getInstance(\"AES/CBC/PKCS5PADDING\");\n            cipher.init(Cipher.ENCRYPT_MODE, secretKey, vector);\n\n            byte[] encrypted = cipher.doFinal(value.getBytes());\n            System.out.println(\"encrypted string: \"+  Base64.encodeBase64(encrypted));\n\n            return Base64.encodeBase64(encrypted);\n        } catch (Exception ex) {\n            ex.printStackTrace();\n        }\n\n        return null;\n    }\n\n    public static String decrypt(String key, String initVector, byte[] encrypted) {\n        try {\n            IvParameterSpec vector = new IvParameterSpec(initVector.getBytes(\"UTF-8\"));\n            SecretKeySpec secretKey = new SecretKeySpec(key.getBytes(\"UTF-8\"), \"AES\");\n\n            Cipher cipher = Cipher.getInstance(\"AES/CBC/PKCS5PADDING\");\n            cipher.init(Cipher.DECRYPT_MODE, secretKey, vector);\n\n            byte[] original = cipher.doFinal(Base64.decodeBase64(encrypted));\n\n            return new String(original);\n        } catch (Exception ex) {\n            ex.printStackTrace();\n        }\n\n        return null;\n    }\n\n    public static void main(String[] args) {\n        String key = \"Foo12345Bar67890\"; // 128 bit key\n        String initVector = \"RandomInitVector\"; // 16 bytes IV\n        StringBuilder sb = new StringBuilder(\"Hi||How||are||26 04 2016||finish\"); //Your Text here\n        byte[] encryptedBytes = encrypt(key, initVector, sb.toString());\n        System.out.println(decrypt(key, initVector,encryptedBytes));\n    }\n}\n", "idx": 2268}
{"project": "cipher", "commit_id": "Snippet15609660_38616.java", "target": 1, "func": "    Key key = generateKey();\n    Cipher c = Cipher.getInstance(ALGO);\n    c.init(Cipher.ENCRYPT_MODE, key);\n    String salt = \"some salt\";\n    String valueToEnc = null;\n    String eValue = Data;\n    for (int i = 0; i < 2; i++) {\n        valueToEnc = salt + eValue;\n        byte[] encValue = c.doFinal(valueToEnc.getBytes(UNICODE_FORMAT));\n        eValue =new String(Base64.encodeBase64(encValue));\n    }\n", "idx": 2293}
{"project": "cipher", "commit_id": "Snippet13613018_37140.java", "target": 0, "func": "44. public void onClick(View arg0) {\n45. \n46.   sp=this.getSharedPreferences(\"AccessApp\", MODE_WORLD_READABLE);\n47.   \n48.    \n49.    \n50.    \n51.   byte[] key = { 0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 0, 1, 2, 3, 4, 5 };\n52.    \n53.    \n54.   try {\n55.        String decryptedUser = decrypt(user, key);  \n56.         user = sp.getString(\"USERNAME_KEY\", decryptedUser);\n57.          \n58.   }\n59. catch (Exception e) {\n60.    // TODO Auto-generated catch block\n61.   e.printStackTrace();\n62.   }   \n63.   try {\n64.        String decryptedPass = decrypt(pass, key);  \n65.        pass = sp.getString(\"PASSWORD_KEY\", decryptedPass);\n66.         \n67.\n68.   } catch (Exception e) {\n69.     // TODO Auto-generated catch block\n70.    e.printStackTrace();\n71.   }\n72.   \n73.   if(lBttn.equals(arg0)){\n74.     \n75.      if((uname.getText().toString().equals(user))&& \n76.        (pword.getText().toString().equals(pass)))\n77.       \n78.            {\n79.          Toast.makeText(this, \"You are Logged In\", 20000).show();\n80.                 \n81.               Intent intent;\n82.                intent=new Intent(this,details.class);\n83.                startActivity(intent);\n84.              flag=1;\n85.            }\n\n\n\n\n135.         public static String decrypt(String encryptedText, byte[ ] key) throws Exception   {\n136.    SecretKeySpec skeySpec = new SecretKeySpec(key, \"AES\");\n137.    Cipher cipher = Cipher.getInstance(\"AES\");\n138.    cipher.init(Cipher.DECRYPT_MODE, skeySpec);\n139.    byte[] toDecrypt = Base64.decode(encryptedText);\n140.    byte[] encrypted = cipher.doFinal(toDecrypt);\n141.    return new String(encrypted);\n142.   }\n143.  }\n", "idx": 1805}
{"project": "cipher", "commit_id": "Snippet5488401_31654.java", "target": 1, "func": "cipher = Cipher.getInstance(\"RSA\");\n", "idx": 2144}
{"project": "cipher", "commit_id": "Snippet42821867_24904.java", "target": 0, "func": "class TCPServer {\npublic static void main(String argv[]) throws Exception {\n    String password = null;\n    String capitalizedSentence;\n    ServerSocket welcomeSocket = new ServerSocket(6789);\n\n    while (true) {\n        Socket connectionSocket = welcomeSocket.accept();\n        BufferedReader inFromClient = new BufferedReader(new InputStreamReader(connectionSocket.getInputStream()));\n        password = \"Passcode\";\n        byte[] salt = new byte[64];\n        Random rnd = new Random();\n        rnd.nextBytes(salt);\n        byte[] data = deriveKey(password, salt, 64);\n        byte [] EncyptedText = inFromClient.readLine().getBytes();\n        System.out.println(\"Received Encrypted message \" + EncyptedText);\n        SecretKey desKey = SecretKeyFactory.getInstance(\"DES\").generateSecret(new DESKeySpec(data));\n        Cipher cipher = Cipher.getInstance(\"DES/ECB/PKCS5Padding\");\n        cipher.init(Cipher.DECRYPT_MODE, desKey);\n        // Decrypt the text\n        System.out.println(\"Text Received \" + EncyptedText);\n        byte[] textDecrypted = cipher.doFinal(EncyptedText);\n        System.out.println(\"Text Decryted : \" + new String(textDecrypted));\n\n    }\n}\n\npublic static byte[] deriveKey(String password, byte[] salt, int keyLen) {\n        SecretKeyFactory kf = null;\n        try {\n            kf = SecretKeyFactory.getInstance(\"PBKDF2WithHmacSHA1\");\n        } catch (NoSuchAlgorithmException e) {\n            // TODO Auto-generated catch block\n            e.printStackTrace();\n        }\n        KeySpec specs = new PBEKeySpec(password.toCharArray(), salt, 1024, keyLen);\n        SecretKey key = null;\n        try {\n            key = kf.generateSecret(specs);\n        } catch (InvalidKeySpecException e) {\n            // TODO Auto-generated catch block\n            e.printStackTrace();\n        }\n        return key.getEncoded();\n}\n}\n", "idx": 1664}
{"project": "cipher", "commit_id": "Snippet36881980_18861.java", "target": 1, "func": "  public byte[] decryptUsingPrivateKey(String encryptedData, Context cntx) {\n\n    byte[] utf8 = null;\n    try {\n        KeyStore.PrivateKeyEntry privateKey = getKeyFromFile(\n                \"PrivateKeyFile.pfx\", \"privatekeypassword\", cntx);\n\n        Cipher rsa;\n        rsa = Cipher.getInstance(\"RSA/ECB/PKCS1Padding\");\n        rsa.init(Cipher.DECRYPT_MODE, privateKey.getPrivateKey());\n        utf8 = rsa.doFinal(Base64.decode(encryptedData));\n\n    } catch (Exception e) {\n        System.out.println(e);\n    }\n\n    return utf8;\n}\n", "idx": 2326}
{"project": "cipher", "commit_id": "Snippet15595200_38612.java", "target": 1, "func": "InputStream cipherInputStream = null;\ntry {\n    final StringBuilder output = new StringBuilder();\n    final byte[] secretKey = javax.xml.bind.DatatypeConverter.parseHexBinary(\"E4A38479A2349177EAE6038A018483318350E7F5430BDC8F82F1974715CB54E5\");\n    final byte[] initVector = javax.xml.bind.DatatypeConverter.parseHexBinary(\"629E2E1500B6BA687A385D410D5B08E3\");\n    final Cipher cipher = Cipher.getInstance(\"AES/CBC/PKCS5Padding\");\n    cipher.init(Cipher.DECRYPT_MODE, new SecretKeySpec(secretKey, \"AES\"), new IvParameterSpec(initVector, 0, cipher.getBlockSize()));\n    cipherInputStream = new CipherInputStream(new FileInputStream(\"text_ENCRYPTED\"), cipher);\n\n    final String charsetName = \"UTF-8\";\n\n    final byte[] buffer = new byte[8192];\n    int read = cipherInputStream.read(buffer);\n\n    while (read > -1) {\n        output.append(new String(buffer, 0, read, charsetName));\n        read = cipherInputStream.read(buffer);\n    }\n\n    System.out.println(output);\n} finally {\n    if (cipherInputStream != null) {\n        cipherInputStream.close();\n    }\n}\n", "idx": 2259}
{"project": "cipher", "commit_id": "Snippet26400365_8539.java", "target": 0, "func": "public class EncryptionHelper {\n\n// Encrypts string and encode in Base64\npublic static String encryptText(String plainText,String key, String IV) throws Exception {\n   // ---- Use specified 3DES key and IV from other source --------------\n    byte[] plaintext = plainText.getBytes();//input\n    byte[] tdesKeyData = key.getBytes();// your encryption key\n\n    byte[] myIV = IV.getBytes();// initialization vector\n\n    Cipher c3des = Cipher.getInstance(\"DESede/CBC/PKCS5Padding\");\n    SecretKeySpec myKey = new SecretKeySpec(tdesKeyData, \"DESede\");\n    IvParameterSpec ivspec = new IvParameterSpec(myIV);\n\n    c3des.init(Cipher.ENCRYPT_MODE, myKey, ivspec);\n    byte[] cipherText = c3des.doFinal(plaintext);\n    String encryptedString = Base64.encodeToString(cipherText,\n            Base64.DEFAULT);\n    // return Base64Coder.encodeString(new String(cipherText));\n    return encryptedString;\n}\n", "idx": 1872}
{"project": "cipher", "commit_id": "Snippet13488262_37028.java", "target": 0, "func": " import java.security.*;\n   import javax.crypto.*;\n   import javax.crypto.spec.*;\n   import java.io.*;\n\n   /**\n   * This program generates a AES key, retrieves its raw bytes, and\n   * then reinstantiates a AES key from the key bytes.\n   * The reinstantiated key is used to initialize a AES cipher for\n   * encryption and decryption.\n   */\n\n   public class AES {\n\n     /**\n     * Turns array of bytes into string\n     *\n     * @param buf   Array of bytes to convert to hex string\n     * @return  Generated hex string\n     */\n     public static String asHex (byte buf[]) {\n      StringBuffer strbuf = new StringBuffer(buf.length * 2);\n      int i;\n\n      for (i = 0; i < buf.length; i++) {\n       if (((int) buf[i] & 0xff) < 0x10)\n        strbuf.append(\"0\");\n\n       strbuf.append(Long.toString((int) buf[i] & 0xff, 16));\n      }\n\n      return strbuf.toString();\n     }\n\n     public static void main(String[] args) throws Exception {\n\n       String message=\"This is just an example\";\n\n       // Get the KeyGenerator\n\n       KeyGenerator kgen = KeyGenerator.getInstance(\"AES\");\n       kgen.init(128); // 192 and 256 bits may not be available\n\n\n       // Generate the secret key specs.\n       SecretKey skey = kgen.generateKey();\n       byte[] raw = skey.getEncoded();\n\n       SecretKeySpec skeySpec = new SecretKeySpec(raw, \"AES\");\n\n\n       // Instantiate the cipher\n\n       Cipher cipher = Cipher.getInstance(\"AES\");\n\n       cipher.init(Cipher.ENCRYPT_MODE, skeySpec);\n\n       byte[] encrypted =\n         cipher.doFinal((args.length == 0 ?\n          \"This is just an example\" : args[0]).getBytes());\n       System.out.println(\"encrypted string: \" + asHex(encrypted));\n\n       cipher.init(Cipher.DECRYPT_MODE, skeySpec);\n       byte[] original =\n         cipher.doFinal(encrypted);\n       String originalString = new String(original);\n       System.out.println(\"Original string: \" +\n         originalString + \" \" + asHex(original));\n     }\n   }\n", "idx": 1694}
{"project": "cipher", "commit_id": "Snippet31944374_14002.java", "target": 1, "func": "package com;\n\nimport java.io.BufferedReader;\nimport java.io.FileOutputStream;\nimport java.io.FileReader;\nimport java.io.IOException;\nimport java.io.InputStream;\nimport java.security.GeneralSecurityException;\nimport java.security.KeyFactory;\nimport java.security.PrivateKey;\nimport java.security.PublicKey;\nimport java.security.spec.PKCS8EncodedKeySpec;\nimport java.security.spec.X509EncodedKeySpec;\nimport java.util.Base64;\nimport java.util.Enumeration;\nimport java.util.Scanner;\nimport java.util.zip.ZipEntry;\nimport java.util.zip.ZipFile;\nimport java.util.zip.ZipOutputStream;\n\nimport javax.crypto.Cipher;\nimport org.bouncycastle.asn1.ASN1EncodableVector;\nimport org.bouncycastle.asn1.ASN1Integer;\nimport org.bouncycastle.asn1.ASN1ObjectIdentifier;\nimport org.bouncycastle.asn1.ASN1Sequence;\nimport org.bouncycastle.asn1.DERNull;\nimport org.bouncycastle.asn1.DEROctetString;\nimport org.bouncycastle.asn1.DERSequence;\nimport org.bouncycastle.asn1.pkcs.PKCSObjectIdentifiers;\n\npublic class Main {\n\n    public final static int BUFFER_SIZE = 117;\n\n    public static void decrypt(String originalZipFileName, String newZipFileName, String privateKeyFileName) throws Exception {\n        byte[] buffer = new byte[128];  \n\n        ZipFile originalZipFile = new ZipFile(originalZipFileName); \n        ZipOutputStream newZipFile = new ZipOutputStream(new FileOutputStream(newZipFileName));\n\n        Enumeration<? extends ZipEntry> zipEntries = originalZipFile.entries();\n\n        String privateKey = getKeyString(privateKeyFileName);\n        PrivateKey key = makePrivateKey(privateKey);\n\n        Cipher cipher = Cipher.getInstance(\"RSA\");\n\n        cipher.init(Cipher.DECRYPT_MODE, key);\n\n\n        while(zipEntries.hasMoreElements()){\n\n            ZipEntry entry = zipEntries.nextElement();          \n\n            ZipEntry copy = new ZipEntry(entry.getName());      \n            newZipFile.putNextEntry(copy);          \n\n            InputStream inputEntry = originalZipFile.getInputStream(entry);         \n\n            while(inputEntry.read(buffer) != -1){   \n                newZipFile.write(cipher.doFinal(buffer));\n            }\n\n            newZipFile.closeEntry();\n            inputEntry.close();\n        }\n        newZipFile.close();\n        originalZipFile.close();\n    }\n\n    public static void encrypt(String originalZipFileName, String newZipFileName, String publicKeyFileName) throws Exception{\n\n        byte[] buffer = new byte[BUFFER_SIZE];  \n\n        ZipFile originalZipFile = new ZipFile(originalZipFileName); \n        ZipOutputStream newZipFile = new ZipOutputStream(new FileOutputStream(newZipFileName));\n\n        Enumeration<? extends ZipEntry> zipEntries = originalZipFile.entries();\n\n        String publicKey = getKeyString(publicKeyFileName);\n        PublicKey key = makePublicKey(publicKey);\n\n        Cipher cipher = Cipher.getInstance(\"RSA\");\n\n        cipher.init(Cipher.ENCRYPT_MODE, key);\n\n\n        while(zipEntries.hasMoreElements()){\n\n            ZipEntry entry = zipEntries.nextElement();          \n\n            ZipEntry copy = new ZipEntry(entry.getName());      \n            newZipFile.putNextEntry(copy);          \n\n            InputStream inputEntry = originalZipFile.getInputStream(entry);         \n\n            while(inputEntry.read(buffer) != -1){               \n                newZipFile.write(cipher.doFinal(buffer));\n            }\n\n            newZipFile.closeEntry();\n            inputEntry.close();\n        }\n        newZipFile.close();\n        originalZipFile.close();\n    }   \n\n    public static String getKeyString(String fileName){\n\n        String key = new String();\n        try {\n            BufferedReader buf = new BufferedReader(new FileReader(fileName));\n            key = buf.readLine();       \n        } catch ( IOException e) {\n            e.printStackTrace();\n        }   \n\n        return key.trim();\n    }\n\n    public static PublicKey makePublicKey(String stored) throws GeneralSecurityException {\n        byte[] data = Base64.getDecoder().decode(stored);\n        X509EncodedKeySpec spec = new  X509EncodedKeySpec(data);\n        KeyFactory fact = KeyFactory.getInstance(\"RSA\");\n        return fact.generatePublic(spec);\n    }\n\n    public static PrivateKey makePrivateKey(String stored) throws GeneralSecurityException, Exception {\n        /*byte[] data = Base64.getDecoder().decode(stored);\n        PKCS8EncodedKeySpec spec = new  PKCS8EncodedKeySpec(data);\n        KeyFactory fact = KeyFactory.getInstance(\"RSA\");\n        return fact.generatePrivate(spec);*/\n\n        byte[] data = Base64.getDecoder().decode(stored);\n\n        ASN1EncodableVector v = new ASN1EncodableVector();\n        v.add(new ASN1Integer(0));\n        ASN1EncodableVector v2 = new ASN1EncodableVector();\n        v2.add(new ASN1ObjectIdentifier(PKCSObjectIdentifiers.rsaEncryption.getId()));\n        v2.add(DERNull.INSTANCE);\n        v.add(new DERSequence(v2));\n        v.add(new DEROctetString(data));\n        ASN1Sequence seq = new DERSequence(v);\n        byte[] privKey = seq.getEncoded(\"DER\");\n\n        PKCS8EncodedKeySpec spec = new  PKCS8EncodedKeySpec(privKey);\n        KeyFactory fact = KeyFactory.getInstance(\"RSA\");\n        PrivateKey key = fact.generatePrivate(spec);\n\n        return key; \n\n    }\n\n    public static void main(String[] args) throws Exception {\n\n        Scanner scan = new Scanner(System.in);\n\n        System.out.println(\"Enter type of operation:\");\n        String line = scan.nextLine();\n\n        if(line.equals(\"encrypt\")){\n            System.out.println(\"Enter name of original ZIP file:\");\n            String originalZipFileName = scan.nextLine();\n\n            System.out.println(\"Enter name of new ZIP file:\");\n            String newZipFileName = scan.nextLine();\n\n            System.out.println(\"Enter name of file containg public key:\");\n            String publicKeyFileName = scan.nextLine();\n\n            encrypt(originalZipFileName, newZipFileName, publicKeyFileName);        \n        }\n\n        if(line.equals(\"decrypt\")){\n            System.out.println(\"Enter name of original ZIP file:\");\n            String originalZipFileName = scan.nextLine();\n\n            System.out.println(\"Enter name of new ZIP file:\");\n            String newZipFileName = scan.nextLine();\n\n            System.out.println(\"Enter name of file containg private key:\");\n            String privateKeyFileName = scan.nextLine();\n\n            decrypt(originalZipFileName, newZipFileName, privateKeyFileName);       \n        }       \n\n    }\n\n}\n", "idx": 2056}
{"project": "cipher", "commit_id": "Snippet40778975_22663.java", "target": 1, "func": "private static String TRANSFORMATION = \"AES/CBC/PKCS5Padding\";\n\nprivate static String ALGORITHM = \"AES\";\nprivate static String DIGEST = \"MD5\";\n\nprivate static Cipher cipher;\nprivate static SecretKey password;\nprivate static IvParameterSpec IVParamSpec;\nprivate final static String pvtkey=\"GDNBCGDRFSC$%#%=\";\n\n//16-byte private key\nprivate static byte[] IV = pvtkey.getBytes();\n\npublic PassWordEncryptor() {\n    try {\n\n        //Encode digest\n        MessageDigest digest;           \n        digest = MessageDigest.getInstance(DIGEST);            \n        password = new SecretKeySpec(digest.digest(pvtkey.getBytes()), ALGORITHM);\n\n        //Initialize objects\n        cipher = Cipher.getInstance(TRANSFORMATION);\n        IVParamSpec = new IvParameterSpec(IV);\n\n    } catch (NoSuchAlgorithmException e) {\n        Log.i(Lams4gApp.TAG, \"No such algorithm \" + ALGORITHM);\n    } catch (NoSuchPaddingException e) {\n        System.out.println( \"No such padding PKCS7\"+ e);\n    }\n}\n/**\nEncryptor.\n\n@text String to be encrypted\n@return Base64 encrypted text\n\n*/\npublic String encrypt(byte[] text) {\n\n    byte[] encryptedData;\n\n    try {\n\n        cipher.init(Cipher.ENCRYPT_MODE, password, IVParamSpec);\n        encryptedData = cipher.doFinal(text);\n\n    } catch (InvalidKeyException e) {\n        System.out.println( \"Invalid key  (invalid encoding, wrong length, uninitialized, etc).\"+ e);\n        return null;\n    } catch (InvalidAlgorithmParameterException e) {\n        System.out.println( \"Invalid or inappropriate algorithm parameters for \" + ALGORITHM+ e);\n        return null;\n    } catch (IllegalBlockSizeException e) {\n        System.out.println( \"The length of data provided to a block cipher is incorrect\"+ e);\n        return null;\n    } catch (BadPaddingException e) {\n        System.out.println( \"The input data but the data is not padded properly.\"+ e);\n        return null;\n    }               \n    return Base64.encodeToString(encryptedData,Base64.DEFAULT);\n\n}\n", "idx": 2319}
{"project": "cipher", "commit_id": "Snippet22783294_5165.java", "target": 1, "func": "public class TestServer {\n\npublic static void main(String[] args) throws Exception{\n    //set variables for port number, RSA key size\n    final int port = 3344;\n    final int RSAKeySize = 1024;\n    final String newline = \"\\n\";\n    //set public key, sockets, server text, plain text\n    PublicKey pubKey = null;\n    PrivateKey priKey = null;\n    ServerSocket server = null;\n    Socket client = null;\n    String serverText = \"Hello Client! This is an authentication message from server\";\n    byte[] plainText = serverText.getBytes(\"UTF8\");\n    //initialize RSA\n    try {\n        System.out.println(\"Start generating RSA key\");\n        KeyPairGenerator RSAKeyGen = KeyPairGenerator.getInstance(\"RSA\");\n        SecureRandom random = new SecureRandom();\n        RSAKeyGen.initialize(RSAKeySize,random);\n        KeyPair pair = RSAKeyGen.generateKeyPair();\n        System.out.println(\"Finish generating RSA key\");\n        pubKey = pair.getPublic();\n        priKey = pair.getPrivate();\n    }catch (GeneralSecurityException e){\n        System.out.println(e.getLocalizedMessage() + newline);\n        System.out.println(\"Error initialising encryption. Exiting.\\n\");\n        System.exit(0);\n    }\n    //initialize cryptography, set cipherText\n    Cipher cipher = Cipher.getInstance(\"RSA/ECB/PKCS1Padding\");\n    System.out.println(\"RSA cipher object and provider\"+cipher.getProvider().getInfo());\n    System.out.println(\"Start Encryption for plainText\");\n    cipher.init(Cipher.ENCRYPT_MODE, pubKey);\n    byte[] cipherText = cipher.doFinal(plainText);\n    System.out.println(\"Finish Encryption to cipherText: \");\n    BASE64Encoder base64 = new BASE64Encoder();\n    String encryptedValue = base64.encode(cipherText);\n    //String encryptedValue = new sun.misc.BASE64Encoder().encode(cipherText);\n    System.out.println(new String(cipherText,\"UTF8\"));\n    System.out.println(\"Base64\");\n    System.out.println(encryptedValue);\n    //initialize socket connection\n    try{\n        server = new ServerSocket(port);\n        client = server.accept();\n    }catch(IOException e){\n        System.out.println(\"Error initialising I/O.\\n\");\n        System.exit(0);\n    }\n    //send server private key\n    try{\n        System.out.println(\"Send private key out\");\n        System.out.println(DatatypeConverter.printHexBinary(priKey.getEncoded()));\n        ByteBuffer bb = ByteBuffer.allocate(4);\n        bb.putInt(priKey.getEncoded().length);\n        client.getOutputStream().write(bb.array());\n        client.getOutputStream().write(pubKey.getEncoded());\n        client.getOutputStream().flush();\n    }catch (IOException e){\n        System.out.println(\"I/O Error\");\n        System.exit(0);\n    }\n    //send cipherText\n    ObjectOutputStream obOut = new ObjectOutputStream(client.getOutputStream());\n    obOut.writeObject(encryptedValue);\n    obOut.flush();\n    client.close();\n}\n", "idx": 2094}
{"project": "cipher", "commit_id": "Snippet6020648_31878.java", "target": 0, "func": "Security.addProvider(new BouncyCastleProvider());\nSecretKeySpec keySpec = new SecretKeySpec(KEY.getBytes(), \"DESede\");\nIvParameterSpec iv = new IvParameterSpec(new byte[8]);\nCipher e_cipher = Cipher.getInstance(\"DESede/CBC/PKCS7Padding\", \"BC\");\ne_cipher.init(Cipher.DECRYPT_MODE, keySpec, iv);\n\nbyte[] hexdecoded = Hex.decode(ENCRYPTED.getBytes());\nbyte [] cipherText = e_cipher.doFinal(hexdecoded);\n\nreturn new String(cipherText);\n", "idx": 1848}
{"project": "cipher", "commit_id": "Snippet13729316_37225.java", "target": 1, "func": " Cipher rsa = Cipher.getInstance(\"RSA\");\n\n rsa.init(Cipher.ENCRYPT_MODE, (RSAPublicKey) obj);\n", "idx": 1964}
{"project": "cipher", "commit_id": "Snippet18231149_1242.java", "target": 1, "func": "    if (plainText == null || plainText.length() == 0)\n        return \"\";\n\n    // convert key to bytes\n    byte[] keyBytes = password.getBytes(\"UTF-8\");\n    // Use the first 16 bytes (or even less if key is shorter)\n\n    byte[] keyBytes16 = new byte[16];\n\n    System.arraycopy(keyBytes, 0, keyBytes16, 0,\n            Math.min(keyBytes.length, 16));\n\n    // convert plain text to bytes\n    byte[] plainBytes = plainText.getBytes(\"UTF-8\");\n\n    // setup cipher\n    SecretKeySpec skeySpec = new SecretKeySpec(keyBytes16, \"AES\");\n    Cipher cipher = Cipher.getInstance(\"AES/CBC/PKCS5Padding\");\n    byte[] iv = new byte[16]; // initialization vector with all 0\n    cipher.init(Cipher.ENCRYPT_MODE, skeySpec, new IvParameterSpec(iv));\n\n    // encrypt\n    byte[] encrypted = cipher.doFinal(plainBytes);\n    String encryptedString = Base64.encodeToString(\n            cipher.doFinal(plainBytes), Base64.NO_WRAP);\n    // encryptedString\n\n    return Base64.encodeToString(encrypted, Base64.NO_WRAP);\n}\n", "idx": 2036}
{"project": "cipher", "commit_id": "Snippet47515834_29518.java", "target": 1, "func": "public class SSNDecrypt {\n\n\n    public static String decrypt(String ssnString, byte[] keyBytes) throws NoSuchAlgorithmException, NoSuchPaddingException, InvalidKeyException, InvalidAlgorithmParameterException, UnsupportedEncodingException, IllegalBlockSizeException, BadPaddingException {\n        Cipher AesCipher = Cipher.getInstance(\"AES/CBC/PKCS5Padding\");\n\n        // byte[] keyBytes = SSNDecrypt.convertHexToBinary(keyString);\n\n          SecretKeySpec spec = new SecretKeySpec(keyBytes, \"AES\");\n// TODO FIND OUT HOW TO ACCESS KEY FROM TEXT FILE\n\n        byte[] iv = SSNDecrypt.convertHexToBinary(SSNDecrypt.getIV(ssnString));\n        byte[] ssn = SSNDecrypt.convertHexToBinary(SSNDecrypt.getSSN(ssnString));\n\n\n\n        AesCipher.init(Cipher.DECRYPT_MODE, spec, new IvParameterSpec(iv));\n        return new String(AesCipher.doFinal(ssn), \"UTF-8\");\n    }\n\n    private   static byte[] convertHexToBinary(String hexString) {\n\n        return DatatypeConverter.parseHexBinary(hexString);\n\n//      int charCount = hexString.length();\n//      byte[] out = new byte[charCount / 2];\n//      for(int i = 0; i < charCount; i+= 2) {\n//          out[i/2] = hexString.substring(i,  i + 1).get\n//      }\n    }\n\n\n    private  static String getSSN(String cryptString) {\n        int delimiterIndex = cryptString.indexOf(\":\");\n        return cryptString.substring(0, delimiterIndex );\n\n    }\n\n\n\n    private static  String getIV(String cryptString) {\n        int delimiterIndex = cryptString.indexOf(\":\");\n        return cryptString.substring(delimiterIndex + 1 );\n    }\n}\n", "idx": 2155}
{"project": "cipher", "commit_id": "Snippet38814051_20731.java", "target": 0, "func": "private static final String seed = \"This is my secret\";\n\npublic static String encrypt(String cleartext) {\n   try {\n       byte[] rawKey = getRawKey(seed.getBytes());\n       byte[] result = encrypt(rawKey, cleartext.getBytes());\n       return toHex(result);\n   }catch(Exception e){\n       e.printStackTrace();\n   }\n    return null;\n}\n\npublic static String decrypt(String encrypted){\n   try {\n       byte[] rawKey = getRawKey(seed.getBytes());\n       byte[] enc = toByte(encrypted);\n       byte[] result = decrypt(rawKey, enc);\n       return new String(result);\n   }catch(Exception e){\n       e.printStackTrace();\n   }\n    return null;\n}\n\nprivate static byte[] getRawKey(byte[] seed) throws Exception {\n    KeyGenerator kgen = KeyGenerator.getInstance(\"AES\");\n    SecureRandom sr = SecureRandom.getInstance(\"SHA1PRNG\");\n    sr.setSeed(seed);\n    kgen.init(128, sr); // 192 and 256 bits may not be available\n    SecretKey skey = kgen.generateKey();\n    byte[] raw = skey.getEncoded();\n    return raw;\n}\n\n\nprivate static byte[] encrypt(byte[] raw, byte[] clear) throws Exception {\n    SecretKeySpec skeySpec = new SecretKeySpec(raw, \"AES\");\n    Cipher cipher = Cipher.getInstance(\"AES\");\n    cipher.init(Cipher.ENCRYPT_MODE, skeySpec);\n    byte[] encrypted = cipher.doFinal(clear);\n    return encrypted;\n}\n\nprivate static byte[] decrypt(byte[] raw, byte[] encrypted) throws Exception {\n    SecretKeySpec skeySpec = new SecretKeySpec(raw, \"AES\");\n    Cipher cipher = Cipher.getInstance(\"AES\");\n    cipher.init(Cipher.DECRYPT_MODE, skeySpec);\n    byte[] decrypted = cipher.doFinal(encrypted);\n    return decrypted;\n}\n\npublic static String toHex(String txt) {\n    return toHex(txt.getBytes());\n}\npublic static String fromHex(String hex) {\n    return new String(toByte(hex));\n}\n\npublic static byte[] toByte(String hexString) {\n    int len = hexString.length()/2;\n    byte[] result = new byte[len];\n    for (int i = 0; i < len; i++)\n        result[i] = Integer.valueOf(hexString.substring(2*i, 2*i+2), 16).byteValue();\n    return result;\n}\n\npublic static String toHex(byte[] buf) {\n    if (buf == null)\n        return \"\";\n    StringBuffer result = new StringBuffer(2*buf.length);\n    for (int i = 0; i < buf.length; i++) {\n        appendHex(result, buf[i]);\n    }\n    return result.toString();\n}\n\nprivate final static String HEX = \"0123456789ABCDEF\";\nprivate static void appendHex(StringBuffer sb, byte b) {\n    sb.append(HEX.charAt((b>>4)&0x0f)).append(HEX.charAt(b&0x0f));\n}\n", "idx": 1814}
{"project": "cipher", "commit_id": "Snippet34643645_16614.java", "target": 1, "func": "Cipher cipher = Cipher.getInstance(\"AES/CBC/NoPadding\");\n", "idx": 2006}
{"project": "cipher", "commit_id": "Snippet21125367_3698.java", "target": 1, "func": "import java.security.NoSuchAlgorithmException;\n\nimport javax.crypto.Cipher;\nimport javax.crypto.NoSuchPaddingException;\nimport javax.crypto.spec.IvParameterSpec;\nimport javax.crypto.spec.SecretKeySpec;\n\npublic class MCrypt {\n\n        private String iv = \"fedcba9876543210\";\n        private IvParameterSpec ivspec;\n        private SecretKeySpec keyspec;\n        private Cipher cipher;\n\n        private String SecretKey ;\n\n        public MCrypt(String s)\n        {\n               SecretKey=s;\n                ivspec = new IvParameterSpec(iv.getBytes());\n\n                keyspec = new SecretKeySpec(SecretKey.getBytes(), \"AES\");\n\n                try {\n                        cipher = Cipher.getInstance(\"AES/CBC/NoPadding\");\n                } catch (NoSuchAlgorithmException e) {\n                        // TODO Auto-generated catch block\n                        e.printStackTrace();\n                } catch (NoSuchPaddingException e) {\n                        // TODO Auto-generated catch block\n                        e.printStackTrace();\n                }\n        }\n\n        public byte[] encrypt(String text) throws Exception\n        {\n                if(text == null || text.length() == 0)\n                        throw new Exception(\"Empty string\");\n\n                byte[] encrypted = null;\n\n                try {\n                        cipher.init(Cipher.ENCRYPT_MODE, keyspec, ivspec);\n\n                        encrypted = cipher.doFinal(padString(text).getBytes());\n                } catch (Exception e)\n                {                       \n                        throw new Exception(\"[encrypt] \" + e.getMessage());\n                }\n\n                return encrypted;\n        }\n\n        public byte[] decrypt(String code) throws Exception\n        {\n                if(code == null || code.length() == 0)\n                        throw new Exception(\"Empty string\");\n\n                byte[] decrypted = null;\n\n                try {\n                        cipher.init(Cipher.DECRYPT_MODE, keyspec, ivspec);\n\n                        decrypted = cipher.doFinal(hexToBytes(code));\n                } catch (Exception e)\n                {\n                        throw new Exception(\"[decrypt] \" + e.getMessage());\n                }\n                return decrypted;\n        }\n\n\n\n        public static String bytesToHex(byte[] data)\n        {\n                if (data==null)\n                {\n                        return null;\n                }\n\n                int len = data.length;\n                String str = \"\";\n                for (int i=0; i<len; i++) {\n                        if ((data[i]&0xFF)<16)\n                                str = str + \"0\" + java.lang.Integer.toHexString(data[i]&0xFF);\n                        else\n                                str = str + java.lang.Integer.toHexString(data[i]&0xFF);\n                }\n                return str;\n        }\n\n\n        public static byte[] hexToBytes(String str) {\n                if (str==null) {\n                        return null;\n                } else if (str.length() < 2) {\n                        return null;\n                } else {\n                        int len = str.length() / 2;\n                        byte[] buffer = new byte[len];\n                        for (int i=0; i<len; i++) {\n                                buffer[i] = (byte) Integer.parseInt(str.substring(i*2,i*2+2),16);\n                        }\n                        return buffer;\n                }\n        }\n\n\n\n        private static String padString(String source)\n        {\n          char paddingChar = ' ';\n          int size = 16;\n          int x = source.length() % size;\n          int padLength = size - x;\n\n          for (int i = 0; i < padLength; i++)\n          {\n                  source += paddingChar;\n          }\n\n          return source;\n        }\n}\n", "idx": 2201}
{"project": "cipher", "commit_id": "Snippet34514103_16513.java", "target": 1, "func": "package Firstage;\n\nimport java.io.File;\nimport java.io.FileInputStream;\nimport java.io.FileOutputStream;\nimport java.security.SecureRandom;\nimport java.security.spec.KeySpec;\nimport java.util.Random;\nimport java.util.Scanner;\n\nimport javax.crypto.Cipher;\nimport javax.crypto.SecretKey;\nimport javax.crypto.SecretKeyFactory;\nimport javax.crypto.spec.IvParameterSpec;\nimport javax.crypto.spec.PBEKeySpec;\nimport javax.crypto.spec.SecretKeySpec;\n\npublic class Thealgorithm1 \n{\n\n    static Scanner get = new Scanner(System.in);\n    private static final String ALGORITHM = \"AES\";\n    private static final String ALGORITHM_MODE =\"AES/CFB/NoPadding\";\n    private static String password;\n\n    public static void encrypt(File inputFile, File outputFile)\n            throws Exception\n    {\n        System.out.println(\"Enetr passprhase\");\n        password=get.nextLine();\n\n        final Random ivspc = new SecureRandom();\n        byte[] ivspec = new byte[16];\n        ivspc.nextBytes(ivspec);\n        IvParameterSpec enciv = new IvParameterSpec(ivspec);\n\n        FileOutputStream outputstrm = new FileOutputStream(outputFile);\n        byte[] outputBytes = doCrypto(Cipher.ENCRYPT_MODE, inputFile,password,enciv);\n        System.arraycopy(ivspec, 0,outputBytes , 0, 16);\n        outputstrm.write(outputBytes);\n        outputstrm.close();\n        System.out.println(\"File encrypted successfully!\");\n    }\n\n    public static void decrypt(File inputFile, File outputFile)\n            throws Exception\n    {\n\n        System.out.println(\"Enter password\");\n        password=get.nextLine();\n        IvParameterSpec hj = null;\n        byte[]outpytBytes=doCrypto(Cipher.DECRYPT_MODE, inputFile,password,hj);\n        FileOutputStream outputstrm = new FileOutputStream(outputFile);\n        outputstrm.write(outpytBytes);\n        outputstrm.close();\n        System.out.println(\"File decrypted successfully!\");\n    }\n\n    private static byte[] doCrypto(int cipherMode, File inputFile,String keyo ,IvParameterSpec ivespec)\n            throws Exception {\n    /* Derive the key, given password and salt. */\n        final Random slt = new SecureRandom();\n        byte[] salt = new byte[8];\n        slt.nextBytes(salt);\n\n\n        char[] passkeyo = keyo.toCharArray();\n        SecretKeyFactory factory = SecretKeyFactory.getInstance(\"PBKDF2WithHmacSHA256\");\n        KeySpec spec = new PBEKeySpec(passkeyo, salt, 65536, 128);\n        SecretKey tmp = factory.generateSecret(spec);\n\n        SecretKey secret = new SecretKeySpec(tmp.getEncoded(), ALGORITHM);\n\n        FileInputStream fylin = new FileInputStream(inputFile);\n        byte[] inputBytes = new byte[(int)inputFile.length()];\n        fylin.read(inputBytes);\n        fylin.close();\n\n        Cipher cipher = Cipher.getInstance(ALGORITHM_MODE);\n\n        byte[] outputBytes;\n        if(cipherMode==2)\n        {\n            IvParameterSpec ivdec = new IvParameterSpec(inputBytes,0,16);\n            cipher.init(cipherMode, secret,ivdec);\n        }\n        else\n        {\n            cipher.init(cipherMode, secret, ivespec);\n        }\n\n\n        if(cipherMode==2)\n        {\n            outputBytes = cipher.doFinal(inputBytes, 16,(inputBytes.length-16));\n        }\n        else\n        {\n            outputBytes=cipher.doFinal(inputBytes);\n        }\n\n\n        return outputBytes;\n\n    }\n\n    public static void main(String[] args)\n    {\n\n        File inputFile = new File(\"C:/temp/File.txt\");\n        File encryptedFile = new File(\"C:/temp/encryaes.enc\");\n        File decryptedFile = new File(\"C:/temp/mydr.txt\");\n\n\n        try {\n\n            Thealgorithm1.encrypt(inputFile, encryptedFile);\n            Thealgorithm1.decrypt(encryptedFile, decryptedFile);\n        }\n        catch (Exception e)\n        {\n            e.printStackTrace();\n        }\n\n    }\n\n}\n", "idx": 2241}
{"project": "cipher", "commit_id": "Snippet8296189_33135.java", "target": 1, "func": "Cipher cipher = Cipher.getInstance(\"AES/CBC/NoPadding\");\nSecretKeySpec keySpec = new SecretKeySpec(\"01234567890abcde\".getBytes(), \"AES\");\nIvParameterSpec ivSpec = new IvParameterSpec(\"fedcba9876543210\".getBytes());\ncipher.init(Cipher.DECRYPT_MODE, keySpec, ivSpec);\nByteArrayInputStream input = new ByteArrayInputStream(mediaCollBuffer); \nCipherInputStream cis = new CipherInputStream(input, cipher);\n", "idx": 2014}
{"project": "cipher", "commit_id": "Snippet31036780_13213.java", "target": 1, "func": "Cipher cipher = Cipher.getInstance(\"AES/CBC/PKCS5Padding\");\nSecretKeySpec keySpec = new SecretKeySpec(keyBytes, \"AES\");\ncipher.init(Cipher.ENCRYPT_MODE, keySpec);\nbyte[] cipherText = cipher.doFinal(plaintext);\nbyte[] iv = cipher.getIV();   //The problematic IV\n", "idx": 1935}
{"project": "cipher", "commit_id": "Snippet47390097_29353.java", "target": 0, "func": "private static String encrypt(String text) throws NoSuchAlgorithmException, NoSuchPaddingException, InvalidKeyException, IllegalBlockSizeException, BadPaddingException, NoSuchProviderException\n{\n    String keyString = AESEncryption.convertToUTF8(\"8DJE7K01U8B51807B3E17D21\");\n    text = AESEncryption.convertToUTF8(text);\n\n    byte[]keyValue = Base64.getEncoder().encode(keyString.getBytes(StandardCharsets.UTF_8));\n    Key key = new SecretKeySpec(keyValue, \"AES\");\n    Cipher c1 = Cipher.getInstance(\"AES/ECB/PKCS5Padding\");\n\n    c1.init(Cipher.ENCRYPT_MODE, key);\n\n    byte[] encodedText =Base64.getEncoder().encode(text.getBytes(StandardCharsets.UTF_8));\n    System.out.println(\"Encoded text: \"+new String(encodedText,StandardCharsets.UTF_8));\n\n    byte[] encVal = c1.doFinal(encodedText);\n    System.out.println(\"Encoded val: \"+new String(encVal,StandardCharsets.UTF_8));\n\n    return new String(encVal);\n}\n", "idx": 1729}
{"project": "cipher", "commit_id": "Snippet13389870_36919.java", "target": 0, "func": "import java.security.SecureRandom;\n\nimport javax.crypto.Cipher;\nimport javax.crypto.KeyGenerator;\nimport javax.crypto.SecretKey;\nimport javax.crypto.spec.SecretKeySpec;\n\nimport android.util.Base64;\n\npublic class EncodeDecodeAES {\n\n    private final static String HEX = \"0123456789ABCDEF\";\n\n    public static String encrypt(String seed, String cleartext) throws Exception {\n        byte[] rawKey = getRawKey(seed.getBytes());\n        byte[] result = encrypt(rawKey, cleartext.getBytes());\n        String fromHex = toHex(result);\n        String base64 = new String(Base64.encodeToString(fromHex.getBytes(), 0));\n        return base64;\n    }\n\n\n    public static String decrypt(String seed, String encrypted) throws Exception {\n        String base64 = new String(Base64.decode(encrypted, 0));\n        byte[] rawKey = getRawKey(seed.getBytes());\n        byte[] enc = toByte(base64);\n        byte[] result = decrypt(rawKey, enc);\n        return new String(result);\n    }\n\n\n    public static byte[] encryptBytes(String seed, byte[] cleartext) throws Exception {\n        byte[] rawKey = getRawKey(seed.getBytes());\n        byte[] result = encrypt(rawKey, cleartext);\n        return result;\n    }\n\n\n    public static byte[] decryptBytes(String seed, byte[] encrypted) throws Exception {\n        byte[] rawKey = getRawKey(seed.getBytes());\n        byte[] result = decrypt(rawKey, encrypted);\n        return result;\n    }\n\n\n\n    private static byte[] getRawKey(byte[] seed) throws Exception {\n        KeyGenerator kgen = KeyGenerator.getInstance(\"AES\");\n        SecureRandom sr = SecureRandom.getInstance(\"SHA1PRNG\");\n        sr.setSeed(seed);\n        try {\n            kgen.init(256, sr);\n        } catch (Exception e) {\n    //      Log.w(LOG, \"This device doesn't suppor 256bits, trying 192bits.\");\n            try {\n                kgen.init(192, sr);\n            } catch (Exception e1) {\n    //          Log.w(LOG, \"This device doesn't suppor 192bits, trying 128bits.\");\n                kgen.init(128, sr);\n            }\n        }\n        SecretKey skey = kgen.generateKey();\n        byte[] raw = skey.getEncoded();\n        return raw;\n    }\n\n\n    private static byte[] encrypt(byte[] raw, byte[] clear) throws Exception {\n        SecretKeySpec skeySpec = new SecretKeySpec(raw, \"AES\");\n        Cipher cipher = Cipher.getInstance(\"AES\");\n        cipher.init(Cipher.ENCRYPT_MODE, skeySpec);\n        byte[] encrypted = cipher.doFinal(clear);\n        return encrypted;\n    }\n\n\n    private static byte[] decrypt(byte[] raw, byte[] encrypted) throws Exception {\n        SecretKeySpec skeySpec = new SecretKeySpec(raw, \"AES\");\n        Cipher cipher = Cipher.getInstance(\"AES\");\n        cipher.init(Cipher.DECRYPT_MODE, skeySpec);\n        byte[] decrypted = cipher.doFinal(encrypted);\n        return decrypted;\n    }\n\n\n    public static String toHex(String txt) {\n        return toHex(txt.getBytes());\n    }\n\n\n    public static String fromHex(String hex) {\n        return new String(toByte(hex));\n    }\n\n\n    public static byte[] toByte(String hexString) {\n        int len = hexString.length() / 2;\n        byte[] result = new byte[len];\n        for (int i = 0; i < len; i++)\n            result[i] = Integer.valueOf(hexString.substring(2 * i, 2 * i + 2), 16).byteValue();\n        return result;\n    }\n\n\n    public static String toHex(byte[] buf) {\n        if (buf == null)\n            return \"\";\n        StringBuffer result = new StringBuffer(2 * buf.length);\n        for (int i = 0; i < buf.length; i++) {\n            appendHex(result, buf[i]);\n        }\n        return result.toString();\n    }\n\n\n    private static void appendHex(StringBuffer sb, byte b) {\n        sb.append(HEX.charAt((b >> 4) & 0x0f)).append(HEX.charAt(b & 0x0f));\n    }\n\n}\n", "idx": 1754}
{"project": "cipher", "commit_id": "Snippet17798503_915.java", "target": 0, "func": "public static final byte[] ige(final byte[] key, final byte[] IV,\n        final byte[] Message) throws Exception {\n\n    final Cipher cipher = Cipher.getInstance(\"AES/ECB/NoPadding\");\n    cipher.init(Cipher.DECRYPT_MODE, new SecretKeySpec(key, \"AES\"));\n\n    final int blocksize = cipher.getBlockSize();\n\n    byte[] xPrev = Arrays.copyOfRange(IV, 0, blocksize);\n    byte[] yPrev = Arrays.copyOfRange(IV, blocksize, IV.length);\n\n    byte[] decrypted = new byte[0];\n\n    byte[] y, x;\n    for (int i = 0; i < Message.length; i += blocksize) {\n        x = java.util.Arrays.copyOfRange(Message, i, i + blocksize);\n        y = xor(cipher.doFinal(xor(x, yPrev)), xPrev);\n        xPrev = x;\n        yPrev = y;\n\n        decrypted = sumBytes(decrypted, y);\n    }\n\n    return decrypted;\n}\n", "idx": 1708}
{"project": "cipher", "commit_id": "Snippet2212400_30254.java", "target": 1, "func": "package com.neocodenetworks.smsfwd;\n\nimport java.security.*;\nimport javax.crypto.*;\nimport javax.crypto.spec.*;\nimport android.util.Log;\n\npublic class Crypto {\n    public static final String TAG = \"smsfwd\";\n\n    private static Cipher aesCipher;\n    private static SecretKey secretKey;\n    private static IvParameterSpec ivParameterSpec;\n\n    private static String CIPHER_TRANSFORMATION = \"AES/CBC/PKCS5Padding\";\n    private static String CIPHER_ALGORITHM = \"AES\";\n    // Replace me with a 16-byte key, share between Java and C#\n    private static byte[] rawSecretKey = {0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,\n                                          0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00};\n\n    private static String MESSAGEDIGEST_ALGORITHM = \"MD5\";\n\n    public Crypto(String passphrase) {\n        byte[] passwordKey = encodeDigest(passphrase);\n\n        try {\n            aesCipher = Cipher.getInstance(CIPHER_TRANSFORMATION);\n        } catch (NoSuchAlgorithmException e) {\n            Log.e(TAG, \"No such algorithm \" + CIPHER_ALGORITHM, e);\n        } catch (NoSuchPaddingException e) {\n            Log.e(TAG, \"No such padding PKCS5\", e);\n        }\n\n        secretKey = new SecretKeySpec(passwordKey, CIPHER_ALGORITHM);\n        ivParameterSpec = new IvParameterSpec(rawSecretKey);\n    }\n\n    public String encryptAsBase64(byte[] clearData) {\n        byte[] encryptedData = encrypt(clearData);\n        return net.iharder.base64.Base64.encodeBytes(encryptedData);\n    }\n\n    public byte[] encrypt(byte[] clearData) {\n        try {\n            aesCipher.init(Cipher.ENCRYPT_MODE, secretKey, ivParameterSpec);\n        } catch (InvalidKeyException e) {\n            Log.e(TAG, \"Invalid key\", e);\n            return null;\n        } catch (InvalidAlgorithmParameterException e) {\n            Log.e(TAG, \"Invalid algorithm \" + CIPHER_ALGORITHM, e);\n            return null;\n        }\n\n        byte[] encryptedData;\n        try {\n            encryptedData = aesCipher.doFinal(clearData);\n        } catch (IllegalBlockSizeException e) {\n            Log.e(TAG, \"Illegal block size\", e);\n            return null;\n        } catch (BadPaddingException e) {\n            Log.e(TAG, \"Bad padding\", e);\n            return null;\n        }\n        return encryptedData;\n    }\n\n    private byte[] encodeDigest(String text) {\n        MessageDigest digest;\n        try {\n            digest = MessageDigest.getInstance(MESSAGEDIGEST_ALGORITHM);\n            return digest.digest(text.getBytes());\n        } catch (NoSuchAlgorithmException e) {\n            Log.e(TAG, \"No such algorithm \" + MESSAGEDIGEST_ALGORITHM, e);\n        }\n\n        return null;\n    }\n}\n", "idx": 2345}
{"project": "cipher", "commit_id": "Snippet20983874_3579.java", "target": 1, "func": "            String key1 = \"1234567812345678\";\n        byte[] key2 = key1.getBytes();\n\n\n        SecretKeySpec secret = new SecretKeySpec(key2, \"AES\");\n        Cipher cipher = Cipher.getInstance(\"AES/CBC/PKCS5Padding\");\n\n        cipher.init(Cipher.ENCRYPT_MODE, secret);\n\n        byte[] encrypted = cipher.doFinal(msg.getBytes(StandardCharsets.UTF_8));\n        byte[] iv = cipher.getIV();\n\n        String text = DatatypeConverter.printBase64Binary(encrypted);\n\n        System.out.println(\"Encrypted info: \" + text);\n\n        bytebuf = ByteBuffer.allocate(1024);\n        bytebuf.clear();\n\n        // send iv\n\n        bytebuf.put(iv);\n        bytebuf.flip();\n        while(bytebuf.hasRemaining()) {\n            nBytes += client.write(bytebuf);\n            System.out.println(\"Iv sent!\");\n        }\n\n        bytebuf.clear();\n        bytebuf.put(text.getBytes());\n\n        bytebuf.flip();\n\n        while(bytebuf.hasRemaining()) {\n            nBytes += client.write(bytebuf);\n        }\n", "idx": 2322}
{"project": "cipher", "commit_id": "Snippet37076126_19003.java", "target": 1, "func": "static String AESEncryptStringWithPassword(String s, String p) throws...{\n    //function to create key from string password\n    SecretKey secret = deriveAESKey(p);\n    Cipher cipher = Cipher.getInstance(\"AES/CBC/PKCS5Padding\");\n    cipher.init(Cipher.ENCRYPT_MODE, secret);\n    AlgorithmParameters params = cipher.getParameters();\n    iv = params.getParameterSpec(IvParameterSpec.class).getIV();\n    byte[] ciphertext = cipher.doFinal(s.getBytes(Charset.forName(\"UTF-8\")));\n    String str = Base64.getEncoder().encodeToString(ciphertext);\n    return str;\n\n}\n", "idx": 1947}
{"project": "cipher", "commit_id": "Snippet20902854_3402.java", "target": 0, "func": "     String input = \"5H5h8acnv2gzv2PeTVb+pw==\";\n     String key = \"thisismykey___2011_1234567898765\";\n        byte[] output = null;\n        try{\n\n            SecretKeySpec skey = new SecretKeySpec(key.getBytes(), \"AES\");\n            Cipher cipher = Cipher.getInstance(\"AES/ECB/PKCS5Padding\");\n            cipher.init(Cipher.DECRYPT_MODE, skey);\n            output = cipher.doFinal(Base64.decode(input, Base64.DEFAULT));\n            Log.i(\"word is: \", new String(output));\n        }catch(Exception e){\n\n            Log.d(\"myapp\", \"Error decrypting data\", e);  // This is the line\n        }\n", "idx": 1656}
{"project": "cipher", "commit_id": "Snippet2027694_30193.java", "target": 1, "func": "KeyPair keys = KeyPairGenerator.getInstance(\"RSA\").generateKeyPair();\nCipher cipher = Cipher.getInstance(\"RSA\");\ncipher.init(Cipher.ENCRYPT_MODE, keys.getPublic());\nbyte[] encrypted = cipher.doFinal(rawData);\n", "idx": 2239}
{"project": "cipher", "commit_id": "Snippet2579103_30348.java", "target": 1, "func": "Cipher.getInstance(\"RSA\", \"BC\")", "idx": 2254}
{"project": "cipher", "commit_id": "Snippet42155037_23993.java", "target": 0, "func": "public static String decrypt(String strEncrypted,String strKey) throws Exception{\n    String strData=\"\";\n\n    try {\n        SecretKeySpec skeyspec=new SecretKeySpec(strKey.getBytes(),\"Blowfish\");\n        Cipher cipher=Cipher.getInstance(\"Blowfish\");\n        cipher.init(Cipher.DECRYPT_MODE, skeyspec);\n        byte[] decrypted=cipher.doFinal(strEncrypted.getBytes());\n        strData=new String(decrypted);\n\n    } catch (Exception e) {\n        e.printStackTrace();\n        throw new Exception(e);\n    }\n    return strData;\n}\n", "idx": 1883}
{"project": "cipher", "commit_id": "Snippet26828649_8981.java", "target": 0, "func": "import java.security.KeyPair;\nimport java.security.PrivateKey;\nimport java.security.PublicKey;\n\nimport javax.crypto.Cipher;\nimport javax.crypto.SecretKey;\n\npublic class DHTest {\n\n    public static void main(String[] args) {\n        //Generates keyPairs for Alice and Bob\n        KeyPair kp1 = DiffieHellmanModule.genDHKeyPair();\n        KeyPair kp2 = DiffieHellmanModule.genDHKeyPair();\n        //Gets the public key of Alice(g^X mod p) and Bob (g^Y mod p)\n        PublicKey pbk1 = kp1.getPublic();\n        PublicKey pbk2 = kp2.getPublic();\n        //Gets the private key of Alice X and Bob Y\n        PrivateKey prk1 = kp1.getPrivate();\n        PrivateKey prk2 = kp2.getPrivate();\n        try {\n            //Computes secret keys for Alice (g^Y mod p)^X mod p == Bob (g^X mod p)^Y mod p\n            SecretKey key1 = DiffieHellmanModule.agreeSecretKey(prk1, pbk2, true);\n            SecretKey key2 = DiffieHellmanModule.agreeSecretKey(prk2, pbk1, true);\n            //Instantiate the Cipher of algorithm \"DES\"\n            Cipher c = Cipher.getInstance(\"DES/ECB/PKCS5Padding\");\n            //Init the cipher with Alice's key1\n            c.init(Cipher.ENCRYPT_MODE, key1);\n            //Compute the cipher text = E(key,plainText)\n            byte[] ciphertext = c.doFinal(\"Stand and unfold yourself\".getBytes());\n            //prints ciphertext\n            System.out.println(\"Encrypted: \" + new String(ciphertext,\"utf-8\"));\n            //inits the encryptionMode\n            c.init(Cipher.DECRYPT_MODE, key2);\n            //Decrypts and print\n            System.out.println(\"Decrypted: \" + new String(c.doFinal(ciphertext), \"utf-8\"));\n            System.out.println(\"Done\");\n        } catch (Exception e) {\n            e.printStackTrace();\n        }\n    }\n\n}\n", "idx": 1606}
{"project": "cipher", "commit_id": "Snippet30860101_13009.java", "target": 0, "func": "String objVal=<the json>;\nSecretKeySpec lKeySpec = new SecretKeySpec(lKey.getBytes(\"UTF8\"),\"Blowfish\");\nCipher lCipher = Cipher.getInstance(\"Blowfish/ECB/PKCS5Padding\");\nlCipher.init(Cipher.ENCRYPT_MODE, lKeySpec);\nbyte[] lPassword = objVal.getBytes(\"UTF8\");\nbyte[] lEncryptPassword = lCipher.doFinal(lPassword);\nString lEncryptString = new BASE64Encoder().encode(lEncryptPassword);\nStringBuffer nString = new StringBuffer();\nfor (int i = 0; i < lEncryptString.length(); i++) {\nint a = lEncryptString.charAt(i);\nif (a != 13 && a != 10 && !lEncryptString.substring(i, i + 1).equals(\" \")){\nnString.append(lEncryptString.charAt(i));\n}\nreturn nString.toString();\n", "idx": 1618}
{"project": "cipher", "commit_id": "Snippet41248700_23210.java", "target": 0, "func": "// function in Java that I need\n// javax.crypto.Cipher.getInstance(\"Blowfish/CBC/NoPadding\").doFinal(\"spamshog\")\n\n\nvar iv_vector = \"2278dc9wf_178703\";\nvar txtToEncrypt = \"spamshog\";\nvar bf = new Blowfish(\"spamshog\", \"cbc\");\n\nvar encrypted = bf.encrypt(txtToEncrypt, iv_vector);\n\nconsole.log(bf.base64Encode(encrypted));\n\nActual output: /z9/n0FzBJQ=\n What I need: /z9/n0FzBJRGS6nPXso5TQ==\n", "idx": 1817}
{"project": "cipher", "commit_id": "Snippet27385370_9571.java", "target": 0, "func": "import java.security.InvalidKeyException;\nimport java.security.NoSuchAlgorithmException;\n\nimport java.util.Scanner;\n\nimport javax.crypto.BadPaddingException;\nimport javax.crypto.Cipher;\nimport javax.crypto.IllegalBlockSizeException;\nimport javax.crypto.KeyGenerator;\nimport javax.crypto.NoSuchPaddingException;\nimport javax.crypto.SecretKey;\nimport javax.crypto.spec.SecretKeySpec;\n\npublic class Encrypt1\n{    \npublic static void main(String[] argv) {\n\n    try{\n\n        //KeyGenerator keygenerator = KeyGenerator.getInstance(\"AES\");\n\n        //SecretKey myAesKey = keygenerator.generateKey(key);\n\n        Scanner input = new Scanner(System.in);\n\n        System.out.println(\"Please enter a message you'd like to encrypt\");\n        String plaintext = input.nextLine();\n\n        System.out.println(\"Please enter a 16 digit password: \");\n        String pass = input.nextLine();\n\n        byte[] key = pass.getBytes();\n        SecretKeySpec aesKey = new SecretKeySpec(key, \"AES\");\n\n        Cipher aesCipher;\n\n        // Create the cipher \n        aesCipher = Cipher.getInstance(\"AES/ECB/PKCS5Padding\");\n\n        // Initialize the cipher for encryption\n        aesCipher.init(Cipher.ENCRYPT_MODE, aesKey);\n\n        //sensitive information\n        byte[] text = plaintext.getBytes();\n\n        System.out.println(\"Text [Byte Format] : \" + text);\n        System.out.println(\"Text : \" + new String(text));\n\n        // Encrypt the text\n        byte[] textEncrypted = aesCipher.doFinal(text);\n\n        System.out.println(\"Text Encryted : \" + textEncrypted);\n\n        // Initialize the same cipher for decryption\n        aesCipher.init(Cipher.DECRYPT_MODE, aesKey);\n\n        // Decrypt the text\n        byte[] textDecrypted = aesCipher.doFinal(textEncrypted);\n\n        System.out.println(\"Text Decryted : \" + new String(textDecrypted));\n\n    }catch(NoSuchAlgorithmException e){\n        e.printStackTrace();\n    }catch(NoSuchPaddingException e){\n        e.printStackTrace();\n    }catch(InvalidKeyException e){\n        e.printStackTrace();\n    }catch(IllegalBlockSizeException e){\n        e.printStackTrace();\n    }catch(BadPaddingException e){\n        e.printStackTrace();\n    } \n\n}\n}\n", "idx": 1813}
{"project": "cipher", "commit_id": "Snippet24554791_6910.java", "target": 0, "func": "String keyStr = \"secret\";\nbyte[] key = (keyStr).getBytes(\"UTF-8\");\nMessageDigest sha = MessageDigest.getInstance(\"MD5\");\nkey = sha.digest(key);\nkey = Arrays.copyOf(key, 16);\nSecretKeySpec secretKeySpec = new SecretKeySpec(key, \"AES\");\nString text = \"Some text\"\n\nCipher cipher = Cipher.getInstance(\"AES\");\ncipher.init(Cipher.ENCRYPT_MODE, secretKeySpec);\nbyte[] encrypted = cipher.doFinal(text.getBytes());\n", "idx": 1755}
{"project": "cipher", "commit_id": "Snippet14931379_38007.java", "target": 1, "func": "Cipher.getInstance(\"AES/CBC/PKCS5Padding\", \"BC\");\n", "idx": 2139}
{"project": "cipher", "commit_id": "Snippet40737563_22596.java", "target": 0, "func": "import java.security.Key;\n\nimport javax.crypto.Cipher;\nimport javax.crypto.spec.SecretKeySpec;\n\nimport sun.misc.BASE64Decoder;\nimport sun.misc.BASE64Encoder;\n\npublic class AdvanceEncryptionSecurity {\n\n    private static final String ALGORITHM = \"AES\";\n    private static final int ITERATIONS = 2;\n    private static final byte[] keyValue = new byte[] { 'P', 'R', 'S', 'a', 'n', 'd', 'A', 'P', 'F', 'A', 'A', 'l', 'l', 'i', 'e', 'd' };\n    private static String salt = \"prs and pfa\";\n\n    public static String encrypt(String value) throws Exception {\n        Key key = generateKey();\n        Cipher c = Cipher.getInstance(ALGORITHM);  \n        c.init(Cipher.ENCRYPT_MODE, key);\n\n        String valueToEnc = null;\n        String eValue = value;\n        for (int i = 0; i < ITERATIONS; i++) {\n            valueToEnc = salt + eValue;\n            byte[] encValue = c.doFinal(valueToEnc.getBytes());\n            eValue = new BASE64Encoder().encode(encValue);\n        }\n        return eValue;\n    }\n\n    public static String decrypt(String value) throws Exception {\n        Key key = generateKey();\n        Cipher c = Cipher.getInstance(ALGORITHM);\n        c.init(Cipher.DECRYPT_MODE, key);\n\n        String dValue = null;\n        String valueToDecrypt = value;\n        for (int i = 0; i < ITERATIONS; i++) {\n            byte[] decordedValue = new BASE64Decoder().decodeBuffer(valueToDecrypt);\n            byte[] decValue = c.doFinal(decordedValue);\n            dValue = new String(decValue).substring(salt.length());\n            valueToDecrypt = dValue;\n        }\n        return dValue;\n    }\n\n    private static Key generateKey() throws Exception {\n        Key key = new SecretKeySpec(keyValue, ALGORITHM);\n        return key;\n    }\n}\n", "idx": 1632}
{"project": "cipher", "commit_id": "Snippet25480250_7826.java", "target": 0, "func": "public class EncryptionHelper {\n\n// Encrypts string and encode in Base64\npublic static String encryptText(String plainText,String key, String IV) throws Exception {\n    // ---- Use specified 3DES key and IV from other source --------------\n    byte[] plaintext = plainText.getBytes();//input\n    byte[] tdesKeyData = key.getBytes();// your encryption key\n\n    byte[] myIV = IV.getBytes();// initialization vector\n\n    Cipher c3des = Cipher.getInstance(\"DESede/CBC/PKCS5Padding\");\n    SecretKeySpec myKey = new SecretKeySpec(tdesKeyData, \"DESede\");\n    IvParameterSpec ivspec = new IvParameterSpec(myIV);\n\n    c3des.init(Cipher.ENCRYPT_MODE, myKey, ivspec);\n    byte[] cipherText = c3des.doFinal(plaintext);\n    String encryptedString = Base64.encodeToString(cipherText,\n            Base64.DEFAULT);\n    // return Base64Coder.encodeString(new String(cipherText));\n    return encryptedString;\n}\n", "idx": 1693}
{"project": "cipher", "commit_id": "Snippet35185261_17120.java", "target": 0, "func": "password = DESCodec.decode(\"String Returned by the output of encode\")\n\n\n\n\nclass DESCodec {\n    def static encode = { String target ->\n        def cipher = getCipher(Cipher.ENCRYPT_MODE)\n        return cipher.doFinal(target.bytes).encodeBase64() as String\n    }\n\n    def static decode = { String target ->\n        def cipher = getCipher(Cipher.DECRYPT_MODE)\n        return new String(cipher.doFinal(target.decodeBase64())) as String\n    }\n\n    private static getCipher(mode) {\n        def keySpec = new DESKeySpec(getPassword())\n        def cipher = Cipher.getInstance(\"DES\")\n        def keyFactory = SecretKeyFactory.getInstance(\"DES\")\n        cipher.init(mode, keyFactory.generateSecret(keySpec))\n        return cipher\n    }\n\n    private static getPassword() {\n        \"testsaltString\".getBytes(\"UTF-8\")\n    }\n\n\n    static void main(args) {\n\n        println args\n        if(args.length == 1) {\n            println encode(args[0])\n        } else {\n\n             println decode(args[1])\n        }\n    }\n}\n", "idx": 1703}
{"project": "cipher", "commit_id": "Snippet25249177_7618.java", "target": 1, "func": "public class BouncyLightWeightCipherExample {\n\n    private static final boolean FOR_DECRYPTION = false;\n\n    public static void main(String[] args) throws NoSuchAlgorithmException, Exception {\n        final byte[] keyData = new byte[256 / Byte.SIZE];\n        final byte[] ivData = new byte[16];\n        final byte[] testData = \"owlstead\".getBytes(UTF_8);\n\n        // JCE creation\n        final Cipher c = Cipher.getInstance(\"AES/CBC/PKCS5Padding\");\n\n        // initialization\n        c.init(Cipher.ENCRYPT_MODE, new SecretKeySpec(keyData, \"AES\"), new IvParameterSpec(ivData));\n\n        // and encryption\n        final byte[] ciphertext = c.doFinal(testData);\n\n        // Bouncy Castle creation\n        final BlockCipher blockCipher = new AESFastEngine();\n        final CBCBlockCipher withModeOfOperation = new CBCBlockCipher(blockCipher);\n        final PaddedBufferedBlockCipher withPadding = new PaddedBufferedBlockCipher(withModeOfOperation);\n\n        // initialization\n        final ParametersWithIV keyAndIV = new ParametersWithIV(new KeyParameter(keyData), ivData);\n        withPadding.init(FOR_DECRYPTION, keyAndIV);\n\n        // and decryption\n        int plaintextSize = withPadding.processBytes(ciphertext, 0, ciphertext.length, ciphertext, 0);\n        plaintextSize += withPadding.doFinal(ciphertext, plaintextSize);\n        final byte[] plaintext = Arrays.copyOf(ciphertext, plaintextSize);\n\n        // there we are\n        System.out.println(new String(plaintext, UTF_8));\n    }\n}\n", "idx": 1939}
{"project": "cipher", "commit_id": "Snippet12895031_36533.java", "target": 1, "func": "public class AES256 {\n    public static void main(String[] args) throws Exception {\n        Security.addProvider(new BouncyCastleProvider());\n\n        final KeyGenerator keyGen = KeyGenerator.getInstance(\"AES\");\n        keyGen.init(256); // doesn't work for 192, too\n\n        final byte[] encoded = keyGen.generateKey().getEncoded();\n\n        final SecretKeySpec keySpec = new SecretKeySpec(encoded, \"AES\");\n        final Cipher c = Cipher.getInstance(\"AES/CBC/PKCS5Padding\", \"BC\");\n        // Please ignore static IV for this example\n        final IvParameterSpec iv = new IvParameterSpec(new byte[]{0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15});\n\n        c.init(Cipher.ENCRYPT_MODE, keySpec, iv); // throws java.security.InvalidKeyException: Illegal key size\n    }\n}\n", "idx": 2058}
{"project": "cipher", "commit_id": "Snippet43684021_25820.java", "target": 1, "func": "Cipher cipher = Cipher.getInstance(\"RSA/None/PKCS1PADDING\");\n", "idx": 1936}
{"project": "cipher", "commit_id": "Snippet19412696_2207.java", "target": 0, "func": "    public static void encrypt(String key, String filename) throws Throwable {\n        InputStream is = new FileInputStream(\"Somefile.class\");\n        OutputStream os = new FileOutputStream(\"tempfile.class\");\n\n        DESKeySpec dks = new DESKeySpec(key.getBytes());\n        SecretKeyFactory skf = SecretKeyFactory.getInstance(\"DES\");\n        SecretKey desKey = skf.generateSecret(dks);\n        Cipher cipher = Cipher.getInstance(\"DES\"); // DES/ECB/PKCS5Padding for SunJCE\n\n            cipher.init(Cipher.ENCRYPT_MODE, desKey);\n            CipherInputStream cis = new CipherInputStream(is, cipher);\n            doCopy(cis, os);\n\n            File file2 = new File(\"tempfile.class\");    \n\n            File f = new File(\"somefile.class\");\n            f.delete();\n            file2.renameTo(f);\n    }\n", "idx": 1741}
{"project": "cipher", "commit_id": "Snippet4060515_30996.java", "target": 0, "func": "    public static String generate(String plaintext, String passphase) throws Exception {\n        try {\n            PBEKeySpec pbeKeySpec = new PBEKeySpec(passphase.toCharArray());\n            PBEParameterSpec pbeParamSpec;\n            SecretKeyFactory keyFac;\n            // Salt\n            byte[] salt = {(byte) 0xc8, (byte) 0x73, (byte) 0x61, (byte) 0x1d, (byte) 0x1a, (byte) 0xf2, (byte) 0xa8, (byte) 0x99};\n            // Iteration count\n            int count = 20;\n            // Create PBE parameter set\n            pbeParamSpec = new PBEParameterSpec(salt, count);\n            keyFac = SecretKeyFactory.getInstance(\"PBEWithMD5AndDES\");\n            SecretKey pbeKey = keyFac.generateSecret(pbeKeySpec);\n            // Create PBE Cipher\n            Cipher pbeCipher = Cipher.getInstance(\"PBEWithMD5AndDES\");\n            // Initialize PBE Cipher with key and parameters\n            pbeCipher.init(Cipher.ENCRYPT_MODE, pbeKey, pbeParamSpec);\n            // Our cleartext\n            byte[] cleartext = plaintext.getBytes();\n            // Encrypt the cleartext\n            byte[] ciphertext = pbeCipher.doFinal(cleartext);\n            return ciphertext;\n        } catch (Exception ex) {\n            throw new Exception(ex.getMessage());\n        }\n    }\n", "idx": 1742}
{"project": "cipher", "commit_id": "Snippet41167894_23131.java", "target": 0, "func": "package com.lahiru.security;\nimport java.io.UnsupportedEncodingException;\nimport java.security.MessageDigest;\nimport java.security.NoSuchAlgorithmException;\nimport java.util.Arrays;\nimport java.util.Base64;\n\nimport javax.crypto.Cipher;\nimport javax.crypto.spec.SecretKeySpec;\n\npublic class AESEncryptionDecryption {\n\n    private static SecretKeySpec secretKey;\n    private static byte[] key;\n\n    public static void main(String[] args){\n        String id = \"00001\";\n        String plainText = \"This is plain text\";\n\n        String cipherText = encrypt(plainText, id);\n        System.out.println(\"Cipher Text after encrption ::: \" + cipherText);\n        System.out.println(\"Plain Text after decryption ::: \" + decrypt(cipherText, id));\n\n    }\n\n\n    public static void setKey(String myKey) \n    {\n        MessageDigest sha = null;\n        try {\n            key = myKey.getBytes(\"UTF-8\");\n            sha = MessageDigest.getInstance(\"SHA-1\");\n            key = sha.digest(key);\n            key = Arrays.copyOf(key, 16); \n            secretKey = new SecretKeySpec(key, \"AES\");\n        } \n        catch (NoSuchAlgorithmException e) {\n            e.printStackTrace();\n        } \n        catch (UnsupportedEncodingException e) {\n            e.printStackTrace();\n        }\n    }\n\n    public static String encrypt(String strToEncrypt, String secret) \n    {\n        try\n        {\n            setKey(secret);\n            Cipher cipher = Cipher.getInstance(\"AES/ECB/PKCS5Padding\");\n            cipher.init(Cipher.ENCRYPT_MODE, secretKey);\n            return Base64.getEncoder().encodeToString(cipher.doFinal(strToEncrypt.getBytes(\"UTF-8\")));\n        } \n        catch (Exception e) \n        {\n            System.out.println(\"Error while encrypting: \" + e.toString());\n        }\n        return null;\n    }\n\n    public static String decrypt(String strToDecrypt, String secret) \n    {\n        try\n        {\n            setKey(secret);\n            Cipher cipher = Cipher.getInstance(\"AES/ECB/PKCS5PADDING\");\n            cipher.init(Cipher.DECRYPT_MODE, secretKey);\n            return new String(cipher.doFinal(Base64.getDecoder().decode(strToDecrypt)));\n        } \n        catch (Exception e) \n        {\n            System.out.println(\"Error while decrypting: \" + e.toString());\n        }\n        return null;\n    }\n}\n", "idx": 1782}
{"project": "cipher", "commit_id": "Snippet22551704_4953.java", "target": 0, "func": "   import java.io.File;\n   import java.io.FileInputStream;\n   import java.io.FileOutputStream;\n   import java.io.InputStream;\n\n   import javax.crypto.Cipher;\n   import javax.crypto.CipherInputStream;\n   import javax.crypto.spec.SecretKeySpec;\n\n    import android.util.Log;\n\n  public class Crypto\n {\n\npublic FileInputStream mIn;\npublic FileOutputStream mOut;\n\npublic Crypto(String fileIn, String fileOut)\n{\n    try\n    {\n        mIn = new FileInputStream(new File(fileIn));\n        mOut = new FileOutputStream(new File(fileOut));\n        decrypt(mIn, mOut);\n    }\n    catch (Exception e)\n    {\n        e.printStackTrace();\n    }\n}\n\npublic static void decrypt(InputStream in, FileOutputStream out) throws Exception\n{\n    final String string = \"346a23652a46392b4d73257c67317e352e3372482177652c\";\n    byte[] hexAsBytes = hexStringToByteArray(string);\n\n    SecretKeySpec keySpec = new SecretKeySpec(hexAsBytes, \"AES\");\n    Cipher cipher = Cipher.getInstance(\"AES\");\n\n    cipher.init(Cipher.DECRYPT_MODE, keySpec);\n\n    in = new CipherInputStream(in, cipher);\n    byte[] buffer = new byte[24];\n    int bytesRead;\n    while ((bytesRead = in.read(buffer)) != -1)\n    {\n        out.write(buffer, 0, bytesRead);\n        String si = new String(buffer);\n        Log.d(\"Crypto\", si);\n    }\n\n}\n\npublic static byte[] hexStringToByteArray(String s)\n{\n    int len = s.length();\n    byte[] data = new byte[len / 2];\n    for(int i = 0; i < len; i += 2)\n    {\n        data[i / 2] = (byte) ((Character.digit(s.charAt(i), 16) << 4) + Character.digit(s.charAt(i + 1), 16));\n    }\n    return data;\n}\n\n       }  \n", "idx": 1595}
{"project": "cipher", "commit_id": "Snippet46244541_28332.java", "target": 1, "func": "userName = URLDecoder.decode(userName, \"ISO-8859-1\");\n\nCipher objCipherTunkicloud = Cipher.getInstance(\"RSA/ECB/PKCS1Padding\");\n\nobjCipherTunkicloud.init(Cipher.DECRYPT_MODE, loadPrivateKey(\"/keylecordonbleu/private.key\", \"RSA\"));\n\nbyte[] arrDecryptedKeyBytes = objCipherTunkicloud.doFinal(userName.getBytes(StandardCharsets.ISO_8859_1));\n\nString tkn = new String(arrDecryptedKeyBytes);\n", "idx": 2112}
{"project": "cipher", "commit_id": "Snippet21411130_3917.java", "target": 1, "func": "Security.addProvider(new org.bouncycastle.jce.provider.BouncyCastleProvider());\n\nbyte[] input = new byte[] { (byte) 0xbe, (byte) 0xef };\nCipher cipher = Cipher.getInstance(\"RSA/None/NoPadding\", \"BC\");\n\nKeyFactory keyFactory = KeyFactory.getInstance(\"RSA\", \"BC\");\nRSAPublicKeySpec pubKeySpec = new RSAPublicKeySpec(new BigInteger(\n    \"12345678\", 16), new BigInteger(\"11\", 16));\nRSAPrivateKeySpec privKeySpec = new RSAPrivateKeySpec(new BigInteger(\n    \"12345678\", 16), new BigInteger(\"12345678\",\n    16));\n\nRSAPublicKey pubKey = (RSAPublicKey) keyFactory.generatePublic(pubKeySpec);\nRSAPrivateKey privKey = (RSAPrivateKey) keyFactory.generatePrivate(privKeySpec);\n\ncipher.init(Cipher.ENCRYPT_MODE, pubKey);\n", "idx": 2234}
{"project": "cipher", "commit_id": "Snippet40099635_22017.java", "target": 0, "func": "static void encrypt() throws IOException, NoSuchAlgorithmException, NoSuchPaddingException, InvalidKeyException {\n    // Here you read the cleartext.\n    FileInputStream fis = new FileInputStream(\"SampleFolder/yourfilename\");\n    // This stream write the encrypted text. This stream will be wrapped by another stream.\n    FileOutputStream fos = new FileOutputStream(\"SampleFolder/yourencryptedfilename\");\n\n    // Length is 16 byte\n    // Careful when taking user input!!! https://stackoverflow.com/a/3452620/1188357\n    SecretKeySpec sks = new SecretKeySpec(\"MyDifficultPassw\".getBytes(), \"AES\");\n    // Create cipher\n    Cipher cipher = Cipher.getInstance(\"AES\");\n    cipher.init(Cipher.ENCRYPT_MODE, sks);\n    // Wrap the output stream\n    CipherOutputStream cos = new CipherOutputStream(fos, cipher);\n    // Write bytes\n    int b;\n    byte[] d = new byte[8];\n    while((b = fis.read(d)) != -1) {\n        cos.write(d, 0, b);\n    }\n    // Flush and close streams.\n    cos.flush();\n    cos.close();\n    fis.close();\n}\n", "idx": 1671}
{"project": "cipher", "commit_id": "Snippet22893220_5286.java", "target": 1, "func": "public class TestSecurityDiscussions {\n\n        public static byte[] encryptData(KeyPair keys){\n\n            String rawData = \"Hi how are you>?\";\n            Cipher cipher = Cipher.getInstance(\"RSA\");\n            try {\n                cipher.init(Cipher.ENCRYPT_MODE, keys.getPublic());\n            } catch (Exception e) {\n                // TODO Auto-generated catch block\n                e.printStackTrace();\n            }\n            byte[] encrypted = cipher.doFinal(rawData.getBytes());\n\n            return encrypted;\n        }\n\n\n        public static String decryptData(byte[] encrypted,KeyPair keys) {\n            Cipher cipher = Cipher.getInstance(\"RSA\");\n            try {\n                cipher.init(Cipher.DECRYPT_MODE, keys.getPrivate());\n            } catch (Exception e) {\n\n                e.printStackTrace();\n            }\n            byte[] deycrypted = cipher.doFinal(encrypted);\n\n            return deycrypted.toString();\n        }\n\n\n        public static void main(String[] args)   {\n            KeyPair keys = KeyPairGenerator.getInstance(\"RSA\").generateKeyPair();\n            byte[] keydata = encryptData(keys);\n            System.out.println(\"======>\"+decryptData(keydata,keys));\n\n        }\n\n    }\n", "idx": 2126}
{"project": "cipher", "commit_id": "Snippet22549251_4951.java", "target": 0, "func": "package com.sample.camera;\n\nimport java.security.SecureRandom;\n\nimport javax.crypto.Cipher;\nimport javax.crypto.KeyGenerator;\nimport javax.crypto.SecretKey;\nimport javax.crypto.spec.SecretKeySpec;\n\nimport android.util.Base64;\n\npublic class EncodeDecodeAES {\n\n\n\n    private final static String HEX = \"0123456789ABCDEF\";\n\n    private final static int JELLY_BEAN_4_2 = 17;\n\n    private final static byte[] key = {\n        0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0\n    };\n\n\n\n\n    // static {\n\n    // Security.addProvider(new BouncyCastleProvider());\n\n    // }\n\n\n\n    public static String encrypt(String seed, String cleartext) throws Exception {\n\n        byte[] rawKey = getRawKey(seed.getBytes());\n\n        byte[] result = encrypt(rawKey, cleartext.getBytes());\n\n        String fromHex = toHex(result);\n\n        String base64 = new String(Base64.encodeToString(fromHex.getBytes(), 0));\n\n        return base64;\n\n\n    }\n\n\n\n\n    public static String decrypt(String seed, String encrypted) throws Exception {\n\n        byte[] seedByte = seed.getBytes();\n\n        System.arraycopy(seedByte, 0, key, 0, ((seedByte.length < 16) ? seedByte.length : 16));\n\n        String base64 = new String(Base64.decode(encrypted, 0));\n\n        byte[] rawKey = getRawKey(seedByte);\n\n        byte[] enc = toByte(base64);\n\n        byte[] result = decrypt(rawKey, enc);\n\n        return new String(result);\n\n\n    }\n\n\n\n\n    public static byte[] encryptBytes(String seed, byte[] cleartext) throws Exception {\n\n        byte[] rawKey = getRawKey(seed.getBytes());\n\n        byte[] result = encrypt(rawKey, cleartext);\n\n        return result;\n\n\n    }\n\n\n\n\n    public static byte[] decryptBytes(String seed, byte[] encrypted) throws Exception {\n\n        byte[] rawKey = getRawKey(seed.getBytes());\n\n        byte[] result = decrypt(rawKey, encrypted);\n\n        return result;\n\n\n    }\n\n\n\n\n    private static byte[] getRawKey(byte[] seed) throws Exception {\n\n        KeyGenerator kgen = KeyGenerator.getInstance(\"AES\"); // , \"SC\");\n\n        SecureRandom sr = null;\n\n        if (android.os.Build.VERSION.SDK_INT >= JELLY_BEAN_4_2) {\n\n            sr = SecureRandom.getInstance(\"SHA1PRNG\", \"Crypto\");\n\n\n        } else {\n\n            sr = SecureRandom.getInstance(\"SHA1PRNG\");\n\n\n        }\n\n        sr.setSeed(seed);\n\n        try {\n\n            kgen.init(256, sr);\n\n            // kgen.init(128, sr);\n\n\n        } catch (Exception e) {\n\n            // Log.w(LOG, \"This device doesn't suppor 256bits, trying 192bits.\");\n\n            try {\n\n                kgen.init(192, sr);\n\n\n            } catch (Exception e1) {\n\n                // Log.w(LOG, \"This device doesn't suppor 192bits, trying 128bits.\");\n\n                kgen.init(128, sr);\n\n\n            }\n\n        }\n\n        SecretKey skey = kgen.generateKey();\n\n        byte[] raw = skey.getEncoded();\n\n        return raw;\n\n\n    }\n\n\n\n\n    private static byte[] encrypt(byte[] raw, byte[] clear) throws Exception {\n\n        SecretKeySpec skeySpec = new SecretKeySpec(raw, \"AES\");\n\n        //Cipher cipher = Cipher.getInstance(\"AES\"); // /ECB/PKCS7Padding\", \"SC\");\n        Cipher cipher = Cipher.getInstance(\"AES/ECB/PKCS5Padding\");\n        cipher.init(Cipher.ENCRYPT_MODE, skeySpec);\n\n        byte[] encrypted = cipher.doFinal(clear);\n\n        return encrypted;\n\n\n    }\n\n\n\n\n    private static byte[] decrypt(byte[] raw, byte[] encrypted) throws Exception {\n\n        SecretKeySpec skeySpec = new SecretKeySpec(raw, \"AES\");\n\n        Cipher cipher = Cipher.getInstance(\"AES/ECB/PKCS5Padding\"); // /ECB/PKCS7Padding\", \"SC\");\n\n        cipher.init(Cipher.DECRYPT_MODE, skeySpec);\n\n        byte[] decrypted = cipher.doFinal(encrypted);\n\n        return decrypted;\n\n\n    }\n\n\n\n\n    public static String toHex(String txt) {\n\n        return toHex(txt.getBytes());\n\n\n    }\n\n\n\n\n    public static String fromHex(String hex) {\n\n        return new String(toByte(hex));\n\n\n    }\n\n\n\n\n    public static byte[] toByte(String hexString) {\n\n        int len = hexString.length() / 2;\n\n        byte[] result = new byte[len];\n\n        for (int i = 0; i < len; i++)\n\n            result[i] = Integer.valueOf(hexString.substring(2 * i, 2 * i + 2), 16).byteValue();\n\n        return result;\n\n    }\n\n\n\n    public static String toHex(byte[] buf) {\n        if (buf == null)\n\n            return \"\";\n\n        StringBuffer result = new StringBuffer(2 * buf.length);\n\n        for (int i = 0; i < buf.length; i++) {\n\n            appendHex(result, buf[i]);\n\n        }\n        return result.toString();\n\n    }\n\n\n\n\n    private static void appendHex(StringBuffer sb, byte b) {\n\n        sb.append(HEX.charAt((b >> 4) & 0x0f)).append(HEX.charAt(b & 0x0f));\n\n\n    }\n\n\n\n\n}\n", "idx": 1605}
{"project": "cipher", "commit_id": "Snippet26762045_8879.java", "target": 1, "func": "@Override\npublic byte[] encryptBytesToBytes(byte[] plainData, byte[] key, byte[] iv) {\n    try {\n        initCipher(Cipher.ENCRYPT_MODE, key, iv);\n        return aesCipher.doFinal(plainData);\n\n    } catch (IllegalBlockSizeException | BadPaddingException e) {\n        log.severe(e.getMessage());\n    }\n\n    return null;\n}    \n\n@Override\npublic byte[] decryptBytesToBytes(byte[] encryptedBytes, int length,\n        byte[] key, byte[] iv) {\n    try {\n        initCipher(Cipher.DECRYPT_MODE, key, iv);\n        return aesCipher.doFinal(encryptedBytes, 0, length);\n    } catch (IllegalBlockSizeException | BadPaddingException e) {\n        e.printStackTrace();\n    }\n    return null;\n}\n\nprivate void initCipher(int mode, byte[] keyBytes, byte[] ivBytes) {\n    try {\n\n        // create shared secret and init cipher mode\n        SecretKeySpec secretKeySpec = new SecretKeySpec(keyBytes, \"AES\");\n        aesCipher = Cipher.getInstance(\"AES/CBC/PKCS5Padding\");\n        aesCipher.init(mode == Cipher.ENCRYPT_MODE ? Cipher.ENCRYPT_MODE : Cipher.DECRYPT_MODE, secretKeySpec, new IvParameterSpec(ivBytes));\n    } catch (InvalidAlgorithmParameterException | NoSuchAlgorithmException | NoSuchPaddingException | InvalidKeyException e) {\n        e.printStackTrace();\n    }\n}\n\npublic String byteArrayToHexStr(byte[] encrypted) {\n    StringBuilder hex = new StringBuilder();\n    for (byte b : encrypted) {\n        hex.append(String.format(\"%02X\", b));\n    }\n    return new String(hex.toString());\n}\n\npublic byte[] hexStrToByteArray(String hex) {\n    StringBuilder sb = new StringBuilder();\n\n    for (int i = 0; i < hex.length() - 1; i += 2) {\n        String output = hex.substring(i, (i + 2));\n        int decimal = Integer.parseInt(output, 16);\n        sb.append((char) decimal);\n    }\n\n    String temp = sb.toString();\n    return temp.getBytes();\n}\n", "idx": 2137}
{"project": "cipher", "commit_id": "Snippet22628085_5033.java", "target": 0, "func": "public class Cryptography {\n\n    public static SecretKey generateKey() throws NoSuchAlgorithmException {\n        MessageDigest digest = MessageDigest.getInstance(\"SHA\");\n        digest.update(\"BhLKTyLoP YroUsRQT\".getBytes());\n        return new SecretKeySpec(digest.digest(), 0, 16, \"AES\");\n    }\n\n    public static byte[] encrypt(String message, SecretKey key) throws NoSuchAlgorithmException, BadPaddingException, IllegalBlockSizeException, NoSuchPaddingException, InvalidKeyException, UnsupportedEncodingException {\n        Cipher aes = Cipher.getInstance(\"AES/ECB/PKCS5Padding\");\n        aes.init(Cipher.ENCRYPT_MODE, key);\n        return aes.doFinal(message.getBytes());\n    }\n\n    public static String decrypt(byte[] cipherText, SecretKey key) throws NoSuchPaddingException, NoSuchAlgorithmException, InvalidKeyException, BadPaddingException, IllegalBlockSizeException {\n        Cipher aes = Cipher.getInstance(\"AES/ECB/PKCS5Padding\");\n        aes.init(Cipher.DECRYPT_MODE, key);\n        return new String(aes.doFinal(cipherText));\n    }\n\n}\n", "idx": 1728}
{"project": "cipher", "commit_id": "Snippet2280375_30276.java", "target": 0, "func": "public byte[] encryptData(byte[] data, String key) {\n    byte[] encrypted = null;\n\n    Security.addProvider(new org.bouncycastle.jce.provider.BouncyCastleProvider());\n    byte[] keyBytes = key.getBytes();\n\n    SecretKeySpec keySpec = new SecretKeySpec(keyBytes, \"AES\");\n\n    try {\n        Cipher cipher = Cipher.getInstance(\"AES/ECB/PKCS7Padding\", \"BC\");\n        cipher.init(Cipher.ENCRYPT_MODE, keySpec);\n\n        encrypted = new byte[cipher.getOutputSize(data.length)];\n        int ctLength = cipher.update(data, 0, data.length, encrypted, 0);\n        ctLength += cipher.doFinal(encrypted, ctLength);\n    } catch (Exception e) {\n        logger.log(Level.SEVERE, e.getMessage());\n    } finally {\n        return encrypted;\n    }\n}\n", "idx": 1579}
{"project": "cipher", "commit_id": "Snippet13571113_37104.java", "target": 1, "func": "public static void main(String[] args) throws Exception {\n    KeyPairGenerator kpg = KeyPairGenerator.getInstance(\"RSA\");\n    Cipher cipher = Cipher.getInstance(\"RSA/ECB/PKCS1Padding\");\n\n    kpg.initialize(1024);\n    KeyPair keyPair = kpg.generateKeyPair();\n    PrivateKey privKey = keyPair.getPrivate();\n    PublicKey pubKey = keyPair.getPublic();\n\n    // Encrypt\n    cipher.init(Cipher.ENCRYPT_MODE, pubKey);\n\n    String test = \"My test string\";\n    String ciphertextFile = \"ciphertextRSA.txt\";\n    InputStream fis = new ByteArrayInputStream(test.getBytes(\"UTF-8\"));\n\n    FileOutputStream fos = new FileOutputStream(ciphertextFile);\n    CipherOutputStream cos = new CipherOutputStream(fos, cipher);\n\n    byte[] block = new byte[32];\n    int i;\n    while ((i = fis.read(block)) != -1) {\n        cos.write(block, 0, i);\n    }\n    cos.close();\n\n    // Decrypt\n    String cleartextAgainFile = \"cleartextAgainRSA.txt\";\n\n    cipher.init(Cipher.DECRYPT_MODE, privKey);\n\n    fis = new FileInputStream(ciphertextFile);\n    CipherInputStream cis = new CipherInputStream(fis, cipher);\n    fos = new FileOutputStream(cleartextAgainFile);\n\n    while ((i = cis.read(block)) != -1) {\n        fos.write(block, 0, i);\n    }\n    fos.close();\n}\n", "idx": 2035}
{"project": "cipher", "commit_id": "Snippet10380570_34739.java", "target": 1, "func": "    Cipher cipher = Cipher.getInstance(\"RSA\");\n    PrivateKey privateKey = keyPair.getPrivate();\n    // decrypt the ciphertext using the private key \n    cipher.init(Cipher.DECRYPT_MODE, privateKey); \n    byte[] decryptedText = cipher.doFinal(theBytes); \n", "idx": 2224}
{"project": "cipher", "commit_id": "Snippet20770072_3368.java", "target": 1, "func": "SecureRandom rnd = new SecureRandom();\nIvParameterSpec iv = new IvParameterSpec(rnd.generateSeed(16));\n\nKeyGenerator generator = KeyGenerator.getInstance(\"AES\");\ngenerator.init(256);\nSecretKey k = generator.generateKey();\n\nCipher c = Cipher.getInstance(\"AES/CBC/PKCS5Padding\");\nc.init(Cipher.ENCRYPT_MODE, k, iv);\n", "idx": 2285}
{"project": "cipher", "commit_id": "Snippet20159619_2822.java", "target": 1, "func": "String stdiv = \"1234567890123456\";\nString txtinput = txtview1.getText().toString();\nString mainkey = \"0000999988887777\";\nbyte[] key;\nkey = mainkey.getBytes(\"UTF8\");\nbyte[] iv = stdiv.getBytes(\"UTF8\");\nbyte[] input = txtinput.getBytes(\"UTF8\");\nCipher cipher;\ncipher = Cipher.getInstance(\"AES/CBC/PKCS7PADDING\");\nSecretKeySpec keyspec = new SecretKeySpec(key, \"AES\" );\nIvParameterSpec paramspec = new IvParameterSpec(iv);\ncipher.init(Cipher.ENCRYPT_MODE, keyspec, paramspec);\nbyte[] result = cipher.doFinal(input);\nString str=new String(result,\"UTF8\");\ntxtview2.setText(str);\n", "idx": 2203}
{"project": "cipher", "commit_id": "Snippet27147016_9300.java", "target": 0, "func": "import java.io.BufferedReader;\nimport java.io.DataOutputStream;\nimport java.io.InputStream;\nimport java.io.InputStreamReader;\nimport java.io.OutputStream;\nimport java.net.Socket;\n\nimport javax.crypto.Cipher;\nimport javax.crypto.CipherInputStream;\nimport javax.crypto.CipherOutputStream;\nimport javax.crypto.SecretKey;\nimport javax.crypto.spec.IvParameterSpec;\nimport javax.crypto.spec.SecretKeySpec;\n\npublic class EchoClientTest {\n\n    public static void main(String[] args) {\n        try {\n            byte[] keyB = {\n                    (byte)0x2C, (byte)0xCF, (byte)0xBC, (byte)0x81, (byte)0x99, (byte)0xB7, (byte)0x37, (byte)0x84, \n                    (byte)0xD1, (byte)0x09, (byte)0x44, (byte)0x4F, (byte)0xB6, (byte)0x66, (byte)0x69, (byte)0x1F, \n                    (byte)0x17, (byte)0x61, (byte)0xAD, (byte)0xD7, (byte)0x43, (byte)0x0E, (byte)0x80, (byte)0x6C                      \n            };\n            byte[] ivB = {\n                    (byte)0x7B, (byte)0x9B, (byte)0x5F, (byte)0x36, (byte)0xC9, (byte)0x26, (byte)0xE9, (byte)0x5E                      \n            };\n\n\n            {\n                Socket echoSocket = new Socket(\"127.0.0.1\",1423);\n                System.out.println(\"Connected\");\n\n                System.out.println(\"Setting up - Unencrypted version\");\n                OutputStream oS = echoSocket.getOutputStream();\n                DataOutputStream doS = new DataOutputStream(oS);\n                InputStream iS = echoSocket.getInputStream();\n                InputStreamReader iSR = new InputStreamReader(iS,\"UTF-8\");\n                BufferedReader bR = new BufferedReader(iSR);\n\n\n                System.out.println(\"Writing Unencrypted output\");\n                doS.write(\"Test Message\\n\".getBytes(\"UTF-8\"));\n                doS.flush();\n\n                System.out.println(\"Waiting 1 second\");\n                Thread.sleep(1000);\n\n                System.out.println(\"Reading data from socket\");\n\n                String inputLine = \"\";\n                while (bR.ready()) {\n                    int i = bR.read();\n                    inputLine += (char)i;\n                }\n                if (inputLine.length()==0) {\n                    System.out.println(\"Error nothing read from socket\");\n                } else {\n                    System.out.println(\"Recieved:\" + inputLine);\n                    inputLine = \"\";\n                };\n\n                System.out.println(\"Closing Socket\");\n                echoSocket.close();\n            }\n            System.out.println(\"Repeating but encrypting the data SENT on the socket\");\n            {\n                Socket echoSocket = new Socket(\"127.0.0.1\",1423);\n                System.out.println(\"Connected\");\n\n                System.out.println(\"Setting up Ciphers\");\n                String Algo = \"DESede\"; //DES or DESede\n\n                final SecretKey key = new SecretKeySpec(keyB, Algo);\n                final IvParameterSpec iv = new IvParameterSpec(ivB);\n                final Cipher cipherEncrypt = Cipher.getInstance(\"DESede/CFB8/NoPadding\");\n                cipherEncrypt.init(Cipher.ENCRYPT_MODE, key, iv);      \n\n                System.out.println(\"Setting up - Encrypted version\");\n                OutputStream oS = echoSocket.getOutputStream();\n                CipherOutputStream cipherOutputS = new CipherOutputStream(oS,cipherEncrypt);\n                DataOutputStream doS = new DataOutputStream(cipherOutputS);\n                InputStream iS = echoSocket.getInputStream();\n                InputStreamReader iSR = new InputStreamReader(iS,\"UTF-8\");\n                BufferedReader bR = new BufferedReader(iSR);\n\n\n                System.out.println(\"Writing Encrypted output\");\n                doS.write(\"Test Message\\n\".getBytes(\"UTF-8\"));\n                doS.flush();\n\n                System.out.println(\"Waiting 1 second\");\n                Thread.sleep(1000);\n\n                System.out.println(\"Reading data from socket\");\n\n                String inputLine = \"\";\n                while (bR.ready()) {\n                    int i = bR.read();\n                    inputLine += (char)i;\n                }\n                if (inputLine.length()==0) {\n                    System.out.println(\"Error nothing read from socket\");\n                } else {\n                    System.out.println(\"Recieved:\" + inputLine);\n                    inputLine = \"\";\n                };\n\n                System.out.println(\"Closing Socket\");\n                echoSocket.close();\n            }\n            System.out.println(\"Repeating but encrypting the data SENT and decrypting RECIEVED on the socket\");\n            {\n                Socket echoSocket = new Socket(\"127.0.0.1\",1423);\n                System.out.println(\"Connected\");\n\n                System.out.println(\"Setting up Ciphers\");\n                String Algo = \"DESede\"; //DES or DESede\n\n                final SecretKey key = new SecretKeySpec(keyB, \"DESede\");\n                final IvParameterSpec iv = new IvParameterSpec(ivB);\n                final Cipher cipherEncrypt = Cipher.getInstance(\"DESede/CFB8/NoPadding\");\n                final Cipher cipherDecrypt = Cipher.getInstance(\"DESede/CFB8/NoPadding\");\n                cipherEncrypt.init(Cipher.ENCRYPT_MODE, key, iv);      \n                cipherDecrypt.init(Cipher.DECRYPT_MODE, key, iv);      \n\n                System.out.println(\"Setting up - Encrypted version\");\n                OutputStream oS = echoSocket.getOutputStream();\n                CipherOutputStream cipherOutputS = new CipherOutputStream(oS,cipherEncrypt);\n                DataOutputStream doS = new DataOutputStream(cipherOutputS);\n                InputStream iS = echoSocket.getInputStream();\n                CipherInputStream cipherInputS =  new CipherInputStream(iS,cipherDecrypt);\n                InputStreamReader iSR = new InputStreamReader(cipherInputS,\"UTF-8\");\n                BufferedReader bR = new BufferedReader(iSR);\n\n\n                System.out.println(\"Writing Encrypted output\");\n                doS.write(\"Test Message\\n\".getBytes(\"UTF-8\"));\n                doS.flush();\n\n                System.out.println(\"Waiting 1 second\");\n                Thread.sleep(1000);\n\n                System.out.println(\"Reading data from socket (and Decrtpying)\");\n\n                String inputLine = \"\";\n                while (bR.ready()) {\n                    int i = bR.read();\n                    inputLine += (char)i;\n                }\n                if (inputLine.length()==0) {\n                    System.out.println(\"Error nothing read from socket\");\n                } else {\n                    System.out.println(\"Recieved:\" + inputLine);\n                    inputLine = \"\";\n                };\n\n                System.out.println(\"Closing Socket\");\n                echoSocket.close();\n            }           \n\n        } catch (Exception e) {\n            e.printStackTrace();\n        }\n    }\n\n}\n", "idx": 1844}
{"project": "cipher", "commit_id": "Snippet47174603_29176.java", "target": 0, "func": "  public static String decryptIt(String value) {\n    try {\n        DESKeySpec keySpec = new DESKeySpec(new byte[]{105, 107, 18, 51, 114, 83, 51, 120, 121});//cryptoPass.getBytes(\"UTF8\"));\n        SecretKeyFactory keyFactory = SecretKeyFactory.getInstance(\"DES\");\n        SecretKey key = keyFactory.generateSecret(keySpec);\n\n        byte[] encrypedPwdBytes = Base64.decode(value, Base64.DEFAULT);\n        // cipher is not thread safe\n        Cipher cipher = Cipher.getInstance(\"DES\");\n        cipher.init(Cipher.DECRYPT_MODE, key);\n        byte[] decrypedValueBytes = (cipher.doFinal(encrypedPwdBytes));\n\n        // Log.d(\"aa\", \"Decrypted: \" + value + \" -> \" + decrypedValue);\n        return new String(decrypedValueBytes);\n    } catch (Exception e) {\n        e.printStackTrace();\n    }\n    return value;\n}\n", "idx": 1875}
{"project": "cipher", "commit_id": "Snippet44461090_26520.java", "target": 0, "func": "import java.security.Key;\nimport javax.crypto.Cipher;\nimport javax.crypto.spec.SecretKeySpec;\nimport java.util.Base64;\n\npublic class encryptData {\n  public static void main(String[] args) {\n\n    String data=\"amount=10&expiryDate=20150101 151515&orderRefNum=11001&postBackURL=http://localhost:9081/local/status.php&storeId=28\";\n    String key=\"89OUITUPRL3I8H3G\";\n\n    Cipher cipher = Cipher.getInstance(\"AES/ECB/PKCS5Padding\");\n    SecretKeySpec secretKey = new SecretKeySpec(key.getBytes(), \"AES\");\n    cipher.init(Cipher.ENCRYPT_MODE, secretKey);\n    encryptedValue = new String(Base64.encodeBase64(cipher.doFinal(data.getBytes())));\n  }\n}\n", "idx": 1611}
{"project": "cipher", "commit_id": "Snippet20680129_3284.java", "target": 1, "func": "  byte[] wholeFileByte = null;\n    Cipher cipher = Cipher.getInstance(\"AES/CBC/PKCS7Padding\");\n    cipher.init(Cipher.DECRYPT_MODE, key, DownloadBookAsyncTask.ivspec);\n    File file = new File(context.getFilesDir().getParentFile().getPath() + \"/download/\" + id + \"/xmldata.xml\");\n    FileInputStream fis = new FileInputStream(file);\n    ByteArrayOutputStream bos = new ByteArrayOutputStream();\n    CipherInputStream cis = new CipherInputStream(fis, cipher);\n    byte data[] = new byte[4096];\n    int count;\n    while ((count = cis.read(data)) != -1) {\n        bos.write(data, 0, count);\n    }\n\n    if(cis != null)\n        cis.close();\n    if(bos != null)\n        bos.close();\n    if(fis != null)\n        fis.close();\n\n    wholeFileByte = bos.toByteArray();\n    String kk = new String(wholeFileByte, \"UTF-8\");\n", "idx": 1962}
{"project": "cipher", "commit_id": "Snippet13300310_36848.java", "target": 0, "func": "private SharedPreferences sp;\n\n\nIntent i;\nButton regBttn,rtnBttn;\nEditText rName,rPwd;\nString user, pass, chk;\nString stat=\"a\";\nString key = \"N@!an@jajpn!==\";\n\n\n/** Called when the activity is first created. */\n@Override\npublic void onCreate(Bundle savedInstanceState)\n{\n\n\n     super.onCreate(savedInstanceState);\n     setContentView(R.layout.register);\n\n    rName=(EditText)findViewById(R.id.reg_uname);\n    rPwd=(EditText)findViewById(R.id.reg_pswd);\n    regBttn=(Button)findViewById(R.id.reg_button);\n    rtnBttn=(Button)findViewById(R.id.rtn_button); \n    regBttn.setOnClickListener(this);\n    rtnBttn.setOnClickListener(this);\n\n    sp=this.getSharedPreferences(\"AccessApp\", MODE_WORLD_READABLE);\n    chk=sp.getString(\"USERNAME_KEY\", \"\");\n    if(chk.length()!=0){\n    sp=getSharedPreferences(\"AccessApp\",MODE_WORLD_WRITEABLE); \n\n    i=new Intent(this,AccessApp.class);\n    startActivity(i); \n\n    }     \n   }\n\npublic void onClick(View arg0) {\n    user=rName.getText().toString().trim();\n    pass=rPwd.getText().toString().trim();\n\n    if(arg0==regBttn){     \n       if((user.length()!=0))\n        {\n         if((pass.length()!=0))\n            {\n\n        sp=getSharedPreferences(\"AccessApp\",MODE_WORLD_WRITEABLE);\n        Editor myEditor=sp.edit();\n\n        try {\n\n            byte[ ] superSecretKeyBytes = Base64.decode(user);\n            byte[] key = { 0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 0, 1, 2, 3, 4, 5, 6 };\n            for (int i = 0; i < superSecretKeyBytes.length && i < key.length; i++) {\n                key[i] = superSecretKeyBytes[i];\n                myEditor.putString(\"USERNAME_KEY\", user);\n            }\n        } catch (IOException e) {\n            // TODO Auto-generated catch block\n            e.printStackTrace();\n        }   \n        try {\n\n            byte[ ] superSecretKeyBytes = Base64.decode(pass);\n            byte[] key = { 0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 0, 1, 2, 3, 4, 5, 6 };\n            for (int i = 0; i < superSecretKeyBytes.length && i < key.length; i++) {\n                key[i] = superSecretKeyBytes[i];\n                myEditor.putString(\"PASSWORD_KEY\", pass);\n            }\n        } catch (IOException e) {\n            // TODO Auto-generated catch block\n            e.printStackTrace();\n        }\n\n        myEditor.commit();\n        Toast.makeText(this, \"Registration is successfull\",10000).show();\n        i=new Intent(this,AccessApp.class);\n        startActivity(i);\n        }\n        else\n         {\n          Toast.makeText(this, \"Please Enter password\", 10000).show();  \n         }\n         }\n        else{\n            Toast.makeText(this,\"Please Enter Username\",10000).show();\n         }\n        }\n\n    else if(arg0==rtnBttn){\n        AlertDialog.Builder builder=new AlertDialog.Builder(this);\n         builder.setTitle(\"Exit\");\n         builder.setMessage(\"Do you want to exit\");\n         builder.setCancelable(false);\n         builder.setPositiveButton(\"Yes\",new DialogInterface.OnClickListener() {\n\n  public void onClick(DialogInterface dialog, int which) {\n  // TODO Auto-generated method stub\n  finish();\n  }\n  });\n    builder.setNegativeButton(\"No\", new DialogInterface.OnClickListener() {\n\n            public void onClick(DialogInterface arg0, int arg1) {\n               arg0.cancel();\n            }\n        });\n    AlertDialog alert=builder.create();\n    alert.show();\n\n    }\n}\npublic String encrypt(String toencrypt, byte key[]) throws Exception {\n    SecretKeySpec secret = new SecretKeySpec(key, \"AES\");\n    Cipher cipher = Cipher.getInstance(\"AES\");\n    cipher.init(Cipher.ENCRYPT_MODE, secret);\n    byte[] encryptedbytes = cipher.doFinal(toencrypt.getBytes());\n    String encrypted = Base64.encodeBytes(encryptedbytes, 0);\n    return encrypted;\n\n}\n\n}\n", "idx": 1916}
{"project": "cipher", "commit_id": "Snippet12685475_36393.java", "target": 1, "func": "    public String encrypt(SecretKey key, String message){ \n        Cipher cipher = Cipher.getInstance(\"AES/CBC/PKCS5Padding\");              \n        cipher.init(Cipher.ENCRYPT_MODE, key);        \n        byte[] stringBytes = message.getBytes(\"UTF8\");       \n        byte[] raw = cipher.doFinal(stringBytes);\n\n        // converts to base64 for easier display.\n        BASE64Encoder encoder = new BASE64Encoder();\n        String base64 = encoder.encode(raw);\n\n        return base64;\n\n    }\n", "idx": 1942}
{"project": "cipher", "commit_id": "Snippet6553036_32188.java", "target": 1, "func": "import java.security.NoSuchAlgorithmException;\n\nimport javax.crypto.Cipher;\nimport javax.crypto.NoSuchPaddingException;\nimport javax.crypto.spec.IvParameterSpec;\nimport javax.crypto.spec.SecretKeySpec;\n\npublic class MCrypt {\n\n    private String iv = \"fedcba9876543210\";//Dummy iv (CHANGE IT!)\n    private IvParameterSpec ivspec;\n    private SecretKeySpec keyspec;\n    private Cipher cipher;\n\n    private String SecretKey = \"0123456789abcdef\";//Dummy secretKey (CHANGE IT!)\n\n    public MCrypt()\n    {\n        ivspec = new IvParameterSpec(iv.getBytes());\n\n        keyspec = new SecretKeySpec(SecretKey.getBytes(), \"AES\");\n\n        try {\n            cipher = Cipher.getInstance(\"AES/CBC/NoPadding\");\n        } catch (NoSuchAlgorithmException e) {\n            // TODO Auto-generated catch block\n            e.printStackTrace();\n        } catch (NoSuchPaddingException e) {\n            // TODO Auto-generated catch block\n            e.printStackTrace();\n        }\n    }\n\n    public byte[] encrypt(String text) throws Exception\n    {\n        if(text == null || text.length() == 0)\n            throw new Exception(\"Empty string\");\n\n        byte[] encrypted = null;\n\n        try {\n            cipher.init(Cipher.ENCRYPT_MODE, keyspec, ivspec);\n\n            encrypted = cipher.doFinal(padString(text).getBytes());\n        } catch (Exception e)\n        {           \n            throw new Exception(\"[encrypt] \" + e.getMessage());\n        }\n\n        return encrypted;\n    }\n\n    public byte[] decrypt(String code) throws Exception\n    {\n        if(code == null || code.length() == 0)\n            throw new Exception(\"Empty string\");\n\n        byte[] decrypted = null;\n\n        try {\n            cipher.init(Cipher.DECRYPT_MODE, keyspec, ivspec);\n\n            decrypted = cipher.doFinal(hexToBytes(code));\n        } catch (Exception e)\n        {\n            throw new Exception(\"[decrypt] \" + e.getMessage());\n        }\n        return decrypted;\n    }\n\n\n\n    public static String bytesToHex(byte[] data)\n    {\n        if (data==null)\n        {\n            return null;\n        }\n\n        int len = data.length;\n        String str = \"\";\n        for (int i=0; i<len; i++) {\n            if ((data[i]&0xFF)<16)\n                str = str + \"0\" + java.lang.Integer.toHexString(data[i]&0xFF);\n            else\n                str = str + java.lang.Integer.toHexString(data[i]&0xFF);\n        }\n        return str;\n    }\n\n\n    public static byte[] hexToBytes(String str) {\n        if (str==null) {\n            return null;\n        } else if (str.length() < 2) {\n            return null;\n        } else {\n            int len = str.length() / 2;\n            byte[] buffer = new byte[len];\n            for (int i=0; i<len; i++) {\n                buffer[i] = (byte) Integer.parseInt(str.substring(i*2,i*2+2),16);\n            }\n            return buffer;\n        }\n    }\n\n\n\n    private static String padString(String source)\n    {\n      char paddingChar = ' ';\n      int size = 16;\n      int x = source.length() % size;\n      int padLength = size - x;\n\n      for (int i = 0; i < padLength; i++)\n      {\n          source += paddingChar;\n      }\n\n      return source;\n    }\n}\n", "idx": 2258}
{"project": "cipher", "commit_id": "Snippet31675689_13778.java", "target": 1, "func": "public byte[] encrypt(byte[] msg, byte[] key, byte[] iv) throws Exception {\n    //prepare key\n    SecretKeySpec secretKeySpec = new SecretKeySpec(key, \"AES\");\n\n    //prepare cipher\n    String cipherALG = \"AES/CBC/PKCS5padding\"; // use your preferred algorithm \n    Cipher cipher = Cipher.getInstance(cipherALG);\n    String string = cipher.getAlgorithm();\n\n    //as iv (Initial Vector) is only required for CBC mode\n    if (string.contains(\"CBC\")) {\n        IvParameterSpec ivParameterSpec = new IvParameterSpec(iv);      \n        cipher.init(Cipher.ENCRYPT_MODE, secretKeySpec, ivParameterSpec);\n    } else {\n        cipher.init(Cipher.ENCRYPT_MODE, secretKeySpec);\n    }\n\n    byte[] encMessage = cipher.doFinal(msg);        \n    return encMessage;\n}\n", "idx": 2130}
{"project": "cipher", "commit_id": "Snippet20935751_3524.java", "target": 1, "func": "private IvParameterSpec ivspec;\nprivate SecretKeySpec keyspec;\nprivate Cipher cipher;\nprivate String iv = \"cant hear you\";\nprivate String SecretKey = \"top secret\";\n\npublic MCrypt()\n{\n    ivspec = new IvParameterSpec(iv.getBytes());\n    keyspec = new SecretKeySpec(SecretKey.getBytes(), \"AES\");                        \n    try {            \n        cipher = Cipher.getInstance(\"AES/CBC/NoPadding\");\n    } catch (NoSuchAlgorithmException e) {\n         e.printStackTrace();\n    } catch (NoSuchPaddingException e) {\n        e.printStackTrace();\n    }\n}\n\npublic byte[] encrypt(String text) throws Exception{\n    if(text == null || text.length() == 0) throw new Exception(\"Empty string\");\n\n    byte[] bs = text.getBytes(\"UTF-8\");\n\n    byte[] toEncrypt = padBytes(bs);\n    byte[] encrypted = null;\n    try {\n        cipher.init(Cipher.ENCRYPT_MODE, keyspec, ivspec);\n        encrypted = cipher.doFinal(toEncrypt);\n    } catch (Exception e){                       \n            throw new Exception(\"[encrypt] \" + e.getMessage());\n    }\n    return encrypted;\n}\n\npublic byte[] decrypt(String code) throws Exception{\n    if(code == null || code.length() == 0)  throw new Exception(\"Empty string\");        \n    byte[] decrypted = null;\n    try {\n        cipher.init(Cipher.DECRYPT_MODE, keyspec, ivspec);                \n        decrypted = cipher.doFinal(hexToBytes(code));\n    } catch (Exception e){\n        throw new Exception(\"[decrypt] \" + e.getMessage());\n    }\n    return decrypted;\n}\n\n\n\n    public static String bytesToHex(byte[] data){\n        if (data==null){\n            return null;\n        }            \n        int len = data.length;\n        String str = \"\";\n        for (int i=0; i<len; i++) {\n            if ((data[i]&0xFF)<16)\n                    str = str + \"0\" + java.lang.Integer.toHexString(data[i]&0xFF);\n            else\n                    str = str + java.lang.Integer.toHexString(data[i]&0xFF);\n        }\n        return str;\n    }\n\n\n    public static byte[] hexToBytes(String str) {\n            if (str==null) {\n                    return null;\n            } else if (str.length() < 2) {\n                    return null;\n            } else {\n                    int len = str.length() / 2;\n                    byte[] buffer = new byte[len];\n                    for (int i=0; i<len; i++) {\n                            buffer[i] = (byte) Integer.parseInt(str.substring(i*2,i*2+2),16);\n                    }\n                    return buffer;\n            }\n    }\n\n\n\n    private static byte[] padBytes(byte[] source){\n        char paddingChar = ' ';\n        int size = 16;\n        int x = source.length % size;\n        int padLength = size - x;\n        int bufferLength = source.length + padLength;\n        byte[] ret = new byte[bufferLength];\n        int i = 0;\n        for ( ; i < source.length; i++){\n            ret[i] = source[i];\n        }\n        for ( ; i < bufferLength; i++){\n            ret[i] = (byte)paddingChar;\n        }\n\n        return ret;\n    }\n} // class close\n", "idx": 2021}
{"project": "cipher", "commit_id": "Snippet43205977_25343.java", "target": 0, "func": "public static String decryptString(String src) throws Exception\n    {\n        String dst = \"\";\n\n            SecretKey secret_key = KeyGenerator.getInstance(\"DES\").generateKey();\n            AlgorithmParameterSpec alogrithm_specs = new IvParameterSpec(initialization_vector);\n            //encrypt = Cipher.getInstance(\"DES/CBC/PKCS5Padding\");\n            //encrypt.init(Cipher.ENCRYPT_MODE, secret_key, alogrithm_specs);\n            decrypt = Cipher.getInstance(\"DES/CBC/PKCS5Padding\");\n            decrypt.init(Cipher.DECRYPT_MODE, secret_key, alogrithm_specs);\n            //encrypt(new FileInputStream(plain), new FileOutputStream(cipher));\n            //decrypt(new FileInputStream(encryptedFile), new FileOutputStream(decryptedFile));\n            //System.out.println(\"End of Encryption/Decryption procedure!\");\n            ByteArrayOutputStream baos = new ByteArrayOutputStream();\n            CipherOutputStream cout = new CipherOutputStream(baos,encrypt);\n            cout.write(src.getBytes());\n            cout.flush();               //ByteOutputStream -> Write Encryption Text\n            cout.close(); \n            dst = DatatypeConverter.printHexBinary(baos.toByteArray());\n            return dst;\n    }\n", "idx": 1885}
{"project": "cipher", "commit_id": "Snippet9596335_34048.java", "target": 0, "func": "// get cipher object for password-based encryption\nCipher cipher1 = Cipher.getInstance(\"PBEWithMD5AndDES\");//You have to pass here algorithm name which PGP uses. May be you have to find and init provider for it.\n\n// initialize cipher for decryption, using one of the \n// init() methods that takes an AlgorithmParameters \n// object, and pass it the algParams object from above\ncipher1.init(Cipher.DECRYPT_MODE, myKey, algParams);\n\n\nFileInputStream fis;\nFileOutputStream fos;\nCipherInputStream cis;\n\nfis = new FileInputStream(\"/tmp/a.txt\");\ncis = new CipherInputStream(fis, cipher1);\nfos = new FileOutputStream(\"/tmp/b.txt\");\nbyte[] b = new byte[8];\nint i = cis.read(b);\nwhile (i != -1) {\n    fos.write(b, 0, i);\n    i = cis.read(b);\n}\nfos.close();\n", "idx": 1596}
{"project": "cipher", "commit_id": "Snippet34133679_15602.java", "target": 1, "func": "byte keySelectedByUser[] = selectedKey.getBytes();\nSecretKeySpec secretKey = new SecretKeySpec(keySelectedByUser, \"AES\");\n\nCipher cipher;\n\ncipher = Cipher.getInstance(\"AES/CBC/PKCS7PADDING\");\n\ncipher.init(Cipher.ENCRYPT_MODE, secretKey);\n\nbyte[] encrypted = cipher.doFinal(stringToEncrypt.getBytes());\n", "idx": 1955}
{"project": "cipher", "commit_id": "Snippet41584629_23504.java", "target": 1, "func": "        createPrivateKey();\n        createPublicKey();\n\n        String data = \"12\";\n\n        Cipher cipher1 = Cipher.getInstance(\"RSA/ECB/NoPadding\");\n        cipher1.init(Cipher.ENCRYPT_MODE, publicKey);\n        byte[] encryptedData = cipher1.doFinal(data.getBytes());\n\n        Cipher cipher2 = Cipher.getInstance(\"RSA/ECB/NoPadding\");\n        cipher2.init(Cipher.DECRYPT_MODE,privateKey);\n        byte[] decryptedData = cipher2.doFinal(encryptedData);\n        System.out.println(new String(decryptedData));\n", "idx": 2214}
{"project": "cipher", "commit_id": "Snippet8990891_33601.java", "target": 1, "func": "public static String encrypt(String input, String key){\n\n    try {\n\n        byte[] ivBytes = new byte[16];\n        SecureRandom.getInstance(\"SHA1PRNG\").nextBytes(ivBytes);\n\n        IvParameterSpec ips = new IvParameterSpec(ivBytes);\n        byte[] keybytes = md5(key);//This isn't final. Don't worry ;)\n        byte[] crypted = null;\n        SecretKeySpec skey = new SecretKeySpec(keybytes, \"AES\");\n        Cipher cipher = Cipher.getInstance(\"AES/CBC/PKCS5Padding\");\n        cipher.init(Cipher.ENCRYPT_MODE, skey, ips);\n        byte[] ptext = input.getBytes(\"UTF-8\");\n        crypted = cipher.doFinal(ptext);\n\n        return Base64.encodeBase64String(ivBytes)+Base64.encodeBase64String(crypted);\n    }catch(Exception e){\n        e.printStackTrace();\n    }\n    return null;\n}\n\npublic static String[] decrypt(String input, String key){\n\n    String iv = input.substring(0, 24);\n    String encrypted = input.substring(24);\n    try {\n        IvParameterSpec ips = new IvParameterSpec(Base64.decodeBase64(iv));\n        byte[] keybytes = md5(key);//This isn't final. Don't worry ;)\n        byte[] output = null;\n        SecretKeySpec skey = new SecretKeySpec(keybytes, \"AES\");\n        Cipher cipher = Cipher.getInstance(\"AES/CBC/PKCS5Padding\");\n        cipher.init(Cipher.DECRYPT_MODE, skey, ips);\n        output = cipher.doFinal(Base64.decodeBase64(encrypted));\n        if(output==null){\n            throw new Exception();\n        }\n\n        return new String[]{new String(output),iv};\n    }catch(Exception e){\n        e.printStackTrace();\n    }\n}\n", "idx": 2020}
{"project": "cipher", "commit_id": "Snippet15709421_38719.java", "target": 1, "func": "final Cipher cipher = Cipher.getInstance(\"AES/CBC/NoPadding\");\ncipher.init(Cipher.ENCRYPT_MODE, key, iv);\ncipher.doFinal(*something*);\n", "idx": 2303}
{"project": "cipher", "commit_id": "Snippet24343938_6646.java", "target": 1, "func": "public byte[] encrypt(PublicKey key, byte[] plaintext) throws NoSuchAlgorithmException, NoSuchPaddingException, InvalidKeyException, IllegalBlockSizeException, BadPaddingException\n{\n    Cipher cipher = Cipher.getInstance(\"RSA/ECB/OAEPWithSHA1AndMGF1Padding\");   \n    cipher.init(Cipher.ENCRYPT_MODE, key);  \n    return cipher.doFinal(plaintext);\n}\n\npublic byte[] decrypt(PrivateKey key, byte[] ciphertext) throws NoSuchAlgorithmException, NoSuchPaddingException, InvalidKeyException, IllegalBlockSizeException, BadPaddingException\n{\n    Cipher cipher = Cipher.getInstance(\"RSA/ECB/OAEPWithSHA1AndMGF1Padding\");   \n    cipher.init(Cipher.DECRYPT_MODE, key);  \n    return cipher.doFinal(ciphertext);\n}\n", "idx": 2244}
{"project": "cipher", "commit_id": "Snippet39509662_21432.java", "target": 0, "func": "import java.lang.reflect.InvocationTargetException;\nimport java.lang.reflect.Method;\nimport java.nio.charset.StandardCharsets;\nimport java.util.prefs.Preferences;\nimport javax.crypto.Cipher;\nimport javax.crypto.KeyGenerator;\nimport javax.crypto.SecretKey;\nimport javax.xml.bind.DatatypeConverter;\n\npublic class Test {\n    private Test() {  } \n    /**\n     * gets the AES encryption key. \n     * @return\n     * @throws Exception\n     */\n    public static SecretKey getSecretEncryptionKey() throws Exception \n    {\n        KeyGenerator generator = KeyGenerator.getInstance(\"AES\");\n        generator.init(128); \n        SecretKey secKey = generator.generateKey();\n        return secKey;\n    } \n    /**\n     * Encrypts password in AES using the secret key.\n     * @param passWord\n     * @param secKey\n     * @return\n     * @throws Exception\n     */\n    public static byte[] encryptText(String passWord,SecretKey secKey) throws Exception \n    {        \n        Cipher aesCipher = Cipher.getInstance(\"AES\");\n        aesCipher.init(Cipher.ENCRYPT_MODE, secKey);\n        byte[] byteCipherText = aesCipher.doFinal(passWord.getBytes());\n        return byteCipherText;\n    }\n    /**\n     * Decrypts encrypted byte array using the key used for encryption.\n     * @param byteCipherText\n     * @param secKey\n     * @return\n     * @throws Exception\n     */\n    public static String decryptText(byte[] byteCipherText, SecretKey secKey) throws Exception \n    {\n        Cipher aesCipher = Cipher.getInstance(\"AES\");\n        aesCipher.init(Cipher.DECRYPT_MODE, secKey);\n        byte[] bytePlainText = aesCipher.doFinal(byteCipherText);\n        return new String(bytePlainText);\n    }\n    //converting byte[] to string\n    private static String bytesToString(byte[] bytesArray)\n    {         \n        StringBuffer stringBuffer = new StringBuffer();         \n        for (int i = 0; i < bytesArray.length; i++) {             \n            stringBuffer.append((char) bytesArray[i]);         \n        }         \n        return stringBuffer.toString();     \n    }\n\n    public static void main(String args[]) throws Exception \n    {\n        SecretKey secKey = getSecretEncryptionKey();        \n        String s = null;        \n        String Username = null;\n        String Password = null;     \n        String value = null;    \n        try \n        {\n            if(args[0] != null)\n                Username = args[0];\n            if(args[1] != null)\n                Password = args[1];     \n        }\n        catch (ArrayIndexOutOfBoundsException e) {\n            System.out.println(\"ArrayIndexOutOfBoundsException caught\");\n        }\n        finally {           \n        } \n        byte[] cipherText = encryptText(Password, secKey);\n        s = bytesToString(cipherText);      //junk value getting here, i'm expecting same encrypted value here even after converting byte[] to string\n        System.out.println(\"Encrypted cipherText = \" + cipherText);\n        System.out.println(\"Encrypted Password = \" + s);        \n        System.out.println(\"Done.\" );\n    }\n}\n", "idx": 1893}
{"project": "cipher", "commit_id": "Snippet4951865_31415.java", "target": 0, "func": "public String Encryption(String toEncrypt) throws Exception\n{\n    Security.addProvider(new org.bouncycastle.jce.provider.BouncyCastleProvider());\n    EditText et = (EditText) findViewById(R.id.entry);\n    byte[] input = toEncrypt.getBytes();\n    byte[] keyBytes = \"hello\".getBytes();\n    // et.setText(\"in encryption\");\n    SecretKeySpec key = new SecretKeySpec(keyBytes, \"AES\");\n    Cipher cipher = Cipher.getInstance(\"AES/ECB/PKCS7Padding\", \"BC\");\n    // et.setText(\"in encryption\");\n\n    cipher.init(Cipher.ENCRYPT_MODE, key);\n\n    et.setText(\"in encryption\");\n    byte[] cipherText = new byte[cipher.getOutputSize(input.length)];\n    int ctLength = cipher.update(input, 0, input.length, cipherText, 0);\n    ctLength += cipher.doFinal(cipherText, ctLength);\n    // et.setText(\"in encryption\");\n    // return \"abc\";\n    return cipherText.toString();\n", "idx": 1902}
{"project": "cipher", "commit_id": "Snippet35228318_17158.java", "target": 1, "func": "static byte[] bytes = new byte[16];\n\npublic static byte[] encrypt(String key, String message) {\n    try {\n        SecureRandom random = new SecureRandom();\n        random.nextBytes(bytes);\n\n        System.out.println(\"Outputting generated IV:\");\n        for(int i=0; i < bytes.length; i++){\n            System.out.println(bytes[i]);\n        }\n\n        IvParameterSpec iv = new IvParameterSpec(bytes);\n        SecretKeySpec skeySpec = new SecretKeySpec(key.getBytes(\"UTF-8\"), \"AES\");\n\n        Cipher cipher = Cipher.getInstance(\"AES/CBC/PKCS5PADDING\");\n        cipher.init(Cipher.ENCRYPT_MODE, skeySpec, iv);\n\n        byte[] encrypted = Base64.encodeBase64(cipher.doFinal(message.getBytes()));\n        System.out.println(\"encrypted string: \"\n                + Base64.encodeBase64String(encrypted));\n\n        byte[] sendMe = new byte[bytes.length + encrypted.length];\n        System.arraycopy(bytes, 0, sendMe, 0, bytes.length);\n        System.arraycopy(encrypted, 0, sendMe, 0, encrypted.length);\n\n        return  sendMe;\n    } catch (Exception ex) {\n        ex.printStackTrace();\n    }\n\n    return null;\n}\n\npublic static String decrypt(String key, byte[] received) {\n    try {\n\n        byte[] initVector = Arrays.copyOfRange(received, 0, 16);\n        byte[] encrypted = Arrays.copyOfRange(received, 16, received.length+1);\n\n        System.out.println(\"Outputting received IV:\");\n        for(int i = 0; i < initVector.length; i++){\n            System.out.println(initVector[i]);\n        }\n\n        IvParameterSpec iv = new IvParameterSpec(initVector);\n        SecretKeySpec skeySpec = new SecretKeySpec(key.getBytes(\"UTF-8\"), \"AES\");\n\n        Cipher cipher = Cipher.getInstance(\"AES/CBC/PKCS5PADDING\");\n        cipher.init(Cipher.DECRYPT_MODE, skeySpec, iv);\n\n        byte[] original = cipher.doFinal(Base64.decodeBase64(encrypted));\n\n        return new String(original);\n    } catch (Exception ex) {\n        ex.printStackTrace();\n    }\n\n    return null;\n}\n", "idx": 2156}
{"project": "cipher", "commit_id": "Snippet19196267_2036.java", "target": 1, "func": "String skey = \"6543210987654321\";\nString siv = \"1234567890123456\";\nString sinput = \"Encrypt_this_text\";\n\nbyte[] key = skey.getBytes(\"UTF8\");\nbyte[] iv = siv.getBytes(\"UTF8\");\nbyte[] input = sinput.getBytes(\"UTF8\");\n\nCipher cipher = Cipher.getInstance(\"AES/CBC/ZeroBytePadding\");\nSecretKeySpec keyspec = new SecretKeySpec(key, \"AES\" );\nIvParameterSpec ivparams = new IvParameterSpec(iv);\ncipher.init(Cipher.ENCRYPT_MODE, keyspec, ivparams);\n\nbyte[] encrypted = cipher.doFinal(input);\n", "idx": 2157}
{"project": "cipher", "commit_id": "Snippet8467380_33261.java", "target": 0, "func": "package betterencryption;   \n\nimport javax.crypto.*;\nimport javax.crypto.spec.*;\nimport java.util.Scanner;\n\n public class BetterEncryption {\n\n public static String asHex (byte buf[]) {               //asHex works just fine, it's the main that's\n                                                         //giving me trouble\n  StringBuffer strbuf = new StringBuffer(buf.length * 2);\n  int i;\n\n  for (i = 0; i < buf.length; i++) {\n   if (((int) buf[i] & 0xff) < 0x10)\n    strbuf.append(\"0\");\n\n   strbuf.append(Long.toString((int) buf[i] & 0xff, 16));\n  }\n\n  return strbuf.toString();\n }\n\n public static void main(String[] args) throws Exception {\n   Scanner sc = new Scanner(System.in);\n   KeyGenerator kgen = KeyGenerator.getInstance(\"AES\");kgen.init(128); \n   SecretKey skey = kgen.generateKey();\n   byte[] bytes = skey.getEncoded();\n   SecretKeySpec skeySpec = new SecretKeySpec(bytes, \"AES\");\n   Cipher cipher = Cipher.getInstance(\"AES\");\n   System.out.print(\"Do you want to encrypt or unencrypt?\\n\");/*This is a weird way of doing it,*/\n   String choice = sc.next(); char cc = choice.charAt(2);     /*I know, but this part checks to see if*/       \n   if(cc=='c'){                                               /*the program is to encrypt or unencrypt*/\n   System.out.print(\"Enter a string to encrypt: \");          /* a string. The 'encrypt' function works.*/\n   String message = sc.next();\n\n\n   cipher.init(Cipher.ENCRYPT_MODE, skeySpec);\n   byte[] encrypted = cipher.doFinal((args.length == 0 ? message : args[0]).getBytes());\n   System.out.println(\"Encrypted string: \" + asHex(encrypted)+\"\\nKey: \"+asHex(bytes));\n\n   //^This^ section actually works! The code outputs an encrypted string and everything.\n   //It's beautiful\n   //Unfortunately getting that string back into readable text has been problematic\n   //Which is where you guys come in!\n   //Hopefully\n\n }\n  if(true){\n   System.out.print(\"\\nEnter the encrypted string: \"); String encryptedString = sc.next();\n   System.out.print(\"\\nEnter the key: \"); String keyString = sc.next();\n   int len = encryptedString.length();    /*this section converts the user-input string*/\n   byte[] encrypted = new byte[len / 2];  /*into an array of bytes*/\n   for (int i = 0; i < len; i += 2) {     /*I'm not sure if it works, though*/\n   encrypted[i / 2] = (byte) ((Character.digit(encryptedString.charAt(i), 16) << 4)+\n           Character.digit(encryptedString.charAt(i+1), 16));\n   cipher.init(Cipher.DECRYPT_MODE, skeySpec); /*as you can see, I haven't even begun to implement*/ \n   byte[] original = cipher.doFinal(encrypted);/*a way to allow the user-input key to be used.*/\n   String originalString = new String(original);\n   System.out.println(\"\\nOriginal string: \"+originalString); //I'm really quite stuck.\n      //can you guys help?\n  } \n\n }\n   }\n}\n", "idx": 1745}
{"project": "cipher", "commit_id": "Snippet30081041_12210.java", "target": 0, "func": "    import javax.crypto.spec.SecretKeySpec;\n\n    class Encrypter\n{\n    String alg = \"AES\";\n    Key key;\n    Cipher cipher;\n\n    public Encrypter() throws Exception\n    {\n         //key = KeyGenerator.getInstance(alg).generateKey();\nkey = new SecretKeySpec(\"C@ThA$rpma#EsP!!\".getBytes(), \"AES\");\n         cipher = Cipher.getInstance(alg);\n    }\n\n    public byte[] encrypt(String str) throws Exception\n    {\n        cipher.init(Cipher.ENCRYPT_MODE, key);\n        byte[] inBytes = str.getBytes(\"UTF-16\");\n\n        return cipher.doFinal(inBytes);\n    }\n\n    public String decrypt(byte[] enBytes) throws Exception\n    {\n        cipher.init(Cipher.DECRYPT_MODE, key);\n        byte[] bytes = cipher.doFinal(enBytes);\n        String rData = new String(bytes, \"UTF-16\");\n\n        return rData;\n    }\n}\n", "idx": 1857}
{"project": "cipher", "commit_id": "Snippet29455404_11470.java", "target": 1, "func": "public static String encrypt(String plainText, String key){\n    try{\n        PublicKey publicKey = KeyFactory.getInstance(\"RSA\").generatePublic(new X509EncodedKeySpec(Base64.decode(key, Base64.DEFAULT)));\n        Cipher cipher = Cipher.getInstance(\"RSA/ECB/PKCS1Padding\");\n        cipher.init(Cipher.ENCRYPT_MODE, publicKey);\n        return Base64.encodeToString(cipher.doFinal(plainText.getBytes(\"UTF-8\")),Base64.DEFAULT);\n    }catch (Exception e) {\n        e.printStackTrace();\n    }\n    return null;\n}\n", "idx": 2061}
{"project": "cipher", "commit_id": "Snippet26267113_8464.java", "target": 1, "func": "import javax.crypto.Cipher; import javax.crypto.spec.IvParameterSpec;\nimport javax.crypto.spec.SecretKeySpec;\n\nimport org.apache.commons.codec.binary.Base64;\n\npublic class Encryptor {\n    public static String encrypt(String key1, String key2, String value) {\n        try {\n            IvParameterSpec iv = new IvParameterSpec(key2.getBytes(\"UTF-8\"));\n\n            SecretKeySpec skeySpec = new SecretKeySpec(key1.getBytes(\"UTF-8\"),\n                    \"AES\");\n            Cipher cipher = Cipher.getInstance(\"AES/CBC/PKCS5PADDING\");\n            cipher.init(Cipher.ENCRYPT_MODE, skeySpec, iv);\n            byte[] encrypted = cipher.doFinal(value.getBytes());\n            System.out.println(\"encrypted string:\"\n                    + Base64.encodeBase64String(encrypted));\n            return Base64.encodeBase64String(encrypted);\n        } catch (Exception ex) {\n            ex.printStackTrace();\n        }\n        return null;\n    }\n\n    public static String decrypt(String key1, String key2, String encrypted) {\n        try {\n            IvParameterSpec iv = new IvParameterSpec(key2.getBytes(\"UTF-8\"));\n\n            SecretKeySpec skeySpec = new SecretKeySpec(key1.getBytes(\"UTF-8\"),\n                    \"AES\");\n            Cipher cipher = Cipher.getInstance(\"AES/CBC/PKCS5PADDING\");\n            cipher.init(Cipher.DECRYPT_MODE, skeySpec, iv);\n            byte[] original = cipher.doFinal(Base64.decodeBase64(encrypted));\n\n            return new String(original);\n        } catch (Exception ex) {\n            ex.printStackTrace();\n        }\n        return null;\n    }\n\n    public static void main(String[] args) {\n\n        String key1 = \"Bar12345Bar12345\"; // 128 bit key\n        String key2 = \"ThisIsASecretKet\";\n        System.out.println(decrypt(key1, key2,\n                encrypt(key1, key2, \"Hello World\")));\n    }\n}\n", "idx": 2045}
{"project": "cipher", "commit_id": "Snippet31771658_13838.java", "target": 1, "func": "    AssetManager assetManager=activity.getAssets();\n    InputStream in=assetManager.open(\"certificate.crt\");\n    CertificateFactory certificateFactory = CertificateFactory.getInstance(\"X.509\");\n    X509Certificate certificate = (X509Certificate)certificateFactory.generateCertificate(in);\n    PublicKey publicServerKey = certificate.getPublicKey();\n    Cipher cipher = Cipher.getInstance(\"RSA\");\n    cipher.init(Cipher.ENCRYPT_MODE,publicServerKey);\n    byte[] parametersCipher = cipher.doFinal(parameters.getBytes());\n    String encoded=new String(Base64.encode(parametersCipher, Base64.DEFAULT));\n    String parametersencrypted=\"data=\"+URLEncoder.encode(encoded,\"UTF-8\");\n", "idx": 1980}
{"project": "cipher", "commit_id": "Snippet35106909_17045.java", "target": 0, "func": "public class AES_Cipher {\n\n    private String keyString;\n    private byte[] byteKey;\n    private SecretKey key;\n    Cipher c;\n\n    public AES_Cipher(String keyString){\n        this.keyString = keyString.toString();\n    }\n\n    public void init() throws InitializtionFailedException{\n        try{\n            c = Cipher.getInstance(\"AES/ECB/PKCS5Padding\");\n            byteKey = keyString.getBytes(\"UTF-8\");\n            MessageDigest sha = MessageDigest.getInstance(\"SHA-1\");\n            byteKey = sha.digest(byteKey);\n            byteKey = Arrays.copyOf(byteKey, 16);\n            key = new SecretKeySpec(byteKey, \"AES\");\n\n        }catch(NoSuchAlgorithmException e){\n            throw new InitializtionFailedException();\n        }\n}\n", "idx": 1838}
{"project": "cipher", "commit_id": "Snippet46159066_28268.java", "target": 1, "func": "OAEPParameterSpec sp = new OAEPParameterSpec(\"SHA-256\", \"MGF1\", new MGF1ParameterSpec(\"SHA-1\"), PSource.PSpecified.DEFAULT);\nCipher cipher = Cipher.getInstance(\"RSA/ECB/OAEPWithSHA-256AndMGF1Padding\");\ncipher.init(Cipher.DECRYPT_MODE, this.getPrivateKey(context), sp);\n", "idx": 2122}
{"project": "cipher", "commit_id": "Snippet39945818_21845.java", "target": 1, "func": "import java.security.SecureRandom;\nimport javax.crypto.Cipher;\nimport javax.crypto.CipherInputStream;\nimport javax.crypto.CipherOutputStream;\nimport javax.crypto.spec.IvParameterSpec;\nimport javax.crypto.spec.SecretKeySpec;\nimport java.io.FileInputStream;\nimport java.io.FileOutputStream;\n\npublic class FileReadWrite {\n\n    public static byte[] getAESKey() {\n        SecureRandom secureRandom = new SecureRandom();\n        byte[] bytes = new byte[32];\n        secureRandom.nextBytes(bytes);\n        return bytes;\n    }\n/**\n * Method used to generate a random new iv\n * \n * @return Randomly generated iv\n */\npublic static byte[] getAESIV() {\n    SecureRandom secureRandom = new SecureRandom();\n    byte[] bytes = new byte[16];\n    secureRandom.nextBytes(bytes);\n    return bytes;\n}\npublic static void main(String[] args) throws Exception {\n    // TODO Auto-generated method stub\n    FileInputStream fin = new FileInputStream(\"/Users/emp/Research/Streams/input_file.txt\");\n    FileOutputStream fout = new FileOutputStream(\"/Users/emp/Research/Streams/output_file.txt\");\n\n    SecretKeySpec keySpec = null;\n    IvParameterSpec ivSpec = null;\n    Cipher ecipher = null;\n    Cipher dcipher = null;\n    byte[] keyBytes = getAESKey();\n    byte[] ivBytes = getAESIV();\n    // Creating keyspec and ivspec for generating cipher\n    keySpec = new SecretKeySpec(keyBytes,\"AES\");\n    ivSpec = new IvParameterSpec(ivBytes);\n    try {\n        ecipher = Cipher.getInstance(\"AES/CTR/NoPadding\");\n        ecipher.init(Cipher.ENCRYPT_MODE, keySpec, ivSpec);\n    } catch (Exception e) {\n        System.out.println(\"Thus the exception occured during cipher generation is ::: \"+e);\n    }\n\n    CipherOutputStream cout = new CipherOutputStream(fout, ecipher);\n    try {\n        int count = 0;\n        int BUFFER_SIZE = 1024;\n        byte[] bytearray = new byte[BUFFER_SIZE];\n        while((count = fin.read(bytearray, 0, BUFFER_SIZE)) != -1) {\n            //fout.write(bytearray, 0, count);\n            cout.write(bytearray, 0, count);\n        }\n    } catch(Exception ex) {\n        System.out.println(\"Thus the exception occured is ::: \"+ex);\n    } finally {\n        fin.close();\n        fout.close();\n        cout.close();\n    }\n\n    fin = new FileInputStream(\"/Users/emp/Research/Streams/output_file.txt\");\n    fout = new FileOutputStream(\"/Users/emp/Research/Streams/decrypted_file.txt\");\n\n    try {\n        dcipher = Cipher.getInstance(\"AES/CTR/NoPadding\");\n        dcipher.init(Cipher.DECRYPT_MODE, keySpec, ivSpec);\n    } catch (Exception e) {\n        System.out.println(\"Thus the exception occured during cipher generation is ::: \"+e);\n    }\n    //fin.skip(1024);\n    CipherInputStream cin = new CipherInputStream(fin, dcipher);\n    try {\n        int count = 0;\n        int BUFFER_SIZE = 1024;\n        byte[] bytearray = new byte[BUFFER_SIZE];\n\n        **//cin.read(bytearray, 0, 30);**\n\n        while((count = cin.read(bytearray, 0, BUFFER_SIZE)) != -1) {\n            //fout.write(bytearray, 0, count);\n            fout.write(bytearray, 0, count);\n        }\n    } catch(Exception ex) {\n        System.out.println(\"Thus the exception occured is ::: \"+ex);\n    } finally {\n        fin.close();\n        cin.close();\n        fout.close();\n    }\n\n    System.out.println(\"File read write completed successfully !!! \");\n}\n}\n", "idx": 2341}
{"project": "cipher", "commit_id": "Snippet29717950_11790.java", "target": 1, "func": "import static java.nio.charset.StandardCharsets.*;\n\nimport java.security.GeneralSecurityException;\nimport java.security.SecureRandom;\n\nimport javax.crypto.Cipher;\nimport javax.crypto.SecretKey;\nimport javax.crypto.spec.IvParameterSpec;\nimport javax.crypto.spec.SecretKeySpec;\nimport javax.xml.bind.DatatypeConverter;\n\npublic class SecurityHelperCTR {\n    private static final int NONCE_SIZE = 8;\n    // make sure that the hexadecimals represent a *truly random* byte array\n    // (e.g. use SecureRandom)\n    private final SecretKey STATIC_SECRET_KEY = new SecretKeySpec(\n            hexDecode(\"66e517bb5fd7df840060aed7e8b58986\"), \"AES\");\n    private Cipher cipher;\n\n    private static byte[] hexDecode(final String hex) {\n        final byte[] data = new byte[hex.length() / 2];\n        for (int i = 0; i < data.length; i++) {\n            data[i] = (byte) Integer.parseInt(hex.substring(i * 2, i * 2 + 2),\n                    16);\n        }\n        return data;\n    }\n\n    public SecurityHelperCTR() {\n        try {\n            this.cipher = Cipher.getInstance(\"AES/CTR/NoPadding\");\n        } catch (final Exception e) {\n            e.printStackTrace();\n        }\n    }\n\n    private static int generateRandomNonce(final byte[] nonceBuffer,\n            final int offset, final int size) {\n        final SecureRandom rng = new SecureRandom();\n        final byte[] nonce = new byte[size];\n        rng.nextBytes(nonce);\n        System.arraycopy(nonce, 0, nonceBuffer, offset, size);\n        return offset + size;\n    }\n\n    private static IvParameterSpec generateIVFromNonce(\n            final byte[] nonceBuffer, final int offset, final int size,\n            final int blockSize) {\n        final byte[] ivData = new byte[blockSize];\n        System.arraycopy(nonceBuffer, offset, ivData, 0, size);\n        final IvParameterSpec iv = new IvParameterSpec(ivData);\n        return iv;\n    }\n\n    public String encrypt(final String secret) {\n        final byte[] plaintext = secret.getBytes(UTF_8);\n        final byte[] nonceAndCiphertext = new byte[NONCE_SIZE\n                + plaintext.length];\n\n        int offset = generateRandomNonce(nonceAndCiphertext, 0, NONCE_SIZE);\n        final IvParameterSpec nonceIV = generateIVFromNonce(nonceAndCiphertext,\n                0, NONCE_SIZE, this.cipher.getBlockSize());\n\n        try {\n            this.cipher.init(Cipher.ENCRYPT_MODE, this.STATIC_SECRET_KEY,\n                    nonceIV);\n            offset += this.cipher.doFinal(plaintext, 0, plaintext.length,\n                    nonceAndCiphertext, offset);\n            if (offset != nonceAndCiphertext.length) {\n                throw new IllegalStateException(\n                        \"Something wrong during encryption\");\n            }\n            // Java 8 contains java.util.Base64\n            return DatatypeConverter.printBase64Binary(nonceAndCiphertext);\n        } catch (final GeneralSecurityException e) {\n            throw new IllegalStateException(\n                    \"Missing basic functionality from Java runtime\", e);\n        }\n    }\n\n    public String decrypt(final String encrypted) {\n        final byte[] nonceAndCiphertext = DatatypeConverter\n                .parseBase64Binary(encrypted);\n        final IvParameterSpec nonceIV = generateIVFromNonce(nonceAndCiphertext,\n                0, NONCE_SIZE, this.cipher.getBlockSize());\n        try {\n            this.cipher.init(Cipher.DECRYPT_MODE, this.STATIC_SECRET_KEY,\n                    nonceIV);\n            final byte[] plaintext = this.cipher.doFinal(nonceAndCiphertext,\n                    NONCE_SIZE, nonceAndCiphertext.length - NONCE_SIZE);\n            // note: this may return an invalid result if the value is tampered\n            // with\n            // it may even contain more or less characters\n            return new String(plaintext, UTF_8);\n        } catch (final GeneralSecurityException e) {\n            throw new IllegalStateException(\n                    \"Missing basic functionality from Java runtime\", e);\n        }\n    }\n\n    public static void main(final String[] args) {\n        final String secret = \"owlstead\";\n        final SecurityHelperCTR securityHelper = new SecurityHelperCTR();\n        final String ct = securityHelper.encrypt(secret);\n        final String pt = securityHelper.decrypt(ct);\n        System.out.println(pt);\n    }\n}\n", "idx": 2342}
{"project": "cipher", "commit_id": "Snippet29471097_11474.java", "target": 0, "func": " private static final String ALGORITHM = \"AES\";\n private static final byte[] keyValue =\n        new byte[] { 'T', 'h', 'i', 's', 'I', 's', 'A', 'S', 'e', 'c', 'r', 'e', 't', 'K', 'e', 'y' };\n\n\n public String encrypt(String valueToEnc) throws Exception {\n    Key key = generateKey();\n    Cipher c = Cipher.getInstance(ALGORITHM);\n    c.init(Cipher.ENCRYPT_MODE, key);\n    byte[] encValue = c.doFinal(valueToEnc.getBytes());\n    // String encryptedValue = new Base64.encoder();\n\n    return Base64.encodeToString(encValue, Base64.DEFAULT);\n}\n\npublic String decrypt(String encryptedValue) throws Exception {\n    Key key = generateKey();\n    Cipher c = Cipher.getInstance(ALGORITHM);\n    c.init(Cipher.DECRYPT_MODE, key);\n    //byte[] decordedValue = new BASE64Decoder().decodeBuffer(encryptedValue);\n    byte[] decordedValue = Base64.decode(encryptedValue, Base64.DEFAULT);\n\n    byte[] decValue = c.doFinal(decordedValue);\n    String decryptedValue = new String(decValue);\n    return decryptedValue;\n}\n", "idx": 1869}
{"project": "cipher", "commit_id": "Snippet16308314_39272.java", "target": 1, "func": "Cipher c = Cipher.getInstance(\"AES/CTR/NoPadding\", \"BC\");\nKeyGenerator kg = KeyGenerator.getInstance(\"AES\");\nc.init(Cipher.ENCRYPT_MODE, kg.generateKey());\nSystem.out.println(c.update(new byte[20]).length); // output: 16\nSystem.out.println(c.update(new byte[1]).length);  // null pointer exception\n", "idx": 2307}
{"project": "cipher", "commit_id": "Snippet22569165_4966.java", "target": 1, "func": "import java.io.UnsupportedEncodingException;\nimport java.security.Security;\nimport java.security.spec.KeySpec;\nimport java.util.Random;\n\nimport javax.crypto.Cipher;\nimport javax.crypto.SecretKey;\nimport javax.crypto.SecretKeyFactory;\nimport javax.crypto.spec.IvParameterSpec;\nimport javax.crypto.spec.PBEKeySpec;\nimport javax.crypto.spec.SecretKeySpec;\n\nimport org.bouncycastle.jce.provider.BouncyCastleProvider;\n\npublic class SSL {\n\n    private final static String HEX = \"0123456789ABCDEF\";\n    private final static String ENC = \"US-ASCII\";\n    private final static int ITERATION = 1337;\n\n    private static final String RANDOM_ALGORITHM = \"PBEWithSHA256And256BitAES-CBC-BC\";\n    private static final String CIPHER_ALGORITHM = \"AES/CBC/PKCS5Padding\";\n    private static final String SECRET_KEY_ALGORITHM = \"AES\";\n\n    private static IvParameterSpec ips;\n\n    public static void init(byte[] iv) {\n        if(iv == null) {\n            iv = new byte[16];\n\n            Random random = new Random();\n            random.nextBytes(iv);\n        }\n\n        ips = new IvParameterSpec(iv);\n\n        Security.addProvider(new BouncyCastleProvider());\n    }\n\n    public static byte[] getCertificate() {\n        return ips.getIV();\n    }\n\n    public static String encrypt(Session current, String cleartext) throws Exception {\n        byte[] rawKey = getRawKey(current.getCurrentSession().toCharArray());\n        byte[] result = encrypt(rawKey, cleartext.getBytes(ENC));\n        return toHex(result);\n    }\n\n    public static String decrypt(Session current, String encrypted) throws Exception {\n        byte[] rawKey = getRawKey(current.getCurrentSession().toCharArray());\n        byte[] enc = toByte(encrypted);     \n        byte[] result = decrypt(rawKey, enc);\n        return new String(result, ENC);\n    }\n\n    private static byte[] getRawKey(char[] seed) throws Exception {\n        KeySpec keySpec = new PBEKeySpec(seed, ips.getIV(), ITERATION);\n\n        SecretKeyFactory keyFactory = SecretKeyFactory.getInstance(RANDOM_ALGORITHM);\n        byte[] keyBytes = keyFactory.generateSecret(keySpec).getEncoded();\n        SecretKey secretKey = new SecretKeySpec(keyBytes, \"AES\");\n\n        return secretKey.getEncoded();\n    }\n\n\n    private static byte[] encrypt(byte[] raw, byte[] clear) throws Exception {\n        SecretKeySpec skeySpec = new SecretKeySpec(raw, SECRET_KEY_ALGORITHM);\n        Cipher cipher = Cipher.getInstance(CIPHER_ALGORITHM);\n        cipher.init(Cipher.ENCRYPT_MODE, skeySpec, ips);\n        byte[] encrypted = cipher.doFinal(clear);\n        return encrypted;\n    }\n\n    private static byte[] decrypt(byte[] raw, byte[] encrypted) throws Exception {\n        SecretKeySpec skeySpec = new SecretKeySpec(raw, SECRET_KEY_ALGORITHM);\n        Cipher cipher = Cipher.getInstance(CIPHER_ALGORITHM);\n        cipher.init(Cipher.DECRYPT_MODE, skeySpec, ips);\n        byte[] decrypted = cipher.doFinal(encrypted);\n        return decrypted;\n    }\n\n    public static String toHex(String txt) throws UnsupportedEncodingException {\n        return toHex(txt.getBytes(ENC));\n    }\n    public static String fromHex(String hex) throws UnsupportedEncodingException {\n        return new String(toByte(hex), ENC);\n    }\n\n    public static byte[] toByte(String hexString) {\n        int len = hexString.length()/2;\n        byte[] result = new byte[len];\n        for (int i = 0; i < len; i++)\n            result[i] = Integer.valueOf(hexString.substring(2*i, 2*i+2), 16).byteValue();\n        return result;\n    }\n\n    public static String toHex(byte[] buf) {\n        if (buf == null)\n            return \"\";\n        StringBuffer result = new StringBuffer(2*buf.length);\n        for (int i = 0; i < buf.length; i++) {\n            appendHex(result, buf[i]);\n        }\n        return result.toString();\n    }\n\n    private static void appendHex(StringBuffer sb, byte b) {\n        sb.append(HEX.charAt((b>>4)&0x0f)).append(HEX.charAt(b&0x0f));\n    }\n}\n", "idx": 2065}
{"project": "cipher", "commit_id": "Snippet32975822_14997.java", "target": 1, "func": "    public static String decrypt(String iv, String encryptedData) throws Exception {\n    byte[] keyValue = \"zy2dEd1pKG5i3WuWbvOBolFQR84AYbvN\".getBytes();\n    Key key = new SecretKeySpec(keyValue, \"AES\");        \n    Cipher c = Cipher.getInstance(\"AES/CBC/PKCS7Padding\");\n    c.init(Cipher.DECRYPT_MODE, key, new IvParameterSpec(iv.getBytes()));\n    byte[] decordedValue = Base64.decode(encryptedData.getBytes(), Base64.DEFAULT);\n    byte[] decValue = c.doFinal(decordedValue);\n    return new String(decValue);\n}\n", "idx": 1970}
{"project": "cipher", "commit_id": "Snippet39387012_21290.java", "target": 1, "func": "    Cipher cipher = null;\n    try {\n\n        byte[] input = Utils.hexStringToByteArray(\"d9313225f88406e5a55909c5aff5269a\");\n        byte[] keyByte = Utils.hexStringToByteArray(\"cfa2b0719afe65b60b1461cdc6a7f7e3\");\n\n        SecretKeySpec key = new SecretKeySpec(keyByte, \"AES\");\n        cipher = Cipher.getInstance(\"AES/GCM/NoPadding\");\n        GCMParameterSpec spec = new GCMParameterSpec(32, Utils.hexStringToByteArray(\"000000000000000000000000\"));\n        cipher.init(Cipher.ENCRYPT_MODE, key, spec);\n        /*byte[] aad = Utils.hexStringToByteArray(\"000000\");\n        cipher.updateAAD(aad);*/\n\n        final byte[] encrypted = new byte[cipher.getOutputSize(0)];\n        cipher.update(input, 0, input.length, encrypted, 0);  //Not being updated for current data.\n\n        //Tag output\n        byte[] tag = new byte[cipher.getOutputSize(0)];\n\n        cipher.doFinal(tag, 0);\n\n        cipher.init(Cipher.DECRYPT_MODE, key, spec);\n        //cipher.updateAAD(aad);\n        final byte[] data1 = new byte[16];\n\n        int offset = cipher.update(encrypted, 0, encrypted.length, data1, 0);\n\n        cipher.update(tag, 0, tag.length, data1, offset);\n        cipher.doFinal(data1,offset);\n\n\n    }\n    catch (NoSuchAlgorithmException e) {\n        e.printStackTrace();\n    } catch (NoSuchPaddingException e) {\n        e.printStackTrace();\n\n    } catch (BadPaddingException e) {\n        e.printStackTrace();\n\n    } catch (InvalidKeyException e) {\n        e.printStackTrace();\n\n    } catch (IllegalBlockSizeException e) {\n        e.printStackTrace();\n\n    } catch (InvalidAlgorithmParameterException e) {\n        e.printStackTrace();\n    } catch (ShortBufferException e) {\n        e.printStackTrace();\n    }\n\n} \n", "idx": 2102}
{"project": "cipher", "commit_id": "Snippet29186434_11244.java", "target": 0, "func": "public class DES {\n    private KeyGenerator keyGen;\n    private SecretKey secretKey;\n    private Cipher cipher;\n    private byte[] bytes_to_encrypt;\n    private byte[] encrypted_bytes;\n    private byte[] decrypted_bytes;\n    public DES(byte[] bytes_to_encrypt) {\n        this.bytes_to_encrypt = bytes_to_encrypt;\n        generate_key();\n        init_cipher();\n        encrypt_text();\n    }\n    private void generate_key(){\n        try{\n            keyGen = KeyGenerator.getInstance(\"DES\");\n        }catch(Exception e){\n            System.out.println(e.toString());   \n        }\n        keyGen.init(56);\n        secretKey = keyGen.generateKey();\n    }\n    private void init_cipher(){\n        try{\n            cipher = Cipher.getInstance(\"DES\");   \n        }catch(Exception e){\n            System.out.println(e.toString());    \n        }\n    }\n    private void encrypt_text(){\n        try{\n            cipher.init(Cipher.ENCRYPT_MODE, secretKey);\n            encrypted_bytes = cipher.doFinal(bytes_to_encrypt);\n        }catch(Exception e){\n            System.out.println(e.toString());\n        }\n    }\n    private void decrypt_text(){\n        try{\n            cipher.init(Cipher.DECRYPT_MODE, secretKey);\n            decrypted_bytes = cipher.doFinal(encrypted_bytes);\n        }catch(Exception e){\n            System.out.println(e.toString());\n        }\n    }\n    public byte[] get_encrypted_data(){\n        return this.encrypted_bytes;    \n    }\n    public byte[] get_decrypted_data(){\n        decrypt_text();\n        return this.decrypted_bytes;    \n    }\n    public byte[] get_original_data(){\n        return this.bytes_to_encrypt;\n    }\n    public SecretKey get_key(){\n        return this.secretKey;    \n    }\n}\n", "idx": 1597}
{"project": "cipher", "commit_id": "Snippet17690611_809.java", "target": 0, "func": "public static String decrypt(byte[] message) throws Exception {\n    final MessageDigest md = MessageDigest.getInstance(\"SHA-1\");\n    final byte[] digestOfPassword = md.digest(token.getBytes(\"utf-8\"));\n    final byte[] keyBytes = Arrays.copyOf(digestOfPassword, 24);\n    for (int j = 0, k = 16; j < 8;) {\n        keyBytes[k++] = keyBytes[j++];\n    }\n\n    final SecretKey key = new SecretKeySpec(keyBytes, \"DESede\");\n    final IvParameterSpec iv = new IvParameterSpec(new byte[8]);\n    final Cipher decipher = Cipher.getInstance(\"DESede/CBC/PKCS5Padding\");\n    // final Cipher decipher = Cipher.getInstance(\"DESede/CFB/NoPadding\");\n    decipher.init(Cipher.DECRYPT_MODE, key, iv);\n    final byte[] plainText = decipher.doFinal(message);\n    return new String(plainText, \"UTF-8\");\n}\n", "idx": 1718}
{"project": "cipher", "commit_id": "Snippet39565618_21490.java", "target": 0, "func": "import java.security.Key;\nimport java.security.MessageDigest;\nimport java.util.Base64;\n\nimport javax.crypto.Cipher;\nimport javax.crypto.spec.SecretKeySpec;\n\n\npublic class H {\n    public static void main(String args[]){\n        try{\n        String strDefaultKey = \"QabC-+50\";\n        Key key = new SecretKeySpec(strDefaultKey.getBytes(\"UTF-8\"), \"DES\");\n        Cipher encryptCipher = Cipher.getInstance(\"DES/ECB/NoPadding\");\n        encryptCipher.init(Cipher.ENCRYPT_MODE, key);\n        String seed = \"2016-09-19 05:11\";\n        String seedMd5 = MD5(seed);\n        byte[] a = encryptCipher.doFinal(seedMd5.getBytes());\n        byte[] encodeUrl = Base64.getEncoder().encode(a);\n        String finalUrl = new String(encodeUrl);\n        String finalResult = finalUrl.substring(2, 8) + finalUrl.substring(10, 13);\n        System.out.println(finalUrl);\n        System.out.println(finalResult);\n        }catch(Exception e){\n            e.printStackTrace();\n        }\n    }\n\n    static String MD5(String src) {\n        MessageDigest md;\n        try {\n            md = MessageDigest.getInstance(\"MD5\");\n            StringBuffer deviceIDString = new StringBuffer(src);\n            src = convertToHex(md.digest(deviceIDString.toString().getBytes()));\n        } catch (Exception e) {\n            src = \"00000000000000000000000000000000\";\n        }\n        return src;\n    }\n\n    private static String convertToHex(byte[] data) {\n        StringBuffer buf = new StringBuffer();\n        for (int i = 0; i < data.length; i++) {\n            int halfbyte = (data[i] >>> 4) & 0x0F;\n            int two_halfs = 0;\n            do {\n                if ((0 <= halfbyte) && (halfbyte <= 9))\n                    buf.append((char) ('0' + halfbyte));\n                else\n                    buf.append((char) ('a' + (halfbyte - 10)));\n                halfbyte = data[i] & 0x0F;\n            } while (two_halfs++ < 1);\n        }\n        return buf.toString();\n    }\n}\n", "idx": 1584}
{"project": "cipher", "commit_id": "Snippet5262696_31530.java", "target": 1, "func": "public byte[] Decrypt(byte[] data)\n    {\n        try {\n            Cipher cipher = Cipher.getInstance(\"RSA\");\n            cipher.init(Cipher.DECRYPT_MODE, privateKey);\n            byte[] cipherData = cipher.doFinal(data);\n            return cipherData;\n        } catch (NoSuchAlgorithmException ex) {\n            Logger.getLogger(EncryptorDecryptor.class.getName()).log(Level.SEVERE, null, ex);\n        } catch (NoSuchPaddingException ex) {\n            Logger.getLogger(EncryptorDecryptor.class.getName()).log(Level.SEVERE, null, ex);\n        } catch(IllegalBlockSizeException ex) {\n            Logger.getLogger(EncryptorDecryptor.class.getName()).log(Level.SEVERE, null, ex);\n        } catch(InvalidKeyException ex) {\n            Logger.getLogger(EncryptorDecryptor.class.getName()).log(Level.SEVERE, null, ex);\n        } catch(BadPaddingException ex) {\n            Logger.getLogger(EncryptorDecryptor.class.getName()).log(Level.SEVERE, null, ex);\n        }\n\n        return null;\n    }\n", "idx": 2128}
{"project": "cipher", "commit_id": "Snippet29038655_11106.java", "target": 1, "func": "private static String buildCipherEncryptCheck(String data){\n\n    byte[] dataBytes = data.getBytes();\n    String encryptedData = null;\n\n    try {                               \n        // Generate valid key\n        KeyGenerator keygenerator = KeyGenerator.getInstance(\"AES\");                \n\n        keygenerator.init(128);\n        SecretKey myKey = keygenerator.generateKey();           \n\n        // Generate cipher encrypt\n        Cipher cipher = Cipher.getInstance(\"AES/CFB1/PKCS5Padding\", new BouncyCastleProvider());\n\n        // Initialize the cipher for encryption\n        cipher.init(Cipher.ENCRYPT_MODE, myKey);                \n\n        // Encrypt the text\n        byte[] textEncrypted = cipher.doFinal(dataBytes);\n        encryptedData = new String(Base64.encode(textEncrypted));\n\n    } catch (NoSuchAlgorithmException e) {\n        e.printStackTrace();\n    } catch (InvalidKeyException e) {\n        e.printStackTrace();\n    } catch (NoSuchPaddingException e) {\n        e.printStackTrace();\n    } catch (IllegalBlockSizeException e) {\n        e.printStackTrace();\n    } catch (BadPaddingException e) {\n        e.printStackTrace();\n    }\n\n    return encryptedData;\n}   \n", "idx": 2264}
{"project": "cipher", "commit_id": "Snippet46886363_28910.java", "target": 1, "func": "import java.security.Security;\nimport java.util.Arrays;\n\nimport javax.crypto.Cipher;\nimport javax.crypto.spec.IvParameterSpec;\nimport javax.crypto.spec.SecretKeySpec;\n\nimport org.bouncycastle.jce.provider.BouncyCastleProvider;\n\npublic class RC6 {\n\n    static String IV = \"AAAAAAAAAAAAAAAA\";\n    static String initkey = \"qwertyuiopasdfgh\"; // 16 characters\n\n    public static void main(String[] args) throws Exception {\n\n        byte toEncrypt[] = { 23, 68, 45, 65, 21, 34, 22, 90 };\n        Security.addProvider(new BouncyCastleProvider());\n        System.out.println(Arrays.toString(toEncrypt));\n        System.out.println(\"Encrypting...\");\n\n        byte[] encrypted = encrypt(toEncrypt, 0, toEncrypt.length);\n        System.out.println(Arrays.toString(encrypted));\n        System.out.println(\"Decrypting...\");\n        byte[] decrypted = decrypt(encrypted, 0, toEncrypt.length);\n\n        System.out.println(Arrays.toString(decrypted));\n    }\n\n    public static byte[] encrypt(byte[] plainData, int offset, int lenght) \n    throws Exception {\n\n        Cipher cipher = Cipher.getInstance(\"RC6/CTR/PKCS5Padding\");\n        SecretKeySpec key = new SecretKeySpec(initkey.getBytes(\"UTF-8\"), \n        \"RC6\");\n        cipher.init(Cipher.ENCRYPT_MODE, key, new \n        IvParameterSpec(IV.getBytes(\"UTF-8\")));\n        return cipher.doFinal(plainData, offset, lenght);\n\n    }\n\n    public static byte[] decrypt(byte[] cipherSound, int offset, int lenght) \n    throws Exception {\n\n        Cipher cipher = Cipher.getInstance(\"RC6/CTR/PKCS5Padding\");\n        SecretKeySpec key = new SecretKeySpec(initkey.getBytes(\"UTF-8\"), \n        \"RC6\");\n        cipher.init(Cipher.DECRYPT_MODE, key, new \n        IvParameterSpec(IV.getBytes(\"UTF-8\")));\n        return cipher.doFinal(cipherSound);\n}\n}\n", "idx": 2343}
{"project": "cipher", "commit_id": "Snippet16165977_39125.java", "target": 0, "func": "public class DesEncryptor {\nprivate static Key key;\nprivate static Cipher cipher;\n\npublic static void keyGenerate() throws NoSuchAlgorithmException, NoSuchPaddingException{\n    // get a DES cipher object and print the provider\n    cipher = Cipher.getInstance(\"DES/ECB/PKCS5Padding\");\n    KeyGenerator keyGen = KeyGenerator.getInstance(\"DES\");\n    keyGen.init(64);\n    key = keyGen.generateKey();\n\n}\n\npublic static String encryptSms(String sms) throws NoSuchAlgorithmException, NoSuchPaddingException, InvalidKeyException, \nIllegalBlockSizeException, BadPaddingException, UnsupportedEncodingException{\n\n\n\n    //System.out.println( \"\\n\" + cipher.getProvider().getInfo() );\n    // encrypt using the key and the plaintext\n    //  System.out.println( \"\\nStart encryption\" );\n    cipher.init(Cipher.ENCRYPT_MODE, key);\n    byte[] cipherText = cipher.doFinal(sms.getBytes(\"UTF8\"));\n    // System.out.println( \"Finish encryption: \" );\n    return( new String(cipherText, \"UTF8\") );\n}\n\npublic static String decryptSms(String smsEncrypted) throws InvalidKeyException, IllegalBlockSizeException, BadPaddingException, \nUnsupportedEncodingException, NoSuchAlgorithmException, NoSuchPaddingException\n{\n    // decrypt the ciphertext using the same key\n    //System.out.println( \"\\nStart decryption\" );\n\n    cipher.init(Cipher.DECRYPT_MODE, key);\n    byte[] newPlainText = cipher.doFinal(smsEncrypted.getBytes());\n    //System.out.println( \"Finish decryption: \" );\n\n    return( new String(newPlainText, \"UTF8\") );\n}\n", "idx": 1615}
{"project": "cipher", "commit_id": "Snippet29937079_11995.java", "target": 0, "func": "public static byte[] decryptAES(SecretKey key, byte[] encrypted) {\n    try {\n\n        SecretKeySpec skeySpec = new SecretKeySpec(key.getEncoded(), \"AES\");\n        Cipher cipher = Cipher.getInstance(\"AES\");\n        cipher.init(Cipher.DECRYPT_MODE, skeySpec);\n        byte[] decrypted = cipher.doFinal(encrypted);\n        return decrypted;\n    } catch (Exception e) {\n        e.printStackTrace();\n    }\n\n    return null;\n}\n", "idx": 1809}
{"project": "cipher", "commit_id": "Snippet11326716_35469.java", "target": 0, "func": "/**\n *\n * @author MUDASSIR\n */\n\nimport java.security.*;\nimport javax.crypto.*;\nimport javax.crypto.spec.SecretKeySpec;\nimport sun.misc.*;\n\npublic class AESencrp {\n\n     private static final String ALGO = \"AES\";\n//    private static final byte[] keyValue = \n//        new byte[] { 'T', 'h', 'e', 'B', 'e', 's', 't',\n//'S', 'e', 'c', 'r','e', 't', 'K', 'e', 'y' };\n\npublic static String encrypt(String Data, byte[] keyValue) throws Exception {\n        Key key = generateKey(keyValue);\n        Cipher c = Cipher.getInstance(ALGO);\n        c.init(Cipher.ENCRYPT_MODE, key);\n        byte[] encVal = c.doFinal(Data.getBytes());\n        String encryptedValue = new BASE64Encoder().encode(encVal);\n        return encryptedValue;\n    }\n\n    public static String decrypt(String encryptedData, byte[] keyValue) throws Exception {\n        Key key = generateKey(keyValue);\n        Cipher c = Cipher.getInstance(ALGO);\n        c.init(Cipher.DECRYPT_MODE, key);\n        byte[] decodedValue = new BASE64Decoder().decodeBuffer(encryptedData);\n        byte[] decValue = c.doFinal(decodedValue);\n        String decryptedValue = new String(decValue);\n        return decryptedValue;\n    }\n    private static Key generateKey(byte[] keyValue) throws Exception {\n        Key key = new SecretKeySpec(keyValue, ALGO);\n        return key;\n}\n\n}\n", "idx": 1841}
{"project": "cipher", "commit_id": "Snippet33082516_15121.java", "target": 0, "func": "Cipher.getInstance(\"AES\")", "idx": 1669}
{"project": "cipher", "commit_id": "Snippet10136585_34498.java", "target": 0, "func": "public class AES {\n\n    public static void main(String[] args) throws Exception {\n        String cleartext = \"abcdefghijklmnop\";\n        String key = \"1234567890123456\";\n        SecretKeySpec skeySpec = new SecretKeySpec(key.getBytes(), \"AES\");\n        Cipher cipher = Cipher.getInstance(\"AES/ECB/NoPadding\");\n        cipher.init(Cipher.ENCRYPT_MODE, skeySpec);\n        byte[] encrypted = cipher.doFinal(cleartext.getBytes());\n        System.out.println(asHex(encrypted));\n    }\n\n    public static String asHex(byte buf[]) {\n        StringBuffer strbuf = new StringBuffer(buf.length * 2);\n        int i;\n        for (i = 0; i < buf.length; i++) {\n            if (((int) buf[i] & 0xff) < 0x10)\n                strbuf.append(\"0\");\n            strbuf.append(Long.toString((int) buf[i] & 0xff, 16));\n        }\n        return strbuf.toString();\n    }\n\n}\n", "idx": 1798}
{"project": "cipher", "commit_id": "Snippet15829002_38819.java", "target": 1, "func": "byte[] rawKey = new byte[32];\n\nSystem.arraycopy(\"A01BD1BE-9D28-11E2-A12E-48086188709B\".getBytes(\"UTF-8\"), 0, rawKey, 0, 32);\n\nCipher cipher = Cipher.getInstance(\"AES/CBC/PKCS7Padding\");\n\nfinal byte[] iv = new byte[16];\nArrays.fill(iv, (byte) 0x00);\nIvParameterSpec ivSpec = new IvParameterSpec(iv);\nSecretKeySpec keySpec = new SecretKeySpec(rawKey, \"AES\");\n\ncipher.init(Cipher.ENCRYPT_MODE, keySpec, ivSpec);\nbyte[] results = cipher.doFinal(clearTextByte);\nString result = Base64.encodeToString(results, Base64.DEFAULT);\n", "idx": 2333}
{"project": "cipher", "commit_id": "Snippet40022672_21961.java", "target": 1, "func": "public class CryptoClass \n{\n  static String IV = \"AAAAAAAAAAAAAAAA\";\n\n  public static byte[] encrypt(String plainText, String encryptionKey) throws Exception {\n    Cipher cipher = Cipher.getInstance(\"AES/CBC/NoPadding\", \"SunJCE\");\n    SecretKeySpec key = new SecretKeySpec(encryptionKey.getBytes(\"UTF-8\"), \"AES\");\n    cipher.init(Cipher.ENCRYPT_MODE, key,new IvParameterSpec(IV.getBytes(\"UTF-8\")));\n    return cipher.doFinal(plainText.getBytes(\"UTF-8\"));\n  }\n\n  public static String decrypt(byte[] cipherText, String encryptionKey) throws Exception{\n    Cipher cipher = Cipher.getInstance(\"AES/CBC/NoPadding\", \"SunJCE\");\n    SecretKeySpec key = new SecretKeySpec(encryptionKey.getBytes(\"UTF-8\"), \"AES\");\n    cipher.init(Cipher.DECRYPT_MODE, key,new IvParameterSpec(IV.getBytes(\"UTF-8\")));\n    return new String(cipher.doFinal(cipherText),\"UTF-8\");\n  }\n}\n", "idx": 1971}
{"project": "cipher", "commit_id": "Snippet15147099_38227.java", "target": 0, "func": "public MyCipher() throws NoSuchAlgorithmException, NoSuchProviderException, NoSuchPaddingException, InvalidKeyException, UnsupportedEncodingException, InvalidParameterSpecException, InvalidAlgorithmParameterException {\n    Security.addProvider(new BouncyCastleProvider());\n    KeyGenerator keyGen = KeyGenerator.getInstance(\"DES\", \"BC\");\n    keyGen.init(new SecureRandom());\n    SecretKey keySpec = keyGen.generateKey();\n\n    this.sharedKey = new String( Base64.encodeBase64URLSafe( keySpec.getEncoded() ) );\n    this.encrypter = Cipher.getInstance(\"DES/CBC/PKCS5Padding\", \"BC\");\n    this.encrypter.init(Cipher.ENCRYPT_MODE, keySpec);\n\n    AlgorithmParameters params = this.encrypter.getParameters();\n    byte[] iv = params.getParameterSpec(IvParameterSpec.class).getIV();\n    IvParameterSpec ivSpec = new IvParameterSpec(iv);\n\n    this.sharedIV = new String( Base64.encodeBase64URLSafe( iv ) );\n    this.decrypter = Cipher.getInstance(\"DES/CBC/PKCS5Padding\", \"BC\");\n    this.decrypter.init(Cipher.DECRYPT_MODE, keySpec, ivSpec);\n}\n", "idx": 1622}
{"project": "cipher", "commit_id": "Snippet37133890_19071.java", "target": 0, "func": "public static String encrypt(String strToEncrypt)\n{\n    try\n    {\n        String secretKey = \"1234567890123456\";\n        DESKeySpec keySpec = new DESKeySpec(secretKey.getBytes(\"UTF8\"));\n        SecretKeyFactory keyFactory = SecretKeyFactory.getInstance(\"DES\");\n        SecretKey key = keyFactory.generateSecret(keySpec);\n        BASE64Encoder base64encoder = new BASE64Encoder();\n        byte[] cleartext = strToEncrypt.getBytes(\"UTF8\");\n        Cipher cipher = Cipher.getInstance(\"DES\");\n        cipher.init(Cipher.ENCRYPT_MODE, key);\n        String encrypted = base64encoder.encode(cipher.doFinal(cleartext));\n        return encrypted;\n\n    }\n    catch (Exception e)\n    {\n        return e.getMessage();\n    }\n}\n", "idx": 1888}
{"project": "cipher", "commit_id": "Snippet6802368_32370.java", "target": 0, "func": "package com.messageHider;\n\nimport java.io.InputStream;\nimport java.io.OutputStream;\nimport java.security.spec.AlgorithmParameterSpec;\nimport javax.crypto.Cipher;\nimport javax.crypto.CipherInputStream;\nimport javax.crypto.CipherOutputStream;\nimport javax.crypto.SecretKey;\nimport javax.crypto.spec.IvParameterSpec;\n\npublic class DesEncrypter {\n    Cipher ecipher;\n    Cipher dcipher;\n    byte[] buf=null;\n    DesEncrypter(SecretKey key) {\n        // Create an 8-byte initialization vector\n        byte[] iv = new byte[]{\n            (byte)0x8E, 0x12, 0x39, (byte)0x9C,\n            0x07, 0x72, 0x6F, 0x5A\n        };\n        AlgorithmParameterSpec paramSpec = new IvParameterSpec(iv);\n        try {\n            ecipher = Cipher.getInstance(\"DES/CBC/PKCS5Padding\");\n            dcipher = Cipher.getInstance(\"DES/CBC/PKCS5Padding\");\n\n            // CBC requires an initialization vector\n            ecipher.init(Cipher.ENCRYPT_MODE, key, paramSpec);\n            dcipher.init(Cipher.DECRYPT_MODE, key, paramSpec);\n        } catch (java.security.InvalidAlgorithmParameterException e) {\n        } catch (javax.crypto.NoSuchPaddingException e) {\n        } catch (java.security.NoSuchAlgorithmException e) {\n        } catch (java.security.InvalidKeyException e) {\n        }\n    }\n\n\n    public void encrypt(InputStream in, OutputStream out,int fileSize) {\n        buf= new byte[fileSize];\n        try {\n            // Bytes written to out will be encrypted\n            out = new CipherOutputStream(out, ecipher);\n\n            // Read in the cleartext bytes and write to out to encrypt\n            int numRead = 0;\n            while ((numRead = in.read(buf)) >= 0) {\n                out.write(buf, 0, numRead);\n            }\n            out.close();\n        } catch (java.io.IOException e) {\n        }\n    }\n\n    public void decrypt(InputStream in, OutputStream out,int fileSize) {\n        buf= new byte[fileSize];\n        try {\n            // Bytes read from in will be decrypted\n            in = new CipherInputStream(in, dcipher);\n            // Read in the decrypted bytes and write the cleartext to out\n            int numRead = 0;\n            while ((numRead = in.read(buf)) >= 0) {\n                out.write(buf, 0, numRead);\n            }\n            out.close();\n        } catch (java.io.IOException e) {\n        }\n    }\n}\n", "idx": 1846}
{"project": "cipher", "commit_id": "Snippet24124091_6423.java", "target": 0, "func": "byte[] keyStart = \"qweroiwejrwoejlsifeoisrn\".getBytes(); // Random character string\n\nbyte[] toEncrypt = myMessageString.getBytes();\n\nkeyGen = KeyGenerator.getInstance(\"AES\");\nsr = SecureRandom.getInstance(\"SHA1PRNG\");\nsr.setSeed(keyStart);\nkeyGen.init(128, sr);\nSecretKey secretKey = keyGen.generateKey();\nbyte[] secretKeyByte = secretKey.getEncoded();\n\nSecretKeySpec skeySpec = new SecretKeySpec(secretKeyByte, \"AES\");\nCipher cipher = Cipher.getInstance(\"AES\");\ncipher.init(Cipher.ENCRYPT_MODE, skeySpec);\ncipher.doFinal(toEncrypt);\n", "idx": 1910}
{"project": "cipher", "commit_id": "Snippet19875489_2549.java", "target": 0, "func": "    public class MainActivity extends Activity {\n\n//@SuppressWarnings(\"unchecked\")\nprivate static final String TAG = \"MyActivity\";\n@Override\n    protected void onCreate(Bundle savedInstanceState) {\n    super.onCreate(savedInstanceState);\n    setContentView(R.layout.activity_main);       \n\n     AlertDialog.Builder alert = new AlertDialog.Builder(this);\n\n        alert.setTitle(\"Title\");\n        alert.setMessage(\"Message\");\n\n        // Set an EditText view to get user input \n        final EditText input = new EditText(this);\n        alert.setView(input);\n\n        alert.setPositiveButton(\"Ok\", new\n      DialogInterface.OnClickListener()   {\n        public void onClick(DialogInterface dialog, int whichButton) {\n        String value = input.getText().toString();\n        try {\n                encrypt(value);\n            } catch (InvalidKeyException e) {\n                // TODO Auto-generated catch block\n                e.printStackTrace();\n            } catch (NoSuchAlgorithmException e) {\n                // TODO Auto-generated catch block\n                e.printStackTrace();\n            } catch (NoSuchPaddingException e) {\n                // TODO Auto-generated catch block\n                e.printStackTrace();\n            } catch (IOException e) {\n                // TODO Auto-generated catch block\n                e.printStackTrace();\n            }\n        }});\n\n        alert.setNegativeButton(\"Cancel\", new\n                   DialogInterface.OnClickListener() {\n             public void onClick(DialogInterface dialog, int\n          whichButton) {\n                 // Canceled.\n            }\n            });\n\n             alert.show();  }               \n    static void encrypt(String Value) throws IOException,\n       NoSuchAlgorithmException, NoSuchPaddingException, InvalidKeyException {\n\n    final String libPath = Environment.getExternalStorageDirectory() + \"/shoaib.jar\";\n    // Here you read the cleartext.\n    FileInputStream fis = new FileInputStream(libPath);\n    // This stream write the encrypted text. \n    FileOutputStream fos = new \n    FileOutputStream(Environment.getExternalStorageDirectory() + \"/encrypted.jar\");\n\n    // Length is 16 byte\n    SecretKeySpec sks = new SecretKeySpec(Value.getBytes(), \"AES\");\n    Log.d(TAG,Value);\n    // Create cipher\n    Cipher cipher = Cipher.getInstance(\"AES\");\n    cipher.init(Cipher.ENCRYPT_MODE, sks);\n    // Wrap the output stream\n    CipherOutputStream cos = new CipherOutputStream(fos, cipher);\n    // Write bytes\n    int b;\n    byte[] d = new byte[8];\n    while((b = fis.read(d)) != -1) {\n        cos.write(d, 0, b);\n    }\n    // Flush and close streams.\n    cos.flush();\n    cos.close();\n    fis.close();\n    }\n", "idx": 1905}
{"project": "cipher", "commit_id": "Snippet23317236_5659.java", "target": 1, "func": " public static boolean verify () {\n            String publickey = \"MIGfMA0GCSqGSIb3DQE\";\n            byte[] encKey = Base64.decodeBase64(publickey.getBytes());\n            try {\n                byte[] MACaddress = GetData();\n                BufferedReader in = new BufferedReader(new FileReader(\n                        \"EndSignatuer.txt\"));\n                FileInputStream keyfis = new FileInputStream(\"EndSignatuer.txt\");\n                byte[] Signen = new byte[keyfis.available()];\n                keyfis.read(Signen);\n                keyfis.close();\n\n                X509EncodedKeySpec pubKeySpec = new X509EncodedKeySpec(encKey);\n                KeyFactory keyFactory = KeyFactory.getInstance(\"RSA\");\n                PublicKey pubKey = keyFactory.generatePublic(pubKeySpec);\n\n                Cipher cipher = Cipher.getInstance(\"RSA\");\n                cipher.init(Cipher.DECRYPT_MODE, pubKey);\n                byte[] deSignen = Base64.decodeBase64(Signen);\n                byte[] decrypted_digest = cipher.doFinal(deSignen);\n\n                MessageDigest md5_digest = MessageDigest.getInstance(\"MD5\");\n                md5_digest.update(MACaddress);\n                byte[] digest = md5_digest.digest();\n\n                   if (decrypted_digest == digest) {\n                        return true;\n                    }else {\n                        return false;//her why give me false \n                    }\n", "idx": 2071}
{"project": "cipher", "commit_id": "Snippet39495602_21408.java", "target": 1, "func": "byte[] encryptData(byte[] bytes) throws NoSuchAlgorithmException, InvalidKeySpecException, NoSuchPaddingException, UnsupportedEncodingException, InvalidKeyException, BadPaddingException, IllegalBlockSizeException {\n        byte[] modulusBytes = Base64.decode(\"rSE5aIjN9rjXrXreZWRMrE/rW1oEWMu1gEhJfcC3ZOxnTuZFRxyws9KAH6Fto2HLGnJeiFaNJSb4dxr10fldsQwCw/0VTSCXrkAviILBjC/lIFx6oqZ3Ivu+bBGjEY0F5Y4mEFzmfou5L10ydXmPECMKB+ezDhPjvX+FXo5uO7gtHv0MOefpkCaeL+WrC0ETwJP6/EIPF4sa+uBHWSC601y8mzQk/t42WI7JsRDI1usQ/MH8g0HT3JgnMffWPm0nfAIvPY575sfvZ1IEQGX4zvU/Fuo7CeOi1jsT3nTk22Sp1a9j0VAu8sBxtfWpVwe2v8m8xa0nUxiJEuRBGFXOU9yS9gyMvZZDbSAMuQOVonz6cJT54KcaT3XoxdMf0N6WKPd3iZiC8I5jTpFtPgd8sOzMucBUbecIoW3/Kx9H0T8Xoc7+bHzcBm5OQ63NQmpmQ8fguw018YBVbe1mfrZrkkl86gJSaknctfoBmvdP4pt74S0Uy5TH54Hit5kL6qkdmWgREwgNhjeHnc3UgvRlUlBIlJqtv90+Z9boe2xyoHad8fWqAwooaMmOhNlQY985y2CEo5NgT8RZogRzhu59pQurNu5wfA0zsO1+c+IdyfKBN3kpy82SMbwyeSym0IQIjYt1x+TnlTk05hahrantejmBBcuWsVJUb/0TyfU84TM=\"\n                .getBytes(\"UTF-8\"), Base64.DEFAULT);\n        byte[] exponentBytes = Base64.decode(\"AQAB\".getBytes(\"UTF-8\"), Base64.DEFAULT);\n\n        BigInteger modules = new BigInteger(1, modulusBytes);\n        BigInteger exponent = new BigInteger(1, exponentBytes);\n\n        int keysize = 4096 / 8;\n        int num1 = keysize - 42;\n        int length = bytes.length;\n        int num2 = length / num1;\n\n        KeyFactory factory = KeyFactory.getInstance(\"RSA\");\n        Cipher cipher = Cipher.getInstance(\"RSA/ECB/OAEPWithSHA-256AndMGF1Padding\");\n        RSAPublicKeySpec pubSpec = new RSAPublicKeySpec(modules, exponent);\n        PublicKey pubKey = factory.generatePublic(pubSpec);\n        cipher.init(Cipher.ENCRYPT_MODE, pubKey);\n\n        StringBuilder stringBuilder = new StringBuilder();\n        for (int i = 0; i <= num2; i++) {\n            byte[] rgb = new byte[length - num1 * i > num1 ? num1 : length - num1 * i];\n            System.arraycopy(bytes, num1 * i, rgb, 0, rgb.length);\n            byte[] inArray = cipher.doFinal(rgb);\n            stringBuilder.append(Base64.encode(inArray,Base64.DEFAULT).toString());\n        }\n\n        return Base64.encode(cipher.doFinal(bytes), Base64.DEFAULT);\n    }\n", "idx": 1966}
{"project": "cipher", "commit_id": "Snippet11567089_35621.java", "target": 1, "func": "Cipher.getInstance(\"AES/CBC/PKCS5Padding\")", "idx": 2212}
{"project": "cipher", "commit_id": "Snippet27558509_9665.java", "target": 1, "func": "    Security.addProvider(new BouncyCastleProvider());\n    PEMParser reader = new PEMParser(new StringReader(key));\n    PemObject obj = reader.readPemObject();\n    org.bouncycastle.asn1.pkcs.RSAPublicKey rsaPublicKey = org.bouncycastle.asn1.pkcs.RSAPublicKey.getInstance(obj.getContent());\n    BigInteger modulus = rsaPublicKey.getModulus();\n    BigInteger publicExponent = rsaPublicKey.getPublicExponent();\n\n    KeyFactory keyFactory = KeyFactory.getInstance(\"RSA\", \"BC\");\n    RSAPublicKeySpec pubKeySpec = new RSAPublicKeySpec(modulus, publicExponent);\n    PublicKey pubKey = keyFactory.generatePublic(pubKeySpec);\n\n    Cipher cipher = Cipher.getInstance(\"RSA/ECB/PKCS1Padding\", \"BC\");//This line should use right padding.For PKCS#1 format RSA key , it should be this.\n    cipher.init(Cipher.ENCRYPT_MODE, pubKey);\n    return cipher.doFinal(data);\n", "idx": 2295}
{"project": "cipher", "commit_id": "Snippet46420669_28537.java", "target": 1, "func": "Path path = null;\nString encryptionKey = null;\nCipher cipher = null;\nSecretKeySpec key = null;\nbyte[] enc1;\n\n\npath = FileSystems.getDefault().getPath(\"c:\\\\temp\\\\encryption\\\\SakisEnc.txt\", \"\");\ncipherText = Files.readAllBytes(path);\n\nencryptionKey = \"0123456789012345\";   \ncipher = Cipher.getInstance(\"AES/CBC/NoPadding\");   \nkey = new SecretKeySpec(encryptionKey.getBytes(\"UTF-8\"), \"AES\");\ncipher.init(Cipher.DECRYPT_MODE, key, new IvParameterSpec(encryptionKey.getBytes()));\ndec1 = cipher.doFinal(cipherText);\n", "idx": 2183}
{"project": "cipher", "commit_id": "Snippet2568841_30330.java", "target": 0, "func": "public static SecretKey getSecretKey(char[] password, byte[] salt) throws NoSuchAlgorithmException, InvalidKeySpecException{\n    SecretKeyFactory factory = SecretKeyFactory.getInstance(\"PBEWithMD5AndDES\");\n    // NOTE: last argument is the key length, and it is 256\n    KeySpec spec = new PBEKeySpec(password, salt, 1024, 256);\n    SecretKey tmp = factory.generateSecret(spec);\n    SecretKey secret = new SecretKeySpec(tmp.getEncoded(), \"AES\");\n    return(secret);\n}\n\n\npublic static byte[] encrypt(char[] password, byte[] salt, String text) throws NoSuchAlgorithmException, InvalidKeySpecException, NoSuchPaddingException, InvalidKeyException, InvalidParameterSpecException, IllegalBlockSizeException, BadPaddingException, UnsupportedEncodingException{\n    SecretKey secret = getSecretKey(password, salt);\n\n    Cipher cipher = Cipher.getInstance(\"AES\");\n\n    // NOTE: This is where the Exception is being thrown\n    cipher.init(Cipher.ENCRYPT_MODE, secret);\n    byte[] ciphertext = cipher.doFinal(text.getBytes(\"UTF-8\"));\n    return(ciphertext);\n}\n", "idx": 1832}
{"project": "cipher", "commit_id": "Snippet31693776_13798.java", "target": 0, "func": "    private static String algorithm = \"RC4\";\n\n            public static byte[] encryptRC4(String toEncrypt, String key) throws Exception {\n              // create a binary key from the argument key (seed)\n              SecureRandom sr = new SecureRandom(key.getBytes(\"ISO-8859-1\"));\n              KeyGenerator kg = KeyGenerator.getInstance(algorithm);\n              kg.init(sr);\n              SecretKey sk = kg.generateKey();\n\n              // create an instance of cipher\n              Cipher cipher = Cipher.getInstance(algorithm);\n\n              // initialize the \n\ncipher with the key\n          cipher.init(Cipher.ENCRYPT_MODE, sk);\n\n          // enctypt!\n          byte[] encrypted = cipher.doFinal(toEncrypt.getBytes(\"ISO-8859-1\"));\n\n          return encrypted;\n        }\n\n        public static String decryptRC4(byte[] toDecrypt, String key, int length) throws Exception {\n          // create a binary key from the argument key (seed)\n          SecureRandom sr = new SecureRandom(key.getBytes(\"ISO-8859-1\"));\n          KeyGenerator kg = KeyGenerator.getInstance(algorithm);\n          kg.init(sr);\n          SecretKey sk = kg.generateKey();\n\n          // do the decryption with that key\n          Cipher cipher = Cipher.getInstance(algorithm);\n          cipher.init(Cipher.DECRYPT_MODE, sk);\n          byte[] decrypted = cipher.doFinal(toDecrypt, 0, length);\n\n\n          return new String(decrypted, \"ISO-8859-1\");\n       }\n", "idx": 1824}
{"project": "cipher", "commit_id": "Snippet13546221_37099.java", "target": 0, "func": "public static void main(String args[]) {\n    Cipher fcipher, scipher;\n    String plaintextstring = \"\";\n\n    System.out.println(\"Enter the first message:\");\n    BufferedReader buffp = new BufferedReader(new InputStreamReader(System.in));\n    try {\n        plaintextstring = buffp.readLine();\n    } catch (Exception e) {\n        System.out.println(\"Exception occured:\" + e.getMessage());\n    }\n\n    int strlen1 = plaintextstring.length();\n\n    int x1 = strlen1 % 8;\n\n    int y1 = 8 - x1;\n\n    StringBuffer buf1 = new StringBuffer(plaintextstring);\n\n    if (x1 > 0) {\n        for (int k = 0; k < y1; k++) {\n            buf1.append('0');\n        }\n    }\n    System.out.println(\"Modified plaintext is:\" + buf1);\n    String inp = buf1.toString();\n\n    try {\n\n        SecretKey key1 = KeyGenerator.getInstance(\"DES\").generateKey();\n        SecretKey key2 = KeyGenerator.getInstance(\"DES\").generateKey();\n\n        fcipher = Cipher.getInstance(\"DES/ECB/NoPadding\");//CBC\n        scipher = Cipher.getInstance(\"DES/ECB/NoPadding\");//CBC\n\n        // Create an 8-byte initialization vector \n        //byte[] iv = {0x01, 0x02, 0x03, 0x04, 0x05, 0x06, 0x07, 0x08};\n        //byte[] iv = {0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00};\n        byte[] iv = {(byte) 0x01, (byte) 0x02, (byte) 0x03, (byte) 0x04, (byte) 0x05, (byte) 0x06, (byte) 0x07, (byte) 0x08};\n        System.out.println(\"Length of IV is :\" + iv.length);\n\n\n\n        byte[] sencrypted = new byte[8];\n\n        fcipher.init(Cipher.ENCRYPT_MODE, key1);\n        scipher.init(Cipher.DECRYPT_MODE, key2);\n        System.out.println(\"Default Charset is :\" + Charset.defaultCharset());\n        byte[] pbytes = inp.getBytes(\"UTF-8\");\n        System.out.println(\"Byte array of input string is :\" + pbytes);\n\n        System.out.println(\"Size of first message in bytes is:\" + pbytes.length);\n        for (int i = 0; i < pbytes.length; i++) {\n            System.out.println(\"Array values of byte array are: \" + pbytes[i]);\n        }\n\n        int z = (pbytes.length) / 8;\n        System.out.println(\"Number of data blocks of 8 bytes formed from message = \" + z);\n        for (int i = 0; i < z; i++) {\n            byte[] ds = getSection(pbytes, i * 8);//getting block of 64bit\n            byte[] out = new byte[8];\n\n            for (int r = 0; r < 8; r++) {\n                System.out.println(\"Array values of IV from previous stage is :\" + iv[r]);\n            }\n            for (int k = 0; k < 8; k++) {\n                out[k] = (byte) (ds[k] ^ iv[k]);//XORing of message block with IV bit by bit.\n                // System.out.println(\"XORed array byte by byte is:\"+out[k]);\n            }\n            byte[] fencrypted = fcipher.doFinal(out);//Applying DES Encryption to the XOR'ed result.(E)key1\n            byte[] fdecrypted = scipher.doFinal(fencrypted);// (D)key2 \n            sencrypted = fcipher.doFinal(fdecrypted);// (E)key1\n\n\n            System.out.println(\"Encrypted byte length: \" + sencrypted.length);\n            System.out.println(\"Encrypted text is :\" + sencrypted);\n\n            fcipher.init(Cipher.DECRYPT_MODE, key1);\n            scipher.init(Cipher.ENCRYPT_MODE, key2);\n\n            byte[] sfdecrypted = fcipher.doFinal(sencrypted);//DES1 key1 (D)\n            byte[] sfencrypted = scipher.doFinal(sfdecrypted);//DES Key2 (E)\n            byte[] ssdecrypted = fcipher.doFinal(sfencrypted);//DES Key3  (D)\n            System.out.println(\"length of final decrypted byte array is :\" + ssdecrypted.length);\n            byte[] d = new byte[8];\n            for (int u = 0; u < 8; u++) {\n                d[u] = (byte) (ssdecrypted[u] ^ iv[u]);//XORing of message block with IV bit by bit.\n                System.out.println(\"final decrypted array byte by byte of a single 64 bit block is:\" + d[u]);\n            }\n            String sdecryptedstr = new String(d);\n            System.out.println(\"Decrypted block is :\" + sdecryptedstr);\n            iv = sencrypted;\n            System.out.println(\"IV from previous stage is: \"+iv); \n        }\n\n\n    } catch (Exception e) {\n        System.out.println(\"Exception Occured: \" + e);\n    }\n\n}\n//function to get CBC message blocks.\npublic static byte[] getSection(byte[] message, int start) {\n    byte[] section = new byte[8];//dividing whole message into 64bit blocks.\n    for (int i = 0, j = start; i < 8; i++, j++) {\n        section[i] = message[j];\n    }\n    return section;\n}//end of getSection function.\n", "idx": 1756}
{"project": "cipher", "commit_id": "Snippet26849580_8985.java", "target": 1, "func": "    Cipher cipher = Cipher.getInstance(\"AES/CBC/PKCS5Padding\");\n    cipher.init(Cipher.DECRYPT_MODE, key, iv);\n    byte[] raw = Base64.decodeBase64(encText);\n    byte[] stringBytes = cipher.doFinal(raw);\n    String clear_text = new String(stringBytes, \"UTF8\");\n    return clear_text;\n", "idx": 2198}
{"project": "cipher", "commit_id": "Snippet28070597_10237.java", "target": 1, "func": "public static String encryptData(String data, BigInteger modulus, BigInteger exponent) throws Exception {\n    RSAPublicKeySpec spec = new RSAPublicKeySpec(modulus, exponent);\n    KeyFactory factory = KeyFactory.getInstance(\"RSA\", \"BC\");\n    PublicKey pub = factory.generatePublic(spec);\n    Cipher rsa = Cipher.getInstance(\"RSA\", \"BC\");\n    rsa.init(Cipher.ENCRYPT_MODE, pub);\n\n    byte[] cipherText = rsa.doFinal(data.getBytes()); // ERROR HERE\n    return Hex.toString(cipherText);\n}\n", "idx": 2107}
{"project": "cipher", "commit_id": "Snippet10291282_34643.java", "target": 1, "func": "import java.io.File;\nimport java.io.FileInputStream;\nimport java.io.FileOutputStream;\nimport java.io.IOException;\nimport java.io.OutputStream;\nimport java.io.RandomAccessFile;\nimport java.security.InvalidAlgorithmParameterException;\nimport java.security.InvalidKeyException;\nimport java.security.NoSuchAlgorithmException;\nimport java.security.SecureRandom;\n\nimport javax.crypto.BadPaddingException;\nimport javax.crypto.Cipher;\nimport javax.crypto.IllegalBlockSizeException;\nimport javax.crypto.NoSuchPaddingException;\nimport javax.crypto.spec.IvParameterSpec;\nimport javax.crypto.spec.SecretKeySpec;\n\n\npublic class AppendAES {\n\n    public static void appendAES(File file, byte[] data, byte[] key) throws IOException, NoSuchAlgorithmException, NoSuchPaddingException, InvalidKeyException, InvalidAlgorithmParameterException, IllegalBlockSizeException, BadPaddingException {\n        RandomAccessFile rfile = new RandomAccessFile(file,\"rw\");\n        byte[] iv = new byte[16];\n        byte[] lastBlock = null;\n        if (rfile.length() % 16L != 0L) {\n            throw new IllegalArgumentException(\"Invalid file length (not a multiple of block size)\");\n        } else if (rfile.length() == 16) {\n            throw new IllegalArgumentException(\"Invalid file length (need 2 blocks for iv and data)\");\n        } else if (rfile.length() == 0L) { \n            // new file: start by appending an IV\n            new SecureRandom().nextBytes(iv);\n            rfile.write(iv);\n            // we have our iv, and there's no prior data to reencrypt\n        } else { \n            // file length is at least 2 blocks\n            rfile.seek(rfile.length()-32); // second to last block\n            rfile.read(iv); // get iv\n            byte[] lastBlockEnc = new byte[16]; \n                // last block\n                // it's padded, so we'll decrypt it and \n                // save it for the beginning of our data\n            rfile.read(lastBlockEnc);\n            Cipher cipher = Cipher.getInstance(\"AES/CBC/PKCS5Padding\");\n            cipher.init(Cipher.DECRYPT_MODE, new SecretKeySpec(key,\"AES\"), new IvParameterSpec(iv));\n            lastBlock = cipher.doFinal(lastBlockEnc);\n            rfile.seek(rfile.length()-16); \n                // position ourselves to overwrite the last block\n        } \n        Cipher cipher = Cipher.getInstance(\"AES/CBC/PKCS5Padding\");\n        cipher.init(Cipher.ENCRYPT_MODE, new SecretKeySpec(key,\"AES\"), new IvParameterSpec(iv));\n        byte[] out;\n        if (lastBlock != null) { // lastBlock is null if we're starting a new file\n            out = cipher.update(lastBlock);\n            if (out != null) rfile.write(out);\n        }\n        out = cipher.doFinal(data);\n        rfile.write(out);\n        rfile.close();\n    }\n\n    public static void decryptAES(File file, OutputStream out, byte[] key) throws IOException, NoSuchAlgorithmException, NoSuchPaddingException, InvalidKeyException, InvalidAlgorithmParameterException, IllegalBlockSizeException, BadPaddingException {\n        // nothing special here, decrypt as usual\n        FileInputStream fin = new FileInputStream(file);\n        byte[] iv = new byte[16];\n        if (fin.read(iv) < 16) {\n            throw new IllegalArgumentException(\"Invalid file length (needs a full block for iv)\");\n        };\n        Cipher cipher = Cipher.getInstance(\"AES/CBC/PKCS5Padding\");\n        cipher.init(Cipher.DECRYPT_MODE, new SecretKeySpec(key,\"AES\"), new IvParameterSpec(iv));\n        byte[] buff = new byte[1<<13]; //8kiB\n        while (true) {\n            int count = fin.read(buff);\n            if (count == buff.length) {\n                out.write(cipher.update(buff));\n            } else {\n                out.write(cipher.doFinal(buff,0,count));\n                break;\n            }\n        }\n        fin.close();\n    }\n\n    public static void main(String[] args) throws Exception {\n        byte[] key = new byte[]{0,1,2,3,4,5,6,7,8,9,10,11,12,13,14,15};\n        for (int i = 0; i<1000; i++) {\n            appendAES(new File(\"log.aes\"),\"All work and no play makes Jack a dull boy. \".getBytes(\"UTF-8\"),key);\n        }\n        decryptAES(new File(\"log.aes\"), new FileOutputStream(\"plain.txt\"), key);\n    }\n\n}\n", "idx": 2099}
{"project": "cipher", "commit_id": "Snippet37824933_19839.java", "target": 1, "func": "Cipher c = null;\ntry {\n    c = Cipher.getInstance(\"RSA\");\n} catch (NoSuchAlgorithmException | NoSuchPaddingException ex) {\n    Logger.getLogger(SecureServer.class.getName()).log(Level.SEVERE, null, ex);\n}\n {\n    try {\n        c.init(Cipher.ENCRYPT_MODE, publicKeyofClient);\n    } catch (InvalidKeyException ex) {\n        Logger.getLogger(SecureServer.class.getName()).log(Level.SEVERE, null, ex);\n    }\n}\nbyte[] encryptedBytes = null;\n {\n    try {\n        encryptedBytes = c.doFinal(ServerSecretKey.getEncoded());\n    } catch (IllegalBlockSizeException | BadPaddingException ex) {\n        Logger.getLogger(SecureServer.class.getName()).log(Level.SEVERE, null, ex);\n    }\n}\n\nOutputStream outputStream;\noutputStream = clientSocket.getOutputStream();\noutputStream.write(encryptedBytes, 0, encryptedBytes.length);\n\noutputStream.flush();\noutputStream.close();\nclientSocket.close(); // closing the connection\n", "idx": 2009}
{"project": "cipher", "commit_id": "Snippet10412771_34785.java", "target": 0, "func": "if ((len = inputStream.read(mainBuffer)) > -1) {\n                totalLength = len;\n            }\nif (totalLength > 0) {\n                byteToAscii = function.byteToAscii(mainBuffer, totalLength);\n            }\nif (byteToAscii.length() > 0) {\n                completeHexString = function.stringToHex(byteToAscii);               \n                debugInfo = \"FRAME RECV.=\" + completeHexString;\n/* FRAME RECV.=41ed34a41a9de6d270aa1e1464527e88c8bee66a00cfb308f60c105de81db0f1ce43d8c0b9bc4e8070b5ab8d4d3650b55d23223fc687bb1485945bc3228e9707a7aecda9f90657e0ac009571c6469c58a2cd9793cc433ccb5993f2*/\n            }\nbyte[] key = new byte[]{31, 30, 31, 36, 32, 11, 11, 11, 22, 26, 30, 30, 30, 30, 30, 30, 30, 30, 30, 30, 30, 30, 30, 30};\nmyKeySpec = new DESedeKeySpec(key);\nmySecretKeyFactory = SecretKeyFactory.getInstance(\"TripleDES\");\ndekey = mySecretKeyFactory.generateSecret(myKeySpec);\nbyte[] zeros = {0, 0, 0, 0, 0, 0, 0, 0};\nIvParameterSpec iv = new IvParameterSpec(zeros);\nCipher c = Cipher.getInstance(\"TripleDES/CBC/PKCS5Padding\");\nc.init(Cipher.DECRYPT_MODE, key, iv);\nbyte[] decordedValue = new BASE64Decoder().decodeBuffer(completeHexString);\nbyte[] decValue = c.doFinal(decordedValue);\nString decryptedValue = new String(decValue);\nSystem.out.println(\"decryptedValue= \" + decryptedValue);\n", "idx": 1784}
{"project": "cipher", "commit_id": "Snippet27729908_9907.java", "target": 1, "func": "public  String decrypt(byte[] text, PrivateKey key) {\n    byte[] dectyptedText = null;\n    try {\n        final Cipher cipher = Cipher.getInstance(\"RSA\");\n        cipher.init(Cipher.DECRYPT_MODE, key);\n        dectyptedText = cipher.doFinal(text); // this is where I get error when trying to use getBytes() to convert encrypted string to byte[]\n    } catch (Exception ex) {\n        ex.printStackTrace();\n    }\n    return new String(dectyptedText);\n}\n", "idx": 2103}
{"project": "cipher", "commit_id": "Snippet31570354_13707.java", "target": 0, "func": "public class EncryptDecrypt {\n\n    public void encryptor(String inputFilePath) {\n\n        FileOutputStream fos = null;\n        File file = new File(inputFilePath);\n        String keyString = \"140405PX_0.$88\";\n        String algorithm = \"DESede\";\n        try {\n            FileInputStream fileInputStream = new FileInputStream(file);\n            byte[] fileByteArray = new byte[fileInputStream.available()];\n            fileInputStream.read(fileByteArray);\n            for (byte b : fileByteArray) {\n                System.out.println(b);\n            }\n            SecretKey secretKey = getKey(keyString);\n            Cipher cipher = Cipher.getInstance(algorithm);\n            cipher.init(Cipher.ENCRYPT_MODE, secretKey);\n            ObjectOutputStream objectOutputStream = new ObjectOutputStream(new CipherOutputStream(new FileOutputStream(\"encrypt.file\"), cipher));\n            objectOutputStream.writeObject(fileByteArray);\n            objectOutputStream.close();\n        } catch (Exception e) {\n            e.printStackTrace();\n        }\n    }\n\n    public void decryptor(String inputFilePath) {\n\n        String outputFilePath = \"decrypt.txt\";\n\n        String keyString = \"140405PX_0.$88\";\n        String algorithm = \"DESede\";\n        try {\n            File inputFileNAme = new File(inputFilePath);\n            FileInputStream fileInputStream = new FileInputStream(inputFileNAme);\n            FileOutputStream fileOutputStream = new FileOutputStream(outputFilePath);\n            SecretKey secretKey = getKey(keyString);\n            Cipher cipher = Cipher.getInstance(algorithm);\n            cipher.init(Cipher.DECRYPT_MODE, secretKey);\n            ObjectInputStream objectInputStream = new ObjectInputStream(new CipherInputStream(fileInputStream, cipher));\n            System.out.println(objectInputStream.available());\n            fileOutputStream.write((byte[]) objectInputStream.readObject());\n            fileOutputStream.flush();\n            fileOutputStream.close();\n            fileInputStream.close();\n            objectInputStream.close();\n        } catch (Exception e) {\n            e.printStackTrace();\n        }\n\n    }\n\n    public static SecretKey getKey(String message) throws Exception {\n        String messageToUpperCase = message.toUpperCase();\n        byte[] digestOfPassword = messageToUpperCase.getBytes();\n        byte[] keyBytes = Arrays.copyOf(digestOfPassword, 24);\n        SecretKey key = new SecretKeySpec(keyBytes, \"DESede\");\n        return key;\n    }\n\n\n}\n", "idx": 1914}
{"project": "cipher", "commit_id": "Snippet37569056_19526.java", "target": 0, "func": "public class Encryptor {\n\n    private static final String ALGORITHM = \"AES\";\n    private static final byte[] keyValue =\n            new byte[] { 'M', 'y', 'S', 'u', 'p', 'e', 'r', 'S',\n            'e', 'c', 'r', 'e', 't', 'K', 'e', 'y' };\n\n    public static String encrypt(String valueToEnc) throws Exception {\n        Key key = generateKey();\n        Cipher cipher = Cipher.getInstance(ALGORITHM);\n        cipher.init(Cipher.ENCRYPT_MODE, key);\n        byte[] encValue = cipher.doFinal(valueToEnc.getBytes());\n        return new BASE64Encoder().encode(encValue);\n    }\n\n    public static String decrypt(String encryptedValue) throws Exception {\n        Key key = generateKey();\n        Cipher cipher = Cipher.getInstance(ALGORITHM);\n        cipher.init(Cipher.DECRYPT_MODE, key);\n        byte[] decodedValue = new BASE64Decoder().decodeBuffer(encryptedValue);\n        byte[] decValue = cipher.doFinal(decodedValue);\n        return new String(decValue);\n    }\n\n    private static Key generateKey() throws Exception {\n        return new SecretKeySpec(keyValue, ALGORITHM);\n    }\n}  \n", "idx": 1879}
{"project": "cipher", "commit_id": "Snippet26493253_8618.java", "target": 0, "func": "public static byte[] decrypt(final byte[] value, final String key) throws InvalidKeyException, InvalidAlgorithmParameterException, NoSuchAlgorithmException, NoSuchPaddingException, UnsupportedEncodingException, InvalidKeySpecException, IllegalBlockSizeException, BadPaddingException {\n    final DESKeySpec objDesKeySpec = new DESKeySpec(key.getBytes(\"UTF-8\"));\n    final SecretKeyFactory objKeyFactory = SecretKeyFactory.getInstance(\"DES\");\n    final SecretKey objSecretKey = objKeyFactory.generateSecret(objDesKeySpec);\n    final byte[] rgbIV = key.getBytes();\n    final IvParameterSpec iv = new IvParameterSpec(rgbIV);\n    final Cipher objCipher = Cipher.getInstance(\"DES/CBC/PKCS5Padding\");\n    objCipher.init(2, objSecretKey, iv);\n    return objCipher.doFinal(value);\n}\n", "idx": 1849}
{"project": "cipher", "commit_id": "Snippet23101320_5460.java", "target": 1, "func": "Cipher.getInstance(\"AES/CFB/NoPadding\")", "idx": 2213}
{"project": "cipher", "commit_id": "Snippet20597890_3202.java", "target": 1, "func": "// Turn the encoded key into a real RSA private key.\n// Private keys are encoded in PKCS#8.\nPKCS8EncodedKeySpec keySpec = new PKCS8EncodedKeySpec(keyBytes);\nKeyFactory keyFactory = KeyFactory.getInstance(\"RSA\");\nPrivateKey privateKey = keyFactory.generatePrivate(keySpec);\n\n// Create a cipher using that key to initialize it\nCipher rsaCipher = Cipher.getInstance(\"RSA/ECB/PKCS1Padding\");\n\n// Read in the encrypted bytes of the session key\nDataInputStream dis = new DataInputStream(new FileInputStream(fileInput));\nbyte[] encryptedKeyBytes = new byte[dis.readInt()];\ndis.readFully(encryptedKeyBytes);\n\n// Decrypt the session key bytes.\nrsaCipher.init(Cipher.DECRYPT_MODE, privateKey);\nbyte[] rijndaelKeyBytes = rsaCipher.doFinal(encryptedKeyBytes);\n\n// Transform the key bytes into an actual key.\nSecretKey rijndaelKey = new SecretKeySpec(rijndaelKeyBytes, \"Rijndael\");\n", "idx": 2062}
{"project": "cipher", "commit_id": "Snippet22209479_4600.java", "target": 0, "func": "public class Obscure {\nprivate byte[] k = \"Now is the time for all good men to come to the aid of their country.\"\n        .getBytes();\n\npublic Obscure(String keyString) {\n    k = keyString.getBytes();\n}\n\npublic boolean encryptFile(String source, String target)\n        throws NoSuchAlgorithmException, NoSuchPaddingException,\n        InvalidKeyException, IOException {\n    Cipher encoding;\n    byte[] buffer = new byte[8192];\n\n    FileInputStream fis = new FileInputStream(source);\n    FileOutputStream fos = new FileOutputStream(target);\n\n    SecretKeySpec key = new SecretKeySpec(k, \"DES\");\n    encoding = Cipher.getInstance(\"DES\");\n    encoding.init(Cipher.ENCRYPT_MODE, key);\n    CipherOutputStream cos = new CipherOutputStream(fos, encoding);\n    int numBytes;\n    while ((numBytes = fis.read(buffer)) != -1) {\n        cos.write(buffer, 0, numBytes);\n    }\n    fos.flush();\n    fis.close();\n    fos.close();\n    cos.close();\n    return true;\n}\n}\n", "idx": 1604}
{"project": "cipher", "commit_id": "Snippet18657184_1652.java", "target": 1, "func": "public String encrypt_rsa(String original) throws IOException, NoSuchAlgorithmException, InvalidKeySpecException, NoSuchPaddingException, InvalidKeyException, IllegalBlockSizeException, BadPaddingException\n{\n    Resources res = getResources();\n    InputStream is = res.openRawResource(R.raw.public_key);\n    byte[] encodedKey = new byte[is.available()];\n    is.read(encodedKey);\n    X509EncodedKeySpec publicKeySpec = new X509EncodedKeySpec(encodedKey);\n    KeyFactory kf = KeyFactory.getInstance(\"RSA\");\n    PublicKey pkPublic = kf.generatePublic(publicKeySpec);\n\n    Cipher pkCipher = Cipher.getInstance(\"RSA/ECB/PKCS1PADDING\");\n    pkCipher.init(Cipher.ENCRYPT_MODE, pkPublic);\n    byte[] encryptedInByte = pkCipher.doFinal(original.getBytes());\n    String encryptedInString = new String(Base64Coder.encode(encryptedInByte));\n    is.close();\n\n    return encryptedInString;\n}\n", "idx": 1952}
{"project": "cipher", "commit_id": "Snippet11838389_35797.java", "target": 0, "func": "Cipher cipher = Cipher.getInstance(\"AES/ECB/NoPadding\");\n", "idx": 1843}
{"project": "cipher", "commit_id": "Snippet17587249_753.java", "target": 0, "func": "static boolean isPrime(long n)\n{\n    if (n%2 == 0)\n    {\n        return false;\n    }\n\n    for(int i = 3 ; i*i<=n;i+=2)\n    {\n        if(n%i==0)\n            return false;\n    }\n    return true;\n}\n\n\npublic static void main(String [] args) throws Exception\n{\n\n    Random randomGenerator = new Random();\n\n    long pValue = randomGenerator.nextInt(1000000);\n    long gValue = randomGenerator.nextInt(100000);\n    long correctPValue;\n\n    boolean checkPrime = isPrime(pValue);\n    System.out.println(\"the number generated is \"+pValue);\n    System.out.println(checkPrime);\n\n    while(checkPrime == false)\n\n    {\n        long pValue2 = randomGenerator.nextInt(1000000);\n        boolean checkPrimeInLoop = isPrime(pValue2);\n        //System.out.println(\"value in loop is \"+pValue2);\n        if(checkPrimeInLoop == true)\n        {\n            pValue=pValue2;\n            break;\n        }\n    }\n\n\n    long checkSP = (pValue*2)+1;\n    boolean checkSafePrime = isPrime(checkSP);\n    //System.out.println(checkSafePrime);\n    while(checkSafePrime==false)\n    {\n        long pValue3=randomGenerator.nextInt(1000000);\n        boolean checkPrimeInLoop = isPrime(pValue3);\n        long pValue5=(pValue3*2)+1;\n        //boolean checkSafePrimeInLoop = isPrime(pValue4);\n        boolean checkSafePrime2InLoop = isPrime(pValue5);\n\n        if(checkSafePrime2InLoop == true && checkPrimeInLoop == true)\n        {\n            pValue=pValue3;\n            break;\n        }\n\n    }\n\n    //System.out.println(\"the safe prime is\"+pValue);//safe prime\n\n    while(gValue>pValue)\n    {\n        long gValue2=randomGenerator.nextInt(100000);\n\n        if(gValue2<pValue)\n        {\n            gValue=gValue2;\n            break;\n        }\n    }\n\n    long getDivisor = (pValue-1)/2;\n    BigInteger bi1,bi2,bi3,bi4,bi10,bi11,bi12,bi13;\n\n    bi1=BigInteger.valueOf(getDivisor);\n\n    bi2 = BigInteger.valueOf(pValue);\n\n    bi3 = BigInteger.valueOf(gValue);\n\n    bi4= bi3.modPow(bi1,bi2);\n\n    String getBi1 = bi1.toString();\n\n    String getBi2 = bi2.toString();\n\n    String getBi3 = bi3.toString();\n\n    String getBi4 = bi4.toString();\n\n\n    //bi10 = new BigInteger(getBi1,64); // divisor\n    //bi11 = new BigInteger(getBi2,64); // safe prime value\n    //bi12 = new BigInteger(getBi3,64); // generator value\n    //bi13 = new BigInteger(getBi4,64); // modular value\n\n\n\n\n    long calculatedValue = bi4.longValue();\n\n\n    while(calculatedValue == 1)\n    {\n        long gValue3=randomGenerator.nextInt(100000);\n        long getDivisorInLoop = (pValue-1)/2;\n        BigInteger bi5,bi6,bi7,bi8,bi14,bi15,bi16,bi17,bi18;\n\n        bi5=BigInteger.valueOf(getDivisorInLoop);\n\n        bi6 = BigInteger.valueOf(pValue);\n\n        bi7 = BigInteger.valueOf(gValue3);\n\n        bi8= bi7.modPow(bi5,bi6);\n\n\n        String getBi5 = bi5.toString();\n\n        String getBi6 = bi6.toString();\n\n        String getBi7 = bi7.toString();\n\n        String getBi8 = bi8.toString();\n\n\n        //bi14 = new BigInteger(getBi1,64); // divisor\n        //bi15 = new BigInteger(getBi2,64); // safe prime value\n        //bi16 = new BigInteger(getBi3,64); // generator value\n        //bi17 = new BigInteger(getBi4,64); // modular value\n\n\n        long calculatedValueInLoop = bi8.longValue();\n        System.out.println(\"the proof that it is  a generator is \"+calculatedValueInLoop);\n        if(calculatedValueInLoop!=1)\n        {\n            gValue=gValue3;\n            break;\n        }\n    }\n\n    BigInteger generatorValue,primeValue,biA,biB,skA,skB,sharedKeyA,sharedKeyB;\n\n    generatorValue = BigInteger.valueOf(gValue);\n    primeValue = BigInteger.valueOf(pValue);\n    long SecretKeyA=generateSKA();\n    long SecretKeyB=generateSKB();\n    skA = BigInteger.valueOf(SecretKeyA);\n    skB = BigInteger.valueOf(SecretKeyB);\n    biA=generatePkA(generatorValue,primeValue,SecretKeyA);\n    biB=generatePkB(generatorValue,primeValue,SecretKeyB);\n    sharedKeyA = calculateSharedKey(biB,skA,primeValue);\n    sharedKeyB = calculateSharedKey(biA,skB,primeValue);\n\n    System.out.println(\"the safe prime is\"+primeValue);\n    System.out.println(\"the generator of the safe prime is \"+generatorValue);\n    System.out.println(\"the public key of A is \"+generatePkA(generatorValue,primeValue,SecretKeyA));\n    System.out.println(\"the public key of B is \"+generatePkB(generatorValue,primeValue,SecretKeyB));\n    System.out.println(\"the shared key for A is\"+calculateSharedKey(biB,skA,primeValue));\n    System.out.println(\"the shared key for B is\"+calculateSharedKey(biA,skB,primeValue));\n    System.out.println(\"The secret key for A is\"+generateSKA());\n\n    //createKey();\n    String getAValue=sharedKeyA.toString();\n    String getBValue=sharedKeyB.toString();\n\n    MessageDigest md = MessageDigest.getInstance(\"SHA-256\");\n    md.update(getAValue.getBytes());\n\n    byte byteData[] = md.digest();\n    StringBuffer sb = new StringBuffer();\n\n    for(int i=0;i<byteData.length;i++)\n    {\n        sb.append(Integer.toString((byteData[i] & 0xff) + 0x100, 16).substring(1));\n    }\n\n    String getHexValue = sb.toString();\n    System.out.println(\"hex format in SHA-256 is \"+getHexValue);\n\n    //createSpecificKey(biG,biP);\n\n    byte [] key = getAValue.getBytes(\"UTF-8\");\n\n    MessageDigest sha = MessageDigest.getInstance(\"SHA-256\");\n\n    key =  sha.digest(key);\n    key = Arrays.copyOf(key, 16);\n    SecretKeySpec secretKeySpec =  new SecretKeySpec(key,\"AES\");\n\n    Cipher cipher = Cipher.getInstance(\"AES\");\n    cipher.init(Cipher.ENCRYPT_MODE, secretKeySpec);\n\n    CipherInputStream cipt = new CipherInputStream(new FileInputStream(new File(\"C:\\\\Users\\\\Larry\\\\Desktop\\\\Java\\\\diffie hellman\\\\src\\\\jessica.jpg\")),cipher); // enter your filename here\n    FileOutputStream fop=new FileOutputStream(new File(\"C:\\\\Users\\\\Larry\\\\Desktop\\\\Java\\\\diffie hellman\\\\src\\\\testEncrypt.jpg\"));\n\n\n\n    int i;\n    while((i=cipt.read())!= -1)\n    {\n        fop.write(i);\n    }\n\n    cipher.init(Cipher.DECRYPT_MODE,secretKeySpec);\n\n    CipherInputStream cipt2 = new CipherInputStream(new FileInputStream(new File(\"C:\\\\Users\\\\Larry\\\\Desktop\\\\Java\\\\diffie hellman\\\\src\\\\testEncrypt.jpg\")),cipher); // encryption of image\n    FileOutputStream fop2 = new FileOutputStream(new File(\"C:\\\\Users\\\\Larry\\\\Desktop\\\\Java\\\\diffie hellman\\\\src\\\\testDecrypt.jpg\"));//decryption of images\n\n    int j;\n    while((j=cipt2.read())!=-1)\n    {\n        fop2.write(j);\n    }\n\n\n\n\n\n}\n\npublic static BigInteger calculateSharedKey(BigInteger pk , BigInteger sk, BigInteger safePrime)\n{\n    BigInteger sharedKey;\n\n    sharedKey = pk.modPow(sk, safePrime);\n\n    return sharedKey;\n}\n\n\npublic static long generateSKA()\n{\n    Random randomGenerator2=new Random();\n    long SKa = randomGenerator2.nextInt(1000000000);\n\n    return SKa;\n}\n\npublic static long generateSKB()\n{\n    Random randomGenerator3=new Random();\n    long SKb = randomGenerator3.nextInt(10000000);\n\n    return SKb;\n}\n\n\npublic static BigInteger generatePkA(BigInteger g,BigInteger p,long skA)\n{\n    BigInteger Pka,SK;\n    long secretKeyA = skA;\n\n    SK = BigInteger.valueOf(secretKeyA);\n\n    Pka=g.modPow(SK, p);\n\n    return Pka;\n}\n\n\npublic static BigInteger generatePkB(BigInteger g,BigInteger p,long skB)\n{\n    BigInteger Pkb,SK;\n    long secretKeyB = skB;\n    SK = BigInteger.valueOf(secretKeyB);\n    Pkb=g.modPow(SK, p);\n    return Pkb;\n}\n", "idx": 1867}
{"project": "cipher", "commit_id": "Snippet20490953_3100.java", "target": 1, "func": "public static void cryptoFunction() throws Exception\n        {\n            KeyStore store = KeyStore.getInstance(\"Windows-MY\", \"SunMSCAPI\");\n            store.load(null);\n            String alias = \"alias\";\n            Certificate cert = store.getCertificate(alias);\n            PublicKey pubKey = (PublicKey) cert.getPublicKey();\n            PrivateKey privKey = (PrivateKey) store.getKey(alias, \"123456\".toCharArray());\n            Cipher ecipher = Cipher.getInstance(\"RSA/ECB/PKCS1Padding\");\n            Cipher dcipher = Cipher.getInstance(\"RSA/ECB/PKCS1Padding\");\n\n            ecipher.init(Cipher.ENCRYPT_MODE, pubKey);\n\n            File userDir = new File(\"C:\\\\TestCryptoFiles\");\n            userDir.mkdir();\n\n            File tmpdestFile = new File(userDir, \"outFile.txt\");\n            File sourceFile = new File(userDir, \"InFile.txt\");\n\n            int cipherMode = Cipher.ENCRYPT_MODE; //Cipher.DECRYPT_MODE\n\n            byte[] buf = cipherMode == Cipher.ENCRYPT_MODE ? new byte[100]: new byte[128];\n            int bufl;\n\n            FileOutputStream outputWriter = new FileOutputStream(tmpdestFile);\n            FileInputStream inputReader = new FileInputStream(sourceFile);         \n            if(cipherMode == Cipher.ENCRYPT_MODE){\n                while ((bufl = inputReader.read(buf)) != -1) {\n                    byte[] encText = null;\n                    encText = ecipher.doFinal(copyBytes(buf, bufl));\n                    System.out.println(new String(encText));\n                //  encText = dcipher.doFinal(encText);  // works well...\n                    outputWriter.write(encText);\n                }\n            }else{\n                while ((bufl = inputReader.read(buf)) != -1) {\n                    byte[] encText = null;\n                    encText = dcipher.doFinal(copyBytes(buf, bufl)); // throws exception Bad data...\n                    System.out.println(new String(encText));\n                    outputWriter.write(encText);\n                }\n            }\n        }\n     public static byte[] copyBytes(byte[] arr, int length) {\n            byte[] newArr = null;\n            if (arr.length == length)\n                newArr = arr;\n            else {\n                newArr = new byte[length];\n                for (int i = 0; i < length; i++) {\n                    newArr[i] = (byte) arr[i];\n                }\n            }\n            return newArr;\n        }\n", "idx": 1963}
{"project": "cipher", "commit_id": "Snippet21043423_3615.java", "target": 0, "func": "Cipher cipherInstance = Cipher.getInstance(\"DES/CBC/NoPadding\");\n", "idx": 1645}
{"project": "cipher", "commit_id": "Snippet32816389_14908.java", "target": 1, "func": "public static void decryptPublic() throws Exception{\n\n    byte[] modulusBytes = Base64.getDecoder().decode(mod);\n    byte[] expBytes = Base64.getDecoder().decode(exp);\n\n    BigInteger modulus = new BigInteger(1, (modulusBytes));\n    BigInteger exponent = new BigInteger(1, (expBytes));\n\n    RSAPublicKeySpec pubKey = new RSAPublicKeySpec(modulus, exponent);\n    KeyFactory fact = KeyFactory.getInstance(\"RSA\");\n    PublicKey publicKey = fact.generatePublic(pubKey);\n    Cipher cipher = Cipher.getInstance(\"RSA/ECB/PKCS1Padding\");\n    cipher.init(Cipher.DECRYPT_MODE, publicKey );\n\n\n    byte[] cipherData = Base64.getDecoder().decode(cipherByte);\n    byte[] plainBytes = cipher.doFinal(cipherData);\n\n    System.out.println(new String(plainBytes));\n} \n", "idx": 1965}
{"project": "cipher", "commit_id": "Snippet43501070_25637.java", "target": 1, "func": "public  String encryptAsymmetric(String input, Key key) throws GeneralSecurityException, IOException {\n    byte[] crypted = null;\n    try{\n\n        Cipher cipher = Cipher.getInstance(\"RSA\");\n        cipher.init(Cipher.ENCRYPT_MODE, key);\n        crypted = cipher.doFinal(input.getBytes());\n    }catch(Exception e){\n        System.out.println(e.toString());\n    }//Base64.encodeBase64(crypted)\n\n    return new String(Base64.encode(crypted, Base64.DEFAULT));\n}\npublic  String decryptAsymmetric(String input, Key key){\n    byte[] output = null;\n    try{\n\n        Cipher cipher = Cipher.getInstance(\"RSA\");\n        cipher.init(Cipher.DECRYPT_MODE, key);//Base64.decodeBase64(input.getBytes())\n        output = cipher.doFinal(Base64.decode(input.getBytes(), Base64.DEFAULT));\n    }catch(Exception e){\n        System.out.println(e.toString());\n    }\n    return new String(output);\n}\n", "idx": 2232}
{"project": "cipher", "commit_id": "Snippet35558249_17452.java", "target": 1, "func": "private static final String fallbackSalt = \"ajefa6tc73t6raiw7tr63wi3r7citrawcirtcdg78o2vawri7t\";\nprivate static final int iterations = 2000;\nprivate static final int keyLength = 256;\nprivate static final SecureRandom random = new SecureRandom();\n\npublic byte[] encrypt(String plaintext, String passphrase, String salt)\n        throws Exception {\n    SecretKey key = generateKey(passphrase, salt);\n    Cipher cipher = Cipher.getInstance(\"AES/GCM/NoPadding\", \"BC\");\n    cipher.init(Cipher.ENCRYPT_MODE, key, generateIV(cipher),random);\n    return cipher.doFinal(plaintext.getBytes());\n}\n\npublic String decrypt(byte[] encrypted, String passphrase, String salt)\n        throws Exception {\n    SecretKey key = generateKey(passphrase, salt);\n    Cipher cipher = Cipher.getInstance(\"AES/GCM/NoPadding\", \"BC\");\n    cipher.init(Cipher.DECRYPT_MODE, key, generateIV(cipher),random);\n    return new String(cipher.doFinal(encrypted));\n}\n\nprivate SecretKey generateKey(String passphrase, String salt)\n        throws Exception {\n    PBEKeySpec keySpec = new PBEKeySpec(passphrase.toCharArray(),\n            salt.getBytes(), iterations, keyLength);\n    SecretKeyFactory keyFactory = SecretKeyFactory\n            .getInstance(\"PBEWITHSHA256AND256BITAES-CBC-BC\");\n    return keyFactory.generateSecret(keySpec);\n}\n\nprivate IvParameterSpec generateIV(Cipher cipher) throws Exception {\n    byte[] ivBytes = new byte[cipher.getBlockSize()];\n    random.nextBytes(ivBytes);\n    return new IvParameterSpec(ivBytes);\n}\n", "idx": 2304}
{"project": "cipher", "commit_id": "Snippet26785193_8940.java", "target": 1, "func": "import javax.crypto.Cipher;\nimport javax.crypto.spec.IvParameterSpec;\nimport javax.crypto.spec.SecretKeySpec;\n\nimport org.apache.commons.codec.binary.Base64;\n\npublic class crypto {\n    public static void main(String [] args) {\n        String s = args[0];\n        String s1 = args[1];\n        String ivkey = \"thisisasecretword1\";\n          byte[] ivraw = ivkey.getBytes();\n          SecretKeySpec skeySpec = new SecretKeySpec(ivraw, \"AES\");\n          byte[] iv = { 't','h','i','s','a','s','e','c','r','e','t','w','o','r','d','1' };\n      IvParameterSpec ivspec = new IvParameterSpec(iv);\n\n        if (s.equalsIgnoreCase(\"ENCRYPT\")) {\n            try {\n                Cipher cipher = Cipher.getInstance(\"AES/CBC/PKCS5Padding\");\n                cipher.init(Cipher.ENCRYPT_MODE, skeySpec, ivspec);\n                byte[] encrypted = cipher.doFinal(s1.getBytes());\n                System.out.println(\"encrypt: \" + new String(Base64.encodeBase64(encrypted)));\n\n            } catch (Exception e) {\n                throw new RuntimeException(e);\n            }\n        } else {\n            try {\n                Cipher cipher = Cipher.getInstance(\"AES/CBC/PKCS5Padding\");\n                cipher.init(Cipher.DECRYPT_MODE, skeySpec, ivspec);\n                byte[] encrypted = cipher.doFinal(Base64.decodeBase64(s1));\n                System.out.println(\"decrypt: \" + new String(encrypted));\n\n            } catch (Exception e) {\n                e.printStackTrace();\n            }\n        }\n    };\n}\n", "idx": 2330}
{"project": "cipher", "commit_id": "Snippet30632407_12829.java", "target": 1, "func": "     public void generateKey() throws NoSuchAlgorithmException, NoSuchPaddingException,\n                IllegalBlockSizeException,BadPaddingException,InvalidKeyException{\n            try{\n                kpg = KeyPairGenerator.getInstance(\"RSA\");\n\n                kpg.initialize(256);\n                kp = kpg.genKeyPair();\n\n            }catch(Exception e){\n                e.printStackTrace();\n                Toast.makeText(getBaseContext(), e.toString(),Toast.LENGTH_LONG).show();\n\n            }\n\n        }\n        public byte[] RSAEncrypt(final String plain) throws NoSuchAlgorithmException, NoSuchPaddingException,\n                IllegalBlockSizeException, BadPaddingException, InvalidKeyException {\n        try {\n            publicKey = kp.getPublic();\n            privateKey = kp.getPrivate();\n\n            cipher = Cipher.getInstance(\"RSA\");\n            cipher.init(Cipher.ENCRYPT_MODE, publicKey);\n            encryptedBytes = cipher.doFinal(plain.getBytes(\"UTF-8\"));\n        }catch (Exception e){\n            e.printStackTrace();\n            Toast.makeText(getBaseContext(),e.toString(),Toast.LENGTH_LONG).show();\n        }\n            return encryptedBytes;\n        }\n public void enviaSMS(View view) {\n        EditText key = (EditText) findViewById(R.id.publicKey);\n        EditText phoneNumber = (EditText) findViewById(R.id.phoneNumber);\n        EditText text = (EditText) findViewById(R.id.TextMessage);\n        String keyText = key.getText().toString();\n        String number = phoneNumber.getText().toString();\n        String sms = text.getText().toString();\n        if (!keyText.equals(\"\") && !number.equals(\"\") && !sms.equals(\"\")) {\n            try {\n\n                byte[] encriptedSMS= RSAEncrypt(sms);\n                Log.i(\"teste\",new String(encriptedSMS));\n                Log.i(\"teste\",new String(encriptedSMS, \"UTF-8\"));\n                Toast.makeText(getBaseContext(), new String(encriptedSMS, \"UTF-8\"), Toast.LENGTH_SHORT).show(); // ou send?:3\n                SmsManager smsManager = SmsManager.getDefault();\n\n                smsManager.sendTextMessage(number, null, new String(encriptedSMS,\"UTF-8\"), null, null);\n\n                Toast.makeText(getApplicationContext(), \"SMS Sent!\", Toast.LENGTH_LONG).show();\n            } catch (Exception e) {\n                e.printStackTrace();\n                Toast.makeText(getBaseContext(),e.toString(),Toast.LENGTH_LONG).show();\n            }\n\n        }\n    }\n", "idx": 2011}
{"project": "cipher", "commit_id": "Snippet22858497_5261.java", "target": 0, "func": "import java.security.InvalidKeyException;  \nimport java.security.NoSuchAlgorithmException;    \nimport javax.crypto.BadPaddingException;  \nimport javax.crypto.Cipher;  \nimport javax.crypto.IllegalBlockSizeException;  \nimport javax.crypto.KeyGenerator;  \nimport javax.crypto.NoSuchPaddingException;  \nimport javax.crypto.SecretKey;\n\npublic class DESEncryptionDecryption {\n\nprivate static Cipher encryptCipher;  \nprivate static Cipher decryptCipher; \npublic static void main(String[] args) {  \ntry {\nKeyGenerator keygenerator = KeyGenerator.getInstance(\"DES\");  \nSecretKey secretKey = keygenerator.generateKey();  \n\nencryptCipher = Cipher.getInstance(\"DES/ECB/PKCS5Padding\");  \nencryptCipher.init(Cipher.ENCRYPT_MODE, secretKey);  \nbyte[] encryptedData = encryptData(\"Classified Information!\");  \n\ndecryptCipher = Cipher.getInstance(\"DES/ECB/PKCS5Padding\");  \ndecryptCipher.init(Cipher.DECRYPT_MODE, secretKey);  \ndecryptData(encryptedData);\n}}}\n", "idx": 1746}
{"project": "cipher", "commit_id": "Snippet30685297_12799.java", "target": 0, "func": "public static String decrypt(String message){\n    try {\n        Cipher c = Cipher.getInstance(\"AES\");\n        SecretKeySpec key = new SecretKeySpec(secrKey.getBytes(), \"AES\");\n        c.init(Cipher.DECRYPT_MODE, key);\n        byte[] decordedValue = Base64.decode(message.getBytes(), Base64.DEFAULT);\n        byte[] decValue = c.doFinal(decordedValue);\n        String decryptedValue = new String(decValue);\n        String decoded = new String(Base64.decode(decryptedValue, Base64.DEFAULT));\n        return decoded;\n    }catch(Exception e){\n        return null;\n    }\n}\n", "idx": 1748}
{"project": "cipher", "commit_id": "Snippet40424606_22269.java", "target": 0, "func": "import javax.crypto.Cipher;\nimport javax.crypto.spec.IvParameterSpec;\nimport javax.crypto.spec.SecretKeySpec;\n\nimport javax.xml.bind.DatatypeConverter;\n\npublic class Encryptor {\n    private static String algorithm = \"RC4\";\n    public static String encrypt(String key, String value) {\n        try {\n            SecretKeySpec rc4Key = new SecretKeySpec(key.getBytes(), algorithm);\n            Cipher rc4 = Cipher.getInstance(algorithm);\n\n            rc4.init(Cipher.ENCRYPT_MODE, rc4Key);\n            byte [] encrypted = rc4.update(value.getBytes());\n            return DatatypeConverter.printBase64Binary(encrypted);\n        } catch (Exception ex) {\n            ex.printStackTrace();\n        }\n\n        return null;\n    }\n\n    public static void main(String[] args) {\n        String key = \"trololol\";\n        String value = \"0612345678\";\n\n        System.out.println(encrypt(key, value));\n    }\n}\n", "idx": 1666}
{"project": "cipher", "commit_id": "Snippet29074406_11136.java", "target": 1, "func": "byte[] encrypt(byte[] clearData) {\n   byte[] passwordKey = { 0x00, 0x01, 0x02, 0x03, 0x04, 0x05, 0x06, 0x07, 0x08, 0x09, 0x0A, 0x0B, 0x0C, 0x0D, 0x0E,0x0f};\n   byte[] rawSecretKey = new byte[]{0x34, (byte) 0xA4, 0x16, 0x09, 0x77, (byte) 0x85, (byte) 0xB4, 0x31,\n                                                0x75, 0x12, (byte) 0x92, (byte) 0xDD, (byte) 0xCA, 0x15, (byte) 0xAB, (byte) 0xBA};\n   secretKey = new SecretKeySpec(passwordKey, \"AES\");\n   ivParameterSpec = new IvParameterSpec(rawSecretKey);\n   Cipher aesCipher = Cipher.getInstance(\"AES/CBC/PKCS5Padding\");\n   aesCipher.init(Cipher.ENCRYPT_MODE, secretKey, ivParameterSpec);\n\n   byte[] encryptedData;\n   encryptedData = aesCipher.doFinal(clearData);\n\n   return encryptedData;\n}\n", "idx": 2313}
{"project": "cipher", "commit_id": "Snippet21008480_3607.java", "target": 1, "func": "public boolean CheckSignature(byte[] aMessage, byte[] aSignature,\n            PublicKey aPK) {\n        try {\n            // get an instance of a cipher with RSA with ENCRYPT_MODE\n            // Init the signature with the private key\n            // decrypt the signature\n            Cipher cipher = Cipher.getInstance(\"RSA\");\n            cipher.init(Cipher.DECRYPT_MODE, aPK);\n            byte[] decrypted_digest =  cipher.doFinal(aSignature);\n\n            // get an instance of the java.security.MessageDigest with MD5\n            MessageDigest md5_digest = MessageDigest.getInstance(\"MD5\");\n\n            // process the digest\n            md5_digest.update(aMessage);\n            byte[] digest = md5_digest.digest();\n\n            // check if digest1 == digest2\n            if (decrypted_digest == digest) {\n                return true;\n            }else {\n                return false;\n            }\n\n        } catch (Exception e) {\n            System.out.println(\"Verify signature error\");\n            e.printStackTrace();\n            return false;\n        }\n    }\n", "idx": 2231}
{"project": "cipher", "commit_id": "Snippet19675946_2406.java", "target": 0, "func": "private void performDecryption(DocumentModel document)\n    {                               \n        byte[] keyBytes = generateByteArray(document.getEncryptionKey());\n\n\n        SecretKeySpec skeySpec = new SecretKeySpec(keyBytes, \"AES\");\n\n        File encryptedDocument = new File(getBookFolderDocumentName(document, document.getFileSuffix()));\n        File decryptedDocument = new File(BOOK_FOLDER + document.getGeneratedAssetName() + \"_decrypted\" + \".\" + document.getFileSuffix());\n\n        decryptedDocument.mkdirs();\n        if (decryptedDocument.exists())\n            decryptedDocument.delete();\n\n\n        Cipher cipher = null;    \n\n        try\n        {\n\n            cipher = Cipher.getInstance(\"AES/ECB/ZeroBytePadding\");\n            cipher.init(Cipher.DECRYPT_MODE, skeySpec);         \n        } \n        catch (NoSuchAlgorithmException noSuchAlgorithmEx)\n        {\n            Log.e(\"Decryption\", \"NoSuchAlgorithmException: \" + noSuchAlgorithmEx.getMessage());\n        }\n        catch (NoSuchPaddingException noSuchPaddingEx)\n        {\n            Log.e(\"Decryption\", \"NoSuchPaddingException: \" + noSuchPaddingEx.getMessage());\n        }\n        catch (InvalidKeyException invalidKeyEx)\n        {\n            Log.e(\"Decryption\", \"InvalidKeyException: \" + invalidKeyEx.getMessage());\n        } \n\n        FileInputStream encryptedFileStream = null;\n        FileOutputStream decryptedFileStream = null;\n\n\n        try\n        {\n\n            encryptedFileStream = new FileInputStream(encryptedDocument);\n            decryptedFileStream = new FileOutputStream(decryptedDocument);\n\n\n\n            long totalFileSize = encryptedDocument.length();\n            long totalDecrypted = 0;\n            int lastPercentage = -1;\n            int currentPercentage = 0;\n\n            byte[] encryptedBuffer = new byte[4096];\n            byte[] decryptedBuffer = new byte[4096];\n            int encryptedLength = 0;\n            int decryptedLength = 0;\n\n            while((encryptedLength = encryptedFileStream.read(encryptedBuffer)) > 0)\n            {   \n                while (encryptedLength % 16 != 0) // the code never lands in this loop\n                {                   \n                    encryptedBuffer[encryptedLength] = 0;\n                    encryptedLength++;\n                }\n\n                decryptedLength = cipher.update(encryptedBuffer, 0, encryptedLength, decryptedBuffer);\n\n\n                while (decryptedLength % 16 != 0) // the code never lands in this loop\n                {\n                    decryptedBuffer[decryptedLength] = 0;\n                    decryptedLength++;\n                }\n\n                decryptedFileStream.write(decryptedBuffer, 0, decryptedLength);\n\n\n                totalDecrypted += encryptedLength;\n\n                currentPercentage = (int)(((float)totalDecrypted / (float)totalFileSize) * 100f);\n\n                if (currentPercentage != lastPercentage)\n                {\n                    lastPercentage = currentPercentage;\n                    Log.i(\"Decryption\", \"Decrypting... \" + currentPercentage + \"%\");\n                }\n            }\n\n\n\n\n            Log.i(\"Decryption\", \"Finished decrypting!\");\n        }\n        catch (FileNotFoundException fileNotFoundEx)\n        {\n            Log.e(\"Decryption\", \"FileNotFoundException: \" + fileNotFoundEx.getMessage());\n        }\n        catch (IOException ioEx)\n        {\n            Log.e(\"Decryption\", \"IOException: \" + ioEx.getMessage());\n        } \n        catch (ShortBufferException e) \n        {       \n            e.printStackTrace();\n        }\n        finally\n        {\n\n        }\n\n        try \n        {                   \n            encryptedFileStream.close();\n            decryptedFileStream.close();\n            cipherOutputStream.close();         \n        } \n        catch (IOException e1) \n        {\n\n        }\n\n\n        document.setDecryptedFilePath(decryptedDocument.getAbsolutePath());\n\n\n\n        Log.i(\"Decryption\", \"Finished!\");\n    }\n", "idx": 1907}
{"project": "cipher", "commit_id": "Snippet14022343_37434.java", "target": 1, "func": "  private static byte[] decryptMessage(byte[] file, byte[] iVector, byte[] aesKey) throws Exception {\n    IvParameterSpec spec = new IvParameterSpec(Arrays.copyOfRange(iVector, 0, 16));\n    SecretKeySpec key = new SecretKeySpec(Arrays.copyOfRange(aesKey, 0, 16), \"AES\");\n    Cipher cipher = Cipher.getInstance(\"AES/CFB/NoPadding\");\n    cipher.init(Cipher.DECRYPT_MODE, key, spec);\n    return cipher.doFinal(file);\n  }\n", "idx": 2191}
{"project": "cipher", "commit_id": "Snippet18175492_1216.java", "target": 1, "func": "String key = \"1234567890123456\";\nbyte[] encrypted_bytes = READ_DATA_FROM_FILE\nSecretKeySpec skeySpec = new SecretKeySpec(key.getBytes(), \"AES\");\nIvParameterSpec ivSpec = new IvParameterSpec(key.getBytes());\nCipher cipher = Cipher.getInstance(\"AES/CBC/NoPadding\");\ncipher.init(Cipher.DECRYPT_MODE, skeySpec, ivSpec);\nString plain_text = new String(cipher.doFinal(encrypted_bytes));\n", "idx": 2349}
{"project": "cipher", "commit_id": "Snippet28740533_10888.java", "target": 1, "func": "import java.io.IOException;\nimport java.io.Reader;\nimport java.io.StringReader;\nimport java.net.URLDecoder;\nimport java.net.URLEncoder;\nimport java.security.Key;\nimport java.security.PublicKey;\nimport java.security.Security;\n\nimport javax.crypto.Cipher;\n\nimport org.bouncycastle.asn1.x509.SubjectPublicKeyInfo;\nimport org.bouncycastle.openssl.PEMKeyPair;\nimport org.bouncycastle.openssl.PEMParser;\nimport org.bouncycastle.openssl.jcajce.JcaPEMKeyConverter;\nimport org.bouncycastle.util.encoders.Base64;\nimport org.junit.Test;\n\npublic class TestTut2 {\n    @Test\n    public void TestKeyPair() throws IOException {\n        Security.addProvider(new org.bouncycastle.jce.provider.BouncyCastleProvider());\n        String privateKeyString = \"-----BEGIN RSA PRIVATE KEY-----\\n\" + \"MIICXQIBAAKBgQDKQtJAyCu5FHwDncK2LB/J5ClJhulGggyc7vwtji6TJHtSJfgD\\n\" + \"4TLpHRIHh/cHqf3brhpQtYB9yjKlwogji/OzedY2mdTdSOP8O6suJYu3QENN2xG/\\n\" + \"HvT8UiYK3feVLbJtukhJm7eSuwfMDsjHh4AK7g11fVs6EmY+foh3mjoKLQIDAQAB\\n\" + \"AoGAR8N/wDaFtOx8t/fAv0xWlxaaQ5lXqYm5GfF9jlhVVCXsj5AjOJUtsCJ9ZCis\\n\" + \"0I5TIR/b/Gj5xyf34nJsRViBxbnf6XdLGyXmzsNxWZoWbM70JaqU3iQKm605/EnD\\n\" + \"vPgrI0AMfc/h6Kog0zLrKWKkna+wE5839yMmm7WPqgvxSc0CQQDoud5e3yZu/1e+\\n\" + \"7piFZZl6StAecl+k10Wq5kzJeVQRffDB3JCca65H/W1EZIzEh76pUNr7SYAIIcbK\\n\" + \"jzOdbj1vAkEA3n0AudM3mBzklLEUSHs1ZSqFkUMNP9MNIikwkZ/9Z2AlhW5gnwiv\\n\" + \"dgeXonTqlTFux4e7uyKZoJpJcKAgmMicIwJBAIMl206TalE6y/Po+UKTUr470rSV\\n\" + \"t5hpR/Va+wK+wMVqt3ZIGaZMeFZRVnYoQ7us06EO05iwftoWTrRvpqKdMTkCQBkE\\n\"\n                + \"QzWhy0l+TjFt69Luj6Vtb5FS0cWQbJSfvwdQzwR1qiJjs9eN+XSzC9jHfq0B3uvu\\n\" + \"lixHirClSIayapfjTrMCQQCM8d97py4u9hCdCpsHBDt54dXkHsDA2abNzaPri/YA\\n\" + \"pNFZGrfXKVGSLFOfsuf7Wj+yL7ew6ZVKOMYdJ+zb9Wwv\\n\" + \"-----END RSA PRIVATE KEY-----\"; // 128\n                                                                                                                                                                                                                                                    // bit\n                                                                                                                                                                                                                                                    // key\n        String publicKeyString = \"-----BEGIN PUBLIC KEY-----\\n\" + \"MIGfMA0GCSqGSIb3DQEBAQUAA4GNADCBiQKBgQDKQtJAyCu5FHwDncK2LB/J5ClJ\\n\" + \"hulGggyc7vwtji6TJHtSJfgD4TLpHRIHh/cHqf3brhpQtYB9yjKlwogji/OzedY2\\n\" + \"mdTdSOP8O6suJYu3QENN2xG/HvT8UiYK3feVLbJtukhJm7eSuwfMDsjHh4AK7g11\\n\" + \"fVs6EmY+foh3mjoKLQIDAQAB\\n\" + \"-----END PUBLIC KEY-----\";\n        String message = \"Lorem ipsum dolor sit amet, consectetur adipiscing elit.\";\n        String cypherText = \"EqVFWCMJ2rSy1J0PjAkRRZKkQ24TJ7xQi%2FjKUa3E7ZJ%2FlwtFsBkUDqJ9VUb0aC53O4TM4uNKMmYQNFDTHpQSgoun95ExgoCAvC1BXz2jVzWkKavt1vWbhS1C5VKcWU0hfUOmxZgiOT4rGWpEXVXoLodKLiJnbkvVNZyjgw0LZPQ%3D\";\n\n        System.out.println(\"private:\");\n\n        Reader privateKeyReader = new StringReader(privateKeyString);\n\n        PEMParser privatePemParser = new PEMParser(privateKeyReader);\n        Object privateObject = privatePemParser.readObject();\n        System.out.println(\"private: \" + privateObject.getClass());\n        if (privateObject instanceof PEMKeyPair) {\n            PEMKeyPair pemKeyPair = (PEMKeyPair) privateObject;\n            System.out.println(\"private: \" + pemKeyPair.getPrivateKeyInfo());\n            System.out.println(\"public: \" + pemKeyPair.getPublicKeyInfo());\n\n            JcaPEMKeyConverter converter = new JcaPEMKeyConverter().setProvider(\"BC\");\n\n            PublicKey publicKey = converter.getPublicKey(pemKeyPair.getPublicKeyInfo());\n\n            String encodedURL = null;\n            try {\n                System.out.println(\"encrypting using WP publicKey and own cypherText\\r\\n\");\n\n                byte[] encripted = encrypt(publicKey, message);\n                System.out.println(\"encrypted: \" + new String(encripted));\n\n                byte[] encodedURLBase64 = Base64.encode(encripted);\n                System.out.println(\"base64: \" + new String(encodedURLBase64));\n\n                encodedURL = URLEncoder.encode(new String(encodedURLBase64));\n                System.out.println(\"encodedURL: \" + encodedURL);\n            } catch (Exception erm) {\n                System.out.println(\"erm: \"+erm.getMessage());\n            }\n            // and back\n            try {\n                System.out.println(\"decrypting using WP publicKey and own cypherText\\r\\n\");\n                String decodedURL = URLDecoder.decode(encodedURL);\n                System.out.println(\"decodedURL: \" + decodedURL);\n\n                byte[] decodedURLBase64 = Base64.decode(decodedURL);\n                System.out.println(\"decodedURLBase64: \" + new String(decodedURLBase64));\n\n                String decrypted = decrypt(publicKey, decodedURLBase64);\n                System.out.println(\"decrypted: \" + new String(decrypted));\n            } catch (Exception erm) {\n                System.out.println(\"erm: \"+erm.getMessage());\n            }\n            // using stuff from external party\n            try {\n                System.out.println(\"decrypting using WP publicKey and WP cypherText\\r\\n\");\n\n                String decodedURLWP = URLDecoder.decode(cypherText);\n                System.out.println(\"decodedURLBase64WP: \" + decodedURLWP);\n\n                byte[] decodedURLBase64WP = Base64.decode(decodedURLWP);\n                System.out.println(\"decodedURLBase64WP: \" + new String(decodedURLBase64WP));\n\n                String decryptedWP = decrypt(publicKey, decodedURLBase64WP);\n                System.out.println(\"decryptedWP: \" + new String(decryptedWP));\n            } catch (Exception erm) {\n                System.out.println(\"erm: \"+erm.getMessage());\n            }\n\n        }\n        privatePemParser.close();\n\n        System.out.println(\"public:\");\n        Reader publicKeyReader = new StringReader(publicKeyString);\n        PEMParser publicPemParser = new PEMParser(publicKeyReader);\n\n        Object publicObject = publicPemParser.readObject();\n        System.out.println(\"public: \" + publicObject.getClass());\n        if (publicObject instanceof SubjectPublicKeyInfo) {\n            SubjectPublicKeyInfo publicSubjectPublicKeyInfo = (SubjectPublicKeyInfo) publicObject;\n            // System.out.println(\"private: \"+publicSubjectPublicKeyInfo);\n            System.out.println(\"public: \" + publicSubjectPublicKeyInfo);\n\n        }\n        publicPemParser.close();\n\n\n\n    }\n\n    private static byte[] encrypt(Key pubkey, String text) {\n        try {\n            Cipher rsa;\n            rsa = Cipher.getInstance(\"RSA\", \"BC\");\n            rsa.init(Cipher.ENCRYPT_MODE, pubkey);\n            return rsa.doFinal(text.getBytes());\n        } catch (Exception e) {\n            e.printStackTrace();\n        }\n        return null;\n    }\n\n    private static String decrypt(Key decryptionKey, byte[] buffer) {\n        try {\n            Cipher rsa;\n            rsa = Cipher.getInstance(\"RSA\", \"BC\");\n            rsa.init(Cipher.DECRYPT_MODE, decryptionKey);\n            byte[] utf8 = rsa.doFinal(buffer);\n            return new String(utf8);\n        } catch (Exception e) {\n            e.printStackTrace();\n        }\n        return null;\n    }\n\n}\n", "idx": 2135}
{"project": "cipher", "commit_id": "Snippet9907052_34317.java", "target": 0, "func": "import java.io.*;\nimport java.security.*;\nimport javax.crypto.*;\nimport sun.misc.BASE64Encoder;\n\n\npublic class RCCC4 {\npublic static void main(String[] args) {\n    String strDataToEncrypt = new String();\n    String strCipherText = new String();\n    String strDecryptedText = new String();\n\n    try{ \n    KeyGenerator keyGen = KeyGenerator.getInstance(\"RC4\");\n    SecretKey secretKey = keyGen.generateKey();\n    Cipher aesCipher = Cipher.getInstance(\"RC4\");\n    aesCipher.init(Cipher.ENCRYPT_MODE,secretKey);\n    strDataToEncrypt = \"Hello World of Encryption using RC4 \";\n    byte[] byteDataToEncrypt = strDataToEncrypt.getBytes();\n    byte[] byteCipherText = aesCipher.doFinal(byteDataToEncrypt); \n    strCipherText = new BASE64Encoder().encode(byteCipherText);\n    System.out.println(\"Cipher Text generated using RC4 is \" +strCipherText);\n    aesCipher.init(Cipher.DECRYPT_MODE,secretKey,aesCipher.getParameters());\n    byte[] byteDecryptedText = aesCipher.doFinal(byteCipherText);\n    strDecryptedText = new String(byteDecryptedText);\n    System.out.println(\" Decrypted Text message is \" +strDecryptedText);\n    }\n    catch (NoSuchPaddingException noSuchPad)\n        {\n            System.out.println(\" No Such Padding exists \" + noSuchPad);\n        }\n\n    catch (InvalidKeyException invalidKey)\n        {\n                System.out.println(\" Invalid Key \" + invalidKey);\n        }\n\n    catch (BadPaddingException badPadding)\n        {\n                System.out.println(\" Bad Padding \" + badPadding);\n        }\n\n    catch (IllegalBlockSizeException illegalBlockSize)\n        {\n                System.out.println(\" Illegal Block Size \" + illegalBlockSize);\n        }\n\n    catch (InvalidAlgorithmParameterException invalidParam)\n        {\n                System.out.println(\" Invalid Parameter \" + invalidParam);\n        }\n\n}\n   }\n", "idx": 1889}
{"project": "cipher", "commit_id": "Snippet11090193_35297.java", "target": 0, "func": "PBEKeySpec pbeKeySpec;\nPBEParameterSpec pbeParamSpec;\nSecretKeyFactory keyFac;\n\n// Salt\nbyte[] salt = {\n    (byte)0xc7, (byte)0x73, (byte)0x21, (byte)0x8c,\n    (byte)0x7e, (byte)0xc8, (byte)0xee, (byte)0x99\n};\n\n// Iteration count\nint count = 20;\n\n// Create PBE parameter set\npbeParamSpec = new PBEParameterSpec(salt, count);\n\n// Prompt user for encryption password.\n// Collect user password as char array (using the\n// \"readPasswd\" method from above), and convert\n// it into a SecretKey object, using a PBE key\n// factory.\nSystem.out.print(\"Enter encryption password:  \");\nSystem.out.flush();\npbeKeySpec = new PBEKeySpec(readPasswd(System.in));\nkeyFac = SecretKeyFactory.getInstance(\"PBEWithMD5AndDES\");\nSecretKey pbeKey = keyFac.generateSecret(pbeKeySpec);\n\n// Create PBE Cipher\nCipher pbeCipher = Cipher.getInstance(\"PBEWithMD5AndDES\");\n\n// Initialize PBE Cipher with key and parameters\npbeCipher.init(Cipher.ENCRYPT_MODE, pbeKey, pbeParamSpec);\n\n// Our cleartext\nbyte[] cleartext = \"This is another example\".getBytes();\n\n// Encrypt the cleartext\nbyte[] ciphertext = pbeCipher.doFinal(cleartext);\n", "idx": 1840}
{"project": "cipher", "commit_id": "Snippet31540927_13683.java", "target": 0, "func": "Cipher cipher = Cipher.getInstance(\"RSA/None/OAEPWithSHA1AndMGF1Padding\", \"BC\");\n", "idx": 1585}
{"project": "cipher", "commit_id": "Snippet13956463_37387.java", "target": 1, "func": "//Compress, Encrypt, Decrypt, Decompress variables \npublic final static String Secretkey = \"###hidden######\";\npublic final static String VectorInitializationKey = \"###hidden###\";\npublic final static String transformation = \"AES/CFB8/PKCS5Padding\";  \n\npublic static byte[] encryptandCompress(byte[] input)\n{\n    ByteArrayOutputStream ms = new ByteArrayOutputStream();\n    GZIPOutputStream gos = null; // Added\n    CipherOutputStream cos= null; // Added\n\n    SecretKeySpec skeySpec = new SecretKeySpec(Secretkey.getBytes(), \"AES\");\n    Cipher cipher;\n\n    try {\n        cipher = Cipher.getInstance(transformation);\n        IvParameterSpec iv = new IvParameterSpec(VectorInitializationKey.getBytes());\n        cipher.init(Cipher.ENCRYPT_MODE, skeySpec, iv);\n        cos = new CipherOutputStream(ms, cipher ); \n        gos= new GZIPOutputStream (cos);\n        gos.write(input);\n        gos.close(); // Must be called before we return bytes from ms\n        cos.close();\n        byte[] toReturn = ms.toByteArray();  \n        Log.d(\"FileWriter\", \"Encrypted and compressed \" + input.length + \" bytes to \" + toReturn.length + \" bytes\");\n        Log.d(\"FileWriter\", \"Encrypted and compressed \" + toReturn.length/16.0 + \" blocks written\");\n\n        return toReturn;        \n\n    } catch (Exception e) {\n        Log.e(\"FileWriter\", \"Compression failed: \" + e.getMessage());\n        return null;\n    }\n\n    finally \n    {\n        try \n        {\n            if (gos != null) \n            {\n                gos.close();\n            }\n            if (cos != null) \n            {\n                cos.close();\n            }\n            if (ms != null) \n            {\n                ms.close();\n            }\n        } \n        catch (IOException e) {\n\n            e.printStackTrace();\n        }\n\n        catch (Exception e) \n        {\n            e.printStackTrace();\n        }\n    }\n}\n", "idx": 2331}
{"project": "cipher", "commit_id": "Snippet17567996_731.java", "target": 0, "func": "public static String symmetricDecrypt(String text, String secretKey) {\n    BASE64Decoder decoder = new BASE64Decoder();\n    BASE64Decoder base64Decoder = new BASE64Decoder();\n    Cipher cipher;\n    String encryptedString;\n    byte[] encryptText = null;\n    byte[] raw;\n    SecretKeySpec skeySpec;\n    try {\n        raw = decoder.decodeBuffer(secretKey);\n        skeySpec = new SecretKeySpec(raw, \"AES\");\n        encryptText = base64Decoder.decodeBuffer(text);\n        cipher = Cipher.getInstance(\"AES\");\n        cipher.init(Cipher.DECRYPT_MODE, skeySpec);\n        encryptedString = new String(cipher.doFinal(encryptText));\n    } catch (Exception e) {\n        e.printStackTrace();\n        return \"Error\";\n    }\n    return encryptedString;\n}\n", "idx": 1758}
{"project": "cipher", "commit_id": "Snippet27896254_10045.java", "target": 1, "func": "public static void main(String[] args) throws Exception {\n\n    encrypt(new Scanner(System.in).next());\n}\npublic static String encrypt(String fileToEncrypt) throws Exception{\n    KeyGenerator kgen = KeyGenerator.getInstance(\"AES\");\n    kgen.init(128);\n    SecretKey _keyPair = kgen.generateKey();\n\n    Cipher _cipher = Cipher.getInstance(\"AES/CBC/PKCS5Padding\");\n    _cipher.init(Cipher.ENCRYPT_MODE, _keyPair);\n\n    File inputfile = new File(fileToEncrypt);\n    File outputfile = new File(\"D:/SECUREFILE\".concat(\"/\").concat(FilenameUtils.getName(fileToEncrypt)));\n    FileInputStream inputstream = new FileInputStream(inputfile);\n    FileOutputStream outputStream = new FileOutputStream(outputfile, false);\n    CipherOutputStream cos = new CipherOutputStream(outputStream, _cipher);\n    IOUtils.copy(inputstream, cos);\n    IOUtils.closeQuietly(inputstream);\n    IOUtils.closeQuietly(cos);\n    return outputfile.getPath();\n}\n", "idx": 1956}
{"project": "cipher", "commit_id": "Snippet27305037_9478.java", "target": 0, "func": "package Test;\n import java.io.*;\n import java.security.*;\n import javax.crypto.*;\n import javax.crypto.spec.*;\n import java.util.*;\n\n public class FileDecryptor\n {\n    private static String filename;\n    private static String password;\n    private static FileInputStream inFile;\n    private static FileOutputStream outFile;\n\n    public static void main(String[] args) throws Exception\n    {\n\n       // File to decrypt.\n\n       filename = \"Test.txt.des\";\n\n       String password = \"super_secret_password\";\n\n       inFile = new FileInputStream(filename);\n       outFile = new FileOutputStream(filename + \".dcr\");\n\n       PBEKeySpec keySpec = new PBEKeySpec(password.toCharArray());\n       SecretKeyFactory keyFactory =\n           SecretKeyFactory.getInstance(\"PBEWithMD5AndDES\");\n       SecretKey passwordKey = keyFactory.generateSecret(keySpec);\n\n       byte[] salt = new byte[8];\n       inFile.read(salt);\n       int iterations = 100;\n\n       PBEParameterSpec parameterSpec = new PBEParameterSpec(salt, iterations);\n\n\n       Cipher cipher = Cipher.getInstance(\"PBEWithMD5AndDES\");\n       cipher.init(Cipher.DECRYPT_MODE, passwordKey, parameterSpec);\n\n       outFile.write(salt);\n\n\n       byte[] input = new byte[64];\n       int bytesRead;\n       while ((bytesRead = inFile.read(input)) != -1)\n       {\n          byte[] output = cipher.update(input, 0, bytesRead);\n          if (output != null)\n             outFile.write(output);\n       }\n       byte[] output = cipher.doFinal();\n       if (output != null)\n          outFile.write(output);\n\n       inFile.close();\n       outFile.flush();\n       outFile.close();\n   }\n}\n", "idx": 1853}
{"project": "cipher", "commit_id": "Snippet33187333_15216.java", "target": 1, "func": "//Decrypt cipher\nCipher decryptCipher = Cipher.getInstance(\"AES/CBC/PKCS5Padding\");\nIvParameterSpec ivParameterSpec = new IvParameterSpec(encryptCipher.getIV());\ndecryptCipher.init(Cipher.DECRYPT_MODE, aesKey, ivParameterSpec);\n", "idx": 2165}
{"project": "cipher", "commit_id": "Snippet34082142_16117.java", "target": 1, "func": "String pubKeyPem = PUBKEY_X509.replace(\"-----BEGIN PUBLIC KEY-----\\n\", \"\")\n.replace(\"-----END PUBLIC KEY-----\", \"\");\nbyte [] encoded = Base64.decode(pubKeyPem, Base64.DEFAULT);\nX509EncodedKeySpec keySpec = new X509EncodedKeySpec(encoded);\nKeyFactory kf = KeyFactory.getInstance(\"RSA\");\nprivateKey = kf.generatePrivate(keySpec);\ncipher = Cipher.getInstance(\"RSA\");\ncipher.init(Cipher.ENCRYPT_MODE, publicKey);\n", "idx": 1946}
{"project": "cipher", "commit_id": "Snippet13067141_36690.java", "target": 0, "func": "public class Crypto {\n   public static String encrypt(String value, String key) throws GeneralSecurityException {\n    SecretKeySpec sks = new SecretKeySpec(hexStringToByteArray(key), \"AES\");\n    Cipher cipher = Cipher.getInstance(\"AES\");\n    cipher.init(Cipher.ENCRYPT_MODE, sks, cipher.getParameters());\n    byte[] encrypted = cipher.doFinal(value.getBytes());\n    return byteArrayToHexString(encrypted);\n}\n\npublic static String decrypt(String message, String key) throws GeneralSecurityException {\n    SecretKeySpec sks = new SecretKeySpec(hexStringToByteArray(key), \"AES\");\n    Cipher cipher = Cipher.getInstance(\"AES\");\n    cipher.init(Cipher.DECRYPT_MODE, sks);\n    byte[] decrypted = cipher.doFinal(hexStringToByteArray(message));\n    return new String(decrypted);\n}   \n\nprivate static String byteArrayToHexString(byte[] b){\n    StringBuffer sb = new StringBuffer(b.length * 2);\n    for (int i = 0; i < b.length; i++){\n        int v = b[i] & 0xff;\n        if (v < 16) {\n            sb.append('0');\n        }\n        sb.append(Integer.toHexString(v));\n    }\n    return sb.toString().toUpperCase();\n}\n\nprivate static byte[] hexStringToByteArray(String s) {\n    byte[] b = new byte[s.length() / 2];\n    for (int i = 0; i < b.length; i++){\n        int index = i * 2;\n        int v = Integer.parseInt(s.substring(index, index + 2), 16);\n        b[i] = (byte)v;\n    }\n    return b;\n}\n  }\n", "idx": 1891}
{"project": "cipher", "commit_id": "Snippet35122795_17061.java", "target": 0, "func": "private String keyString;\nprivate byte[] byteKey;\nprivate SecretKey key;\nCipher c;\n\npublic AES_Cipher(String keyString){\n    this.keyString = keyString.toString();\n}\n\npublic void init() throws InitializtionFailedException{\n    try{\n        c = Cipher.getInstance(\"AES/ECB/PKCS5Padding\");\n        byteKey = keyString.getBytes(\"UTF-8\");\n        MessageDigest sha = MessageDigest.getInstance(\"SHA-1\");\n        byteKey = sha.digest(byteKey);\n        byteKey = Arrays.copyOf(byteKey, 16);\n        key = new SecretKeySpec(byteKey, \"AES\");\n\n    }catch(NoSuchAlgorithmException e){\n        throw new InitializtionFailedException();\n    }\n }\n", "idx": 1642}
{"project": "cipher", "commit_id": "Snippet18089923_1129.java", "target": 1, "func": "// my clear text password\nString clearTextPassword = \"XXXXX\";\n\n// these values are provided by the web service team\nString modulusString = \"...\";\nString publicExponentString = \"...\";\n\nBigInteger modulus = new BigInteger(1, Base64.decodeBase64(modulusString.getBytes(\"UTF-8\")));\nBigInteger publicExponent = new BigInteger(1, Base64.decodeBase64(publicExponentString.getBytes(\"UTF-8\")));\n\nKeyFactory keyFactory = KeyFactory.getInstance(\"RSA\");\n\nRSAPublicKeySpec publicKeySpec = new RSAPublicKeySpec(modulus, publicExponent);\nPublicKey publicKey = keyFactory.generatePublic(publicKeySpec);\n\nCipher cipher = Cipher.getInstance(\"RSA/ECB/NoPadding\");\ncipher.init(Cipher.ENCRYPT_MODE, publicKey);\n\nString encodedEncryptedPassword = new String(Base64.encodeBase64(cipher.doFinal(clearTextPassword.getBytes(\"UTF-8\"))));\n", "idx": 1997}
{"project": "cipher", "commit_id": "Snippet11408490_35567.java", "target": 0, "func": "<%@ page import=\"java.io.*\" %>\n<%@ page import=\"java.security.*\" %>\n<%@ page import=\"javax.crypto.*\" %>\n<%@ page import=\"javax.crypto.spec.*\" %>\n<%@ page import=\"java.lang.*\" %>\n<%@ page import=\"org.apache.commons.codec.binary.*\" %>\n\n    <HTML>\n    <HEAD>\n    <TITLE> Cheers! </TITLE>\n    </HEAD>\n    <BODY>\n\n    <%\n        String algorithm1 = \"DES\";//magical mystery constant\n        String algorithm2 = \"DES/CBC/NoPadding\";//magical mystery constant\n        IvParameterSpec iv = new IvParameterSpec( new byte [] { 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00 } );//magical mystery constant\n        Cipher cipher;\n        SecretKey key;\n        String k=\"12345abc\"; //Just a random pick for testing\n        key = new SecretKeySpec( k.getBytes(\"UTF-8\"), algorithm1 );\n        cipher = Cipher.getInstance( algorithm2 );\n\n        String str=\"test4abc\"; //Test String, 8 characters\n\n        cipher.init( Cipher.ENCRYPT_MODE, key, iv ); //normally you could leave out the IvParameterSpec argument, but not with Oracle\n\n        byte[] bytes=str.getBytes(\"UTF-8\");\n\n        byte[] encrypted = cipher.doFinal( bytes );\n\n        String encoded = new String( Hex.encodeHex( encrypted ) );\n        out.println( \"Encrypted/Encoded: \\\"\" + encoded + \"\\\"\" );\n\n\n\n        cipher.init( Cipher.DECRYPT_MODE, key, iv );    \n\n        //byte [] decoded = org.apache.commons.codec.binary.Hex.decodeHex( encoded.toCharArray( ) );\n        byte [] decoded = Hex.decodeHex( encoded.toCharArray( ) );\n\n        String decrypted = new String (cipher.doFinal( decoded ));\n        out.println(\"DECRYPTED: \\\"\" + decrypted + \"\\\"\" );\n    }\n\n    %>  \n    </BODY>\n    </HTML>\n", "idx": 1773}
{"project": "cipher", "commit_id": "Snippet44680760_26778.java", "target": 1, "func": "package ReadFileExample;\n\n\nimport java.io.BufferedOutputStream;\nimport java.io.ByteArrayOutputStream;\nimport java.io.FileInputStream;\nimport java.io.FileOutputStream;\nimport java.io.IOException;\nimport java.io.ObjectOutputStream;\nimport java.security.PrivateKey;\nimport java.security.PublicKey;\nimport java.security.cert.CertificateFactory;\nimport java.security.cert.X509Certificate;\nimport java.util.Base64;\nimport javax.crypto.Cipher;\nimport javax.crypto.KeyGenerator;\nimport javax.crypto.SecretKey;\nimport javax.crypto.spec.SecretKeySpec;\nimport javax.xml.bind.DatatypeConverter;\n\nimport java.security.KeyStore;\n\n\n\npublic class generatekey {\n\n\n  static Cipher cipher;\n  public static void main(String[] args) throws Exception {\n\n\n\n\n\n\n    // generating a symmetric key using the AES algorithm\n    KeyGenerator generator = KeyGenerator.getInstance(\"AES\");\n    // 128 bit key\n    generator.init(256);\n    //generates a secret key\n    SecretKey secretkey = generator.generateKey();\n    // returns an AES cipher\n    cipher = Cipher.getInstance(\"AES/CBC/PKCS5Padding\");\n    //print key\n    System.out.println(\"Key: \" + cipher);\n\n\n\n\n\n\n\n\n    String plainText = \"Hello World\";\n    // call to method encrypt \n    String hexEncryptedByteText  = encrypt(plainText, secretkey);\n    // print orignial text and encrypted text\n    System.out.println(\"Plain Text: \" + plainText);\n    System.out.println(\"Encrypted Text: \" + hexEncryptedByteText);\n\n    int plainTextlength = plainText.length();\n    System.out.println(\"length of text: \" + plainTextlength);\n\n\n    // allows to write data to a file\n    FileOutputStream fos = null;\n    // write bytes to file\n    BufferedOutputStream bos = null;\n    // create file to which data needs to be written\n    String fileName = \"C:/Users/******/newFile.txt\";\n\n    try{\n        // allows written data to go into the written path\n        fos = new FileOutputStream(fileName);\n        // converts written data into bytes\n        bos = new BufferedOutputStream(fos);\n\n\n        // writes the encrypted text into file\n        bos.write(hexEncryptedByteText.length());                \n\n\n        System.out.println(\"encryptedText has been written successfully in \"\n                     +fileName);\n\n        // allows to catch bug in code\n    } catch (IOException e) {\n        e.printStackTrace();\n    } finally {\n        try{\n            // check for null exception\n            if (bos != null){\n                bos.close();\n\n            }\n            // check for null exception\n            if (fos != null){\n                fos.close();\n            }\n        } catch (IOException e){\n            e.printStackTrace();\n\n        }\n\n\n\n    }\n\n\n\n\n\n\n    // creates a file input stream by opening a path to the file needed\n    FileInputStream fin = new FileInputStream(\"C:/Users/*****/public.cert\");\n    // implements the X509 certificate type\n    CertificateFactory f = CertificateFactory.getInstance(\"X.509\");\n    // initalizes data found in the file\n    X509Certificate certificate = (X509Certificate)f.generateCertificate(fin);\n    // gets public key from this certificate \n    PublicKey pk = certificate.getPublicKey();\n    System.out.println(pk);\n\n    String hexEncryptedByteKey = encryptedKey(pk, secretkey);\n    System.out.println(\"Encrypted Key: \" + hexEncryptedByteKey);\n    System.out.println(\"Encrypted Key length: \" + hexEncryptedByteKey.length());\n\n    // allows to write data to a file\n    FileOutputStream newFos = null;\n    // write bytes to file\n    BufferedOutputStream newBos = null;\n    // create file to which data needs to be written\n    String fileNameKey = \"C:/Users/****/symmetric.txt\";\n\n    try{\n        // allows written data to go into the written path\n        newFos = new FileOutputStream(fileNameKey);\n        // converts written data into bytes\n        newBos = new BufferedOutputStream(newFos);\n\n\n\n        // writes the encrypted text into file\n        newBos.write(hexEncryptedByteKey.length());                \n\n\n        System.out.println(\"encryptedKey has been written successfully in \"\n                     +fileNameKey);\n\n\n\n\n\n\n        // allows to catch bug in code\n    } catch (IOException e) {\n        e.printStackTrace();\n    } finally {\n        try{\n            // check for null exception\n            if (newBos != null){\n                newBos.close();\n\n            }\n            // check for null exception\n            if (newFos != null){\n                newFos.close();\n            }\n        } catch (IOException e){\n            e.printStackTrace();\n\n        }\n    }\n\n    // load keystore to get private key\n    KeyStore ks = KeyStore.getInstance(\"JKS\");\n    String password = \"*****\";\n    char[] passwordChar = password.toCharArray();\n    System.out.println(\"password: \" + passwordChar);\n    // locate file\n    try (FileInputStream fis = new FileInputStream(\"C:/Users/*****/keystore.jks\")) {\n        ks.load(fis, passwordChar);\n    }\n\n    // protect password for keystore\n    KeyStore.ProtectionParameter protParam = new KeyStore.PasswordProtection(passwordChar);\n\n    // get private key from keystore \n    KeyStore.PrivateKeyEntry pkEntry = (KeyStore.PrivateKeyEntry)\n            ks.getEntry(\"*****\", protParam);\n\n    PrivateKey myPrivateKey = pkEntry.getPrivateKey();\n\n    System.out.println(\"private key: \" + myPrivateKey);\n    //method declaration\n    String decryptedKey = decryptedKey(myPrivateKey, hexEncryptedByteKey);\n\n    System.out.println(\"decrypted Key: \" + decryptedKey);\n\n    String hexDecryptedByteText = decryptedTextHex(decryptedKey, hexEncryptedByteText);\n    System.out.println(\"key: \" + hexDecryptedByteText);\n\n}\n\n\n\n\npublic static String encrypt(String plainText, SecretKey secretkey) throws Exception {\n    //Encodes the string into a sequence of bytes\n    byte[] plainTextByte = plainText.getBytes();\n    //intialize cipher to encryption mode\n    cipher.init(Cipher.ENCRYPT_MODE, secretkey);\n    //data is encrypted \n    byte[] encryptedByte = cipher.doFinal(plainTextByte);\n    //Base64.Encoder encoder = Base64.getEncoder();\n    //encodes bytes into a string using Base64\n    byte[] encryptedByteText = Base64.getEncoder().encode(plainTextByte);\n    String hexEncryptedByteText = DatatypeConverter.printHexBinary(plainTextByte);\n    // return the string encrypted text to the main method\n    return hexEncryptedByteText;\n\n}\n\npublic static String encryptedKey(PublicKey pk, SecretKey secretkey) throws Exception {\n    // data written to byte array\n    ByteArrayOutputStream baos = new ByteArrayOutputStream();\n    // writes data types to the output stream\n    ObjectOutputStream writter = new ObjectOutputStream(baos);\n    //specific object of secretkey is written to the output stream\n    writter.writeObject(secretkey);\n\n    //creates a byte array  \n    byte[] plainTextByteKey = baos.toByteArray();\n\n    //creates a cipher using the RSA algorithm \n    Cipher cipher = Cipher.getInstance(\"RSA\");\n    // initalizes cipher for encryption using the public key \n    cipher.init(Cipher.ENCRYPT_MODE, pk);\n    //encrypts data\n    //byte[] encryptedByteKey = Base64.getEncoder().encode(plainTextByteKey);\n\n    String hexEncryptedByteKey = DatatypeConverter.printHexBinary(plainTextByteKey);\n    //Base64.Encoder encoderKey = Base64.getEncoder();\n    // encodes the byte array into a string.\n    //String encryptedTextKey = new String(encryptedByteKey);\n    return hexEncryptedByteKey;\n\n}\n\nprivate static String decryptedKey(PrivateKey myPrivateKey, String hexEncryptedByteKey) throws Exception {\n\n    //ByteArrayOutputStream baosDecrypt = new ByteArrayOutputStream();\n    //ObjectOutputStream writterDecrypt = new ObjectOutputStream(baosDecrypt);\n    //writterDecrypt.writeObject(hexEncryptedByteKey);\n    //byte[] byteKeyDecrypt = baosDecrypt.toByteArray();\n\n\n    Cipher cipher;\n    cipher = Cipher.getInstance(\"RSA\");\n    cipher.init(Cipher.DECRYPT_MODE, myPrivateKey);\n    //cipher.doFinal();\n\n    //byte [] decryptedKey = Base64.getDecoder().decode(byteKeyDecrypt);\n    //String decryptedTextKey = new String(byteKeyDecrypt);\n\n    byte[] decodedHex = DatatypeConverter.parseHexBinary(hexEncryptedByteKey);\n    System.out.println(\"decoded hex key: \" + decodedHex);\n    String decryptedKey = new String(decodedHex, \"UTF-8\");\n    return decryptedKey;\n\n\n\n\n\n}\n\nprivate static String decryptedTextHex(String decryptedKey, String hexEncryptedByteText) throws Exception {\n\n    byte[] decryptedTextByte = decryptedKey.getBytes();\n    byte[] textString = hexEncryptedByteText.getBytes();\n    SecretKey key = new SecretKeySpec(decryptedTextByte, 0, decryptedTextByte.length, \"AES\");\n\n\n    Cipher cipher;\n    cipher = Cipher.getInstance(\"AES/CBC/PKCS5Padding\");\n    //IvParameterSpec iv = new IvParameterSpec(cipher.getIV());\n    cipher.init(Cipher.DECRYPT_MODE, key);\n    byte[] decodedTextHex = cipher.doFinal(textString);\n\n    byte[] decoded = Base64.getDecoder().decode(decodedTextHex);\n\n    String hexDecryptedByteText = DatatypeConverter.printHexBinary(decoded);\n\n\n    return hexDecryptedByteText;\n\n\n\n}\n", "idx": 2149}
{"project": "cipher", "commit_id": "Snippet15926867_38922.java", "target": 1, "func": "Cipher.getInstance(\"AES/CBC/PKCS5Padding\")", "idx": 2133}
{"project": "cipher", "commit_id": "Snippet6927177_32458.java", "target": 1, "func": "package com.android.basetableview;\n\nimport java.io.File;\nimport java.io.FileOutputStream;\nimport java.io.IOException;\nimport java.io.InputStream;\nimport java.net.HttpURLConnection;\nimport java.net.URL;\nimport javax.crypto.Cipher;\nimport javax.crypto.CipherInputStream;\nimport javax.crypto.spec.IvParameterSpec;\nimport javax.crypto.spec.SecretKeySpec;\nimport android.app.Activity;\nimport android.graphics.Bitmap;\nimport android.os.Bundle;\nimport android.os.Environment;\nimport android.util.Log;\nimport android.widget.ImageView;\n\npublic class BaseTableViewActivity extends Activity {\n    /** Called when the activity is first created. */\n    @Override\n    public void onCreate(Bundle savedInstanceState) {\n        super.onCreate(savedInstanceState);\n        setContentView(R.layout.main);\n\n\n        ImageView imgView = (ImageView) findViewById(R.id.imgView);\n\n        Bitmap myBitmap = getBitmapFromURL(\"http://pu-twitter.netau.net/card1.png\");\n        imgView.setImageBitmap(myBitmap);\n    }\n\n\n    public static Bitmap getBitmapFromURL(String src) {\n        Bitmap myBitmap = null;\n            try {\n\n                URL url = new URL(src);\n                HttpURLConnection connection = (HttpURLConnection) url.openConnection();\n                connection.setDoInput(true);\n                connection.connect();\n\n                //Decryption\n                try {\n                Cipher cipher = Cipher.getInstance(\"AES/CBC/NoPadding\");\n                SecretKeySpec keySpec = new SecretKeySpec(\"01234567890abcde\".getBytes(), \"AES\");\n                IvParameterSpec ivSpec = new IvParameterSpec(\"fedcba9876543210\".getBytes());\n                cipher.init(Cipher.DECRYPT_MODE, keySpec, ivSpec);\n\n                InputStream input = connection.getInputStream();\n                CipherInputStream cis = new CipherInputStream(input, cipher);\n                FileOutputStream fos  = new FileOutputStream(\n                           new File(Environment.getExternalStorageDirectory(), \"card2_decrypted.jpg\"));\n                byte[] b = new byte[8];\n                int i;\n\n                while ((i = cis.read(b)) != -1) {\n                  fos.write(b, 0, i);\n                }\n                fos.flush(); fos.close();\n                cis.close(); input.close();\n\n\n                //myBitmap = BitmapFactory.decodeStream(input);\n\n                }\n                catch(Exception e){\n                    e.fillInStackTrace();\n                    Log.v(\"ERROR\",\"Errorchence : \"+e);\n                }\n\n                return myBitmap;\n\n\n            } catch (IOException e) {\n                e.printStackTrace();\n                return null;\n            }\n        }\n}\n", "idx": 1990}
{"project": "cipher", "commit_id": "Snippet15406388_38458.java", "target": 0, "func": "    SecureRandom sr = new SecureRandom();  \n    DESKeySpec dks = new DESKeySpec(rawKeyData);\n\n    SecretKeyFactory keyFactory = SecretKeyFactory.getInstance(\"DES\");  \n    SecretKey key = keyFactory.generateSecret(dks);  \n    Cipher cipher = Cipher.getInstance(\"DES\");  \n    cipher.init(Cipher.ENCRYPT_MODE, key, sr);  \n    // why the sr is necessary to init a Cipher object?\n    byte data[] = str.getBytes();  \n    byte[] encryptedData = cipher.doFinal(data);\n", "idx": 1651}
{"project": "cipher", "commit_id": "Snippet26510954_8650.java", "target": 1, "func": "public class EncryptionServiceImpl\n{\n\n    private static final Charset UTF8 = Charset.forName(\"UTF-8\");\n\n    @Resource(name = \"briqueAuthentificationClient\")\n    private BriqueAuthentificationClientImpl briqueAuthentificationClient;\n\n    protected static final String ALGORITHM_RSA = \"RSA\";\n\n    protected static final String TRANSFORMATION_RSA_ECB_PKCS1PADDING = \"RSA/ECB/PKCS1Padding\";\n\n    private static final Logger LOG = LoggerFactory.getLogger(EncryptionServiceImpl.class);\n\n    public EncryptionServiceImpl() {\n        LOG.info(\"constructeur EncryptionServiceImpl\");\n    }\n\n    /**\n     * @param briqueAuthentificationClient the briqueAuthentificationClient to set\n     */\n    public void setBriqueAuthentificationClient(final BriqueAuthentificationClientImpl briqueAuthentificationClient) {\n        this.briqueAuthentificationClient = briqueAuthentificationClient;\n    }\n\n    public String encrypt(final String input) throws GeneralSecurityException {\n\n        if (StringUtils.isNotBlank(input)) {\n            final CertificateDto certificate = this.briqueAuthentificationClient.getCurrentCertificate();\n\n            if (certificate != null) {\n                return new String(this.encryptAndEncode(input.getBytes(), certificate), EncryptionServiceImpl.UTF8);\n            } else {\n                throw new RuntimeException(\"Certificate is null\");\n            }\n        }\n        return null;\n    }\n\n    protected byte[] encryptAndEncode(final byte[] input, final CertificateDto currentCertificate)\n            throws GeneralSecurityException {\n\n        // Cr\u00c3\u00a9ation de la cl\u00c3\u00a9 publique\n        final PublicKey publicKey = this.buildPublicKey(currentCertificate);\n\n        // Chiffre\n        final byte[] inputEncrypted = this.encrypte(input, publicKey);\n\n        // Encode\n        return this.encodeBase64Url(inputEncrypted);\n    }\n\n    protected PublicKey buildPublicKey(final CertificateDto currentCertificate) throws GeneralSecurityException {\n\n        if (\"RSA\".equals(currentCertificate.getKeyType())) {\n            return this.buildRSAPublicKey(currentCertificate);\n        }\n        LOG.error(String.format(\"Tentative de cr\u00c3\u00a9ation d'une cl\u00c3\u00a9 publique avec un algorithme non connu [%s]\",\n                currentCertificate.getKeyType()));\n        return null;\n    }\n\n    protected PublicKey buildRSAPublicKey(final CertificateDto currentCertificate) throws GeneralSecurityException {\n\n        final BigInteger modulus = new BigInteger(new String(Base64.decodeBase64(currentCertificate.getModulus()),\n                EncryptionServiceImpl.UTF8));\n        final BigInteger publicExponent = new BigInteger(new String(Base64.decodeBase64(currentCertificate\n                .getPublicExponent()), EncryptionServiceImpl.UTF8));\n\n        try {\n            return KeyFactory.getInstance(ALGORITHM_RSA).generatePublic(new RSAPublicKeySpec(modulus, publicExponent));\n        } catch (InvalidKeySpecException e) {\n            throw e;\n        } catch (NoSuchAlgorithmException e) {\n            throw e;\n        }\n    }\n\n    protected byte[] encrypte(final byte[] input, final RSAPublicKeySpec rsaPublicKeySpec)\n            throws GeneralSecurityException {\n\n        PublicKey publicKey;\n        try {\n            publicKey = KeyFactory.getInstance(ALGORITHM_RSA).generatePublic(\n                    new RSAPublicKeySpec(rsaPublicKeySpec.getModulus(), rsaPublicKeySpec.getPublicExponent()));\n        } catch (InvalidKeySpecException e) {\n            throw e;\n        } catch (NoSuchAlgorithmException e) {\n            throw e;\n        }\n        return this.encrypte(input, publicKey);\n    }\n\n    protected byte[] encrypte(final byte[] input, final PublicKey publicKey) throws GeneralSecurityException {\n\n        try {\n            final Cipher cipher = Cipher.getInstance(TRANSFORMATION_RSA_ECB_PKCS1PADDING);\n            cipher.init(Cipher.ENCRYPT_MODE, publicKey);\n            return cipher.doFinal(input);\n        } catch (NoSuchAlgorithmException e) {\n            throw e;\n        } catch (NoSuchPaddingException e) {\n            throw e;\n        } catch (IllegalBlockSizeException e) {\n            throw e;\n        } catch (BadPaddingException e) {\n            throw e;\n        }\n\n    }\n\n    protected byte[] decrypte(final byte[] input, final RSAPrivateKeySpec rsaPrivateKeySpec)\n            throws GeneralSecurityException {\n\n        final BigInteger modulus = rsaPrivateKeySpec.getModulus();\n        final BigInteger privateExponent = rsaPrivateKeySpec.getPrivateExponent();\n\n        try {\n            final PrivateKey privateKey = KeyFactory.getInstance(ALGORITHM_RSA).generatePrivate(\n                    new RSAPrivateKeySpec(modulus, privateExponent));\n\n            final Cipher cipher = Cipher.getInstance(TRANSFORMATION_RSA_ECB_PKCS1PADDING);\n            cipher.init(Cipher.DECRYPT_MODE, privateKey);\n            return cipher.doFinal(input);\n\n        } catch (NoSuchAlgorithmException e) {\n            throw e;\n        } catch (NoSuchPaddingException e) {\n            throw e;\n        } catch (IllegalBlockSizeException e) {\n            throw e;\n        } catch (BadPaddingException e) {\n            throw e;\n        } catch (InvalidKeySpecException e) {\n            throw e;\n        } catch (InvalidKeyException e) {\n            throw e;\n        }\n\n    }\n\n    protected byte[] encodeBase64Url(final byte[] input) {\n        return Base64.encodeBase64(input, false);\n    }\n\n    protected byte[] decodeBase64Url(final byte[] input) {\n        return Base64.decodeBase64(input);\n    }\n\n    /**\n     * Method to connect to an url\n     * \n     * @param httpclient the http connection\n     * @return the response GetMethod\n     * @throws OAuthException in cas of connection error\n     */\n    private GetMethod connect(final HttpClient httpclient, final String url) {\n\n        final GetMethod httpget = new GetMethod(url);\n        try {\n\n            httpclient.executeMethod(httpget);\n\n        } catch (final UnknownHostException e) {\n            throw new RuntimeException(\"Connection ERROR - Host could not be determined.\", e);\n        } catch (final IOException e) {\n            throw new RuntimeException(\"Connection ERROR - Input/Output error.\", e);\n        }\n        return httpget;\n    }\n\n}\n", "idx": 2305}
{"project": "cipher", "commit_id": "Snippet42252463_24213.java", "target": 1, "func": "public static String AesEncrypt(String encryptedMessage){\n    try {\n        IvParameterSpec initialVector = new IvParameterSpec(\"xxxxxxxxxxxxxxxx\".getBytes(\"UTF-8\"));\n        SecretKeySpec secretKeySpec = new SecretKeySpec(\"xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx\".getBytes(\"UTF-8\"), \"AES\");\n\n        Cipher cipher = Cipher.getInstance(\"AES/CBC/PKCS5Padding\");\n        cipher.init(Cipher.ENCRYPT_MODE, secretKeySpec, initialVector);\n\n        byte[] encrypted = cipher.doFinal(encryptedMessage.getBytes());\n\n        byte[] base64 = Base64.encodeBase64(encrypted);\n\n        StringBuilder encryptedSb = new StringBuilder(base64.length);\n        for (byte i : base64){\n            encryptedSb.append(i);\n        }\n        return toHex(encryptedSb.toString());\n    } catch (Exception ex) {\n        ex.printStackTrace();\n        return null;\n    }\n}\n", "idx": 2115}
{"project": "cipher", "commit_id": "Snippet17587813_755.java", "target": 0, "func": "    package security.symmatric;\n\n    import javax.crypto.Cipher;\n    import javax.crypto.spec.SecretKeySpec;\n\n    import org.apache.commons.codec.binary.Base64;\n\n    public class AES {\n        public static String symmetricEncrypt(String text, String secretKey) {\n            byte[] raw;\n            String encryptedString;\n            SecretKeySpec skeySpec;\n            byte[] encryptText = text.getBytes();\n            Cipher cipher;\n            try {\n                raw = Base64.decodeBase64(secretKey);\n                skeySpec = new SecretKeySpec(raw, \"AES\");\n                cipher = Cipher.getInstance(\"AES\");\n                cipher.init(Cipher.ENCRYPT_MODE, skeySpec);\n                encryptedString = Base64.encodeBase64String(cipher.doFinal(encryptText));\n            } \n            catch (Exception e) {\n                e.printStackTrace();\n                return \"Error\";\n            }\n            return encryptedString;\n        }\n\n        public static String symmetricDecrypt(String text, String secretKey) {\n            Cipher cipher;\n            String encryptedString;\n            byte[] encryptText = null;\n            byte[] raw;\n            SecretKeySpec skeySpec;\n            try {\n                raw = Base64.decodeBase64(secretKey);\n                skeySpec = new SecretKeySpec(raw, \"AES\");\n                encryptText = Base64.decodeBase64(text);\n                cipher = Cipher.getInstance(\"AES\");\n                cipher.init(Cipher.DECRYPT_MODE, skeySpec);\n                encryptedString = new String(cipher.doFinal(encryptText));\n            } catch (Exception e) {\n                e.printStackTrace();\n                return \"Error\";\n            }\n            return encryptedString;\n        }\n\n        public static void main(String[] args) {\n            String secretKey = \"XMzDdG4D03CKm2IxIWQw7g==\";\n            String value1= \"ABCD\";\n            String enctypedValue1= \"3uweh4pzoVyH1uODQmVNJA==\";\n            String enctypedValue2= \"37PTC20w4DMZYjG3f+GWepSvAbEJUccMXwS/lXilLav1qM/PrCTdontw5/82OdC1zzyhDEsFVRGo rV6gXAQcm+Zai15hliiUQ8l8KRMtUl4=\";\n            String value4= \"20000\";\n\n            /**  Ecnryption and decryption of value1 **/\n            String encryptedValue1= symmetricEncrypt(value1, secretKey);\n            String decryptedValue1 = symmetricDecrypt(encryptedValue1, secretKey);\n            System.out.println(decryptedValue1);\n\n            /**  Decryption of  enctypedValue1 **/\n            String decryptedValue2 = symmetricDecrypt(enctypedValue1, secretKey);\n            System.out.println(decryptedValue2);\n\n            /**  Decryption of  enctypedValue2 **/\n            String decryptedValue3 = symmetricDecrypt(enctypedValue2, secretKey);\n            System.out.println(decryptedValue3);\n\n            /**  Ecnryption and decryption of value4 **/\n            String encryptedValue4= symmetricEncrypt(value4, secretKey);\n            String decryptedValue4 = symmetricDecrypt(encryptedValue4, secretKey);\n            System.out.println(decryptedValue4);\n        }\n    }\n", "idx": 1686}
{"project": "cipher", "commit_id": "Snippet45295240_27413.java", "target": 0, "func": "public static void decrypt(FileInputStream fis,FileOutputStream fos ) throws IOException, NoSuchAlgorithmException,\n            NoSuchPaddingException, InvalidKeyException {\n        // FileInputStream fis = new FileInputStream(\"data/encrypted\");\n        // FileOutputStream fos = new FileOutputStream(\"data/decrypted\");\n        String password =\"passwordProtectd\";\n        byte[] inputByte = password.getBytes(\"UTF-8\");\n        SecretKeySpec sks = new SecretKeySpec(inputByte, \"AES\");\n        Cipher cipher = Cipher.getInstance(\"AES\");\n        cipher.init(Cipher.DECRYPT_MODE, sks);\n        CipherInputStream cis = new CipherInputStream(fis, cipher);\n        int b;\n        byte[] d = new byte[8];\n        while((b = cis.read(d)) != -1) {\n            fos.write(d, 0, b);\n        }\n        fos.flush();\n        fos.close();\n        cis.close();\n    }\n", "idx": 1870}
{"project": "cipher", "commit_id": "Snippet10276821_34634.java", "target": 0, "func": "Cipher.getInstance(\"3DES/CBC/PKCS5Padding\")", "idx": 1732}
{"project": "cipher", "commit_id": "Snippet32167799_14278.java", "target": 1, "func": "Cipher oaepFromInit = Cipher.getInstance(\"RSA/ECB/OAEPPadding\");\nOAEPParameterSpec oaepParams = new OAEPParameterSpec(\"SHA-256\", \"MGF1\", new MGF1ParameterSpec(\"SHA-1\"), PSpecified.DEFAULT);\noaepFromInit.init(Cipher.DECRYPT_MODE, privkey, oaepParams);\nbyte[] pt = oaepFromInit.doFinal(ct);\nSystem.out.println(new String(pt, StandardCharsets.UTF_8));\n", "idx": 2116}
{"project": "cipher", "commit_id": "Snippet20868745_3462.java", "target": 0, "func": "public String Padding_key() {\n\n  try {\n\n    PBEKeySpec pbeKeySpec = new PBEKeySpec(STReditTxtPass.toCharArray());\n    Log.e(\"PBEkEYsPEC\", pbeKeySpec.toString());\n    Toast.makeText(this, \"step 1\", Toast.LENGTH_SHORT).show();\n    Cipher cipher = Cipher.getInstance(\"AES\");\n    Toast.makeText(this, \"after ciphering\", Toast.LENGTH_SHORT).show();\n    SecretKeyFactory keyFactory = SecretKeyFactory\n    .getInstance(\"PBEWithMD5AndDES\");\n    Toast.makeText(this, \"after keyFactory\", Toast.LENGTH_SHORT).show();\n\n    SecretKey pbeKey = keyFactory.generateSecret(pbeKeySpec);\n    Log.e(\"PBEkEYsPEC\", pbeKey.toString());\n    Toast.makeText(this, \"after SecreteKey\", Toast.LENGTH_SHORT).show();\n\n    PBEParameterSpec pbeSpec = new PBEParameterSpec(salt, iterations);\n    Log.e(\"PBEkEYsPEC\", pbeSpec.toString());\n    Toast.makeText(this, \"after PBEParameterSpec\", Toast.LENGTH_SHORT).show();\n    cipher.init(Cipher.ENCRYPT_MODE, pbeKey, pbeSpec);\n\n    Toast.makeText(this, \"after cypher.init\", Toast.LENGTH_SHORT).show();\n\n    byte[] cipherText = cipher.doFinal(PlainText.getBytes(\"UTF-8\"));\n    Toast.makeText(this, \"after byte[]\", Toast.LENGTH_SHORT).show();\n\n    cyphertext = String.format(\"%s%s%s\", toBase64(salt), \"]\",\n    toBase64(cipherText));\n    Toast.makeText(this, \"after cypherText.format\", Toast.LENGTH_SHORT).show();\n\n    edit_txt_enc_string.setText(cyphertext);\n\n    strPaddingencryption = edit_txt_enc_string.getText().toString();\n\n  } catch (Exception e) {\n\n  }\n  return strPaddingencryption;\n}\n", "idx": 1735}
{"project": "cipher", "commit_id": "Snippet36309745_18164.java", "target": 1, "func": "public static String decryptData(String data) {\n\n    try {\n\n        String modulus = \"sAyRG6mbVY1XoPGZ9Yh+ZJvI40wxiq4LzoSbLlIdrYLelvzeQZD6Y6eG9XIALpEvnL3ZECf1Emnv17yELrcQ5w==\";\n        String exponent = \"AQAB\";\n\n        byte[] modulusBytes = Base64.decode(modulus.getBytes(\"UTF-8\"), Base64.DEFAULT);\n        byte[] exponentBytes = Base64.decode(exponent.getBytes(\"UTF-8\"), Base64.DEFAULT);\n\n        BigInteger modulusInt = new BigInteger(1, modulusBytes);\n        BigInteger exponentInt = new BigInteger(1, exponentBytes);\n\n       /* RSAPrivateKeySpec rsaPrivKey = new RSAPrivateKeySpec(modulusInt, exponentInt);\n        KeyFactory fact = KeyFactory.getInstance(\"RSA\");\n        PrivateKey privKey = fact.generatePrivate(rsaPrivKey);*/\n\n        RSAPublicKeySpec rsaPubKey = new RSAPublicKeySpec(modulusInt, exponentInt);\n        KeyFactory fact = KeyFactory.getInstance(\"RSA\");\n        PublicKey pubKey = fact.generatePublic(rsaPubKey);\n\n        Cipher cipher = Cipher.getInstance(\"RSA/ECB/PKCS1PADDING\");\n        cipher.init(Cipher.DECRYPT_MODE, pubKey);\n\n        byte[] base64String = Base64.decode(data, Base64.DEFAULT);\n\n        byte[] plainBytes = new String(base64String).getBytes(\"UTF-8\");\n\n        plainBytes = cipher.update(plainBytes);\n\n        byte[] values = cipher.doFinal(plainBytes);\n\n        return new String(values, \"UTF-8\");\n\n    } catch (Exception e) {\n        e.printStackTrace();\n        return null;\n    }\n}\n", "idx": 2269}
{"project": "cipher", "commit_id": "Snippet29152379_11229.java", "target": 1, "func": "public static void main(String[] args) throws UnsupportedEncodingException, GeneralSecurityException {\n    String ciphertext = \"U2FsdGVkX1+0m/gle/XQX1shjnpveUrl1fO3oOlurPMlTks6+oQlEPfOrucihzEz\";\n    String plaintext = \"This is some example plaintext\";\n    String password = \"This is a very strong password\";\n    int keySize = 256;\n    int ivSize = 128;\n\n    // var wordArray = WordArray.create([0x53616c74, 0x65645f5f]).concat(salt).concat(ciphertext);\n    byte[] ctBytes = Base64.getDecoder().decode(ciphertext.getBytes(\"UTF-8\"));\n    System.out.println(\"Is salted: \" + Arrays.equals(Arrays.copyOf(ctBytes, 8), new byte[]{0x53, 0x61, 0x6c, 0x74, 0x65, 0x64, 0x5f, 0x5f}));\n    System.out.println(\"Is salted: \" + new String(Arrays.copyOf(ctBytes, 8)).equals(\"Salted__\"));\n\n    byte[] saltBytes = Arrays.copyOfRange(ctBytes, 8, 16);\n    System.out.println(\"Salt matches: \" + Arrays.equals(saltBytes, hexStringToByteArray(\"b49bf8257bf5d05f\")));\n\n    byte[] ciphertextBytes = Arrays.copyOfRange(ctBytes, 16, ctBytes.length);\n    System.out.println(\"CT matches: \" + Arrays.equals(ciphertextBytes, hexStringToByteArray(\"5b218e7a6f794ae5d5f3b7a0e96eacf3254e4b3afa842510f7ceaee722873133\")));\n\n    byte[] key = new byte[keySize/8];\n    byte[] iv = new byte[ivSize/8];\n    EvpKDF(password.getBytes(\"UTF-8\"), keySize, ivSize, saltBytes, key, iv);\n\n    Cipher cipher = Cipher.getInstance(\"AES/CBC/PKCS5Padding\");\n    cipher.init(Cipher.DECRYPT_MODE, new SecretKeySpec(key, \"AES\"), new IvParameterSpec(iv));\n    byte[] recoveredPlaintextBytes = cipher.doFinal(ciphertextBytes);\n    String recoveredPlaintext = new String(recoveredPlaintextBytes);\n\n    System.out.println(\"Recovered Plaintext: \" + recoveredPlaintext);\n    System.out.println(\"Expected Plaintext: \" + plaintext);\n}\n\npublic static byte[] EvpKDF(byte[] password, int keySize, int ivSize, byte[] salt, byte[] resultKey, byte[] resultIv) throws NoSuchAlgorithmException {\n    return EvpKDF(password, keySize, ivSize, salt, 1, \"MD5\", resultKey, resultIv);\n}\n\npublic static byte[] EvpKDF(byte[] password, int keySize, int ivSize, byte[] salt, int iterations, String hashAlgorithm, byte[] resultKey, byte[] resultIv) throws NoSuchAlgorithmException {\n    keySize = keySize / 32;\n    ivSize = ivSize / 32;\n    int targetKeySize = keySize + ivSize;\n    byte[] derivedBytes = new byte[targetKeySize * 4];\n    int numberOfDerivedWords = 0;\n    byte[] block = null;\n    MessageDigest hasher = MessageDigest.getInstance(hashAlgorithm);\n    while (numberOfDerivedWords < targetKeySize) {\n        if (block != null) {\n            hasher.update(block);\n        }\n        hasher.update(password);\n        block = hasher.digest(salt);\n        hasher.reset();\n\n        // Iterations\n        for (int i = 1; i < iterations; i++) {\n            block = hasher.digest(block);\n            hasher.reset();\n        }\n\n        System.arraycopy(block, 0, derivedBytes, numberOfDerivedWords * 4,\n                Math.min(block.length, (targetKeySize - numberOfDerivedWords) * 4));\n\n        numberOfDerivedWords += block.length/4;\n    }\n\n    System.arraycopy(derivedBytes, 0, resultKey, 0, keySize * 4);\n    System.arraycopy(derivedBytes, keySize * 4, resultIv, 0, ivSize * 4);\n\n    return derivedBytes; // key + iv\n}\n\n/**\n * Copied from https://stackoverflow.com/a/140861\n * */\npublic static byte[] hexStringToByteArray(String s) {\n    int len = s.length();\n    byte[] data = new byte[len / 2];\n    for (int i = 0; i < len; i += 2) {\n        data[i / 2] = (byte) ((Character.digit(s.charAt(i), 16) << 4)\n                + Character.digit(s.charAt(i+1), 16));\n    }\n    return data;\n}\n", "idx": 2166}
{"project": "cipher", "commit_id": "Snippet26375667_8473.java", "target": 1, "func": "public String RSADecrypt(final byte[] encryptedBytes) throws NoSuchAlgorithmException, NoSuchPaddingException,\n        InvalidKeyException, IllegalBlockSizeException, BadPaddingException {\n\n    cipher1 = Cipher.getInstance(\"RSA\");\n    cipher1.init(Cipher.DECRYPT_MODE, privateKey);\n    decryptedBytes = cipher1.doFinal(encryptedBytes);\n    decrypted = new String(decryptedBytes);\n    System.out.println(\"DDecrypted?????\" + decrypted);\n    return decrypted;\n}\n", "idx": 2160}
{"project": "cipher", "commit_id": "Snippet30503295_12675.java", "target": 1, "func": "Cipher cipher = Cipher.getInstance(\"RSA/None/PKCS1Padding\");\n", "idx": 2170}
{"project": "cipher", "commit_id": "Snippet774122_29731.java", "target": 1, "func": "SecretKey secret = new SecretKeySpec(key, \"AES\");\nCipher cipher = Cipher.getInstance(\"AES/CBC/PKCS5Padding\");\ncipher.init(Cipher.ENCRYPT_MODE, secret);\nAlgorithmParameters param = cipher.getParameters();\n/* In addition to ciphertext in \"cos\", recipient needs IV. */\nbyte[] iv = param.getParameterSpec(IvParameterSpec.class).getIV();\nCipherOutputStream cos = new CipherOutputStream(output, cipher);\nbyte[] buf = new byte[2048];\nwhile (true) {\n  int n = input.read(buf, 0, buf.length);\n  if (n < 0)\n    break;\n  cos.write(buf, 0, n);\n}\ncos.flush();\n", "idx": 2066}
{"project": "cipher", "commit_id": "Snippet39011165_20897.java", "target": 0, "func": "public Main3Activity() {\n    try {\n      //  SecureRandom sr = SecureRandom.getInstance(\"SHA1PRNG\",\"Crypto\");\n\n        keyGenerator = KeyGenerator.getInstance(\"Blowfish\");\n        secretKey = keyGenerator.generateKey();\n        cipher = Cipher.getInstance(\"Blowfish\");\n    } catch (NoSuchPaddingException ex) {\n        System.out.println(ex);\n    } catch (NoSuchAlgorithmException ex) {\n        System.out.println(ex);\n    }\n}\n\n@Override\nprotected void onCreate(Bundle savedInstanceState) {\n    super.onCreate(savedInstanceState);\n    setContentView(R.layout.activity_main3);\n\n\n    ActivityCompat.requestPermissions(this, new String[]{ACCESS_FINE_LOCATION, CAMERA, WRITE_EXTERNAL_STORAGE}, PERMISSION_REQUEST_CODE);\n    v1=(ImageView)findViewById(R.id.imageViewnew);\n    b1=(Button)findViewById(R.id.cameranew);\n\n    final String imagePath = \"image\" + \".png\";\n    File root = new File(Environment.getExternalStorageDirectory() + File.separator + \"savedimages\");\n    root.mkdirs();\n    if (!root.exists()) {\n        root.mkdir();\n    }\n\n    file = new File(Environment.getExternalStorageDirectory() + File.separator + \"savedimages\",imagePath);\n    file1 = new File(Environment.getExternalStorageDirectory() + File.separator + \"savedimages\",\"Encryp\"+imagePath);\n    file2 = new File(Environment.getExternalStorageDirectory() + File.separator + \"savedimages\",\"decryp\"+imagePath);\n\n    b1.setOnClickListener(new View.OnClickListener() {\n        @Override\n        public void onClick(View v) {\n\n            Intent intent = new Intent(MediaStore.ACTION_IMAGE_CAPTURE);\n            outputFileUri = Uri.fromFile(file);\n            intent.putExtra(MediaStore.EXTRA_OUTPUT, outputFileUri);\n            startActivityForResult(intent, CAMERA_REQUEST);\n\n        }\n    });\n}\nprotected void onActivityResult(int requestCode, int resultCode, Intent data) {\n    if (requestCode == CAMERA_REQUEST && resultCode == RESULT_OK) {\n\n\n        OutputStream outStream = null;\n        InputStream inStream = null;\n        try {\n\n            System.out.println(\"Encryption Over\");\n            cipher.init(Cipher.ENCRYPT_MODE, secretKey);\n            inStream = new FileInputStream(file);\n            outStream = new FileOutputStream(file1);\n            byte[] buffer = new byte[1024];\n            int len;\n\n            while ((len = inStream.read(buffer)) > 0) {\n                outStream.write(cipher.update(buffer, 0, len));\n                outStream.flush();\n            }\n            outStream.write(cipher.doFinal());\n            outStream.close();\n        } catch (IllegalBlockSizeException ex) {\n            System.out.println(ex);\n        } catch (BadPaddingException ex) {\n            System.out.println(ex);\n        } catch (InvalidKeyException ex) {\n            System.out.println(ex);\n        } catch (FileNotFoundException ex) {\n            System.out.println(ex);\n        } catch (IOException ex) {\n            System.out.println(ex);\n        }\n\n\n        try {\n            System.out.println(\"Decryption Over\");\n\n            cipher.init(Cipher.DECRYPT_MODE, secretKey);\n            inStream = new FileInputStream(file1);\n            outStream = new FileOutputStream(file2);\n            byte[] buffer = new byte[1024];\n            int len;\n\n            while ((len = inStream.read(buffer)) > 0)\n            {\n            //------------>>>>>>>>>    Here Image is Storing instead of that it should read as byte array\n                // ------------>>>>>>>>>>   and read as bitmap and set in Imageview for preview\n\n                outStream.write(cipher.update(buffer, 0, len));\n                outStream.flush();\n            }\n            System.out.print(\"Decryption ovverrr\");\n            outStream.write(cipher.doFinal());\n            inStream.close();\n            outStream.close();\n        } catch (IllegalBlockSizeException ex) {\n            System.out.println(ex);\n        } catch (BadPaddingException ex) {\n            System.out.println(ex);\n        } catch (InvalidKeyException ex) {\n            System.out.println(ex);\n        } catch (FileNotFoundException ex) {\n            System.out.println(ex);\n        } catch (IOException ex) {\n            System.out.println(ex);\n        } catch (Exception ex) {\n            System.out.println(ex);\n        }\n\n\n        BitmapFactory.Options options=new BitmapFactory.Options();\n        final Bitmap b=BitmapFactory.decodeFile(file2.toString(),options);\n        System.out.println(\"Image getting from File\");\n\n        //----------->>>>>>>>>> Decrypted Image should view Here. Currently I am getting directly from file.\n        v1.setImageBitmap(b);\n\n    }\n}\n}\n", "idx": 1730}
{"project": "cipher", "commit_id": "Snippet24330683_6615.java", "target": 1, "func": "@Test\npublic void chunkDecrypt() throws Exception {\n    key = MessageDigest.getInstance(\"MD5\").digest(\"som3C0o7p@s5\".getBytes());\n    iv = Hex.decode(\"EECE34808EF2A9ACE8DF72C9C475D751\");\n    byte[] ciphertext = Hex\n            .decode(\"EF26839493BDA6DA6ABADD575262713171F825F2F477FDBB53029BEADB41928EA5FB46737D7A94D5BE74B6049008443664F0E0D883943D0EFBEA09DB\");\n\n    Cipher cipher = Cipher.getInstance(\"AES/GCM/NoPadding\", \"BC\");\n    cipher.init(Cipher.DECRYPT_MODE, new SecretKeySpec(key, \"AES\"), new IvParameterSpec(iv));\n\n    byte[] fullDecryptedPlainText = cipher.doFinal(ciphertext);\n    assertThat(new String(fullDecryptedPlainText),\n            is(\"The quick brown fox jumps over the lazy dogs\"));\n\n    byte[] first32 = Arrays.copyOfRange(ciphertext, 0, 32);\n    byte[] final28 = Arrays.copyOfRange(ciphertext, 32, 60);\n    byte[] decryptedChunk = new byte[32];\n\n    int num = cipher.update(first32, 0, 32, decryptedChunk);\n    assertThat(num, is(16));\n    assertThat(new String(decryptedChunk, 0, 16), is(\"The quick brown \"));\n\n    num = cipher.update(first32, 0, 32, decryptedChunk);\n    assertThat(num, is(32));\n    assertThat(new String(decryptedChunk, 0, 16), is(\"fox jumps over t\"));\n\n    num = cipher.update(final28, 0, 24, decryptedChunk);\n    assertThat(num, is(44));\n    assertThat(new String(decryptedChunk, 0, 12), is(\"he lazy dogs\"));\n}\n", "idx": 2276}
{"project": "cipher", "commit_id": "Snippet22358653_4757.java", "target": 1, "func": "public class AES {\n    public static void main(String[] args) throws Exception {\n        byte[] data = \"abcdefghijkl\".getBytes();\n        byte[] tmp = null;\n        SecretKey tempKey1 = generateKey();\n        // saveKey(tempKey1);\n        // SecretKey tempKey2 = loadKey();\n        tmp = encrypt(data, tempKey1);\n        byte[] printString = decrypt(tmp, tempKey1);\n        System.out.println(Arrays.equals(data, printString));\n\n    }\n\n    public static SecretKey generateKey() throws NoSuchAlgorithmException {\n        KeyGenerator keyGenerator = KeyGenerator.getInstance(\"AES\");\n        keyGenerator.init(128);\n        SecretKey key = keyGenerator.generateKey();\n        return key;\n    }\n\n    public static byte[] encrypt(byte[] data, SecretKey encryptionKey) throws Exception {\n        IvParameterSpec iv = new IvParameterSpec(\"0102030405060708\".getBytes());\n        Cipher cipher = Cipher.getInstance(\"AES/CBC/PKCS5Padding\");\n        cipher.init(Cipher.ENCRYPT_MODE, encryptionKey, iv);\n        byte[] encryptData = cipher.doFinal(data);\n\n        return encryptData;\n    }\n\n    public static byte[] decrypt(byte[] tmp, SecretKey encryptionKey) throws Exception {\n        IvParameterSpec iv = new IvParameterSpec(\"0102030405060708\".getBytes());\n        SecretKeySpec spec = new SecretKeySpec(encryptionKey.getEncoded(), \"AES\");\n        Cipher cipher = Cipher.getInstance(\"AES/CBC/PKCS5Padding\");\n        cipher.init(Cipher.DECRYPT_MODE, spec, iv);\n\n        System.out.println(tmp.length);\n        return cipher.doFinal(tmp);\n\n    }\n}\n", "idx": 2063}
{"project": "cipher", "commit_id": "Snippet42404354_24433.java", "target": 1, "func": "public static void encrypt(byte[] file, String password, String fileName, String dir) throws Exception {\n\n    SecureRandom r = new SecureRandom();\n    //128 bit IV generated for each file\n    byte[] iv = new byte[IV_LENGTH];\n    r.nextBytes(iv);\n    IvParameterSpec ivspec = new IvParameterSpec(iv);\n    SecretKeySpec keySpec = new SecretKeySpec(password.getBytes(), \"AES\");\n\n    Cipher cipher = Cipher.getInstance(\"AES/CBC/NoPadding\");\n    cipher.init(Cipher.ENCRYPT_MODE, keySpec, ivspec);\n\n    FileOutputStream fos = new FileOutputStream(dir + fileName);\n    fos.write(iv);\n\n    CipherOutputStream cos = new CipherOutputStream(fos, cipher);\n\n    // Have to append IV --------\n\n    cos.write(file);\n\n    fos.flush();\n    cos.flush();\n    cos.close();\n    fos.close();\n}\n", "idx": 2003}
{"project": "cipher", "commit_id": "Snippet8343894_33168.java", "target": 1, "func": "public class crypto {\n\n    public static void main( String[] args )\n    {\n        try {\n            File f = new File(\"test.enc\");\n            Cipher c;\n            Key k;\n            String secretString = \"01020304050607080900010203040506\";\n            String ivString = \"01020304050607080900010203040506\";\n            byte[] secret = hexStringToByteArray(secretString);\n            byte[] iv = hexStringToByteArray(ivString);\n\n            c = Cipher.getInstance(\"AES/CBC/PKCS5Padding\");\n            k = new SecretKeySpec(secret, \"AES\");\n            c.init(Cipher.DECRYPT_MODE, k, new IvParameterSpec(iv));\n\n            CipherInputStream cis = new CipherInputStream(new FileInputStream(f), c);\n            BufferedReader br = new BufferedReader(new InputStreamReader(cis));\n\n            String line;\n            while ((line = br.readLine()) != null) {\n                System.out.println(line);\n            }\n            br.close();\n        } catch (IOException e) {\n            System.out.println(e.getMessage());\n        } catch (NoSuchAlgorithmException e) {\n            System.out.println(e.getMessage());\n        } catch (NoSuchPaddingException e) {\n            System.out.println(e.getMessage());\n        } catch (InvalidKeyException e) {\n            System.out.println(e.getMessage());\n        } catch (InvalidAlgorithmParameterException e) {\n            System.out.println(e.getMessage());\n        }\n\n    }\n\n    public static byte[] hexStringToByteArray(String s) {\n        int len = s.length();\n        byte[] data = new byte[len / 2];\n        for (int i = 0; i < len; i += 2) {\n            data[i / 2] = (byte) ((Character.digit(s.charAt(i), 16) << 4)\n                                 + Character.digit(s.charAt(i+1), 16));\n        }\n        return data;\n    }\n}\n                                                            33,1          71%\n", "idx": 1987}
{"project": "cipher", "commit_id": "Snippet35241522_17167.java", "target": 1, "func": " public class encryption {\n\n    private String iv = \"fedcba9876543210\";//Dummy iv (CHANGE IT!)\n    private IvParameterSpec ivspec;\n    private SecretKeySpec keyspec;\n    private Cipher cipher;\n\n    private String SecretKey = \"0123456789abcdef\";//Dummy secretKey (CHANGE IT!)\n\n    public encryption()\n    {\n        ivspec = new IvParameterSpec(iv.getBytes());\n\n        keyspec = new SecretKeySpec(SecretKey.getBytes(), \"AES\");\n\n        try\n        {\n            cipher = Cipher.getInstance(\"AES/CBC/PKCS5PADDING\");//\"AES/CBC/NoPadding\"\n        }\n        catch (NoSuchAlgorithmException e)\n        {\n            // TODO Auto-generated catch block\n            e.printStackTrace();\n        }\n        catch (NoSuchPaddingException e) {\n            // TODO Auto-generated catch block\n            e.printStackTrace();\n        }\n    }\n\n    public byte[] encrypt(String text) throws Exception\n    {\n        if(text == null || text.length() == 0)\n            throw new Exception(\"Empty string\");\n\n        byte[] encrypted = null;\n\n        try {\n            cipher.init(Cipher.ENCRYPT_MODE, keyspec, ivspec);\n\n            encrypted = cipher.doFinal(padString(text).getBytes());\n        } catch (Exception e)\n        {\n            throw new Exception(\"[encrypt] \" + e.getMessage());\n        }\n\n        return encrypted;\n    }\n\n    public byte[] decrypt(String code) throws Exception\n    {\n        if(code == null || code.length() == 0)\n            throw new Exception(\"Empty string\");\n\n        byte[] decrypted = null;\n\n        try {\n            cipher.init(Cipher.DECRYPT_MODE, keyspec, ivspec);\n\n            decrypted = cipher.doFinal(hexToBytes(code));\n        } catch (Exception e)\n        {\n            throw new Exception(\"[decrypt] \" + e.getMessage());\n        }\n        return decrypted;\n    }\n\n\n\n    public static String bytesToHex(byte[] data)\n    {\n        if (data==null)\n        {\n            return null;\n        }\n\n        int len = data.length;\n        String str = \"\";\n        for (int i=0; i<len; i++) {\n            if ((data[i]&0xFF)<16)\n                str = str + \"0\" + java.lang.Integer.toHexString(data[i]&0xFF);\n            else\n                str = str + java.lang.Integer.toHexString(data[i]&0xFF);\n        }\n        return str;\n    }\n\n\n    public static byte[] hexToBytes(String str) {\n        if (str==null) {\n            return null;\n        } else if (str.length() < 2) {\n            return null;\n        } else {\n            int len = str.length() / 2;\n            byte[] buffer = new byte[len];\n            for (int i=0; i<len; i++) {\n                buffer[i] = (byte) Integer.parseInt(str.substring(i*2,i*2+2),16);\n            }\n            return buffer;\n        }\n    }\n\n\n\n    private static String padString(String source)\n    {\n        char paddingChar = ' ';\n        int size = 16;\n        int x = source.length() % size;\n        int padLength = size - x;\n\n        for (int i = 0; i < padLength; i++)\n        {\n            source += paddingChar;\n        }\n\n        return source;\n    }\n}\n", "idx": 2238}
{"project": "cipher", "commit_id": "Snippet29293748_11330.java", "target": 0, "func": "public class EncDec\n{\n    private static final String ALGO = \"AES\";\n    private static final byte[] keyValue = \"1234567891234567\".getBytes();\n    public static void main(String[] args) throws Exception \n    {\n        String testData = \"ABC\";\n        String enc = encrypt(testData);\n        System.out.println(\"Encrypted data: \"+enc);\n        String dec = decrypt(enc);\n        System.out.println(\"Decrypted data: \"+enc);\n    }\n    public static String encrypt(String Data) throws Exception \n    {\n\n        Key key = generateKey();\n        Cipher c = Cipher.getInstance(ALGO);\n        c.init(Cipher.ENCRYPT_MODE, key);\n        byte[] encVal = c.doFinal(Data.getBytes());\n        String encryptedValue = new BASE64Encoder().encode(encVal);\n        return encryptedValue;\n    }\n    public static String decrypt(String encryptedData) throws Exception \n    {\n        try{\n            Key key = generateKey();\n            Cipher c = Cipher.getInstance(ALGO);\n            c.init(Cipher.DECRYPT_MODE, key);\n            byte[] decordedValue = new BASE64Decoder().decodeBuffer(encryptedData);\n            byte[] decValue = c.doFinal(decordedValue);\n            String decryptedValue = new String(decValue);\n            return decryptedValue;\n        }catch(Exception e)\n        {\n            System.out.println(\"Something wrong..\");\n            return \"\";\n        }\n    }\n    private static Key generateKey() throws Exception\n    {\n        Key key = new SecretKeySpec(keyValue, ALGO);\n        return key;\n    }\n}\n", "idx": 1687}
{"project": "cipher", "commit_id": "Snippet45503448_27563.java", "target": 0, "func": "public class FileEncryptor {    \n    private static String filename;\n    private static String password;\n    private static FileInputStream inFile;\n    private static FileOutputStream outFile;\n    public static String tempFilename;\n    public static File tempFile;\n\n    public static File encryptFile(File f, String passkey) throws Exception {\n        if(f.isDirectory()) {\n            JOptionPane.showMessageDialog(null, \"file object is a directory\");\n            return null;\n        }\n        filename = f.getPath();\n        password = passkey;     \n        //Need to create a temporary file which is filled with the encrypted data.\n        tempFilename = filename + \".des\";\n        tempFile = new File(tempFilename);      \n        inFile = new FileInputStream(f);\n        outFile = new FileOutputStream(tempFile);       \n        // Use PBEKeySpec to create a key based on a password.\n        // The password is passed as a character array.\n        PBEKeySpec keySpec = new PBEKeySpec(password.toCharArray());\n        SecretKeyFactory sKeyFac = SecretKeyFactory.getInstance(\"PBEWithMD5AndDES\");\n        SecretKey sKey = sKeyFac.generateSecret(keySpec);       \n        byte[] salt = new byte[8];\n        Random rnd = new Random();\n        rnd.nextBytes(salt);\n        int iterations = 100;       \n         //Create the parameter spec for this salt and iteration count\n        PBEParameterSpec parameterSpec = new PBEParameterSpec(salt, iterations);\n        //Create the cipher and initiate it for encryption\n        Cipher c = Cipher.getInstance(\"PBEWithMD5AndDES\");\n        c.init(Cipher.ENCRYPT_MODE, sKey, parameterSpec);\n\n        //Need to write the salt into the file. It is required for decryption\n        outFile.write(salt);\n\n        //Read the file and encrypt its bytes\n        byte[] input = new byte[64];\n        int bytesRead;\n        while((bytesRead = inFile.read(input)) != -1) {\n            byte[] output = c.update(input, 0, bytesRead);\n            if(output != null) { outFile.write(output); }           \n        }\n\n        byte[] output = c.doFinal();\n        if(output != null) { outFile.write(output); }\n\n        //Closing the streams before exiting.\n        inFile.close();\n        outFile.flush();\n        outFile.close();\n\n        return tempFile;\n    }\n\n}\n", "idx": 1908}
{"project": "cipher", "commit_id": "Snippet33818911_15896.java", "target": 0, "func": "import java.io.File;\nimport java.io.FileInputStream;\nimport java.io.FileNotFoundException;\nimport java.io.FileOutputStream;\nimport java.io.IOException;\nimport java.io.ObjectInputStream;\nimport java.io.ObjectOutputStream;\nimport java.io.Serializable;\nimport java.security.NoSuchAlgorithmException;\nimport java.util.ArrayList;\nimport javax.crypto.Cipher;\nimport javax.crypto.CipherInputStream;\nimport javax.crypto.CipherOutputStream;\nimport javax.crypto.NoSuchPaddingException;\nimport premierleague.model.FootballClub;\nimport premierleague.model.Match;\n\n/**\n *\n * @author Akila\n */\npublic class Serializing implements Serializable{\n\n    private FileInputStream fileIn;\n    private FileOutputStream fileOut;\n    private ObjectInputStream in;\n    private ObjectOutputStream out;\n\n    public ArrayList<FootballClub> FootBallInputStream() throws FileNotFoundException, IOException, ClassNotFoundException, NoSuchAlgorithmException, NoSuchPaddingException {\n        Cipher cipher = Cipher.getInstance(\"DES\");\n        File file = new File(\"FootballClub.ser\");\n        fileIn = new FileInputStream(file);\n        CipherInputStream CipherIn = new CipherInputStream(in, cipher);\n        in = new ObjectInputStream(CipherIn);\n        ArrayList<FootballClub> e = (ArrayList<FootballClub>) in.readObject();\n        in.close();\n        fileIn.close();\n\n        return e;\n\n    }\n\n    public void FootBallOutputStream(ArrayList<FootballClub> e) throws FileNotFoundException, IOException, NoSuchAlgorithmException, NoSuchPaddingException {\n        Cipher cipher = Cipher.getInstance(\"DES\");\n        File file = new File(\"FootballClub.ser\");\n        fileOut = new FileOutputStream(file);\n        CipherOutputStream cipherOut = new CipherOutputStream(out,cipher);\n        out = new ObjectOutputStream(cipherOut);\n        out.writeObject(e);\n        out.close();\n        fileOut.close();\n    }\n\n\n}\n", "idx": 1819}
{"project": "cipher", "commit_id": "Snippet39218791_21081.java", "target": 0, "func": "   public static String base64Encode(byte[] bytes)\n    {\n        return new BASE64Encoder().encode(bytes);\n    }\n\n   public static byte[] base64Decode(String property) throws IOException\n    {\n        return new BASE64Decoder().decodeBuffer(property);\n    }\n\n\n    public static String encrypt(String mystring) throws GeneralSecurityException, UnsupportedEncodingException\n       {\n        SecretKeyFactory keyFactory = SecretKeyFactory.getInstance(\"PBEWithMD5AndDES\");\n        SecretKey key = keyFactory.generateSecret(new PBEKeySpec(mystring.toCharArray()));\n        Cipher pbeCipher = Cipher.getInstance(\"PBEWithMD5AndDES\");\n        pbeCipher.init(Cipher.ENCRYPT_MODE, key, new PBEParameterSpec(SALT, 20));\n        return base64Encode(pbeCipher.doFinal(mystring.getBytes(\"UTF-8\")));\n        }\n\n    public static String decrypt(String estring) throws GeneralSecurityException, IOException\n        {\n        SecretKeyFactory keyFactory = SecretKeyFactory.getInstance(\"PBEWithMD5AndDES\");\n        SecretKey key = keyFactory.generateSecret(new PBEKeySpec(estring.toCharArray()));\n        Cipher pbeCipher = Cipher.getInstance(\"PBEWithMD5AndDES\");\n        pbeCipher.init(Cipher.DECRYPT_MODE, key, new PBEParameterSpec(SALT, 20));\n        return new String(pbeCipher.doFinal(base64Decode(estring)), \"UTF-8\");\n        }\n", "idx": 1658}
{"project": "cipher", "commit_id": "Snippet16055100_39013.java", "target": 0, "func": "Cipher.getInstance(\"AES\");\n", "idx": 1808}
{"project": "cipher", "commit_id": "Snippet28024135_10157.java", "target": 0, "func": "// bytes to encrypt\nbyte[] input;\n\n// the key and the initialization vector\nbyte[] keyBytes;\nbyte[] ivBytes;\n\n// initialize the Cipher\nSecretKeySpec key = new SecretKeySpec(keyBytes, \"DES\");\nIvParameterSpec ivSpec = new IvParameterSpec(ivBytes);\nCipher cipher = Cipher.getInstance(\"DES/CBC/PKCS5Padding\");\n\n// encryption\ncipher.init(Cipher.ENCRYPT_MODE, key, ivSpec);\nbyte[] encrypted= new byte[cipher.getOutputSize(input.length)];\nint enc_len = cipher.update(input, 0, input.length, encrypted, 0);\nenc_len += cipher.doFinal(encrypted, enc_len);\n\n// decryption\ncipher.init(Cipher.DECRYPT_MODE, key, ivSpec);\nbyte[] decrypted = new byte[cipher.getOutputSize(enc_len)];\nint dec_len = cipher.update(encrypted, 0, enc_len, decrypted, 0);\ndec_len += cipher.doFinal(decrypted, dec_len);\n", "idx": 1897}
{"project": "cipher", "commit_id": "Snippet22748230_5151.java", "target": 1, "func": "Cipher.getInstance(\"AES/CBC/PKCS7Padding\", providerBC)\n", "idx": 2265}
{"project": "cipher", "commit_id": "Snippet19161819_2006.java", "target": 1, "func": "        String keyword  = \"keyword\";\n        int iterationCount = 1000; \n        int keyLength = 256;\n        String[] fields = encryptedPassword.split(\"]\");\n        byte[] salt = fromBase64(fields[0]);\n        byte[] cipherBytes = fromBase64(fields[1]);\n        KeySpec keySpec = new PBEKeySpec(keyword.toCharArray(), salt, iterationCount, keyLength);\n        SecretKeyFactory keyFactory = SecretKeyFactory.getInstance(\"PBEWITHSHA256AND256BITAES-CBC-BC\");\n        SecretKey key = keyFactory.generateSecret(keySpec);\n        Cipher cipher = Cipher.getInstance(\"AES/CBC/PKCS5Padding\");\n        PBEParameterSpec pbeSpec = new PBEParameterSpec(salt, iterationCount);\n        cipher.init(Cipher.DECRYPT_MODE, key, pbeSpec);\n        byte[] plainBytes = cipher.doFinal(cipherBytes);\n        plainStr = new String(plainBytes, \"UTF-8\").trim();\n        return plainStr;\n", "idx": 2187}
{"project": "cipher", "commit_id": "Snippet20185689_2863.java", "target": 1, "func": "    // generate a key\n        KeyGenerator keygen = KeyGenerator.getInstance(\"AES\");\n        keygen.init(128);  // To use 256 bit keys, you need the \"unlimited strength\" encryption policy files from Sun.\n        //byte[] key = keygen.generateKey().getEncoded();\n        byte key[] = {0x00, 0x01, 0x02, 0x11, 0x00, 0x00, 0x00, 0x00, 0x00, 0x0C, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00};\n        SecretKeySpec skeySpec = new SecretKeySpec(key, \"AES\");\n\n\n        SecureRandom random = new SecureRandom();\n\n        IvParameterSpec ivspec = new IvParameterSpec(key);\n\n        // initialize the cipher for encrypt mode\n        Cipher cipher = Cipher.getInstance(\"AES/CBC/PKCS5Padding\");\n        cipher.init(Cipher.ENCRYPT_MODE, skeySpec, ivspec);\n\n        System.out.println();\n\n        byte[] encrypted = cipher.doFinal(IOUtils.toByteArray(new FileInputStream(new File(fileName))));\n", "idx": 2089}
{"project": "cipher", "commit_id": "Snippet46915299_28935.java", "target": 1, "func": "private static final int pswdIterations = 1000;\nprivate static final int keySize = 256;\nprivate static final int saltlength = keySize / 8;\n\nprivate static final String ENCODING = \"UTF-8\";\nprivate static final String PBK = \"PBKDF2WithHmacSHA1\";\nprivate static final String AES = \"AES\";\nprivate static final String CIPHER = \"AES/CBC/PKCS5Padding\";\n\npublic String encrypt(String plainText) throws Exception {\n    //get text from password field\n    final String pass = password.getText().toString();\n    //get salt from generateSalt() method (see below)\n    String salt = generateSalt();\n    //convert salt to bytes\n    byte[] saltBytes = salt.getBytes(ENCODING);\n\n    // Derive the key from\n    SecretKeyFactory factory = SecretKeyFactory.getInstance(PBK);\n    PBEKeySpec spec = new PBEKeySpec(\n            pass.toCharArray(),\n            saltBytes,\n            pswdIterations,\n            keySize\n    );\n\n    //encode key\n    SecretKey secretKey = factory.generateSecret(spec);\n    SecretKeySpec secret = new SecretKeySpec(secretKey.getEncoded(), AES);\n\n    //encrypt the message\n    Cipher cipher = Cipher.getInstance(CIPHER);\n    cipher.init(Cipher.ENCRYPT_MODE, secret);\n    AlgorithmParameters params = cipher.getParameters();\n    byte[] ivBytes = params.getParameterSpec(IvParameterSpec.class).getIV();\n    byte[] encryptedTextBytes = cipher.doFinal(plainText.getBytes(ENCODING));\n\n    //encode text and output final encrypted text\n    String encodedText = Base64.encodeToString(encryptedTextBytes, Base64.DEFAULT);\n    String encodedIV = Base64.encodeToString(ivBytes, Base64.DEFAULT);\n    String encodedSalt = Base64.encodeToString(saltBytes, Base64.DEFAULT);\n    return encodedSalt +  encodedText + encodedIV;\n}\n\npublic static String generateSalt() {\n    SecureRandom random = new SecureRandom();\n    byte bytes[] = new byte[saltlength];\n    random.nextBytes(bytes);\n    return new String(bytes);\n}\n", "idx": 2068}
{"project": "cipher", "commit_id": "Snippet32082537_14144.java", "target": 1, "func": "Cipher myCipher = Cipher.getInstance(\"AES/CTR/NoPadding\");\n", "idx": 2204}
{"project": "cipher", "commit_id": "Snippet30495630_12652.java", "target": 1, "func": "Cipher cipher = Cipher.getInstance(\"Threefish-256/CBC/NoPadding\");\ncipher.init(???);\n", "idx": 2057}
{"project": "cipher", "commit_id": "Snippet23539444_5902.java", "target": 1, "func": "    public String decryptJson(String data)\n{\n    String[] split= data.trim().split(\"=\");\n\n    byte[] iv = Base64.decode(split[0],3);      \n    String hash = split[1];\n    byte[] encd = Base64.decode(split[2],0);\n\n    String skey  = \"secretkeyfromdatabase\";\n    byte[] skeyb = skey.getBytes();\n\n            try\n            {                   \n            IvParameterSpec ivspec = new IvParameterSpec(iv);\n            SecretKeySpec skeyspec = new SecretKeySpec(skeyb,\"AES\");\n\n            Cipher cipher = Cipher.getInstance(\"AES/CBC/PKCS5Padding\");\n\n            cipher.init(Cipher.DECRYPT_MODE,skeyspec,ivspec);\n\n            byte[] original = cipher.doFinal(encd);\n\n            return original.toString();\n\n            }\n            catch(Exception ex)\n            {\n                ex.printStackTrace();\n                return \"ERROR! | \"+ex+\"IV:\"+iv;\n            }\n}\n", "idx": 1991}
{"project": "cipher", "commit_id": "Snippet34389464_16384.java", "target": 0, "func": " KeyGenerator keygenerator = KeyGenerator.getInstance(\"DES\");\n SecretKey myDesKey = keygenerator.generateKey();\n Cipher desCipher;\n desCipher = Cipher.getInstance(\"DES\");\n byte[] text = \"Hello\".getBytes(\"UTF8\");\n\n\n desCipher.init(Cipher.ENCRYPT_MODE, myDesKey);\n byte[] textEncrypted = desCipher.doFinal(text);\n String s = new String(textEncrypted);\n System.out.println(s);\n", "idx": 1616}
{"project": "cipher", "commit_id": "Snippet10275913_34632.java", "target": 0, "func": "     public byte[] encript(byte[] dataToEncrypt, byte[] key)\n            throws NoSuchAlgorithmException, NoSuchPaddingException,\n            InvalidKeyException, IllegalBlockSizeException, BadPaddingException {\n    //I'm using AES encription\n    Cipher c = Cipher.getInstance(\"AES\");\n    SecretKeySpec k = new SecretKeySpec(key, \"AES\");\n    c.init(Cipher.ENCRYPT_MODE, k);\n    return c.doFinal(dataToEncrypt);\n    }\n\n    public byte[] decript(byte[] encryptedData, byte[] key)\n            throws NoSuchAlgorithmException, NoSuchPaddingException,\n            InvalidKeyException, IllegalBlockSizeException, BadPaddingException {\n    Cipher c = Cipher.getInstance(\"AES\");\n    SecretKeySpec k = new SecretKeySpec(key, \"AES\");\n    c.init(Cipher.DECRYPT_MODE, k);\n    return c.doFinal(encryptedData);\n    }\n", "idx": 1826}
{"project": "cipher", "commit_id": "Snippet13774127_37260.java", "target": 1, "func": "import java.awt.*;\nimport java.awt.event.*;    \n\nimport javax.crypto.BadPaddingException;\nimport javax.crypto.Cipher;\nimport javax.crypto.IllegalBlockSizeException;\nimport javax.crypto.NoSuchPaddingException;\nimport javax.swing.*;       \nimport javax.swing.event.*;\nimport java.io.*;\nimport java.net.*;\nimport java.security.InvalidKeyException;\nimport java.security.KeyFactory;\nimport java.security.KeyPair;\nimport java.security.KeyPairGenerator;\nimport java.security.NoSuchAlgorithmException;\nimport java.security.PrivateKey;\nimport java.security.PublicKey;\nimport java.security.spec.InvalidKeySpecException;\nimport java.security.spec.RSAPublicKeySpec;\n\npublic class chatClient extends SwingChatGUI\n{\n\n    /**\n     * \n     */\n    private static final long serialVersionUID = 1L;\n    static Socket socket = null;\n    static PrintWriter out = null;\n    static BufferedReader in = null;\n    public ButtonHandler bHandler;\n    static PublicKey publicKey;\n    static PrivateKey privateKey;\n    String fromServer;\n    int stage = 0;\n\n    public chatClient (String title)\n    {\n        super (title);\n        bHandler = new ButtonHandler();\n        sendButton.addActionListener( bHandler );\n    }\n\n    private class ButtonHandler implements ActionListener\n    {\n        public void actionPerformed (ActionEvent event)\n        {\n            String outputLine;\n            outputLine = txArea.getText ();\n            System.out.println (\"Client > \" + outputLine);\n            out.println (outputLine);\n        }\n    }\n\n    public void decrypt() {\n\n\n         Cipher cipher1;\n        try {\n\n            //fromServer = fromServer.substring(0, fromServer.length() - 2);\n            int count = fromServer.length();\n            System.out.println(\"the length is \" +count);\n            byte[] src = fromServer.getBytes();\n            cipher1 = Cipher.getInstance(\"RSA\");\n              cipher1.init(Cipher.DECRYPT_MODE, privateKey);\n              byte[] cipherData1 = cipher1.doFinal(src);\n              System.out.println(\"encrypted?\" + new String(cipherData1));\n\n\n\n        } catch (NoSuchAlgorithmException e) {\n            // TODO Auto-generated catch block\n            e.printStackTrace();\n        } catch (NoSuchPaddingException e) {\n            // TODO Auto-generated catch block\n            e.printStackTrace();\n        } catch (InvalidKeyException e) {\n            // TODO Auto-generated catch block\n            e.printStackTrace();\n        } catch (IllegalBlockSizeException e) {\n            // TODO Auto-generated catch block\n            e.printStackTrace();\n        } catch (BadPaddingException e) {\n            // TODO Auto-generated catch block\n            e.printStackTrace();\n        }\n\n\n    }\n\n    public void run () throws IOException\n    {\n        try\n        {\n            socket = new Socket (\"localhost\", 4444);\n            out = new PrintWriter (socket.getOutputStream (), true);\n            in = new BufferedReader (new InputStreamReader (socket.getInputStream ()));\n        }\n        catch (UnknownHostException e)\n        {\n            System.err.println (\"Don't know about host: to host.\");\n            System.exit(1);\n        }\n        catch (IOException e)\n        {\n            System.err.println (\"Couldn't get I/O for the connection to: to host.\");\n            System.exit (1);\n        }\n\n\n        kp();\n        CharArrayWriter os = new CharArrayWriter();\n        char[] buf = new char[4096];\n        int read;\n        while ((read=in.read(buf, 0, 4096)) > 0) {\n          System.out.println(\"x\");\n                 os.write(buf, 0, read);\n          fromServer = os.toString();\n\n            if (stage > 2)\n            {\n                decrypt();\n            }\n            stage++;\n            System.out.println (\"Client <  \" + fromServer);\n            rxArea.setText (fromServer);\n            os.reset();\n            if (fromServer.equals (\"Bye.\")) break;\n        }\n\n        out.close();\n        in.close();\n        socket.close();\n    }\n\n    public static void main(String[] args) \n    {\n\n        chatClient f = new chatClient (\"Chat Client Program\");\n\n        f.pack ();\n        f.show ();\n        try\n        {\n            f.run ();\n        }\n        catch (IOException e)\n        {\n            System.err.println(\"Couldn't get I/O for the connection to: to host.\");\n            System.exit(1);\n        }\n    }\n\n\n    public static void kp() {\n\n        KeyPairGenerator kpg;\n\n            try {\n                kpg = KeyPairGenerator.getInstance(\"RSA\");\n                kpg.initialize(2048);\n                KeyPair kp = kpg.genKeyPair();\n                publicKey = kp.getPublic();\n                privateKey = kp.getPrivate();\n                KeyFactory fact = KeyFactory.getInstance(\"RSA\");\n                RSAPublicKeySpec pub;\n\n                    pub = fact.getKeySpec(kp.getPublic(),\n                          RSAPublicKeySpec.class);\n                    out.println(\"!m! \" + pub.getModulus() + \"!e! \" + pub.getPublicExponent());\n                } catch (InvalidKeySpecException e) {\n                    // TODO Auto-generated catch block\n                    e.printStackTrace();\n\n\n\n\n\n\n            } catch (NoSuchAlgorithmException e) {\n                // TODO Auto-generated catch block\n                e.printStackTrace();\n            }\n\n\n\n\n    }\n\n\n\n}\n", "idx": 2247}
{"project": "cipher", "commit_id": "Snippet36708658_18601.java", "target": 0, "func": "public class CryptoFile {\n\npublic  byte[] encrypt(String seed, byte[] cleartext) throws Exception {           \n\n        byte[] rawKey = getRawKey(seed.getBytes());\n\n    byte[] result = encrypt(rawKey, cleartext);\n\n  //  return toHex(result);\n    return result;\n} \npublic  byte[] decrypt(String seed, byte[] encrypted) throws Exception {\n\n    byte[] rawKey = getRawKey(seed.getBytes());\n\n    byte[] enc = encrypted;\n\n    byte[] result = decrypt(rawKey, enc); \n\n    return result;     }\n\n//done\n private  byte[] getRawKey(byte[] seed) throws Exception {\n\n    KeyGenerator kgen = KeyGenerator.getInstance(\"AES\");\n\n    SecureRandom sr = SecureRandom.getInstance(\"SHA1PRNG\");\n\n    sr.setSeed(seed);\n\nkgen.init(128, sr); // 192 and 256 bits may not be available\n\nSecretKey skey = kgen.generateKey();\n\nbyte[] raw = skey.getEncoded();\n\nreturn raw;\n}\nprivate  byte[] encrypt(byte[] raw, byte[] clear) throws Exception {\n\nSecretKeySpec skeySpec = new SecretKeySpec(raw, \"AES\");\n\n    Cipher cipher = Cipher.getInstance(\"AES\");\n\ncipher.init(Cipher.ENCRYPT_MODE, skeySpec);\n\nbyte[] encrypted = cipher.doFinal(clear);\n\n    return encrypted;\n\n}\n\n private  byte[] decrypt(byte[] raw, byte[] encrypted) throws Exception {\n\nSecretKeySpec skeySpec = new SecretKeySpec(raw, \"AES\");\n\n    Cipher cipher = Cipher.getInstance(\"AES\");\n\ncipher.init(Cipher.DECRYPT_MODE, skeySpec);\n\nbyte[] decrypted = cipher.doFinal(encrypted);\n\n    return decrypted;\n\n}\n\n}\n", "idx": 1842}
{"project": "cipher", "commit_id": "Snippet22754788_5152.java", "target": 0, "func": "final Path origFile = Paths.get(\"C:\\\\3.txt\");\nfinal byte[] contents = Files.readAllBytes(origFile);\n\n// Get the KeyGenerator\n\n   KeyGenerator kgen = KeyGenerator.getInstance(\"AES\");\n   kgen.init(128); // 192 and 256 bits may not be available\n\n\n// Generate the secret key specs.\n   SecretKey skey = kgen.generateKey();\n   byte[] raw = skey.getEncoded();\n\n   SecretKeySpec skeySpec = new SecretKeySpec(raw, \"AES\");\n\n\n// Instantiate the cipher\n\n   Cipher cipher = Cipher.getInstance(\"AES\");\n\n   cipher.init(Cipher.ENCRYPT_MODE, skeySpec);\n\n   byte[] encrypted = cipher.doFinal(contents.toString().getBytes());\n\n   System.out.println(\"encrypted string: \" + encrypted.toString());\n\n   cipher.init(Cipher.DECRYPT_MODE, skeySpec);\n   byte[] original =cipher.doFinal(encrypted);\n\n   String originalString = new String(original);\n   System.out.println(\"Original string: \" +originalString);\n\n   final Path newFile = Paths.get(\"C:\\\\3encrypted.aes\");\n   Files.write(newFile, encrypted, StandardOpenOption.CREATE);\n\n     }\n", "idx": 1868}
{"project": "cipher", "commit_id": "Snippet21973958_4405.java", "target": 0, "func": "import java.security.SecureRandom;\n\nimport javax.crypto.Cipher;\nimport javax.crypto.KeyGenerator;\nimport javax.crypto.SecretKey;\nimport javax.crypto.spec.SecretKeySpec;\n\nimport android.util.Base64;\n\npublic class StringCryptor \n{\nprivate static final String CIPHER_ALGORITHM = \"AES\";\nprivate static final String RANDOM_GENERATOR_ALGORITHM = \"SHA1PRNG\";\nprivate static final int RANDOM_KEY_SIZE = 128;\n\n// Encrypts string and encode in Base64\npublic static String encrypt( String password, String data ) throws Exception \n{\n    byte[] secretKey = generateKey( password.getBytes() );\n    byte[] clear = data.getBytes();\n\n    SecretKeySpec secretKeySpec = new SecretKeySpec( secretKey, CIPHER_ALGORITHM );\n    Cipher cipher = Cipher.getInstance( CIPHER_ALGORITHM );\n    cipher.init( Cipher.ENCRYPT_MODE, secretKeySpec );\n\n    byte[] encrypted = cipher.doFinal( clear );\n    String encryptedString = Base64.encodeToString( encrypted, Base64.DEFAULT );\n\n    return encryptedString;\n}\n\n// Decrypts string encoded in Base64\npublic static String decrypt( String password, String encryptedData ) throws Exception \n{\n    byte[] secretKey = generateKey( password.getBytes() );\n\n    SecretKeySpec secretKeySpec = new SecretKeySpec( secretKey, CIPHER_ALGORITHM );\n    Cipher cipher = Cipher.getInstance( CIPHER_ALGORITHM );\n    cipher.init( Cipher.DECRYPT_MODE, secretKeySpec );\n\n    byte[] encrypted = Base64.decode( encryptedData, Base64.DEFAULT );\n    byte[] decrypted = cipher.doFinal( encrypted );\n\n    return new String( decrypted );\n}\n\npublic static byte[] generateKey( byte[] seed ) throws Exception\n{\n    KeyGenerator keyGenerator = KeyGenerator.getInstance( CIPHER_ALGORITHM );\n    SecureRandom secureRandom = SecureRandom.getInstance( RANDOM_GENERATOR_ALGORITHM );\n    secureRandom.setSeed( seed );\n    keyGenerator.init( RANDOM_KEY_SIZE, secureRandom );\n    SecretKey secretKey = keyGenerator.generateKey();\n    return secretKey.getEncoded();\n}\n}\n", "idx": 1750}
{"project": "cipher", "commit_id": "Snippet15335905_38398.java", "target": 0, "func": "import java.security.Key;\n\nimport javax.crypto.Cipher;\nimport javax.crypto.spec.SecretKeySpec;\n\nimport org.apache.commons.codec.binary.Hex;\n\n public class AESEncryptionDecryptionTest {\n\n   private static final String ALGORITHM       = \"AES\";\n   private static final String myEncryptionKey = \"OIXQUULC7khaJzzOOHRqgw==\";\n   private static final String UNICODE_FORMAT  = \"UTF8\";\n\n   public static String encrypt(String valueToEnc) throws Exception {\n        Key key = generateKey();\n        Cipher c = Cipher.getInstance(ALGORITHM);\n        c.init(Cipher.ENCRYPT_MODE, key);  \n        byte[] encValue = c.doFinal(valueToEnc.getBytes(UNICODE_FORMAT));\n        String encryptedValue = new Hex().encodeHexString(encValue);\n        return encryptedValue;\n   }\n\n   public static String decrypt(String encryptedValue) throws Exception {\n        Key key = generateKey();\n        Cipher c = Cipher.getInstance(ALGORITHM);\n        c.init(Cipher.DECRYPT_MODE, key);\n        byte[] decordedValue = new Hex().decode(encryptedValue.getBytes());\n        byte[] decValue = c.doFinal(decordedValue);//////////LINE 50\n        String decryptedValue = new String(decValue);\n        return decryptedValue;\n   }\n\n   private static Key generateKey() throws Exception {\n        byte[] keyAsBytes;\n        keyAsBytes = myEncryptionKey.getBytes();\n        Key key = new SecretKeySpec(keyAsBytes, ALGORITHM);\n        return key;\n   }\n\n   public static void main(String[] args) throws Exception {\n\n        String value = \"PFN123\";\n        String valueEnc = AESEncryptionDecryptionTest.encrypt(value);\n        String valueDec = AESEncryptionDecryptionTest.decrypt(valueEnc);\n\n        System.out.println(\"Plain Text : \" + value);\n        System.out.println(\"Encrypted : \" + valueEnc);\n        System.out.println(\"Decrypted : \" + valueDec);\n   }\n\n}\n", "idx": 1582}
{"project": "cipher", "commit_id": "Snippet45392201_27470.java", "target": 0, "func": "public class MainActivity extends AppCompatActivity {\nTextView txtChuoi, txtKey, txtMaHoa, txtGiaiMa;\nButton btnMaHoa, btnGiaiMa;\nprivate static Cipher ecipher;\nprivate static Cipher dcipher;\nprivate  static SecretKey key;\nString encrypted;\n\n@Override\nprotected void onCreate(Bundle savedInstanceState) {\n    super.onCreate(savedInstanceState);\n    setContentView(R.layout.activity_main);\n    addControl();\n    addEvent();\n}\n\nprivate void addEvent() {\n    btnMaHoa.setOnClickListener(new View.OnClickListener() {\n        @Override\n        public void onClick(View v) {\n            try {\n\n                key = KeyGenerator.getInstance(\"DES\").generateKey();\n                /////How to use\n                ////txtKey.setText().toString() -----> for SecretKey?\n                ecipher = Cipher.getInstance(\"DES\");\n                ecipher.init(Cipher.ENCRYPT_MODE,key);\n                encrypted = encrypt(txtChuoi.getText().toString());\n                txtMaHoa.setText(encrypted);\n            } catch (Exception e) {\n                e.printStackTrace();\n            } \n        }\n    });\n    btnGiaiMa.setOnClickListener(new View.OnClickListener() {\n        @Override\n        public void onClick(View v) {\n            String decrypt = decrypt(encrypted);\n            txtGiaiMa.setText(decrypt);\n        }\n    });\n}\n\nprivate String decrypt(String encrypted) {\n\n    try {\n        dcipher = Cipher.getInstance(\"DES\");\n        dcipher.init(Cipher.DECRYPT_MODE, key);\n        byte[] dec = Base64.decode(encrypted.getBytes(),Base64.DEFAULT);\n        byte[] utf8 = dcipher.doFinal(dec);\n        return  new String(utf8,\"UTF-8\");\n    } catch (Exception e) {\n        e.printStackTrace();\n    } \n    return null;\n}\n\nprivate String encrypt(String s){\n    byte[]enc = null;\n    try {\n        byte[] utf8 = s.getBytes(\"UTF-8\");\n        enc = ecipher.doFinal(utf8);\n        enc = Base64.encode(enc,Base64.DEFAULT);\n        return new String(enc);\n    } catch (Exception e) {\n        e.printStackTrace();\n    } \n    return null;\n}\n\n\nprivate void addControl() {\n    txtChuoi = (TextView) findViewById(R.id.txtChuoi);\n    txtKey = (TextView) findViewById(R.id.txtKey);\n    txtMaHoa = (TextView) findViewById(R.id.txtMaHoa);\n    txtGiaiMa = (TextView) findViewById(R.id.txtGiaiMa);\n    btnMaHoa = (Button) findViewById(R.id.btnMaHoa);\n    btnGiaiMa = (Button) findViewById(R.id.btnGiaiMa);\n\n    }\n}\n", "idx": 1589}
{"project": "cipher", "commit_id": "Snippet40886165_22782.java", "target": 1, "func": "public static void main(String[] args) throws UnrecoverableKeyException, KeyStoreException, NoSuchAlgorithmException {\n    final byte[] IV_PARAM = {\n        0x06,\n        0x07,\n        0x08,\n        0x09,\n        0x0A,\n        0x0B,\n        0x0C,\n        0x0D,\n        0x0E,\n        0x0F,\n        0x00,\n        0x01,\n        0x02,\n        0x03,\n        0x04,\n        0x05,\n    };\n\n    // MAGATZEM DE CLAUS\n    String magatzemClaus = null;\n    String contraMagatzemClaus = null;\n    String alias = null;\n    String contraAlias = null;\n    String text = null;\n    String concatenat = null;\n\n    int opcio = 0;\n\n    KeyStore keystore = null;\n    SecretKey secretkey = null;\n    PublicKey publickey = null;\n    PrivateKey privateKey = null;\n\n    byte[] missatgeEncriptat = null;\n    byte[] clauEncriptada = null;\n    byte[] clauMissatgeEncriptat = null;\n    byte[] missatgeADesencriptar = null;\n    byte[] missatgeDesencriptat = null;\n    byte[] clau = null;\n\n    // SCANNER\n    Scanner teclat = new Scanner(System.in);\n\n    // DEMANEM EL TEXT A ENCRIPTAR\n    System.out.print(\"Introdueix el text: \");\n    text = teclat.next();\n\n    // DEMANEM MAGATZEM DE CLAUS\n    System.out.print(\"MAGATZEM DE CLAUS: QuiMatA3\\n\");\n    magatzemClaus = \"QuiMatA3\";\n\n    // DEMANEM CONTRASENYA PER AL MAGATZEM DE CLAUS\n    System.out.print(\"CONTRASENYA DE [\" + magatzemClaus + \"]: QuiMatA3\\n\");\n    contraMagatzemClaus = \"QuiMatA3\";\n\n    //DEMANEM OPCIO\n    System.out.println(\"Transformaci\ufffd a realitzar [1] xifrar [2] desxifrar.\");\n    opcio = teclat.nextInt();\n\n    //////////////////////////////////////////////\n    //  KEYSTORE\n    //////////////////////////////////////////////\n\n    try {\n        keystore = KeyStore.getInstance(\"JKS\");\n        File arxiu = new File(magatzemClaus + \".jks\");\n        if (arxiu.isFile()) {\n            FileInputStream llegeix = new FileInputStream(arxiu);\n            keystore.load(llegeix, contraMagatzemClaus.toCharArray());\n        }\n    } catch (KeyStoreException e) {\n        System.err.println(\"error keystore: \" + e.toString());\n    } catch (FileNotFoundException e) {\n        System.err.println(\"Error fileinput: \" + e.toString());\n    } catch (Exception e) {\n        System.err.println(\"error al carregar: \" + e.toString());\n    }\n\n    switch (opcio) {\n        case 1:\n\n            ///////////////////////////////////////////\n            //      GENEREM SECRET KEY\n            ///////////////////////////////////////////\n\n            try {\n\n                //GENEREM LA CLAU SECRETA\n                KeyGenerator keyGenerator = KeyGenerator.getInstance(\"AES\");\n                keyGenerator.init(192);\n                secretkey = keyGenerator.generateKey();\n\n                // ALIAS DE LA CLAU\n                System.out.println(\"ALIAS DE LA CLAU [\" + contraMagatzemClaus + \"]: QuiMat\\n\");\n                alias = \"QuiMat\";\n\n                //////////////////////////////////\n                // ENCRIPTAR\n                /////////////////////////////////\n                Cipher xifrar = Cipher.getInstance(\"AES/CBC/PKCS5Padding\");\n                IvParameterSpec ivParam = new IvParameterSpec(IV_PARAM);\n                xifrar.init(Cipher.ENCRYPT_MODE, secretkey, ivParam);\n                missatgeEncriptat = xifrar.doFinal(text.getBytes());\n\n            } catch (Exception e) {\n                System.err.println(\"Error al generar clau secreta o al xifrar!\" + e.toString());\n            }\n\n            //GENEREM LA CLAU PUBLICA\n\n            try {\n                publickey = keystore.getCertificate(alias).getPublicKey();\n            } catch (KeyStoreException e) {\n                System.err.println(\"Error al generar clau p\ufffdblica! \" + e.toString());\n            }\n\n            //ENCRPITEM CLAU SIM\ufffdTRICA AMB LA CLAU P\ufffdBLICA\n            // CLAU ENCRIPTADA\n            Cipher xifrar;\n            try {\n                xifrar = Cipher.getInstance(\"RSA/ECB/PKCS1Padding\");\n                xifrar.init(Cipher.ENCRYPT_MODE, publickey);\n                clauEncriptada = xifrar.doFinal(secretkey.getEncoded());\n            } catch (Exception e) {\n                System.err.println(\"Error al encriptar la clau sim\ufffdtrica: \" + e.toString());\n            }\n\n            // CONCATENEM\n            concatenat = MadMarConverter.byteArrayToHexString(missatgeEncriptat) +\n                MadMarConverter.byteArrayToHexString(clauEncriptada);\n            System.out.println(\"Concatenaci\ufffd clau i text: \" + concatenat);\n\n            break;\n\n        case 2:\n\n            ////////////////////////////////////////////////////////////////////\n            ////////////            DESENCRIPTAR\n            ////////////////////////////////////////////////////////////////////\n\n            // ALIAS DE LA CLAU\n            System.out.println(\"ALIAS DE LA CLAU [\" + contraMagatzemClaus + \"]: QuiMat\\n\");\n            alias = \"QuiMat\";\n            //teclat.next();\n\n            // CONTRASENYA ALIAS\n            System.out.println(\"CONTRASENYA DE L'ALIAS  [\" + alias + \"]:QuiMatP\\n\");\n            contraAlias = \"QuiMatP\";\n\n            clauMissatgeEncriptat = MadMarConverter.hexStringToByteArray(text);\n\n            //SEPAREM CLAU SIMETRICA DE MISSATGE ENCRIPTAT\n            clau = Arrays.copyOfRange(clauMissatgeEncriptat, 0, 256); //GUARDEM CLAU EN UN ARRAY\n            missatgeADesencriptar = Arrays.copyOfRange(clauMissatgeEncriptat, 256, clauMissatgeEncriptat.length); //MISSATGE EN UN ARRAY\n\n            //CLAU PRIVADA\n\n            privateKey = (PrivateKey) keystore.getKey(alias, contraAlias.toCharArray());\n\n            /////////////////////////////////////\n            //      DESXIFRAT CLAU SIMETRICA\n            /////////////////////////////////////\n            byte[] clauDesencriptada = null;\n\n            try {\n\n                Cipher desxifrar = Cipher.getInstance(\"RSA/ECB/PKCS1Padding\");\n                desxifrar.init(Cipher.DECRYPT_MODE, privateKey);\n                clauDesencriptada = desxifrar.doFinal(clau);\n            } catch (Exception e) {\n                System.err.println(\"Error al desencriptar clau: \" + e.toString());\n            }\n\n            secretkey = new SecretKeySpec(clauDesencriptada, 0, clauDesencriptada.length, \"AES\");\n\n            /////////////////////////////////////////////////////\n            //          DESXIFRAR MISSATGE\n            /////////////////////////////////////////////////////\n            try {\n                Cipher desxifrar = Cipher.getInstance(\"AES/CBC/PKCS5Padding\");\n                IvParameterSpec ivParam = new IvParameterSpec(IV_PARAM);\n                desxifrar.init(Cipher.DECRYPT_MODE, secretkey, ivParam);\n                missatgeDesencriptat = desxifrar.doFinal(missatgeADesencriptar);\n            } catch (Exception e) {\n                System.err.println(\"Error al desencriptar missatge: \" + e.toString());\n            }\n\n            System.out.println(\"Miisatge desencriptat: \" + new String(missatgeDesencriptat));\n            break;\n        case 0:\n            System.out.println(\"deu!\");\n            break;\n    }\n\n    teclat.close();\n}\n", "idx": 2100}
{"project": "cipher", "commit_id": "Snippet12989107_36617.java", "target": 0, "func": "public class PasswordCrypter {\n    Cipher ecipher;\n    Cipher dcipher;\n    SecretKey key;\n    DESKeySpec dks;\n    SecretKeyFactory skf;\n    byte[] psword;\n\n    public PasswordCrypter(String password) {\n\n        try {\n            psword = password.getBytes(\"UTF-16\");\n            dks = new DESKeySpec(psword);\n            skf = SecretKeyFactory.getInstance(\"DES\");\n            key = skf.generateSecret(dks);\n            ecipher = Cipher.getInstance(\"DES\");\n            ecipher.init(Cipher.ENCRYPT_MODE, key);\n            dcipher = Cipher.getInstance(\"DES\");\n            dcipher.init(Cipher.DECRYPT_MODE, key);\n        } catch (NoSuchAlgorithmException e) {\n            throw new CrypterException(e);\n        } catch (NoSuchPaddingException e) {\n            throw new CrypterException(e);\n        } catch (InvalidKeyException e) {\n            throw new CrypterException(e);\n        } catch (InvalidKeySpecException e) {\n            throw new CrypterException(e);\n        } catch (UnsupportedEncodingException e) {\n            throw new CrypterException(e);\n        }\n\n    }\n\n    public byte[] encrypt(byte[] array) {\n\n        try {\n            return ecipher.doFinal(array);\n        } catch (IllegalBlockSizeException e) {\n            throw new CrypterException(e);\n        } catch (BadPaddingException e) {\n            throw new CrypterException(e);\n        }\n    }\n\n    public byte[] decrypt(byte[] array) {\n\n        try {\n            return dcipher.doFinal(array);\n        } catch (IllegalBlockSizeException e) {\n            throw new CrypterException(e);\n        } catch (BadPaddingException e) {\n            throw new CrypterException(e);\n        }\n    }\n}\n", "idx": 1696}
{"project": "cipher", "commit_id": "Snippet36998066_18950.java", "target": 0, "func": "SecretKeySpec secretkeyspec = new SecretKeySpec(\"password\".getBytes(), \"AES\");\nCipher cipher = Cipher.getInstance(\"AES\");\ncipher.init(Cipher.ENCRYPT_MODE, secretkeyspec);\nbyte[] encoded = cipher.doFinal(s.getBytes());\nSystem.out.println(Arrays.toString(encoded));", "idx": 1667}
{"project": "cipher", "commit_id": "Snippet47576722_29592.java", "target": 1, "func": "String path = \"/path/to/secret/saved/in/text\";\nString payload = \"...ENCRYPTED DATA...\";\nStringBuilder output = new StringBuilder();\n\nString iv = payload.substring(0, 16);\nbyte[] secret = Base64.getDecoder().decode(Files.readAllBytes(Paths.get(path)));\nString data = payload.substring(16);\n\nCipher cipher = Cipher.getInstance(\"AES/CBC/PKCS5Padding\");\nSecretKeySpec secretKeySpec = new SecretKeySpec(secret, \"AES\");\nIvParameterSpec ivParameterSpec = new IvParameterSpec(iv.getBytes(), 0, cipher.getBlockSize());\ncipher.init(Cipher.DECRYPT_MODE, secretKeySpec, ivParameterSpec); // This line throws exception : \n\ncipher.doFinal(data.getBytes(StandardCharsets.UTF_8));\n", "idx": 1950}
{"project": "cipher", "commit_id": "Snippet47484654_29472.java", "target": 1, "func": "{\n        byte[] data = Base64.decode(s1.getBytes(),Base64.DEFAULT);\n\n        Log.e(TAG, \"RSADecrypt1: byte \"+encryptedByte );\n        cipher1 = Cipher.getInstance(\"RSA\");\n        cipher1.init(Cipher.DECRYPT_MODE, privateKey);\n        decryptedBytes = cipher1.doFinal(data);\n\n        decrypted = new String(decryptedBytes);\n        System.out.println(\"DDecrypted?????\" + decrypted);\n//        String encodedString = Base64.decode(decryptedBytes, Base64.NO_WRAP);\n//        Log.e(TAG, \"RSADecrypt1: encodedString  \"+encodedString );\n\n        System.out.println(\"DDecrypted????? dejdejednjdnn   \" + Base64.encodeToString(decryptedBytes,0,decryptedBytes.length,Base64.DEFAULT));\n\n        Log.e(TAG, \"RSADecrypt1: woww \"+Base64.encodeToString(decryptedBytes, Base64.DEFAULT) );\n        return decrypted;\n    }\n", "idx": 2098}
{"project": "cipher", "commit_id": "Snippet26831860_8989.java", "target": 0, "func": "import java.security.KeyPair;\nimport java.security.KeyPairGenerator;\nimport java.security.MessageDigest;\nimport java.security.NoSuchAlgorithmException;\nimport java.security.PrivateKey;\nimport java.security.PublicKey;\nimport java.util.Arrays;\n\nimport javax.crypto.Cipher;\nimport javax.crypto.KeyAgreement;\nimport javax.crypto.SecretKey;\nimport javax.crypto.spec.SecretKeySpec;\n\n/**\n * Diffie-Hellman module for demonstrating KeyAgreement Algorithm\n */\npublic class DiffieHellmanModule {\n\n    private static final int AES_KEY_SIZE = 128;\n\n    public static void main(String[] args) {\n        // Generates keyPairs for Alice and Bob\n        KeyPair kp1 = DiffieHellmanModule.genDHKeyPair();\n        KeyPair kp2 = DiffieHellmanModule.genDHKeyPair();\n        // Gets the public key of Alice(g^X mod p) and Bob (g^Y mod p)\n        PublicKey pbk1 = kp1.getPublic();\n        PublicKey pbk2 = kp2.getPublic();\n        // Gets the private key of Alice X and Bob Y\n        PrivateKey prk1 = kp1.getPrivate();\n        PrivateKey prk2 = kp2.getPrivate();\n        try {\n            // Computes secret keys for Alice (g^Y mod p)^X mod p == Bob (g^X\n            // mod p)^Y mod p\n            SecretKey key1 = DiffieHellmanModule.agreeSecretKey(prk1, pbk2,\n                    true);\n            SecretKey key2 = DiffieHellmanModule.agreeSecretKey(prk2, pbk1,\n                    true);\n            // Instantiate the Cipher of algorithm \"DES\"\n            Cipher c = Cipher.getInstance(\"AES/ECB/PKCS5Padding\");\n            // Init the cipher with Alice's key1\n            c.init(Cipher.ENCRYPT_MODE, key1);\n            // Compute the cipher text = E(key,plainText)\n            byte[] ciphertext = c.doFinal(\"Stand and unfold yourself\"\n                    .getBytes());\n            // prints ciphertext\n            System.out.println(\"Encrypted: \" + new String(ciphertext, \"utf-8\"));\n            // inits the encryptionMode\n            c.init(Cipher.DECRYPT_MODE, key2);\n            // Decrypts and print\n            System.out.println(\"Decrypted: \"\n                    + new String(c.doFinal(ciphertext), \"utf-8\"));\n            System.out.println(\"Done\");\n        } catch (Exception e) {\n            e.printStackTrace();\n        }\n    }\n\n    private static KeyPairGenerator kpg;\n\n    static {\n        try {\n            // === Generates and inits a KeyPairGenerator ===\n\n            // changed this to use default parameters, generating your\n            // own takes a lot of time and should be avoided\n            // use ECDH or a newer Java (8) to support key generation with\n            // higher strength\n            kpg = KeyPairGenerator.getInstance(\"DH\");\n            kpg.initialize(1024);\n        } catch (NoSuchAlgorithmException e) {\n            e.printStackTrace();\n        }\n    }\n\n    public static SecretKey agreeSecretKey(PrivateKey prk_self,\n            PublicKey pbk_peer, boolean lastPhase) throws Exception {\n        // instantiates and inits a KeyAgreement\n        KeyAgreement ka = KeyAgreement.getInstance(\"DH\");\n        ka.init(prk_self);\n        // Computes the KeyAgreement\n        ka.doPhase(pbk_peer, lastPhase);\n        // Generates the shared secret\n        byte[] secret = ka.generateSecret();\n\n        // === Generates an AES key ===\n\n        // you should really use a Key Derivation Function instead, but this is\n        // rather safe\n\n        MessageDigest sha256 = MessageDigest.getInstance(\"SHA-256\"); \n        byte[] bkey = Arrays.copyOf(\n                sha256.digest(secret), AES_KEY_SIZE / Byte.SIZE);\n\n        SecretKey desSpec = new SecretKeySpec(bkey, \"AES\");\n        return desSpec;\n    }\n\n    public static KeyPair genDHKeyPair() {\n        return kpg.genKeyPair();\n    }\n}\n", "idx": 1834}
{"project": "cipher", "commit_id": "Snippet39974172_21885.java", "target": 1, "func": "package Streams;\nimport java.io.FileOutputStream;\nimport java.io.FileInputStream;\nimport java.math.BigInteger;\nimport java.security.InvalidAlgorithmParameterException;\nimport java.security.InvalidKeyException;\nimport java.security.SecureRandom;\nimport java.util.Arrays;\n\nimport javax.crypto.Cipher;\nimport javax.crypto.CipherInputStream;\nimport javax.crypto.CipherOutputStream;\nimport javax.crypto.ShortBufferException;\nimport javax.crypto.spec.IvParameterSpec;\nimport javax.crypto.spec.SecretKeySpec;\n\npublic class FileReadWrite {\n    private static final int AES_BLOCK_SIZE = 16;\n\n    public static final void jumpToOffset(final Cipher c, final SecretKeySpec aesKey, final IvParameterSpec iv, final long offset) {\n        if (!c.getAlgorithm().toUpperCase().startsWith(\"AES/CTR\")) {\n            throw new IllegalArgumentException(\"Invalid algorithm, only AES/CTR mode supported\");\n        }\n        if (offset < 0) {\n            throw new IllegalArgumentException(\"Invalid offset\");\n        }\n        final int skip = (int) (offset % AES_BLOCK_SIZE);\n        final IvParameterSpec calculatedIVForOffset = calculateIVForOffset(iv, offset - skip);\n        try {\n            c.init(Cipher.ENCRYPT_MODE, aesKey, calculatedIVForOffset);\n            final byte[] skipBuffer = new byte[skip];\n            c.update(skipBuffer, 0, skip, skipBuffer);\n            Arrays.fill(skipBuffer, (byte) 0);\n        } catch (ShortBufferException | InvalidKeyException | InvalidAlgorithmParameterException e) {\n            throw new IllegalStateException(e);\n        }\n    }\n\n    private static IvParameterSpec calculateIVForOffset(final IvParameterSpec iv, final long blockOffset) {\n\n        final BigInteger ivBI = new BigInteger(1, iv.getIV());\n        final BigInteger ivForOffsetBI = ivBI.add(BigInteger.valueOf(blockOffset / AES_BLOCK_SIZE));\n        final byte[] ivForOffsetBA = ivForOffsetBI.toByteArray();\n        final IvParameterSpec ivForOffset;\n        if (ivForOffsetBA.length >= AES_BLOCK_SIZE) {\n            ivForOffset = new IvParameterSpec(ivForOffsetBA, ivForOffsetBA.length - AES_BLOCK_SIZE, AES_BLOCK_SIZE);\n        } else {\n            final byte[] ivForOffsetBASized = new byte[AES_BLOCK_SIZE];\n            System.arraycopy(ivForOffsetBA, 0, ivForOffsetBASized, AES_BLOCK_SIZE - ivForOffsetBA.length, ivForOffsetBA.length);\n            ivForOffset = new IvParameterSpec(ivForOffsetBASized);\n        }\n        return ivForOffset;\n    }\n\n    public static byte[] getAESKey() {\n        SecureRandom secureRandom = new SecureRandom();\n        byte[] bytes = new byte[32];\n        secureRandom.nextBytes(bytes);\n        return bytes;\n    }\n    /**\n     * Method used to generate a random new iv\n     * \n     * @return Randomly generated iv\n     */\n    public static byte[] getAESIV() {\n        SecureRandom secureRandom = new SecureRandom();\n        byte[] bytes = new byte[16];\n        secureRandom.nextBytes(bytes);\n        return bytes;\n    }\n    public static void main(String[] args) throws Exception {\n        // TODO Auto-generated method stub\n        FileInputStream fin = new FileInputStream(\"/Users/emp/Research/Streams/input_file.txt\");\n        FileOutputStream fout = new FileOutputStream(\"/Users/emp/Research/Streams/output_file.txt\");\n\n        SecretKeySpec keySpec = null;\n        IvParameterSpec ivSpec = null;\n        Cipher ecipher = null;\n        Cipher dcipher = null;\n        byte[] keyBytes = getAESKey();\n        byte[] ivBytes = getAESIV();\n        // Creating keyspec and ivspec for generating cipher\n        keySpec = new SecretKeySpec(keyBytes,\"AES\");\n        ivSpec = new IvParameterSpec(ivBytes);\n        try {\n            ecipher = Cipher.getInstance(\"AES/CTR/NoPadding\");\n            ecipher.init(Cipher.ENCRYPT_MODE, keySpec, ivSpec);\n        } catch (Exception e) {\n            System.out.println(\"Thus the exception occured during cipher generation is ::: \"+e);\n        }\n\n        CipherOutputStream cout = new CipherOutputStream(fout, ecipher);\n        try {\n            int count = 0;\n            int BUFFER_SIZE = 1024;\n            byte[] bytearray = new byte[BUFFER_SIZE];\n            while((count = fin.read(bytearray, 0, BUFFER_SIZE)) != -1) {\n                //fout.write(bytearray, 0, count);\n                cout.write(bytearray, 0, count);\n            }\n        } catch(Exception ex) {\n            System.out.println(\"Thus the exception occured is ::: \"+ex);\n        } finally {\n            fin.close();\n            fout.close();\n            cout.close();\n        }\n\n        fin = new FileInputStream(\"/Users/emp/Research/Streams/output_file.txt\");\n        fout = new FileOutputStream(\"/Users/emp/Research/Streams/decrypted_file.txt\");\n\n        try {\n            dcipher = Cipher.getInstance(\"AES/CTR/NoPadding\");\n            dcipher.init(Cipher.DECRYPT_MODE, keySpec, ivSpec);\n        } catch (Exception e) {\n            System.out.println(\"Thus the exception occured during cipher generation is ::: \"+e);\n        }\n\n        fin.skip(1024);\n        jumpToOffset(dcipher, keySpec, ivSpec, 1024);\n        CipherInputStream cin = new CipherInputStream(fin, dcipher);\n        //cin.skip(1024);\n        try {\n            int count = 0;\n            int BUFFER_SIZE = 1024;\n            byte[] bytearray = new byte[BUFFER_SIZE];\n            //cin.read(bytearray, 0, 30);\n            while((count = cin.read(bytearray, 0, BUFFER_SIZE)) != -1) {\n                //fout.write(bytearray, 0, count);\n                fout.write(bytearray, 0, count);\n            }\n        } catch(Exception ex) {\n            System.out.println(\"Thus the exception occured is ::: \"+ex);\n        } finally {\n            fin.close();\n            cin.close();\n            fout.close();\n        }\n\n        System.out.println(\"File read write completed successfully !!! \");\n    }\n}\n", "idx": 2249}
{"project": "cipher", "commit_id": "Snippet3032832_30585.java", "target": 1, "func": "private static final String ALGORITHM = \"AES\";\nprivate static final byte[] keyValue = getKeyBytes(\"12345678901234567890123456789012\");\n\nprivate static final byte[] INIT_VECTOR = new byte[16];\nprivate static IvParameterSpec ivSpec = new IvParameterSpec(INIT_VECTOR);\n\npublic static void main(String[] args) throws Exception {\n    String encoded = encrypt(\"watson?\");\n    System.out.println(encoded);\n}\n\nprivate static Key generateKey() throws Exception {\n    Key key = new SecretKeySpec(keyValue, ALGORITHM);\n    // SecretKeyFactory keyFactory = SecretKeyFactory.getInstance(ALGORITHM);\n    // key = keyFactory.generateSecret(new DESKeySpec(keyValue));\n    return key;\n}\n\nprivate static byte[] getKeyBytes(String key) {\n    byte[] hash = DigestUtils.sha(key); // key.getBytes()\n    byte[] saltedHash = new byte[16];\n    System.arraycopy(hash, 0, saltedHash, 0, 16);\n    return saltedHash;\n}\n\npublic static String encrypt(String valueToEnc) throws Exception {\n    Key key = generateKey();\n    Cipher c = Cipher.getInstance(\"AES/CBC/PKCS5Padding\");\n    c.init(Cipher.ENCRYPT_MODE, key,ivSpec);\n    byte[] encValue = c.doFinal(valueToEnc.getBytes());\n    String encryptedValue = new BASE64Encoder().encode(encValue);\n    return encryptedValue;\n}\n\npublic static String decrypt(String encryptedValue) throws Exception {\n    Key key = generateKey();\n    Cipher c = Cipher.getInstance(ALGORITHM);\n    c.init(Cipher.DECRYPT_MODE, key);\n    byte[] decordedValue = new BASE64Decoder().decodeBuffer(encryptedValue);\n    byte[] decValue = c.doFinal(decordedValue);\n    String decryptedValue = new String(decValue);\n    return decryptedValue;\n}\n", "idx": 1940}
{"project": "cipher", "commit_id": "Snippet12591391_36361.java", "target": 0, "func": "     import java.io.*;\n     import java.util.*;\n     import javax.crypto.*;\n     import javax.crypto.spec.*;\n\n     import java.security.Provider;\n     import java.security.Security;\n     public class Test\n     {\n       public static byte[] raw =null;\n       public static SecretKeySpec skeySpec;\n       public static Cipher cipher;\n       public static void main(String ags[]) throws Exception\n       {\n           byte[] key={1,2,3,4,5,6,7};\n           skeySpec = new SecretKeySpec(key, \"Blowfish\");\n           System.out.println(\"KEY : \"+bytesToString(skeySpec.getEncoded()));\n                   String cipherInstName = \"Blowfish/ECB/PKCS5Padding\";\n           cipher = Cipher.getInstance(cipherInstName);\n           cipher.init(Cipher.ENCRYPT_MODE,skeySpec);\n           byte[] encrypted = cipher.doFinal((\"asdfgh\").getBytes());        \n           System.out.println(\"PLAIN TEXT : \"+(\"asdfgh\").getBytes());\n           System.out.println(\"ENCRYPTED TEXT : \"+bytesToString(encrypted));             \n       }\n\n           private static String bytesToString(byte [] value)\n           {\n                   StringBuffer retVal = new StringBuffer();\n                   for(int i=0; i<value.length; i++)\n                   {\n                       retVal.append(value[i]+\":\");\n                   }\n                   int inx = retVal.toString().lastIndexOf(\":\");\n                   retVal= new StringBuffer(retVal.toString().substring(0,inx));\n                   return retVal.toString();\n           }\n     }\n", "idx": 1818}
{"project": "cipher", "commit_id": "Snippet24314873_6588.java", "target": 1, "func": "   Cipher cipher = Cipher.getInstance(\"RSA\");\n", "idx": 2261}
{"project": "cipher", "commit_id": "Snippet41202338_23169.java", "target": 1, "func": "char[] password = passwordString.toCharArray();\n\n    SecureRandom random = new SecureRandom();\n    byte salt[] = new byte[SALT_BYTES]; \n    random.nextBytes(salt);\n\n    SecretKeyFactory factory = SecretKeyFactory.getInstance(\"PBKDF2WithHmacSHA256\");\n\n    KeySpec keySpec = new PBEKeySpec(password, salt, ITERATION, AES_KEY_BITS);\n\n    SecretKey tmp = factory.generateSecret(keySpec);\n\n    SecretKey secretKey = new SecretKeySpec(tmp.getEncoded(), \"AES\");\n\n    Cipher cipher = Cipher.getInstance(\"AES/CFB/PKCS5Padding\");\n\n    cipher.init(Cipher.ENCRYPT_MODE, secretKey);\n\n    FileOutputStream fout = null;\n    ObjectOutputStream objOut = null;\n\n\n        fout = new FileOutputStream(PRIVATE_RING_FILENAME);\n\n        fout.write(salt);\n\n        byte[] ivN = cipher.getIV();\n        fout.write(ivN);\n\n        CipherOutputStream cos = new CipherOutputStream(fout, cipher);\n        objOut = new ObjectOutputStream(cos);\n\n        PrivateKeyRing prvKeyRing = new PrivateKeyRing();\n        SealedObject sealedObject = new SealedObject(prvKeyRing, cipher);\n        objOut.writeObject(sealedObject);\n\n        fout.close();\n        objOut.close();\n        cos.close();\n", "idx": 2004}
{"project": "cipher", "commit_id": "Snippet41461525_23415.java", "target": 1, "func": "IvParameterSpec ivParameterSpec = new IvParameterSpec(\"randombigrandom\".getBytes(\"UTF-8\"));\n        bytes = key.getBytes(\"UTF-8\");\n        keySpec = new SecretKeySpec(bytes, \"AES\");\n        cipher = Cipher.getInstance(\"AES/CCM/NOPADDING\", new BouncyCastleProvider());\n        cipher.init(Cipher.DECRYPT_MODE, keySpec, ivParameterSpec);\n        ret = ByteBuffer.wrap(cipher.doFinal(Base64Utils.decode(requestBody.getEncryptedData().getBytes())));\n", "idx": 2029}
{"project": "cipher", "commit_id": "Snippet46835158_28877.java", "target": 1, "func": "import javax.crypto.Cipher;\nimport javax.crypto.spec.IvParameterSpec;\nimport javax.crypto.spec.SecretKeySpec;\n\npublic class AesCBC {\n    private byte[] key;\n    private byte[] iv;\n\n    private static final String ALGORITHM=\"AES\";\n\n    public AesCBC(byte[] key, byte[] iv) {\n        this.key = key;\n        this.iv = iv;\n    }\n\n    public byte[] encrypt(byte[] plainText) throws Exception{\n        SecretKeySpec secretKey=new SecretKeySpec(key,ALGORITHM);\n        IvParameterSpec ivParameterSpec=new IvParameterSpec(iv);\n        Cipher cipher=Cipher.getInstance(\"AES/CBC/PKCS5Padding\");\n        cipher.init(Cipher.ENCRYPT_MODE,secretKey,ivParameterSpec);\n        return cipher.doFinal(plainText);\n    }\n\n    public byte[] getKey() {\n        return key;\n    }\n\n    public void setKey(byte[] key) {\n        this.key = key;\n    }\n\n    public byte[] getIv() {\n        return iv;\n    }\n\n    public void setIv(byte[] iv) {\n        this.iv = iv;\n    }\n}\n", "idx": 2279}
{"project": "cipher", "commit_id": "Snippet19640735_2369.java", "target": 1, "func": "DataInputStream in=new DataInputStream(ctx.openFileInput(PRIVKEY_FILE));\nbyte[] data=new byte[in.available()];\nin.readFully(data);\n\nPKCS8EncodedKeySpec keySpec = new PKCS8EncodedKeySpec(data);\nKeyFactory kf = KeyFactory.getInstance(\"RSA\");\nprivKey = kf.generatePrivate(keySpec);\n\ndecryptCipher = Cipher.getInstance(\"RSA/ECB/PKCS1Padding\");\ndecryptCipher.init(Cipher.DECRYPT_MODE, privKey);\n", "idx": 2164}
{"project": "cipher", "commit_id": "Snippet26160561_8368.java", "target": 0, "func": "// salt\njava.security.SecureRandom rgen = new SecureRandom();\nbyte[] salt = rgen.generateSeed(20);\n// add Bouncy Castle\njava.security.Security.addProvider(new org.bouncycastle.jce.provider.BouncyCastleProvider());\n// aes secret key\njavax.crypto.KeyGenerator kgen = KeyGenerator.getInstance(\"AES\", \"BC\");\nKey cleSecrete = kgen.generateKey();\n// aes\njavax.crypto.Cipher cipher = Cipher.getInstance(\"AES\", \"BC\");\n// sha-256\njava.security.MessageDigest sha256 = MessageDigest.getInstance(\"SHA-256\",\"BC\");\n\n// hash the clear password with the salt to avoid collisions\nbyte[] motDePasseHash = hasherSaler(motDePasseClair.getBytes(\"UTF-8\"),salt);\n// Encrypt the hash with the salt to get the salt back\nbyte[] chiffreBDD = chiffrerSalerHash(salt,motDePasseHash,cleSecrete );\n// Store the cipher in DB\n...\n\n// Get back the hash and the salt from DB\nbyte[] deChiffreBDD = deChiffrer(chiffreBDD,cleSecrete );\nbyte[] saltBDD = extraireOctets(deChiffreBDD,0,19);\nbyte[] hashBDD = extraireOctets(deChiffreBDD,20,deChiffreBDD.length-1);\n// hash the user intput\nbyte[] motDePasseHashCandidat = hasherSaler(motDePasseClairCandidat.getBytes(\"UTF-8\"),saltBDD);\n// Compare hased user input with DB hash \nboolean isMotDePasseOK = Arrays.equals(hashBDD,motDePasseHashCandidat);\n\nprivate final byte[] hasherSaler(byte[] clair,byte[] salt) {\n    byte[] concat = concatenerOctets(clair,salt);\n    return sha256.digest(concat);\n}\nprivate final byte[] chiffrerSalerHash(byte[] salt,byte[] hash, Key cle) {\n    cipher.init(true,cle);\n    return cipher.doFinal(concatenerOctets(salt,hash));\n}\nprivate final byte[] deChiffrer(byte[] chiffre, Key cle) {\n    cipher.init(false,cle);\n    return cipher.doFinal(chiffre);\n}\n", "idx": 1683}
{"project": "cipher", "commit_id": "Snippet908672_29801.java", "target": 1, "func": "import java.awt.*;\n\nimport javax.swing.*;\nimport java.awt.event.*;\nimport javax.crypto.*;\nimport javax.crypto.spec.*;\nimport java.security.*;\nimport java.io.*;\n\n\npublic class EncryptURL extends JApplet implements ActionListener {\n  Container content;\n  JTextField userName = new JTextField();\n     JTextField firstName = new JTextField();\n      JTextField lastName = new JTextField();\n      JTextField email = new JTextField();\n      JTextField phone = new JTextField();\n      JTextField heartbeatID = new JTextField();\n      JTextField regionCode = new JTextField();\n      JTextField retRegionCode = new JTextField();\n      JTextField encryptedTextField = new JTextField();\n\n    JPanel finishPanel = new JPanel();\n\n\n  public void init() {\n    //setTitle(\"Book - E Project\");\n    setSize(800,600);\n    content = getContentPane();\n    content.setBackground(Color.yellow);\n    content.setLayout(new BoxLayout(content, BoxLayout.Y_AXIS));\n\n\n    JButton submit = new JButton(\"Submit\");\n\n    content.add(new JLabel(\"User Name\"));\n    content.add(userName);\n\n    content.add(new JLabel(\"First Name\"));\n    content.add(firstName);\n\n    content.add(new JLabel(\"Last Name\"));\n    content.add(lastName);\n\n    content.add(new JLabel(\"Email\"));\n    content.add(email);\n\n    content.add(new JLabel(\"Phone\"));\n    content.add(phone);\n\n    content.add(new JLabel(\"HeartBeatID\"));\n    content.add(heartbeatID);\n\n    content.add(new JLabel(\"Region Code\"));\n    content.add(regionCode);\n\n    content.add(new JLabel(\"RetRegionCode\"));\n    content.add(retRegionCode);\n\n    content.add(submit);\n\n    submit.addActionListener(this);\n\n\n  }\n\n  public void actionPerformed(ActionEvent e) {\n    if(e.getActionCommand() == \"Submit\"){\n\n        String subUserName = userName.getText();\n        String subFName = firstName.getText();\n        String subLName = lastName.getText();\n        String subEmail = email.getText();\n        String subPhone = phone.getText();\n        String subHeartbeatID = heartbeatID.getText();\n        String subRegionCode = regionCode.getText();\n        String subRetRegionCode = retRegionCode.getText();\n\n        String concatURL = \"user=\"+ subUserName + \"&f=\"+ subFName + \"&l=\" +subLName+ \"&em=\" + subEmail + \"&p=\"+subPhone+\"&h=\"+subHeartbeatID+\"&re=\"+subRegionCode+ \"&ret=\" + subRetRegionCode;\n        concatURL = padString(concatURL, ' ', 16);\n        byte[] encrypted = encrypt(concatURL);\n        String encryptedString = bytesToHex(encrypted);\n        content.removeAll();\n        content.add(new JLabel(\"Concatenated User Input -->\" + concatURL));\n\n        content.add(encryptedTextField);\n        setContentPane(content);\n    }\n  }\n\n  public static byte[] encrypt(String toEncrypt) throws Exception{\n    try{\n      String plaintext = toEncrypt;\n      String key = \"01234567890abcde\";\n      String iv = \"fedcba9876543210\";\n\n      SecretKeySpec keyspec = new SecretKeySpec(key.getBytes(), \"AES\");\n      IvParameterSpec ivspec = new IvParameterSpec(iv.getBytes());\n\n      Cipher cipher = Cipher.getInstance(\"AES/CBC/NoPadding\");\n      cipher.init(Cipher.ENCRYPT_MODE,keyspec,ivspec);\n      byte[] encrypted = cipher.doFinal(toEncrypt.getBytes());\n\n      return encrypted;\n    }\n    catch(Exception e){\n\n    }\n\n  }\n\n  public static byte[] decrypt(byte[] toDecrypt) throws Exception{\n      String key = \"01234567890abcde\";\n      String iv = \"fedcba9876543210\";\n\n      SecretKeySpec keyspec = new SecretKeySpec(key.getBytes(), \"AES\");\n      IvParameterSpec ivspec = new IvParameterSpec(iv.getBytes());\n\n      Cipher cipher = Cipher.getInstance(\"AES/CBC/NoPadding\");\n      cipher.init(Cipher.DECRYPT_MODE,keyspec,ivspec);\n      byte[] decrypted = cipher.doFinal(toDecrypt);\n\n      return decrypted;\n  }\n  public static String bytesToHex(byte[] data) {\n    if (data==null)\n    {\n      return null;\n    }\n    else\n    {\n      int len = data.length;\n      String str = \"\";\n      for (int i=0; i<len; i++)\n      {\n        if ((data[i]&0xFF)<16)\n          str = str + \"0\" + java.lang.Integer.toHexString(data[i]&0xFF);\n        else\n          str = str + java.lang.Integer.toHexString(data[i]&0xFF);\n      }\n      return str;\n    }\n  }\n  public static String padString(String source, char paddingChar, int size)\n  {\n    int padLength = size-source.length()%size;\n    for (int i = 0; i < padLength; i++) {\n      source += paddingChar;\n    }\n    return source;\n  }\n}\n", "idx": 2141}
{"project": "cipher", "commit_id": "Snippet35572903_17470.java", "target": 1, "func": "import java.security.SecureRandom;\nimport java.security.Security;\nimport javax.crypto.Cipher;\nimport javax.crypto.SecretKey;\nimport javax.crypto.SecretKeyFactory;\nimport javax.crypto.spec.IvParameterSpec;\nimport javax.crypto.spec.PBEKeySpec;\nimport org.bouncycastle.jce.provider.BouncyCastleProvider;\nimport org.bouncycastle.util.Arrays;\nimport com.sun.org.apache.xml.internal.security.utils.Base64;\n\npublic class BouncyCastleEX {\n\nprivate static final int iterations = 2000;\nprivate static final int keyLength = 256;\nprivate static final SecureRandom random = new SecureRandom();\nprivate static BouncyCastleEX instance = null;\n\npublic String encryptString(String plaintext, String passphrase, String salt)\n        throws Exception {\n    return Base64.encode(encrypt(plaintext, passphrase, salt));\n}\n\npublic String decryptString(String encrypted, String passphrase, String salt)\n        throws Exception {\n    return decrypt(Base64.decode(encrypted), passphrase, salt);\n}\n\nprivate BouncyCastleEX() {\n    Security.addProvider(new BouncyCastleProvider());\n}\n\npublic static BouncyCastleEX getInstance() {\n    if (instance == null) {\n        instance = new BouncyCastleEX();\n    }\n    return instance;\n}\n\nprivate byte[] encrypt(String plaintext, String passphrase, String salt)\n        throws Exception {\n    SecretKey key = generateKey(passphrase, salt);\n    Cipher cipher = Cipher.getInstance(\"AES/GCM/NoPadding\", \"BC\");\n    byte[] ivBytes = generateIVBytes(cipher);\n    cipher.init(Cipher.ENCRYPT_MODE, key, new IvParameterSpec(ivBytes),\n            random);\n    return Arrays\n            .concatenate(ivBytes, cipher.doFinal(plaintext.getBytes()));\n}\n\nprivate String decrypt(byte[] encrypted, String passphrase, String salt)\n        throws Exception {\n    SecretKey key = generateKey(passphrase, salt);\n    Cipher cipher = Cipher.getInstance(\"AES/GCM/NoPadding\", \"BC\");\n    cipher.init(Cipher.DECRYPT_MODE, key,\n            new IvParameterSpec(Arrays.copyOfRange(encrypted, 0, 12)),\n            random);\n    return new String(cipher.doFinal(Arrays.copyOfRange(encrypted, 12,\n            encrypted.length)));\n}\n\nprivate SecretKey generateKey(String passphrase, String salt)\n        throws Exception {\n    PBEKeySpec keySpec = new PBEKeySpec(passphrase.toCharArray(),\n            salt.getBytes(), iterations, keyLength);\n    SecretKeyFactory keyFactory = SecretKeyFactory\n            .getInstance(\"PBEWITHSHA256AND256BITAES-CBC-BC\");\n    return keyFactory.generateSecret(keySpec);\n}\n\nprivate byte[] generateIVBytes(Cipher cipher) throws Exception {\n    byte[] ivBytes = new byte[12];\n    random.nextBytes(ivBytes);\n\n    return ivBytes;\n}\n\n}\n", "idx": 2039}
{"project": "cipher", "commit_id": "Snippet26078764_8304.java", "target": 0, "func": "protected String encrypt( String value ) {\n\n    try {\n        final byte[] bytes = value!=null ? value.getBytes(UTF8) : new byte[0];\n        SecretKeyFactory keyFactory = SecretKeyFactory.getInstance(\"PBEWithMD5AndDES\");\n        SecretKey key = keyFactory.generateSecret(new PBEKeySpec(SEKRIT));\n        Cipher pbeCipher = Cipher.getInstance(\"PBEWithMD5AndDES\");\n        pbeCipher.init(Cipher.ENCRYPT_MODE, key, new PBEParameterSpec(Settings.Secure.getString(context.getContentResolver(),Settings.System.ANDROID_ID).getBytes(UTF8), 20));\n        return new String(Base64.encode(pbeCipher.doFinal(bytes), Base64.NO_WRAP),UTF8);\n\n    } catch( Exception e ) {\n        throw new RuntimeException(e);\n    }\n\n}\n\nprotected String decrypt(String value){\n    try {\n        final byte[] bytes = value!=null ? Base64.decode(value,Base64.DEFAULT) : new byte[0];\n        SecretKeyFactory keyFactory = SecretKeyFactory.getInstance(\"PBEWithMD5AndDES\");\n        SecretKey key = keyFactory.generateSecret(new PBEKeySpec(SEKRIT));\n        Cipher pbeCipher = Cipher.getInstance(\"PBEWithMD5AndDES\");\n        pbeCipher.init(Cipher.DECRYPT_MODE, key, new PBEParameterSpec(Settings.Secure.getString(context.getContentResolver(),Settings.System.ANDROID_ID).getBytes(UTF8), 20));\n        return new String(pbeCipher.doFinal(bytes),UTF8);\n\n    } catch( Exception e) {\n        throw new RuntimeException(e);\n    }\n}\n", "idx": 1691}
{"project": "cipher", "commit_id": "Snippet30742378_12933.java", "target": 1, "func": " Cipher cipher = Cipher.getInstance(\"RSA/ECB/PKCS1Padding\");\n", "idx": 2120}
{"project": "cipher", "commit_id": "Snippet33214730_15276.java", "target": 1, "func": "    public static String encrypt(String text) throws UnsupportedEncodingException {\n        byte iv[] = new byte[16];\n        byte[] encrypted = null;\n        BASE64Encoder enc = new BASE64Encoder();\n        try {            \n            SecureRandom random = new SecureRandom();\n            random.nextBytes(iv);\n            IvParameterSpec ivspec = new IvParameterSpec(iv);\n            Cipher cipher = Cipher.getInstance(\"AES/CBC/PKCS5Padding\");\n            cipher.init(Cipher.ENCRYPT_MODE, getKeySpec(), ivspec);\n            encrypted = cipher.doFinal(text.getBytes());\n        } catch (Exception ex) {\n            ex.printStackTrace();\n        }\n        return URLEncoder.encode(enc.encode(iv)+enc.encode(encrypted), \"UTF-8\");\n    }\n\n    public static String decrypt(String text) {\n        byte iv[] = new byte[16];\n        String decrypted  = \"\";\n        byte[] splitText = null;\n        byte[] textToDecrypt = null;\n        BASE64Decoder dec = new BASE64Decoder();\n        try { \n            text = URLDecoder.decode(text, \"UTF-8\");\n            text = text.replaceAll(\" \", \"+\");\n            splitText = dec.decodeBuffer(text);\n            splitText.toString();\n            for(int i=0;i<16;i++){\n                iv[i]=splitText[i];\n            }\n            textToDecrypt = new byte[splitText.length - 16];\n            for(int i=16;i<splitText.length;i++){\n                textToDecrypt[i-16]=splitText[i];\n            }\n            IvParameterSpec ivspec = new IvParameterSpec(iv);\n            Cipher cipher = Cipher.getInstance(\"AES/CBC/PKCS5Padding\");\n            cipher.init(Cipher.DECRYPT_MODE, getKeySpec(), ivspec);\n           decrypted = new String(cipher.doFinal(textToDecrypt));\n        } catch (UnsupportedEncodingException ex) {\n            ex.printStackTrace();\n        }catch (Exception e){\n            e.printStackTrace();\n        }\n        return decrypted;\n    }\n\nstatic SecretKeySpec spec = null;\npublic static SecretKeySpec getKeySpec() throws IOException,\n                                            NoSuchAlgorithmException {\n    if (spec == null) {\n        String keyFile = \"aes_key.key\";\n        spec = null;\n        InputStream fis = null;\n        fis = Config.class.getClassLoader().getResourceAsStream(keyFile);\n        byte[] rawkey = new byte[16];\n        fis.read(rawkey);\n        fis.close();\n        spec = new SecretKeySpec(rawkey, \"AES\");\n}\nreturn spec;\n}\n", "idx": 2140}
{"project": "cipher", "commit_id": "Snippet38271609_20213.java", "target": 0, "func": "import java.io.BufferedOutputStream;\nimport java.io.FileOutputStream;\nimport java.io.InputStream;\nimport java.net.InetAddress;\nimport java.net.Socket;\nimport java.security.Key;\n\nimport javax.crypto.Cipher;\nimport javax.crypto.spec.SecretKeySpec;\n\n\npublic class FileTransferClient { \n\n    public static void main(String[] args) throws Exception{\n\n        //Initialize socket\n        Socket socket = new Socket(InetAddress.getByName(\"localhost\"), 5000);\n        byte[] contents = new byte[100000000];\n\n        //Initialize the FileOutputStream to the output file's full path.\n        FileOutputStream fos = new FileOutputStream(\"/home/shanmukhh/Desktop/op.mp4\");\n        BufferedOutputStream bos = new BufferedOutputStream(fos);\n        InputStream is = socket.getInputStream();\n        System.out.println(\"is: \"+is);\n        //No of bytes read in one read() call\n        int bytesRead = 0; \n        String key =\"1234567812345678\";\n        Key secretKey = new SecretKeySpec(key.getBytes(), \"AES\");\n        Cipher cipher = Cipher.getInstance(\"AES\");\n        cipher.init(Cipher.DECRYPT_MODE, secretKey);\n        byte[] outputBytes =null;\n        while((bytesRead=is.read(is.toString().getBytes()))!=-1){\n            outputBytes = cipher.doFinal(is.toString().getBytes());\n            bos.write(outputBytes, 0, bytesRead); \n        }\n\n        bos.flush(); \n        socket.close(); \n\n\n\n        System.out.println(\"File saved successfully!\");\n    }\n    }\n", "idx": 1659}
{"project": "cipher", "commit_id": "Snippet42387514_24402.java", "target": 1, "func": "package com.ust;\n\nimport java.io.UnsupportedEncodingException;\nimport java.security.InvalidAlgorithmParameterException;\nimport java.security.InvalidKeyException;\nimport java.security.MessageDigest;\nimport java.security.NoSuchAlgorithmException;\nimport java.security.spec.InvalidKeySpecException;\nimport java.util.Arrays;\nimport javax.crypto.BadPaddingException;\nimport javax.crypto.Cipher;\nimport javax.crypto.IllegalBlockSizeException;\nimport javax.crypto.NoSuchPaddingException;\nimport javax.crypto.spec.IvParameterSpec;\nimport javax.crypto.spec.SecretKeySpec;\nimport org.apache.commons.codec.binary.Base64;    \nimport org.apache.commons.codec.digest.DigestUtils;\n\npublic class Encryptor {\n    private static final String AES_PASS = \"0ca763dc6b05b5230e44beb6b90e346440204b6d334b09623eafd3fcfbad6a302faca28b0994872e3fd782e7353026684b7ac9385662144e0ed1e2a8e3e14fab79059929681e3794eb97271328ecccda6dbfb3a7991ea1324615cf5908fabdf6\"; // Hashed into an AES key later\n    private SecretKeySpec keyObj;\n    private Cipher cipher;\n    private IvParameterSpec ivObj;\n    final protected static char[] hexArray = \"0123456789ABCDEF\".toCharArray();\n\n\n    public Encryptor() throws NoSuchAlgorithmException, InvalidKeySpecException, NoSuchPaddingException {\n        // A constant IV, since CBC requires an IV but we don't really need one\n\n        String ivValue = new StringBuilder(\"astring\").reverse().toString() + new StringBuilder(\"0ca763dc6b05b5230e44beb6b90e346440204b6d334b09623eafd3fcfbad6a302faca28b0994872e3fd782e7353026684b7ac9385662144e0ed1e2a8e3e14fab\").reverse();\n        System.out.println(\"ivValue => \"+ivValue);\n        try {\n            byte[] ivkey = ivValue.getBytes(\"UTF-8\");\n            MessageDigest shaIv = MessageDigest.getInstance(\"SHA-256\");\n            ivkey = shaIv.digest(ivkey);\n            ivkey = Arrays.copyOf(ivkey, 16);\n            System.out.println(\"IV => \"+bytesToHex(ivkey));\n            this.ivObj = new IvParameterSpec(ivkey);\n        } catch (UnsupportedEncodingException e) {\n            // TODO Auto-generated catch block\n            e.printStackTrace();\n        }\n\n        // Create an SHA-256 256-bit hash of the key\n        byte[] key = AES_PASS.getBytes();\n        MessageDigest sha = MessageDigest.getInstance(\"SHA-256\");\n        key = sha.digest(key);\n        key = Arrays.copyOf(key, 32); // Use only first 256 bit\n        System.out.println(\"SEC KEY => \"+bytesToHex(key));\n        this.keyObj = new SecretKeySpec(key, \"AES\");\n\n        // Create a Cipher by specifying the following parameters\n        //  a. Algorithm name - here it is AES \n        //  b. Mode - here it is CBC mode \n        //  c. Padding - e.g. PKCS7 or PKCS5\n        this.cipher = Cipher.getInstance(\"AES/CBC/PKCS5PADDING\");\n    }\n\n    public String encrypt(String strDataToEncrypt) throws InvalidAlgorithmParameterException, InvalidKeyException, BadPaddingException, IllegalBlockSizeException, NoSuchAlgorithmException, NoSuchPaddingException {\n        String strCipherText = new String();\n\n        this.cipher.init(Cipher.ENCRYPT_MODE, this.keyObj, this.ivObj);\n\n        // Encrypt the Data \n        //  a. Declare / Initialize the Data. Here the data is of type String \n        //  b. Convert the Input Text to Bytes \n        //  c. Encrypt the bytes using doFinal method\n        byte[] byteDataToEncrypt = strDataToEncrypt.getBytes();\n\n        byte[] byteCipherText = this.cipher.doFinal(byteDataToEncrypt);\n\n        // b64 is done differently on Android\n        strCipherText = Base64.encodeBase64String(byteCipherText);\n\n        return strCipherText;\n    }\n\n    public String decrypt(String strCipherText) throws InvalidAlgorithmParameterException, InvalidKeyException, BadPaddingException, IllegalBlockSizeException, NoSuchAlgorithmException, NoSuchPaddingException {\n        String strDecryptedText = new String();\n\n        // Initialize the Cipher for Encryption\n        this.cipher.init(Cipher.DECRYPT_MODE, this.keyObj, this.ivObj);\n\n        // Decode the Base64 text\n        byte[] cipherBytes = Base64.decodeBase64(strCipherText);\n\n        // Decrypt the Data\n        //  a. Initialize a new instance of Cipher for Decryption (normally don't reuse the same object)\n        //     Be sure to obtain the same IV bytes for CBC mode.\n        //  b. Decrypt the cipher bytes using doFinal method\n        byte[] byteDecryptedText = this.cipher.doFinal(cipherBytes);\n        strDecryptedText = new String(byteDecryptedText);\n\n        return strDecryptedText;\n    }\n    public static String bytesToHex(byte[] bytes) {\n        char[] hexChars = new char[bytes.length * 2];\n        int v;\n        for ( int j = 0; j < bytes.length; j++ ) {\n            v = bytes[j] & 0xFF;\n            hexChars[j * 2] = hexArray[v >>> 4];\n            hexChars[j * 2 + 1] = hexArray[v & 0x0F];\n        }\n        return new String(hexChars);\n    }\n\n    public static void main (String args[]) throws NoSuchAlgorithmException, InvalidKeySpecException, NoSuchPaddingException{\n        Encryptor aesCipher = new Encryptor();\n        try {\n            String encText = aesCipher.encrypt(\"Test\");\n            System.out.println(\"enc text => \"+encText);\n            String plaintext = aesCipher.decrypt(\"Tn2SzI8dmgCmEvQrzdqLxw==\");//(\"eat6f1uCCXVqJgTNUA8BCqXSA4kG4GhKajXdkyV0TewK+jgDkbQ/lPVaevv4rW3XdSmtVyOKLVJjPw9Akeblrh+ejIv9u48n7PkRKniwfxq/URuPU7lhS/sO5JMiJ7+ufgKFvJapxhSfftCtigtDc8F6Y2lJIPEUeQeQKOVc1noeLqPFggz55hWjWvDtpYh/sG76MwLlWDM7cj+uu6ru3ImmDA7qoM4tJOWBBkfng8u20R1ZcF3gM45TgDLUdL912AE1WO+grGBGjqzTXlK2/jgu3OOsLVI0jndB49K5q3/oKJc7JEoIZb0eZJcuZ80A\");\n            System.out.println(\"plain text => \"+plaintext);\n        } catch (InvalidKeyException e) {\n            // TODO Auto-generated catch block\n            e.printStackTrace();\n        } catch (InvalidAlgorithmParameterException e) {\n            // TODO Auto-generated catch block\n            e.printStackTrace();\n        } catch (BadPaddingException e) {\n            // TODO Auto-generated catch block\n            e.printStackTrace();\n        } catch (IllegalBlockSizeException e) {\n            // TODO Auto-generated catch block\n            e.printStackTrace();\n        }\n    }\n}\n", "idx": 2042}
{"project": "cipher", "commit_id": "Snippet45835697_27902.java", "target": 0, "func": "// this is the encripted text\nbyte[] PinBytes = Base64.decodeBase64(encryptedText.getBytes(\"utf-8\"));\n\nbyte[] VectorBytes = Base64.decodeBase64(vectorKey.getBytes(\"utf-8\"));\n\nbyte[] SecretKeyBytes = Base64.decodeBase64(secretKey.getBytes(\"utf-8\")); \n\n// initialize the vector with the one you receive               \nIvParameterSpec spec = new IvParameterSpec(VectorBytes);\n\n// create the key. DESede should be correct, but if it doesn't work try also with DES\nKey key = new SecretKeySpec(SecretKeyBytes, \"DESede\");\n\n// Initialize the cipher\nCipher c = Cipher.getInstance(\"DESede/CBC/PKCS5Padding\");\n\n// decrypt the string\nc.init(Cipher.DECRYPT_MODE, key, spec);\nbyte[] decodedDecryptedBytes = c.doFinal(PinBytes);\n", "idx": 1629}
{"project": "cipher", "commit_id": "Snippet9257005_33796.java", "target": 1, "func": "public static byte[] encrypt(byte[] bytes, byte[] key, byte[] iv)\n        throws Exception\n{\n    Cipher cipher = Cipher.getInstance(\"AES/CBC/ISO10126Padding\");\n    cipher.init(Cipher.ENCRYPT_MODE, new SecretKeySpec(key, \"AES\"),\n            new IvParameterSpec(iv));\n    return cipher.doFinal(bytes);\n}\n", "idx": 1959}
{"project": "cipher", "commit_id": "Snippet3811302_30887.java", "target": 0, "func": "import java.io.UnsupportedEncodingException;\nimport java.security.InvalidAlgorithmParameterException;\nimport java.security.InvalidKeyException;\nimport java.security.NoSuchAlgorithmException;\nimport java.security.SecureRandom;\nimport java.security.spec.InvalidKeySpecException;\nimport java.security.spec.InvalidParameterSpecException;\nimport javax.crypto.BadPaddingException;\nimport javax.crypto.Cipher;\nimport javax.crypto.IllegalBlockSizeException;\nimport javax.crypto.NoSuchPaddingException;\nimport javax.crypto.SecretKey;\nimport javax.crypto.SecretKeyFactory;\nimport javax.crypto.spec.IvParameterSpec;\nimport javax.crypto.spec.PBEKeySpec;\nimport javax.crypto.spec.SecretKeySpec;\n\npublic class CipherTest\n{\n\n    private static class EncryptInfo\n    {\n\n        private final byte[] encryptedData;\n        private final byte[] initVector;\n        private final byte[] salt;\n\n        public EncryptInfo(byte[] encryptedData, byte[] initVector, byte[] salt)\n        {\n            this.encryptedData = encryptedData.clone();\n            this.initVector = initVector.clone();\n            this.salt = salt.clone();\n        }\n\n        public byte[] getEncryptedData()\n        {\n            return encryptedData;\n        }\n\n        public byte[] getInitVector()\n        {\n            return initVector;\n        }\n\n        public byte[] getSalt()\n        {\n            return salt;\n        }\n\n    }\n\n    private static final String keyGenAlgorithm = \"PBEWithMD5AndDES\";\n    private static final String keyAlgorithm = \"DES\";\n    private static final String cipherTransform = \"PBEWithMD5AndDES/CBC/PKCS5Padding\";\n\n    private static EncryptInfo encrypt(char[] password, byte[] data)\n            throws NoSuchAlgorithmException, InvalidKeySpecException,\n            NoSuchPaddingException, InvalidKeyException,\n            InvalidParameterSpecException, IllegalBlockSizeException,\n            BadPaddingException, UnsupportedEncodingException\n    {\n\n        byte[] salt = new byte[16];\n        new SecureRandom().nextBytes(salt);\n\n        PBEKeySpec keySpec = new PBEKeySpec(password, salt, 1024);\n\n        SecretKeyFactory secretKeyFactory = SecretKeyFactory\n                .getInstance(keyGenAlgorithm);\n        SecretKey secretKey = secretKeyFactory.generateSecret(keySpec);\n        keySpec.clearPassword();\n        byte[] key = secretKey.getEncoded();\n        SecretKeySpec secretKeySpec = new SecretKeySpec(key, keyAlgorithm);\n        Cipher cipher = Cipher.getInstance(cipherTransform);\n        cipher.init(Cipher.ENCRYPT_MODE, secretKeySpec);\n\n        byte[] initVector = cipher.getParameters().getParameterSpec(\n                IvParameterSpec.class).getIV();\n\n        return new EncryptInfo(cipher.doFinal(data), initVector, salt);\n    }\n\n    public static byte[] decrypt(byte[] data, char[] password, byte[] salt,\n            byte[] initVector) throws NoSuchAlgorithmException,\n            InvalidKeySpecException, NoSuchPaddingException,\n            InvalidKeyException, InvalidAlgorithmParameterException,\n            IllegalBlockSizeException, BadPaddingException\n    {\n        PBEKeySpec keySpec = new PBEKeySpec(password, salt, 1024);\n\n        SecretKeyFactory secretKeyFactory = SecretKeyFactory\n                .getInstance(keyGenAlgorithm);\n        SecretKey secretKey = secretKeyFactory.generateSecret(keySpec);\n        keySpec.clearPassword();\n        byte[] key = secretKey.getEncoded();\n        SecretKeySpec secretKeySpec = new SecretKeySpec(key, keyAlgorithm);\n        Cipher cipher = Cipher.getInstance(cipherTransform);\n        cipher.init(Cipher.DECRYPT_MODE, secretKeySpec, new IvParameterSpec(\n                initVector));\n        return cipher.doFinal(data);\n    }\n\n    public static void main(String[] args) throws Exception\n    {\n        char[] password = \"password\".toCharArray();\n\n        EncryptInfo info = encrypt(password, \"Message\".getBytes());\n\n        byte[] decyptedText = decrypt(info.getEncryptedData(), password, info\n                .getSalt(), info.getInitVector());\n\n        System.out.println(new String(decyptedText));\n\n    }\n}\n", "idx": 1744}
{"project": "cipher", "commit_id": "Snippet33246352_15306.java", "target": 1, "func": "public static String encrypt(String text, Context c, String pub) {\n        try {\n            byte[] pubKey = Base64.decode(pub, 0);\n\n            KeyFactory factory = KeyFactory.getInstance(\"RSA\");\n            EncodedKeySpec keySpec = new X509EncodedKeySpec(pubKey);\n            PublicKey key = factory.generatePublic(keySpec);\n\n            Cipher cipher = Cipher.getInstance(\"RSA/None/PKCS1Padding\");\n\n            cipher.init(Cipher.ENCRYPT_MODE, key);\n            byte[] bytes = text.getBytes(\"UTF-8\");\n\n            ByteArrayOutputStream baos = new ByteArrayOutputStream();\n\n            for (int i = 0; i < (bytes.length / 128 + 1); i++) {\n                int start = i * 128;\n                int blockLength;\n                if (i == bytes.length / 128)\n                    blockLength = bytes.length - i * 128;\n                else\n                    blockLength = 128;\n                if (blockLength > 0) {\n                    byte[] encrypted = cipher\n                            .doFinal(bytes, start, blockLength);\n                    baos.write(encrypted);\n                }\n\n            }\n\n            byte[] encrypted = baos.toByteArray();\n            return Base64.encodeToString(encrypted, 0);\n        } catch (Exception e) {\n            e.printStackTrace();\n        }\n        return null;\n    }\n", "idx": 2147}
{"project": "cipher", "commit_id": "Snippet40887490_22785.java", "target": 0, "func": " private String _encrypt(String message, String secretKey) throws Exception {\n\n        MessageDigest md = MessageDigest.getInstance(\"MD5\");\n        byte[] digestOfPassword = md.digest(secretKey.getBytes(\"utf-8\"));\n        byte[] keyBytes = Arrays.copyOf(digestOfPassword, 16);\n\n        SecretKey key = new SecretKeySpec(keyBytes, \"DESede/ECB/PKCS7Padding\");\n        Cipher cipher = Cipher.getInstance(\"DESede/ECB/PKCS7Padding\");\n        cipher.init(Cipher.ENCRYPT_MODE, key);\n        byte[] plainTextBytes = message.getBytes(\"utf-8\");\n\n\n        byte[] buf = cipher.doFinal(plainTextBytes);\n        byte [] base64Bytes = Base64.encodeBase64(buf);\n        String base64EncryptedString = new String(base64Bytes);\n\n        return base64EncryptedString;\n    }\n", "idx": 1673}
{"project": "cipher", "commit_id": "Snippet35820688_17706.java", "target": 0, "func": "public class EncryptAsync extends AsyncTask<Void, Void, Void> {\n    //ProgressDialog progressDialog;\n\n    //declare other objects as per your need\n    @Override\n    protected void onPreExecute() {\n        //   progressDialog = ProgressDialog.show(EncryptFile.this, \"Progress Dialog Title Text\", \"Process Description Text\", true);\n\n\n        if (password.getText().toString().equals(confirmPassword.getText().toString())) {\n\n            correctPassword = password.getText().toString();\n            //Toast.makeText(this,correctPassword,Toast.LENGTH_LONG).show();\n\n            //copies Plain Text to String\n            fileEditText.setInputType(InputType.TYPE_CLASS_TEXT);\n            returnFile = fileEditText.getText().toString();\n            Toast.makeText(EncryptFile.this, returnFile, Toast.LENGTH_LONG).show();\n        } else {\n            Toast.makeText(EncryptFile.this, \"Passwords do not match\", Toast.LENGTH_LONG).show();\n\n        }\n\n    }\n\n\n\n    @Override\n    protected Void doInBackground(Void... params) {\n\n\n        if (spinnerValue.equals(\"AES\")) {\n            Toast.makeText(EncryptFile.this, returnFile, Toast.LENGTH_LONG).show();\n\n            try {\n                // Here you read the cleartext.\n                FileInputStream fis = new FileInputStream(returnFile);\n                // This stream write the encrypted text. This stream will be wrapped by another stream.\n                FileOutputStream fos = new FileOutputStream(returnFile + \".aes\");\n\n                // hash password with SHA-256 and crop the output to 128-bit for key\n                MessageDigest digest = MessageDigest.getInstance(\"SHA-256\");\n                digest.update(correctPassword.getBytes());\n\n                // copys hashed password to key\n                System.arraycopy(digest.digest(), 0, key, 0, key.length);\n\n\n                SecretKeySpec sks = new SecretKeySpec(key, \"AES\");\n                // Create cipher\n                Cipher cipher = Cipher.getInstance(\"AES\");\n                cipher.init(Cipher.ENCRYPT_MODE, sks);\n                // Wrap the output stream\n                CipherOutputStream cos = new CipherOutputStream(fos, cipher);\n                // Write bytes\n                int b;\n                byte[] d = new byte[8];\n                while ((b = fis.read(d)) != -1) {\n                    cos.write(d, 0, b);\n                }\n                // Flush and close streams.\n                cos.flush();\n                cos.close();\n                fis.close();\n            } catch (Exception ex) {\n                Toast.makeText(EncryptFile.this, \"Error with Exception\", Toast.LENGTH_LONG).show();\n            } catch(Throwable t){\n                Toast.makeText(EncryptFile.this, \"Error with throwable\", Toast.LENGTH_LONG).show();\n            }\n\n        } else if (spinnerValue.equals(\"Blowfish\")) {\n//code for blowfish\n        }\n\n\n\n         return null;\n    }\n@Override\n    protected void onPostExecute(Void result) {\n        Toast.makeText(EncryptFile.this, \"Finished Encryption\", Toast.LENGTH_LONG).show();\n        // super.onPostExecute(result);\n        // progressDialog.dismiss();\n    }\n", "idx": 1648}
{"project": "cipher", "commit_id": "Snippet45898618_27979.java", "target": 1, "func": "private String encryptJava(String plainText, String saltValue, String passPhrase, String initVector) {//working!!!\n    String result = \"\";\n\n    byte[] initVectorBytes = initVector.getBytes(US_ASCII);\n    byte[] saltValueBytes = saltValue.getBytes(US_ASCII);\n    byte[] plainTextBytes = plainText.getBytes(UTF_8);\n\n    Cipher cipher;\n    try {\n        final com.gmail.example.PasswordDeriveBytes password = new com.gmail.example.PasswordDeriveBytes(passPhrase, saltValueBytes);\n        final byte[] keyBytes = password.getBytes(256 / Byte.SIZE);\n        SecretKeySpec secretKey = new SecretKeySpec(keyBytes, \"AES\");\n\n        cipher = Cipher.getInstance(\"AES/CBC/PKCS5Padding\");\n        try {\n            cipher.init(Cipher.ENCRYPT_MODE, secretKey, new IvParameterSpec(initVectorBytes));\n        } catch (InvalidAlgorithmParameterException e) {\n            e.printStackTrace();\n        }\n\n        final byte[] ct = cipher.doFinal(plainTextBytes);\n        result = Base64.encodeToString(ct, Base64.DEFAULT);//**added this line!** \n        //result = new String(ct, \"US-ASCII\");**-- deleted this line!** \n    } catch (NoSuchAlgorithmException e) {\n        e.printStackTrace();\n    } catch (NoSuchPaddingException e) {\n        e.printStackTrace();\n    } catch (InvalidKeyException e) {\n        e.printStackTrace();\n    } catch (BadPaddingException e) {\n        e.printStackTrace();\n    } catch (IllegalBlockSizeException e) {\n        e.printStackTrace();\n    }\n    return result;\n}\n", "idx": 2167}
{"project": "cipher", "commit_id": "Snippet9614189_33831.java", "target": 0, "func": "Cipher cipher = Cipher.getInstance(\"AES\");", "idx": 1713}
{"project": "cipher", "commit_id": "Snippet12778174_36447.java", "target": 0, "func": "import java.io.UnsupportedEncodingException;\nimport java.security.InvalidKeyException;\nimport java.security.MessageDigest;\nimport java.security.NoSuchAlgorithmException;\nimport java.util.Arrays;\n\nimport javax.crypto.BadPaddingException;\nimport javax.crypto.Cipher;\nimport javax.crypto.IllegalBlockSizeException;\nimport javax.crypto.KeyGenerator;\nimport javax.crypto.NoSuchPaddingException;\nimport javax.crypto.SecretKey;\nimport javax.crypto.spec.IvParameterSpec;\nimport javax.crypto.spec.SecretKeySpec;\nimport javax.xml.bind.DatatypeConverter;\n\n\npublic class DesRun {\n    /**\n     * @param args\n     */\n    public static void main(String[] args) {\n        String theKey = \"01234567\";\n        String message = \"abcdefghijklmnop\";\n        Cipher ecipher, dcipher;\n         try {\n            // generate secret key using DES algorithm\n             SecretKeySpec key = new SecretKeySpec(theKey.getBytes(\"UTF-8\"), \"DES\");\n\n                 ecipher = Cipher.getInstance(\"DES\");\n                 dcipher = Cipher.getInstance(\"DES\");\n\n                 // initialize the ciphers with the given key\n                 ecipher.init(Cipher.ENCRYPT_MODE, key);\n                 dcipher.init(Cipher.DECRYPT_MODE, key);\n\n                 byte[] encrypted = ecipher.doFinal(message.getBytes(\"UTF-8\"));\n                 System.out.println(DatatypeConverter.printHexBinary(encrypted));\n                 String decrypted = new String(dcipher.doFinal(encrypted), \"UTF-8\");\n\n                 System.out.println(\"Decrypted: \" + decrypted);\n\n             }\n             catch (Exception e) {\n                // TODO Auto-generated catch block\n                e.printStackTrace();\n            }\n\n    }\n}\n", "idx": 1830}
{"project": "cipher", "commit_id": "Snippet11689384_35714.java", "target": 1, "func": "    Cipher encryptor = Cipher.getInstance(\"AES/CBC/PKCS5Padding\");\n    Cipher decryptor = Cipher.getInstance(\"AES/CBC/PKCS5Padding\");\n\n    encryptor.init(Cipher.ENCRYPT_MODE, secret);\n    byte[] IV = encryptor.getIV();\n\n    packet.setData(IV);\n    socket.send(packet);\n\n    IvParameterSpec ips = new IvParameterSpec(IV);\n\n    decryptor.init(Cipher.DECRYPT_MODE, secret, ips);\n", "idx": 1977}
{"project": "cipher", "commit_id": "Snippet3683915_30833.java", "target": 1, "func": "cipher = Cipher.getInstance(algorithm);  \n", "idx": 2055}
{"project": "cipher", "commit_id": "Snippet2732808_30406.java", "target": 0, "func": "\nkgen = KeyGenerator.getInstance(\"AES\");\n            kgen.init(128);\n            raw = new byte[]{(byte)0x00,(byte)0x11,(byte)0x22,(byte)0x33,(byte)0x44,(byte)0x55,(byte)0x66,(byte)0x77,(byte)0x88,(byte)0x99,(byte)0xaa,(byte)0xbb,(byte)0xcc,(byte)0xdd,(byte)0xee,(byte)0xff};\n            skeySpec = new SecretKeySpec(raw, \"AES\");\n            cipher = Cipher.getInstance(\"AES\");\n\n            plainText=null;\n            cipherText=null;\n\n", "idx": 1639}
{"project": "cipher", "commit_id": "Snippet13960996_37388.java", "target": 1, "func": "Cipher cipher = Cipher.getInstance(\"RSA\");\ncipher.init(Cipher.ENCRYPT_MODE, privateKey);\nbyte[] cipherBytes = cipher.doFinal(plainText.getBytes());\n", "idx": 2131}
{"project": "cipher", "commit_id": "Snippet8141959_33100.java", "target": 1, "func": "private static void test() throws Exception {\n\n    // create wrap key\n    KeyGenerator keyGenerator = KeyGenerator.getInstance(\"AESWrap\");\n    keyGenerator.init(256);\n    Key wrapKey = keyGenerator.generateKey();\n\n    SecretKey key = generateKey(PASSPHRASE);\n    Cipher cipher;\n\n    // wrap key\n    cipher = Cipher.getInstance(\"AESWrap\");\n    cipher.init(Cipher.WRAP_MODE, wrapKey);\n    byte[] wrappedKeyBytes = cipher.wrap(key);\n\n    // unwrap key again\n    cipher.init(Cipher.UNWRAP_MODE, wrapKey);\n    key = (SecretKey)cipher.unwrap( wrappedKeyBytes, \"AES/CTR/NOPADDING\", Cipher.SECRET_KEY);\n\n    // encrypt\n    cipher = Cipher.getInstance(\"AES/CTR/NOPADDING\");\n    cipher.init(Cipher.ENCRYPT_MODE, key, generateIV(cipher), random);\n    byte[] b = cipher.doFinal(\"Test\".toString().getBytes());\n\n    // decrypt\n    cipher = Cipher.getInstance(\"AES/CTR/NOPADDING\");\n    cipher.init(Cipher.DECRYPT_MODE, key, generateIV(cipher), random);\n    b = cipher.doFinal(b);\n\n    System.out.println(new String(b));  \n    // should output \"Test\", but outputs \ufffdJ\ufffd\ufffd if wrapping/unwrapping\n\n}\n", "idx": 2196}
{"project": "cipher", "commit_id": "Snippet1761748_30079.java", "target": 1, "func": "package org.temp2.cod1;\nimport java.security.*;\nimport java.security.spec.InvalidKeySpecException;\nimport java.security.spec.InvalidParameterSpecException;\nimport java.security.spec.KeySpec;\n\nimport javax.crypto.*;\nimport javax.crypto.spec.*;\nimport java.io.*;\n\npublic class Code2 {\n\npublic static void main(String[] args) throws NoSuchAlgorithmException, NoSuchPaddingException, InvalidKeyException, IllegalBlockSizeException, BadPaddingException, UnsupportedEncodingException, InvalidKeySpecException, InvalidParameterSpecException {\n\n    char[] password = args[0].toCharArray();\n    byte[] salt = new byte[8];\n    for (int i = 0; i < 8; ++i) {\n      salt[i] = (byte) Integer.parseInt(args[1].substring(i * 2, i * 2 + 2), 16);\n    }\n\n\n    SecretKeyFactory factory = SecretKeyFactory.getInstance(\"PBKDF2WithHmacSHA1\");\n    KeySpec spec = new PBEKeySpec(password, salt, 1024, 256);\n    SecretKey tmp = factory.generateSecret(spec);\n    SecretKey secret = new SecretKeySpec(tmp.getEncoded(), \"AES\");\n\n    Cipher cipher = Cipher.getInstance(\"AES/CBC/PKCS5Padding\");\n    cipher.init(Cipher.ENCRYPT_MODE, secret);\n    AlgorithmParameters params = cipher.getParameters();\n    byte[] iv = params.getParameterSpec(IvParameterSpec.class).getIV();\n    byte[] ciphertext = cipher.doFinal(\"Hello, World!\".getBytes(\"UTF-8\"));\n\n\n    }\n}\n", "idx": 1981}
{"project": "cipher", "commit_id": "Snippet36723150_18623.java", "target": 1, "func": "import java.nio.file.Files;\nimport java.nio.file.Paths;\nimport javax.crypto.*;\nimport javax.crypto.spec.IvParameterSpec;\nimport javax.crypto.spec.SecretKeySpec;\n\nimport java.util.*;\n\npublic class Encrypter {\n\npublic static void main(String[] args) throws Exception {\n    String FileName = \"encryptedtext.txt\";\n    String FileName2 = \"decryptedtext.txt\";\n\n    Scanner input = new Scanner(System.in);\n\n   System.out.println(\"Enter your 16 character key here:\");\n   String EncryptionKey = input.next();\n   byte[] iv = { 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0 };\n   IvParameterSpec ivspec = new IvParameterSpec(iv);\n\n\n    KeyGenerator KeyGen = KeyGenerator.getInstance(\"AES\");\n    KeyGen.init(128);\n\n\n    Cipher AesCipher = Cipher.getInstance(\"AES/CFB/NoPadding\");\n    System.out.println(\"Enter text to encrypt or decrypt:\");\n    String Text = input.next();\n\n    System.out.println(\"Do you want to encrypt or decrypt (e/d)\");\n    String answer = input.next();\n    if (answer.equalsIgnoreCase(\"e\")){\n\n        byte[] byteKey = (EncryptionKey.getBytes());\n        byte[] byteText = (Text).getBytes();\n        SecretKeySpec secretKeySpec = new SecretKeySpec(byteKey, \"AES\");\n        AesCipher.init(Cipher.ENCRYPT_MODE, secretKeySpec,ivspec );\n        AesCipher.init(Cipher.ENCRYPT_MODE, secretKeySpec,ivspec); // ERROR LINE\n        byte[] byteCipherText = AesCipher.doFinal(byteText);\n        Files.write(Paths.get(FileName), byteCipherText);\n\n\n          }\n    else if (answer.equalsIgnoreCase(\"d\")){\n\n        byte[] byteKey = (EncryptionKey.getBytes());\n        byte[] byteText = (Text).getBytes();\n        byte[] cipherText = Files.readAllBytes(Paths.get(FileName));\n\n        SecretKeySpec secretKeySpec = new SecretKeySpec(byteKey, \"AES\");\n        AesCipher.init(Cipher.DECRYPT_MODE, secretKeySpec,ivspec); // ERROR LINE\n        byte[] bytePlainText = AesCipher.doFinal(cipherText);\n        Files.write(Paths.get(FileName2), bytePlainText);\n    }\n}\n\n}\n", "idx": 2338}
{"project": "cipher", "commit_id": "Snippet31930949_13979.java", "target": 0, "func": "package com.boolbalabs.petlinx.settings;\n\nimport java.security.SecureRandom;\n\nimport javax.crypto.Cipher;\nimport javax.crypto.KeyGenerator;\nimport javax.crypto.SecretKey;\nimport javax.crypto.spec.SecretKeySpec;\n\npublic class Encryptor {\n\n    private final static String HEX = \"0123456789ABCDEF\";\n\n    private static void appendHex(StringBuffer sb, byte b) {\n        sb.append(HEX.charAt((b>>4)&0x0f)).append(HEX.charAt(b&0x0f));\n    }\n\n    private static byte[] decrypt(byte[] raw, byte[] encrypted) throws Exception {\n        SecretKeySpec skeySpec = new SecretKeySpec(raw, \"AES\");\n        Cipher cipher = Cipher.getInstance(\"AES\");\n        cipher.init(Cipher.DECRYPT_MODE, skeySpec);\n        byte[] decrypted = cipher.doFinal(encrypted);//ERROR HERE////////////////////////////////////////////////////////////////////////////\n        return decrypted;\n    }\n\n\n    public static String decrypt(String seed, String encrypted) throws Exception {\n        byte[] rawKey = getRawKey(seed.getBytes());\n        byte[] enc = toByte(encrypted);\n        byte[] result = decrypt(rawKey, enc);\n        return new String(result);\n    }\n\n    private static byte[] encrypt(byte[] raw, byte[] clear) throws Exception {\n        SecretKeySpec skeySpec = new SecretKeySpec(raw, \"AES\");\n        Cipher cipher = Cipher.getInstance(\"AES\");\n        cipher.init(Cipher.ENCRYPT_MODE, skeySpec);\n        byte[] encrypted = cipher.doFinal(clear);\n        return encrypted;\n    }\n\n    public static String encrypt(String seed, String cleartext) throws Exception {\n        byte[] rawKey = getRawKey(seed.getBytes());\n        byte[] result = encrypt(rawKey, cleartext.getBytes());\n        return toHex(result);\n    }\n    public static String fromHex(String hex) {\n        return new String(toByte(hex));\n    }\n\n    private static byte[] getRawKey(byte[] seed) throws Exception {\n        KeyGenerator kgen = KeyGenerator.getInstance(\"AES\");\n        SecureRandom sr = SecureRandom.getInstance(\"SHA1PRNG\");\n        sr.setSeed(seed);\n        kgen.init(128, sr); // 192 and 256 bits may not be available\n        SecretKey skey = kgen.generateKey();\n        byte[] raw = skey.getEncoded();\n        return raw;\n    }\n\n    public static byte[] toByte(String hexString) {\n        int len = hexString.length()/2;\n        byte[] result = new byte[len];\n        for (int i = 0; i < len; i++)\n            result[i] = Integer.valueOf(hexString.substring(2*i, 2*i+2), 16).byteValue();\n        return result;\n    }\n    public static String toHex(byte[] buf) {\n        if (buf == null)\n            return \"\";\n        StringBuffer result = new StringBuffer(2*buf.length);\n        for (int i = 0; i < buf.length; i++) {\n            appendHex(result, buf[i]);\n        }\n        return result.toString();\n    }\n    public static String toHex(String txt) {\n        return toHex(txt.getBytes());\n    }\n}\n", "idx": 1662}
{"project": "cipher", "commit_id": "Snippet37686794_19659.java", "target": 0, "func": "public class Encryptor {\n\nprivate static final String ALGORITHM = \"AES\";\nprivate static final String TRANSFORMATION = \"AES\";\n\npublic void encrypt(String key, File inputFile, File outputFile) throws CryptoException {\n    doCrypto(Cipher.ENCRYPT_MODE, key, inputFile, outputFile);\n}\n\npublic void decrypt(String key, File inputFile, File outputFile) throws CryptoException {\n    doCrypto(Cipher.DECRYPT_MODE, key, inputFile, outputFile);\n}    \nprivate void doCrypto(int cipherMode, String key, File inputFile, File outputFile) throws CryptoException {\n    try {\n\n        Key secretKey = new SecretKeySpec(key.getBytes(), ALGORITHM);\n        Cipher cipher = Cipher.getInstance(TRANSFORMATION);\n        cipher.init(cipherMode, secretKey);\n\n        byte[] inputBytes = new byte[16];\n        byte[] outputBytes = new byte[16];\n\n        //Open the file in read write mode\n        RandomAccessFile fileStore = new RandomAccessFile(inputFile, \"rw\"); \n        fileStore.seek(0); \n\n        //encrypt first 1024bytes\n        int bytesRead = 0;\n        for(int ctr=0;bytesRead!= -1 && ctr<64 ;ctr++){\n            //get file pointer position\n            long prevPosition = fileStore.getFilePointer();\n\n            //read 16 bytes to array\n            bytesRead = fileStore.read(inputBytes); \n\n            //if successful, go move back pointer and overwrite these 16 bytes with encrypted bytes\n            if(bytesRead != 1){\n                outputBytes = cipher.doFinal(inputBytes);\n                fileStore.seek(prevPosition);\n                fileStore.write(outputBytes);\n            }   \n        }\n\n        fileStore.close();\n\n    } catch (NoSuchPaddingException | NoSuchAlgorithmException | InvalidKeyException | BadPaddingException\n            | IllegalBlockSizeException | IOException ex) {\n        throw new CryptoException(ex);\n    }\n}\n", "idx": 1652}
{"project": "cipher", "commit_id": "Snippet3451823_30740.java", "target": 0, "func": "        PBEKeySpec pbeKeySpec;\n        PBEParameterSpec pbeParamSpec;\n        SecretKeyFactory keyFac;\n\n        // Salt\n        byte[] salt = {\n            (byte)0xc7, (byte)0x73, (byte)0x21, (byte)0x8c,\n            (byte)0x7e, (byte)0xc8, (byte)0xee, (byte)0x99\n        };\n\n        // Iteration count\n        int count = 20;\n\n        // Create PBE parameter set\n        pbeParamSpec = new PBEParameterSpec(salt, count);\n\n        // Prompt user for encryption password.\n        // Collect user password as char array (using the\n        // \"readPassword\" method from above), and convert\n        // it into a SecretKey object, using a PBE key\n        // factory.\n        System.out.print(\"Enter encryption password:  \");\n        System.out.flush();\n        pbeKeySpec = new PBEKeySpec(readPassword(System.in));\n        keyFac = SecretKeyFactory.getInstance(\"PBEWithMD5AndDES\");\n        SecretKey pbeKey = keyFac.generateSecret(pbeKeySpec);\n\n        // Create PBE Cipher\n        Cipher pbeCipher = Cipher.getInstance(\"PBEWithMD5AndDES\");\n\n        // Initialize PBE Cipher with key and parameters\n        pbeCipher.init(Cipher.ENCRYPT_MODE, pbeKey, pbeParamSpec);\n\n        // Our cleartext\n        byte[] cleartext = \"This is another example\".getBytes();\n\n        // Encrypt the cleartext\n        byte[] ciphertext = pbeCipher.doFinal(cleartext);\n", "idx": 1593}
{"project": "cipher", "commit_id": "Snippet35992681_17843.java", "target": 1, "func": "public KeyStore getKeyStore() {\n    try {\n        return KeyStore.getInstance(\"AndroidKeyStore\");\n    } catch (KeyStoreException exception) {\n        throw new RuntimeException(\"Failed to get an instance of KeyStore\", exception);\n    }\n}\n\npublic KeyPairGenerator getKeyPairGenerator() {\n    try {\n        return KeyPairGenerator.getInstance(\"EC\", \"AndroidKeyStore\");\n    } catch(NoSuchAlgorithmException | NoSuchProviderException exception) {\n        throw new RuntimeException(\"Failed to get an instance of KeyPairGenerator\", exception);\n    }\n}\n\npublic Cipher getCipher() {\n    try {\n        return Cipher.getInstance(\"EC\");\n    } catch(NoSuchAlgorithmException | NoSuchPaddingException exception) {\n        throw new RuntimeException(\"Failed to get an instance of Cipher\", exception);\n    }\n}\n\nprivate void createKey() {\n    try {\n        mKeyPairGenerator.initialize(\n                new KeyGenParameterSpec.Builder(KEY_ALIAS,\n                        KeyProperties.PURPOSE_ENCRYPT | KeyProperties.PURPOSE_DECRYPT)\n                        .setAlgorithmParameterSpec(new ECGenParameterSpec(\"secp256r1\")\n                        .setUserAuthenticationRequired(true)\n                        .build());\n        mKeyPairGenerator.generateKeyPair();\n    } catch(InvalidAlgorithmParameterException exception) {\n        throw new RuntimeException(exception);\n    }\n}\n\nprivate boolean initCipher(int opmode) {\n    try {\n        mKeyStore.load(null);\n\n        if(opmode == Cipher.ENCRYPT_MODE) {\n            PublicKey key = mKeyStore.getCertificate(KEY_ALIAS).getPublicKey();\n            mCipher.init(opmode, key);\n        } else {\n            PrivateKey key = (PrivateKey) mKeyStore.getKey(KEY_ALIAS, null);\n            mCipher.init(opmode, key);\n        }\n\n        return true;\n    } catch (KeyPermanentlyInvalidatedException exception) {\n        return false;\n    } catch(KeyStoreException | CertificateException | UnrecoverableKeyException\n            | IOException | NoSuchAlgorithmException | InvalidKeyException\n            | InvalidAlgorithmParameterException exception) {\n        throw new RuntimeException(\"Failed to initialize Cipher\", exception);\n    }\n}\n\nprivate void encrypt(String password) {\n    try {\n        initCipher(Cipher.ENCRYPT_MODE);\n        byte[] bytes = mCipher.doFinal(password.getBytes());\n        String encryptedPassword = Base64.encodeToString(bytes, Base64.NO_WRAP);\n        mPreferences.getString(\"password\").set(encryptedPassword);\n    } catch(IllegalBlockSizeException | BadPaddingException exception) {\n        throw new RuntimeException(\"Failed to encrypt password\", exception);\n    }\n}\n\nprivate String decryptPassword(Cipher cipher) {\n    try {\n        String encryptedPassword = mPreferences.getString(\"password\").get();\n        byte[] bytes = Base64.decode(encryptedPassword, Base64.NO_WRAP);\n        return new String(cipher.doFinal(bytes));\n    } catch (IllegalBlockSizeException | BadPaddingException exception) {\n        throw new RuntimeException(\"Failed to decrypt password\", exception);\n    }\n}\n", "idx": 2225}
{"project": "cipher", "commit_id": "Snippet11528491_35601.java", "target": 1, "func": "Cipher contentCipher = Cipher.getInstance(\"AES/CBC/PKCS5Padding\");\ncontentCipher.init(Cipher.ENCRYPT_MODE, contentEncryptionKey);\nAlgorithmParameters params = contentCipher.getParameters();\nbyte[] iv = params.getParameterSpec(IvParameterSpec.class).getIV();\n", "idx": 2048}
{"project": "cipher", "commit_id": "Snippet19149603_1988.java", "target": 1, "func": "public byte[] encrypt(byte[] plainText, SecretKey secretKey, String outputFilePath) throws Exception\n{\n    //select putput file for encrypted text\n    FileOutputStream fos = new FileOutputStream(outputFilePath);\n\n    //Cipher in encrypt mode\n    Cipher cipher = Cipher.getInstance(\"AES/CBC/PKCS5Padding\");\n    cipher.init(Cipher.ENCRYPT_MODE, secretKey, new IvParameterSpec(iv));\n\n    fos.write(cipher.doFinal(plainText));\n    fos.close();\n\n    //Encrypted text is returned in a byte array.\n    return cipher.doFinal(plainText);\n}\n\n// Decryption function\npublic String decrypt(String sharedKeyFilepath, String cipherTextFilepath, String plainTextFilepath) throws Exception\n{\n    FileInputStream fis = null;\n\n\n    File sharedKeyFile = new File(sharedKeyFilepath);\n    byte[] sharedKeyByte = new byte[(int)sharedKeyFile.length()];\n\n    File cipherTextFile = new File(cipherTextFilepath);\n    byte[] cipherText = new byte[(int)cipherTextFile.length()];\n\n    File plainTextFile = new File(plainTextFilepath);\n    byte[] plainText = new byte[(int)plainTextFile.length()];\n\n    fis = new FileInputStream(sharedKeyFile);\n    fis.read(sharedKeyByte);\n    fis.close();\n\n    fis = new FileInputStream(cipherTextFile);\n    fis.read(cipherText);\n    fis.close();\n\n    fis = new FileInputStream(plainTextFile);\n    fis.read(plainText);\n    fis.close();\n\n    SecretKey sharedKey = new SecretKeySpec(sharedKeyByte, 0, sharedKeyByte.length, \"AES\");\n\n    // Cipher in decrypt mode\n    Cipher cipher = Cipher.getInstance(\"AES/CBC/PKCS5Padding\");\n    cipher.init(Cipher.DECRYPT_MODE, sharedKey, new IvParameterSpec(iv));\n\n    // Select output file for decrypted cipher Text\n    FileOutputStream fos = new FileOutputStream(\"Receiver/DecryptedPlainText.txt\");\n    String decrypted = new String(cipher.doFinal(cipherText));\n\n    byte [] decryptedBytes = cipher.doFinal(cipherText);\n    fos.write(decryptedBytes);\n    fos.close();\n\n    // Return the decrypted text as a string.\n    return decrypted;\n}\n", "idx": 2219}
{"project": "cipher", "commit_id": "Snippet11838197_35820.java", "target": 0, "func": "import java.io.*;\nimport java.net.*;\nimport java.security.InvalidKeyException;\nimport java.security.NoSuchAlgorithmException;\n\nimport javax.crypto.*;\nimport javax.crypto.spec.*;\n\nimport org.apache.commons.codec.binary.Base64;\nimport org.apache.commons.codec.digest.DigestUtils;\n\n\npublic class Main {\n\n    /**\n     * @param args\n     * @throws Exception \n     */\n    public static void main(String[] args) throws Exception {\n\n        String pw = \"[E%Xr6pG-IDIA89_&=NI[AREofOy0#Mv[nJ7rO@T^PwgT!NVY*Hri@($p4luBM)ugVvbnAnWL@xGK*jBP3s$g#-XTH{e3@X*0StJ\";\n        String str = encode(\"Testing Testing Testing Testing Testing Testing Testing Testing Testing Testing Testing Testing Testing Testing Testing Testing Testing Testing Testing Testing \", pw);\n        System.out.println(str);\n        System.out.println(decode(str, pw));\n    }\n\n    public static String encode(String s, String p) throws Exception\n    {\n        String cleartext = padRight(s, s.length()+(16-(s.length()%16)));\n        String key = DigestUtils.md5Hex(p);\n        SecretKeySpec skeySpec = new SecretKeySpec(key.getBytes(), \"AES\");\n        Cipher cipher = Cipher.getInstance(\"AES/ECB/NoPadding\");\n        cipher.init(Cipher.ENCRYPT_MODE, skeySpec);\n        byte[] encrypted = cipher.doFinal(cleartext.getBytes());\n        return Base64.encodeBase64String(encrypted);\n    }\n\n    public static String decode(String encrypted, String p) throws Exception\n    {\n        byte[] bts = Base64.decodeBase64(encrypted);\n\n\n        String key = DigestUtils.md5Hex(p);\n        SecretKeySpec skeySpec = new SecretKeySpec(key.getBytes(), \"AES\");\n        Cipher cipher = Cipher.getInstance(\"AES/ECB/NoPadding\");\n        cipher.init(Cipher.DECRYPT_MODE, skeySpec);\n\n\n\n        byte[] decrypted = cipher.doFinal(bts);\n\n        return new String(decrypted).replaceAll(\"\\0\", \"\");\n    }\n\n    public static String padRight(String s, int n) {\n        while (s.length() < n)\n        {\n            s+=\"\\0\";\n        }\n        return s;\n    }\n\n}\n", "idx": 1702}
{"project": "cipher", "commit_id": "Snippet41514199_23444.java", "target": 1, "func": "public class img {\n        static String IV = \"AAAAAAAAAAAAAAAA\";\n        static String encryptionKey = \"0123456789abcdef\";\n\nstatic public void main(String args[]) throws Exception {\n    try {\n        BufferedImage image;\n        int width;\n        int height;\n\n        File input = new File(\"C:\\\\Users\\\\AKRAM\\\\Desktop\\\\sample.jpg\");\n        image = ImageIO.read(input);\n        width = image.getWidth();\n        height = image.getHeight();\n\n        int[] t = new int[width * height * 3];\n        int k = 0;\n        int kk = 0;\n\n        // fill the table t with RGB values;\n        for (int i = 0; i < height; i++) {\n\n            for (int j = 0; j < width; j++) {\n\n                Color c = new Color(image.getRGB(j, i));\n                int r = c.getRed();\n                int g = c.getGreen();\n                int b = c.getBlue();\n\n                t[k] = r;\n                k++;\n                t[k] = g;\n                k++;\n                t[k] = b;\n                k++;\n\n            }\n        }\n\n        // convert table of RGB values into byte Array for the Encryption\n        byte[] bb = integersToBytes(t);\n\n        /* AES Encryption */\n        byte[] cipher = encrypt(bb, encryptionKey);\n\n        t = convertByte2Int(cipher);\n\n        // create image with table RGB values;\n        for (int i = 0; i < height; i++) {\n\n            for (int j = 0; j < width; j++) {\n\n                int r = t[kk];\n                kk++;\n                int g = t[kk];\n                kk++;\n                int b = t[kk];\n                kk++;\n\n                Color newColor = new Color(r, g, b);\n                image.setRGB(j, i, newColor.getRGB());\n\n            }\n        }\n        //write the output image\n        File ouptut = new File(\"C:\\\\Users\\\\AKRAM\\\\Desktop\\\\output.jpg\");\n        ImageIO.write(image, \"jpg\", ouptut);\n\n    } catch (Exception e) {\n    }\n}// end main\n\npublic static byte[] encrypt(byte[] plainText, String encryptionKey) throws Exception {\n    Cipher cipher = Cipher.getInstance(\"AES/CBC/NoPadding\", \"SunJCE\");\n    SecretKeySpec key = new SecretKeySpec(encryptionKey.getBytes(\"UTF-8\"), \"AES\");\n    cipher.init(Cipher.ENCRYPT_MODE, key, new IvParameterSpec(IV.getBytes(\"UTF-8\")));\n    return cipher.doFinal(plainText);\n}\n\npublic static byte[] integersToBytes(int[] values) throws IOException {\n    ByteArrayOutputStream baos = new ByteArrayOutputStream();\n    DataOutputStream dos = new DataOutputStream(baos);\n    for (int i = 0; i < values.length; ++i) {\n        dos.writeInt(values[i]);\n    }\n\n    return baos.toByteArray();\n}\n\npublic static int[] convertByte2Int(byte buf[]) {\n    int intArr[] = new int[buf.length / 4];\n    int offset = 0;\n    for (int i = 0; i < intArr.length; i++) {\n        intArr[i] = (buf[3 + offset] & 0xFF) | ((buf[2 + offset] & 0xFF) << 8) | ((buf[1 + offset] & 0xFF) << 16)\n                | ((buf[0 + offset] & 0xFF) << 24);\n        offset += 4;\n    }\n    return intArr;\n  }\n", "idx": 2072}
{"project": "cipher", "commit_id": "Snippet37442548_19374.java", "target": 0, "func": "public class AES {\n    private String a= \"AES/ECB/NoPadding\";\n    private byte[] key;\n    Cipher c;\n    public AES(byte [] key) throws NoSuchAlgorithmException, NoSuchPaddingException{\n            this.key = key;\n            c = Cipher.getInstance(a);\n        }\npublic String encrypt(byte[] Data) throws Exception{\n        Key k = new SecretKeySpec(key, \"AES\");\n        c.init(Cipher.ENCRYPT_MODE, k);\n        byte[] encoded = c.doFinal(Data);\n        String encrypted= new String(encoded);\n        return encrypted;\n\n    }\npublic String decrypt(byte[] v) throws Exception{\n        Key k = new SecretKeySpec(key, \"AES\");\n        if(v.length%16!=0)\n            return null;\n        c.init(Cipher.DECRYPT_MODE, k);\n        byte[] decv = c.doFinal(v);\n        String decrypted = new String(decv);\n        return decrypted;\n    }\n}\n", "idx": 1637}
{"project": "cipher", "commit_id": "Snippet13501136_37048.java", "target": 1, "func": "// Get an instance of the Cipher for RSA encryption/decryption\nCipher c = Cipher.getInstance(\"RSA\");\n// Initiate the Cipher, telling it that it is going to Encrypt, giving it the public key\nc.init(Cipher.ENCRYPT_MODE, myPair.getPublic()); \n", "idx": 2125}
{"project": "cipher", "commit_id": "Snippet8757101_33472.java", "target": 0, "func": "SecretKeySpec skeySpec = new SecretKeySpec(pad16(pass), \"AES\");\nCipher c = Cipher.getInstance(\"AES\");\nc.init(Cipher.ENCRYPT_MODE, skeySpec);\nbyte[] out = c.doFinal( input )\n", "idx": 1827}
{"project": "cipher", "commit_id": "Snippet26698138_8825.java", "target": 0, "func": "byte[] keyBytes = new byte[] { 0x00, 0x01, 0x02, 0x03, 0x04, 0x05, 0x06, 0x07, 0x08, 0x09,\n    0x0a, 0x0b, 0x0c, 0x0d, 0x0e, 0x0f, 0x10, 0x11, 0x12, 0x13, 0x14, 0x15, 0x16, 0x17 }; //Choose a key wisely\n\nSecretKeySpec key = new SecretKeySpec(keyBytes, \"AES\");\n\nCipher cipher = Cipher.getInstance(\"AES/ECB/PKCS7Padding\", \"BC\");\n\nfis = new FileInputStream(\"some_img.png\");\ncis = new CipherInputStream(fis, cipher);\nfos = new FileOutputStream(\"encrypted_img.enc\");\nbyte[] b = new byte[8];\nint i = cis.read(b);\nwhile (i != -1) {\n    fos.write(b, 0, i);\n    i = cis.read(b);\n}\nfos.close();\n", "idx": 1780}
{"project": "cipher", "commit_id": "Snippet39271415_21152.java", "target": 0, "func": "public class Encrypter {\n\n    Cipher ecipher;\n    Cipher dcipher;\n\n    SecretKeySpec key = new SecretKeySpec(\"missyou1\".getBytes(), \"DES\");\n\n    public DesEncrypter() throws Exception {\n        ecipher = Cipher.getInstance(\"DES\");\n        dcipher = Cipher.getInstance(\"DES\");\n        ecipher.init(Cipher.ENCRYPT_MODE, key);\n        dcipher.init(Cipher.DECRYPT_MODE, key);\n    }\n\n    public String encrypt(String str) throws Exception {\n        byte[] utf8 = str.getBytes(\"UTF8\");\n        byte[] enc = ecipher.doFinal(utf8);\n        return new sun.misc.BASE64Encoder().encode(enc);\n    }\n\n    public String decrypt(String str) throws Exception {\n        byte[] dec = new sun.misc.BASE64Decoder().decodeBuffer(str);\n\n        byte[] asd = new byte[(dec.length/8+1)*8];\n        for(int i = 0; i < dec.length; i++){\n            asd[i] = dec[i];\n        }\n        byte[] utf8 = dcipher.doFinal(asd);\n\n        return new String(utf8, \"UTF8\");\n    }\n}\n", "idx": 1900}
{"project": "cipher", "commit_id": "Snippet19640079_2367.java", "target": 0, "func": "import javax.crypto.Cipher;\nimport javax.crypto.SecretKey;\nimport javax.crypto.SecretKeyFactory;\nimport javax.crypto.spec.DESKeySpec;\n\nimport sun.misc.BASE64Decoder;\nimport sun.misc.BASE64Encoder;\n\n/**\n * @author rishad.ali\n *\n */\npublic class Security\n{\n    //The secret Key to encrypt and decrypt text\n    private SecretKey key = null;\n\n    /**\n     * Constructor of the class to generate Key\n     */\n    public Security(String secretCode)\n    {\n        try\n        {\n            DESKeySpec keySpec = new DESKeySpec(secretCode.getBytes(\"UTF8\")); \n            SecretKeyFactory keyFactory = SecretKeyFactory.getInstance(\"DES\");\n            key = keyFactory.generateSecret(keySpec);\n        }\n        catch (Exception e)\n        {\n            e.printStackTrace();\n        } \n    }\n    /**\n     * Returns the encrypted text for the given plain text.\n     * \n     * @param plainText - given plain text\n     * @return\n     */\n    public String encrypt (String plainText)\n    {\n        BASE64Encoder base64encoder = new BASE64Encoder();\n        //Encrypted Text to be sent\n        String encryptedText = \"\";\n        //Encrypt the plain text\n        try\n        {\n            byte[] cleartext = plainText.getBytes(\"UTF8\");      \n            Cipher cipher = Cipher.getInstance(\"DES\"); \n            cipher.init(Cipher.ENCRYPT_MODE, key);\n            encryptedText = base64encoder.encode(cipher.doFinal(cleartext));\n        }\n        catch (Exception e)\n        {\n            e.printStackTrace();\n        } \n        return encryptedText;\n    }\n\n    /**\n     * Returns the plain text for the given encrypted Text\n     * \n     * @param encryptedText - Given Encrypted Text\n     * @return\n     */\n    public String decrypt (String encryptedText)\n    {\n        sun.misc.BASE64Decoder base64decoder = new BASE64Decoder();\n        //Plain text to be sent\n        String plainText = \"\";\n        // Decrypt the  encrypted text\n        try\n        {\n            byte[] encrypedPwdBytes = base64decoder.decodeBuffer(encryptedText);\n            Cipher cipher = Cipher.getInstance(\"DES\");\n            cipher.init(Cipher.DECRYPT_MODE, key);\n            byte[] plainTextPwdBytes = (cipher.doFinal(encrypedPwdBytes));\n            plainText = new String(plainTextPwdBytes, \"US-ASCII\");\n        }\n        catch (Exception e)\n        {\n            e.printStackTrace();\n        } \n        return plainText;\n    }\n\n    public static void main (String args [])\n    {\n        Security sec = new Security(\"secrtkey\");\n        String text = \"sometext\";\n        System.out.println(\"Encrypted Text : \"+sec.encrypt(text));\n    }\n}\n", "idx": 1855}
{"project": "cipher", "commit_id": "Snippet31584918_13722.java", "target": 1, "func": "    Security.addProvider(new org.bouncycastle.jce.provider.BouncyCastleProvider());\n    Cipher cipher = Cipher.getInstance(\"RSA/ECB/PKCS1Padding\", \"BC\");\n\n    byte[] keyBytes =   Base64.decode(this.publicKey, 0);\n\n    /* the strToPublicKey is the previews code block */\n    PublicKey publickey = strToPublicKey(new String(keyBytes));\n    cipher.init( Cipher.ENCRYPT_MODE , publickey );\n\n    // Base 64 encode removed.\n    //byte[] encryptedBytes = Base64.encode( cipher.doFinal(plainText.getBytes()), 0 );\n    byte[] encryptedBytes = cipher.doFinal(plainText.getBytes());\n", "idx": 2320}
{"project": "cipher", "commit_id": "Snippet15147099_38225.java", "target": 0, "func": "public MyCipher() throws NoSuchAlgorithmException, NoSuchProviderException, NoSuchPaddingException, InvalidKeyException, UnsupportedEncodingException {\n    Security.addProvider(new BouncyCastleProvider());\n    KeyGenerator keyGen = KeyGenerator.getInstance(\"DESede\", \"BC\");\n    keyGen.init(new SecureRandom());\n    SecretKey keySpec = keyGen.generateKey();\n\n    this.sharedKey = keySpec.getEncoded().toString();\n    this.encrypter = Cipher.getInstance(\"DESede/ECB/Nopadding\", \"BC\");\n    this.encrypter.init(Cipher.ENCRYPT_MODE, keySpec);\n    this.decrypter = Cipher.getInstance(\"DESede/ECB/Nopadding\", \"BC\");\n    this.decrypter.init(Cipher.DECRYPT_MODE, keySpec);\n}\n", "idx": 1726}
{"project": "cipher", "commit_id": "Snippet37699169_19671.java", "target": 0, "func": "String key = \"Bar12345Bar12345\"; // 128 bit key\n// Create key and cipher\nKey aesKey = new SecretKeySpec(key.getBytes(), \"AES\");\nCipher cipher = Cipher.getInstance(\"AES\");\n// encrypt the text\ncipher.init(Cipher.ENCRYPT_MODE, aesKey);\nbyte[] encrypted = cipher.doFinal(text.getBytes());\nString e=new String(encrypted);\nbyte[] encrypted1 = cipher.doFinal(e.getBytes());\nSystem.out.println(encrypted.length+\" \"+encrypted1.length);\nSystem.out.println(e);\n// decrypt the text\ncipher.init(Cipher.DECRYPT_MODE, aesKey);\nString decrypted = new String(cipher.doFinal(encrypted));\nSystem.out.println(decrypted);\n", "idx": 1631}
{"project": "cipher", "commit_id": "Snippet1913971_30153.java", "target": 0, "func": "cipher = Cipher.getInstance(\"AES\");\n", "idx": 1660}
{"project": "cipher", "commit_id": "Snippet7415598_32720.java", "target": 0, "func": "byte[] input = \"6KzVyH0s3RyliBBAkcIrKOmripAUrDgBrm3VZR0VKkDlBTsHdOm/ONN1st/PBhquynxOjIPvgTfXJKx3aYDaARvCBmJwm1a0kfqFUcdpho+QSqpnqlDaBelL3taPKy2XPNmbOWlYUQtircPwcTrbOEUrQeUjEKqtataHw1tIp5c=\".getBytes();\n\n\n            String key1=\"12345891456\";\n\n           // byte[] keyBytes = new byte[] { 1234567891123456 };\n\n            byte[] keyBytes = null;\n            try {\n                keyBytes = key1.getBytes(\"UTF-16LE\");               \n\n            } catch (UnsupportedEncodingException e) {\n                // TODO Auto-generated catch block\n                e.printStackTrace();\n            }\n\n            SecretKeySpec key = new SecretKeySpec(keyBytes, \"AES\");\n\n            //key.init(128);\n\n            Cipher cipher = Cipher.getInstance(\"AES/ECB/PKCS7Padding\", \"BC\");\n\n            System.out.println(new String(input));\n\n            // encryption pass\n            cipher.init(Cipher.ENCRYPT_MODE, key);\n\n            byte[] cipherText = new byte[cipher.getOutputSize(input.length)];           \n            int ctLength = cipher.update(input, 0, input.length, cipherText, 0);       \n\n            // decryption pass\n            cipher.init(Cipher.DECRYPT_MODE, key);\n\n            byte[] plainText = new byte[cipher.getOutputSize(ctLength)];\n\n            int ptLength = cipher.update(cipherText, 0, ctLength, plainText, 0);\n\n            ptLength += cipher.doFinal(plainText, ptLength);\n            System.out.println(new String(plainText));\n            System.out.println(ptLength);\n          }\n", "idx": 1856}
{"project": "cipher", "commit_id": "Snippet38407929_20355.java", "target": 0, "func": "Cipher cipher = Cipher.getInstance(\"blowfish\");\n", "idx": 1788}
{"project": "cipher", "commit_id": "Snippet47000362_29006.java", "target": 1, "func": "        Cipher cipher = Cipher.getInstance(\"RSA\");\n        X509EncodedKeySpec keySpec = new X509EncodedKeySpec(encoded);\n        KeyFactory keyFactory = KeyFactory.getInstance(\"RSA\");\n        PublicKey pKey = keyFactory.generatePublic(keySpec);\n        cipher.init(Cipher.ENCRYPT_MODE, pKey);\n        encoded = cipher.doFinal(clearText.getBytes());\n", "idx": 2189}
{"project": "cipher", "commit_id": "Snippet10424334_34791.java", "target": 1, "func": "    KeySpec keySpec = new PBEKeySpec(password.toCharArray(), salt.getBytes(), iterationCount); \n\n    SecretKey key = SecretKeyFactory.getInstance( \n            \"PBEWithSHA1And128BitAES-CBC-BC\").generateSecret(keySpec);\n\n    Cipher cipher = Cipher.getInstance(\"AES/CBC/PKCS7Padding\", \"BC\");\n\n    cipher.init(Cipher.DECRYPT_MODE, key, new IvParameterSpec(iv.getBytes()));\n\n    byte[] decrypted = cipher.doFinal(encrypted);\n", "idx": 2329}
{"project": "cipher", "commit_id": "Snippet28600389_10762.java", "target": 1, "func": "public class FileActivity extends Activity{\n    @Override\n    protected void onCreate(Bundle savedInstanceState) {\n        // TODO Auto-generated method stub\n        super.onCreate(savedInstanceState);\n        setContentView(R.layout.activity_file);\n        encryptPDF();\n    }\n\npublic void encryptPDF() \n{\n    //CipherInputStream input=null;\n    /*FileInputStream fis=null ;\n    FileOutputStream fos=null;*/\n    // get the key\n\n    try {\n        final KeyGenerator generator = KeyGenerator.getInstance(\"AES\");\n        generator.init(128);\n        final SecretKey secretKey = generator.generateKey();\n\n        // perform encryption\n        Cipher cipher;\n        cipher = Cipher.getInstance(\"AES/CBC/PKCS5Padding\");\n\n    cipher.init(Cipher.ENCRYPT_MODE, secretKey);\n    FileInputStream fis = new FileInputStream(Environment.getExternalStorageDirectory()+\"/sample.pdf\");\n    FileOutputStream fos = new FileOutputStream(Environment.getExternalStorageDirectory()+\"/pdf_encrypt.enc\");\n    final CipherOutputStream output = new CipherOutputStream(fos, cipher);\n\n    int bytesRead = 0;\n    final byte[] plainText = new byte[4096];\n    while ((bytesRead = fis.read(plainText)) >= 0) {\n        output.write(plainText, 0, bytesRead);\n    }\n    output.flush();\n    output.close();\n    fos.close();\n    fis.close();\n    final byte[] iv = cipher.getIV();\n\n    // decrypt the file\n    cipher.init(Cipher.DECRYPT_MODE, secretKey, new IvParameterSpec(iv));\n    fis = new FileInputStream(Environment.getExternalStorageDirectory()+\"/pdf_encrypt.enc\");\n    fos = new FileOutputStream(Environment.getExternalStorageDirectory()+\"/test.pdf\");\n    CipherInputStream input = new CipherInputStream(fis, cipher);\n\n    final byte[] decryptedData = new byte[4096];\n    int decryptedRead;\n    while ((decryptedRead = input.read(decryptedData)) >= 0) {\n        fos.write(decryptedData, 0, decryptedRead);\n    }\n\n    fos.flush();\n    fos.close();\n    input.close();\n    fis.close();\n    } catch (Exception e) {\n        // TODO Auto-generated catch block\n        e.printStackTrace();\n    }\n}\n}\n", "idx": 2153}
{"project": "cipher", "commit_id": "Snippet11042742_35272.java", "target": 1, "func": "public static String encrypt(String value, String key) throws InvalidKeySpecException, NoSuchAlgorithmException, NoSuchPaddingException, InvalidKeyException, IllegalBlockSizeException, BadPaddingException {\n    byte[] bytes = value.getBytes(Charset.forName(\"UTF-8\"));\n    X509EncodedKeySpec x509 = new X509EncodedKeySpec(DatatypeConverter.parseBase64Binary(key));\n    KeyFactory factory = KeyFactory.getInstance(\"RSA\");\n    PublicKey publicKey = factory.generatePublic(x509);\n    Cipher cipher = Cipher.getInstance(\"RSA\");\n    cipher.init(Cipher.ENCRYPT_MODE, publicKey);\n    bytes = cipher.doFinal(bytes);\n    return DatatypeConverter.printBase64Binary(bytes);\n}\n", "idx": 2190}
{"project": "cipher", "commit_id": "Snippet11687169_35706.java", "target": 0, "func": "    public static byte[] key_reg = new byte[] {1, 2, 3, 4, 5,6, 7, 8, 9, 1, 2, 3, 4, 5, 6, 7};//... secret sequence of bytes\n\n    public static String getDecryptedString(byte[] data,int i){\n    String str = null;\n    try {\n        Cipher ci = Cipher.getInstance(\"AES/ECB/PKCS5Padding\",\"SunJCE\");\n        SecretKeySpec sk =   new SecretKeySpec(key_reg, \"AES\");\n        ci.init(Cipher.DECRYPT_MODE, sk);\n        byte[] dataD = ci.doFinal(data);\n        str = new String(dataD,\"UTF-8\");\n        return str;\n    } catch (Throwable e) {\n        logger.error(\"Error in getRequestString : \"+e);\n        e.printStackTrace();\n    }\n    return str;\n}\n", "idx": 1823}
{"project": "cipher", "commit_id": "Snippet35563149_17454.java", "target": 0, "func": "public static String encryptString(String string, String key){\n    try {\n        SecretKeySpec skeySpec = new SecretKeySpec(key.getBytes(), \"AES\");\n        Cipher cipher = Cipher.getInstance(\"AES\");\n        cipher.init(Cipher.ENCRYPT_MODE, skeySpec);\n        byte[] encrypted = cipher.doFinal(string.getBytes());\n        return Base64.encodeToString(encrypted, Base64.URL_SAFE);\n    } catch(Exception e){\n        return e.getMessage();\n    }\n}\n\nprivate static String decryptString(String string, String key){\n    try {\n        SecretKeySpec skeySpec = new SecretKeySpec(key.getBytes(), \"AES\");\n        Cipher cipher = Cipher.getInstance(\"AES\");\n        cipher.init(Cipher.DECRYPT_MODE, skeySpec);\n        byte[] decrypted = cipher.doFinal(string.getBytes());\n        return Base64.decode(decrypted, Base64.DEFAULT ).toString();\n\n    } catch(Exception e){\n        return null;\n    }\n}\n", "idx": 1833}
{"project": "cipher", "commit_id": "Snippet39259655_21146.java", "target": 1, "func": "private Cipher cipher;\nprivate SecretKey secretKey;\nprivate IvParameterSpec ivParameterSpec;\n\nint iterationCount = 1024;\nint keyStrength = 128;\n\nprivate String sampleInputForPassSaltIV = \"Abcd1234Abcd1234\";\n\nprivate String encryptInput = \"helloAES\";\nprivate String encryptedOutput = \"\";\nprivate String decryptedOutput = \"\";\n\npublic Boolean initializeEncryption() throws Exception {\n    String secretKeyAlgorithm = \"PBKDF2WithHmacSHA1\";\n\n    SecretKeyFactory secretKeyFactory;\n    KeySpec keySpec;\n    SecretKey secretKeyTemp;\n\n    String passPhrase = sampleInputForPassSaltIV;\n    String keySalt = sampleInputForPassSaltIV;\n\n    secretKeyFactory = SecretKeyFactory.getInstance(secretKeyAlgorithm);\n    keySpec = new PBEKeySpec(passPhrase.toCharArray(), keySalt.getBytes(), iterationCount, keyStrength);\n    secretKeyTemp = secretKeyFactory.generateSecret(keySpec);\n    secretKey = new SecretKeySpec(secretKeyTemp.getEncoded(), \"AES\");\n\n    byte[] IV = sampleInputForPassSaltIV.getBytes();\n    ivParameterSpec = new IvParameterSpec(IV);\n\n    cipher = Cipher.getInstance(\"AES/CBC/PKCS7Padding\");\n\n    return true;\n}\n\nprivate void encrypt(String dataToEncrypt) throws Exception {\n    if (dataToEncrypt.length() > 0) {\n        byte[] UTF8Data;\n        cipher.init(Cipher.ENCRYPT_MODE, secretKey, ivParameterSpec);\n        UTF8Data = cipher.doFinal(dataToEncrypt.getBytes());\n        encryptedOutput = Base64.encodeToString(UTF8Data, 0);\n\n        Toast toast = Toast.makeText(context, \"Encrypted Text : \" + encryptedOutput, Toast.LENGTH_LONG);\n        toast.show();\n    }\n}\n", "idx": 2292}
{"project": "cipher", "commit_id": "Snippet29030035_11100.java", "target": 1, "func": "private static SecretKey key = generateAESkey();\nprivate static String cipherString = \"AES/CBC/PKCS5Padding\";\n\npublic static void main(String[] args) throws Exception {\n    ByteArrayOutputStream log = new ByteArrayOutputStream();\n    appendToLog(\"Test1\", log);\n    appendToLog(\"Test2 is longer\", log);\n    appendToLog(\"Test3 is multiple of block size!\", log);\n    appendToLog(\"Test4 is shorter.\", log);\n\n    byte[] encLog = log.toByteArray();\n\n    List<String> logs = decryptLog(new ByteArrayInputStream(encLog));\n\n    for(String logLine : logs) {\n        System.out.println(logLine);\n    }\n}\n\nprivate static SecretKey generateAESkey() {\n    try {\n        return KeyGenerator.getInstance(\"AES\").generateKey();\n    } catch (NoSuchAlgorithmException e) {\n        e.printStackTrace();\n    }\n    return null;\n}\n\nprivate static byte[] generateIV() {\n    SecureRandom random = new SecureRandom();\n    byte[] iv = new byte[16];\n    random.nextBytes(iv);\n    return iv;\n}\n\npublic static void appendToLog(String s, OutputStream os) throws Exception {\n    Cipher cipher = Cipher.getInstance(cipherString);\n    byte[] iv = generateIV();\n    cipher.init(Cipher.ENCRYPT_MODE, key, new IvParameterSpec(iv));\n    byte[] data = cipher.doFinal(s.getBytes(\"UTF-8\"));\n    os.write(data.length);\n    os.write(iv);\n    os.write(data);\n}\n\npublic static List<String> decryptLog(InputStream is) throws Exception{\n    ArrayList<String> logs = new ArrayList<String>();\n    while(is.available() > 0) {\n        int len = is.read();\n        byte[] encLogLine = new byte[len];\n        byte[] iv = new byte[16];\n        is.read(iv);\n        is.read(encLogLine);\n\n        Cipher cipher = Cipher.getInstance(cipherString);\n        cipher.init(Cipher.DECRYPT_MODE, key, new IvParameterSpec(iv));\n        byte[] data = cipher.doFinal(encLogLine);\n        logs.add(new String(data, \"UTF-8\"));\n    }\n    return logs;\n}\n", "idx": 2077}
{"project": "cipher", "commit_id": "Snippet8973826_33596.java", "target": 1, "func": "//Generate a key\nKeyGenerator KeyGen = KeyGenerator.getInstance(\"AES\");\nKeyGen.init(128);\nSecretKey Key = KeyGen.generateKey();\n\n//Generate init vector\nSecureRandom rng = SecureRandom.getInstance(\"SHA1PRNG\");\nbyte [] IV = new byte[16];\nrng.nextBytes(IV);\n\n//Initialize the encryptor\nCipher ci = Cipher.getInstance(\"AES/CBC/NoPadding\"); //The spec might be different!\nci.init(Cipher.ENCRYPT_MODE, Key, new IvParameterSpec(IV));\n", "idx": 2233}
{"project": "cipher", "commit_id": "Snippet3183462_30680.java", "target": 0, "func": "cipher = Cipher.getInstance(\"AES\");\n", "idx": 1866}
{"project": "cipher", "commit_id": "Snippet27835498_9989.java", "target": 1, "func": "private  String RSA_Decryption(String encryptedData) \n        throws InvalidKeyException, NoSuchAlgorithmException, NoSuchPaddingException,     IOException, IllegalBlockSizeException, BadPaddingException, GeneralSecurityException \n{\n    BigInteger m = new BigInteger(\"verylongnumber1\");\n    BigInteger e = new BigInteger(\"verylongnumber2\");\n\n    RSAPrivateKeySpec keySpec = new RSAPrivateKeySpec(m, e);\n    KeyFactory fact = KeyFactory.getInstance(\"RSA\");\n    PrivateKey privateKey = fact.generatePrivate(keySpec);\n\n    Cipher cipher = Cipher.getInstance(\"RSA/ECB/PKCS1Padding\");\n    cipher.init(Cipher.DECRYPT_MODE, privateKey);\n    byte[] decordedValue = new BASE64Decoder().decodeBuffer(encryptedData);\n    byte[] decValue = cipher.doFinal(decordedValue);\n    String decryptedValue = new String(decValue, \"UTF-8\");\n\n    return decryptedValue;     \n}\n", "idx": 1978}
{"project": "cipher", "commit_id": "Snippet34933816_16901.java", "target": 1, "func": "public byte[] AESencrypt(String plainText, String encryptionKey) throws Exception {\n\n    Cipher cipher = Cipher.getInstance(\"AES/CBC/PKCS5Padding\");\n\n    SecretKeySpec key = new SecretKeySpec(encryptionKey.getBytes(\"UTF-8\"), \"AES\");\n\n    final byte[] iv = new byte[16];\n    Arrays.fill(iv, (byte) 0x00);\n    IvParameterSpec ivParameterSpec = new IvParameterSpec(iv);\n\n    cipher.init(Cipher.ENCRYPT_MODE, key,ivParameterSpec/*new IvParameterSpec(INITIALIZATIO_VECTOR.getBytes(\"UTF-8\"))*/);\n\n    return cipher.doFinal(plainText.getBytes(\"UTF-8\"));\n\n  }\n", "idx": 2159}
{"project": "cipher", "commit_id": "Snippet22230302_4635.java", "target": 0, "func": "KeyPairGenerator generator = KeyPairGenerator.getInstance(\"RSA\");\n        KeyPair keyPair = generator.generateKeyPair();\n        PublicKey publicKey = keyPair.getPublic();\n        PrivateKey privateKey = keyPair.getPrivate();\n\n        Cipher aes = Cipher.getInstance(\"AES/ECB/PKCS5Padding\");\n        aes.init(Cipher.ENCRYPT_MODE,publicKey);\n        byte[] cipherText = aes.doFinal(\"my password\".getBytes());\n        System.out.println(new String(cipherText));\n", "idx": 1609}
{"project": "cipher", "commit_id": "Snippet40390320_22257.java", "target": 0, "func": "final static byte[] KEY = {13, 92, 9, 7, 111, 84, 19, 3, 20, 76, 67, 47, 12, 2, 32, 99};\n\nfinal static Base64 ENCODER = new Base64(-1, new byte[0], true);\nfinal static Key S_KEY = new SecretKeySpec(KEY, \"AES\");\n\nstatic String encrypt(long aid) {\n    byte[] clear = Longs.toByteArray(aid);\n\n    try {\n        Cipher cipher = Cipher.getInstance(\"AES\");\n\n        cipher.init(Cipher.ENCRYPT_MODE, S_KEY);\n\n        byte[] bytes = cipher.doFinal(clear);\n\n        System.out.println(\"Byte array: \" + Arrays.toString(bytes));\n\n        return ENCODER.encodeAsString(bytes);\n\n    } catch (Exception e) {\n        e.printStackTrace();\n    }\n\n    return null;\n}\n", "idx": 1781}
{"project": "cipher", "commit_id": "Snippet40673746_22529.java", "target": 1, "func": "public class MCrypt {\n\n    private String iv = \"fedcba9876543210\";//Dummy iv (CHANGE IT!)\n    private IvParameterSpec ivspec;\n    private SecretKeySpec keyspec;\n    private Cipher cipher;\n\n    private String SecretKey = \"0123456789abcdef\";//Dummy secretKey (CHANGE IT!)\n\n    public MCrypt()\n    {\n        ivspec = new IvParameterSpec(iv.getBytes());\n\n        keyspec = new SecretKeySpec(SecretKey.getBytes(), \"AES\");\n\n        try {\n            cipher = Cipher.getInstance(\"AES/CBC/NoPadding\");\n//            cipher = Cipher.getInstance(\"AES/CBC/PKCS5Padding\");\n        } catch (NoSuchAlgorithmException e) {\n            // TODO Auto-generated catch block\n            e.printStackTrace();\n        } catch (NoSuchPaddingException e) {\n            // TODO Auto-generated catch block\n            e.printStackTrace();\n        }\n    }\n\n    public byte[] encrypt(String text) throws Exception\n    {\n        if(text == null || text.length() == 0)\n            throw new Exception(\"Empty string\");\n\n        byte[] encrypted = null;\n\n        try {\n            cipher.init(Cipher.ENCRYPT_MODE, keyspec, ivspec);\n\n            encrypted = cipher.doFinal(padString(text).getBytes());\n        } catch (Exception e)\n        {\n            throw new Exception(\"[encrypt] \" + e.getMessage());\n        }\n\n        return encrypted;\n    }\n\n    public byte[] decrypt(String code) throws Exception\n    {\n        if(code == null || code.length() == 0)\n            throw new Exception(\"Empty string\");\n\n        byte[] decrypted = null;\n\n        try {\n            cipher.init(Cipher.DECRYPT_MODE, keyspec, ivspec);\n\n            decrypted = cipher.doFinal(hexToBytes(code));\n        } catch (Exception e)\n        {\n            throw new Exception(\"[decrypt] \" + e.getMessage());\n        }\n        return decrypted;\n    }\n\n\n\n    public static String bytesToHex(byte[] data)\n    {\n        if (data==null)\n        {\n            return null;\n        }\n\n        int len = data.length;\n        String str = \"\";\n        for (int i=0; i<len; i++) {\n            if ((data[i]&0xFF)<16)\n                str = str + \"0\" + java.lang.Integer.toHexString(data[i]&0xFF);\n            else\n                str = str + java.lang.Integer.toHexString(data[i]&0xFF);\n        }\n        return str;\n    }\n\n\n    public static byte[] hexToBytes(String str) {\n        if (str==null) {\n            return null;\n        } else if (str.length() < 2) {\n            return null;\n        } else {\n            int len = str.length() / 2;\n            byte[] buffer = new byte[len];\n            for (int i=0; i<len; i++) {\n                buffer[i] = (byte) Integer.parseInt(str.substring(i*2,i*2+2),16);\n            }\n            return buffer;\n        }\n    }\n\n\n\n    private static String padString(String source)\n    {\n        char paddingChar = ' ';\n        int size = 16;\n        int x = source.length() % size;\n        int padLength = size - x;\n\n        for (int i = 0; i < padLength; i++)\n        {\n            source += paddingChar;\n        }\n\n        return source;\n    }\n", "idx": 2158}
{"project": "cipher", "commit_id": "Snippet1330032_29926.java", "target": 0, "func": "cipher = Cipher.getInstance(\"DESede/CBC/X9.23PADDING\");\n", "idx": 1851}
{"project": "cipher", "commit_id": "Snippet8771725_33495.java", "target": 1, "func": "import java.io.UnsupportedEncodingException;\nimport java.nio.charset.Charset;\nimport java.security.GeneralSecurityException;\nimport java.security.InvalidAlgorithmParameterException;\nimport java.security.InvalidKeyException;\nimport java.security.NoSuchAlgorithmException;\nimport java.security.NoSuchProviderException;\nimport java.security.Security;\nimport java.util.regex.Pattern;\n\nimport javax.crypto.BadPaddingException;\nimport javax.crypto.Cipher;\nimport javax.crypto.IllegalBlockSizeException;\nimport javax.crypto.NoSuchPaddingException;\nimport javax.crypto.SecretKey;\nimport javax.crypto.spec.IvParameterSpec;\nimport javax.crypto.spec.SecretKeySpec;\n\nimport org.bouncycastle.jce.provider.BouncyCastleProvider;\n\n/*\n * Add state handling! Don't allow same key/iv for encrypting different cipher text!\n */\npublic class AES {\n\n    private static Charset PLAIN_TEXT_ENCODING = Charset.forName(\"UTF-8\"); \n    private static String CIPHER_TRANSFORMATION = \"AES/CTR/NoPadding\";\n    private static String KEY_TYPE = \"AES\";\n    // 192 and 256 bits may not be available\n    private static int KEY_SIZE_BITS = 128;\n\n    private Cipher cipher;\n    private SecretKey key;\n    private IvParameterSpec iv;\n\n    static {\n        // only needed if the platform does not contain CTR encryption by default\n        if (Security.getProvider(BouncyCastleProvider.PROVIDER_NAME) == null) {\n            // only needed for some platforms I presume\n            Security.addProvider(new org.bouncycastle.jce.provider.BouncyCastleProvider());\n        }\n    }\n\n    public AES() throws NoSuchAlgorithmException, NoSuchPaddingException,\n            NoSuchProviderException {\n        // not much use without a getter\n//      final KeyGenerator kgen = KeyGenerator.getInstance(KEY_TYPE);\n//      kgen.init(KEY_SIZE_BITS);\n//      key = kgen.generateKey();\n        cipher = Cipher.getInstance(CIPHER_TRANSFORMATION);\n    }\n\n    public void setKeyHex(String keyText) {\n\n        byte[] bText = hexStringToByteArray(keyText);\n        if (bText.length * Byte.SIZE != KEY_SIZE_BITS) {\n            throw new IllegalArgumentException(\n                    \"Wrong key size, expecting \" + KEY_SIZE_BITS / Byte.SIZE + \" bytes in hex\");\n        }\n        key = new SecretKeySpec(bText, KEY_TYPE);\n    }\n\n    public void setIVHex(String ivText) {\n        byte[] bText = hexStringToByteArray(ivText);\n        if (bText.length != cipher.getBlockSize()) {\n            throw new IllegalArgumentException(\n                    \"Wrong IV size, expecting \" + cipher.getBlockSize() + \" bytes in hex\");\n        }\n        iv = new IvParameterSpec(bText);\n    }\n\n    public String encrypt(String message) throws InvalidKeyException,\n            IllegalBlockSizeException, BadPaddingException,\n            InvalidAlgorithmParameterException {\n        cipher.init(Cipher.ENCRYPT_MODE, key, iv);\n        byte[] encrypted = cipher.doFinal(message.getBytes(PLAIN_TEXT_ENCODING));\n        return byteArrayToHexString(encrypted);\n    }\n\n    public String decrypt(String hexCiphertext)\n            throws IllegalBlockSizeException, BadPaddingException,\n            InvalidKeyException, InvalidAlgorithmParameterException,\n            UnsupportedEncodingException {\n        cipher.init(Cipher.DECRYPT_MODE, key, iv);\n        byte[] dec = hexStringToByteArray(hexCiphertext);\n        byte[] decrypted = cipher.doFinal(dec);\n        return new String(decrypted, PLAIN_TEXT_ENCODING);\n    }\n\n    private static String byteArrayToHexString(byte[] raw) {\n        StringBuilder sb = new StringBuilder(2 + raw.length * 2);\n        sb.append(\"0x\");\n        for (int i = 0; i < raw.length; i++) {\n            sb.append(String.format(\"%02X\", Integer.valueOf(raw[i] & 0xFF)));\n        }\n        return sb.toString();\n    }\n\n    // better add some input validation\n    private static byte[] hexStringToByteArray(String hex) {\n        Pattern replace = Pattern.compile(\"^0x\");\n        String s = replace.matcher(hex).replaceAll(\"\");\n\n        byte[] b = new byte[s.length() / 2];\n        for (int i = 0; i < b.length; i++) {\n            int index = i * 2;\n            int v = Integer.parseInt(s.substring(index, index + 2), 16);\n            b[i] = (byte) v;\n        }\n        return b;\n    }\n\n    public static void main(String[] args) {\n        try {\n            String key = \"0x000102030405060708090A0B0C0D0E0F\";\n            String iv = \"0x000102030405060708090A0B0C0D0E0F\";\n\n            String text = \"Owlsteads answer\";\n            AES aes = new AES();\n            aes.setKeyHex(key);\n            aes.setIVHex(iv);\n            String cipherHex = aes.encrypt(text);\n            System.out.println(cipherHex);\n            String deciphered = aes.decrypt(cipherHex);\n            System.out.println(deciphered);\n        } catch (GeneralSecurityException e) {\n            throw new IllegalStateException(\"Something is rotten in the state of Denmark\", e);\n        } catch (UnsupportedEncodingException e) {\n            // not always thrown even if decryption fails, add integrity check such as MAC\n            throw new IllegalStateException(\"Decryption and/or decoding plain text message failed\", e);\n        }\n    }\n}\n", "idx": 2274}
{"project": "cipher", "commit_id": "Snippet43104256_25233.java", "target": 0, "func": "Cipher.getInstance(\"AES\");", "idx": 1685}
{"project": "cipher", "commit_id": "Snippet20655099_3255.java", "target": 1, "func": "    connection = (HttpURLConnection) url.openConnection();\n    connection.connect();\n    SecretKey secretKey = getSecretKey(context);\n    SecretKeySpec secretKeySpec = new SecretKeySpec(secretKey.getEncoded(), \"AES\");\n    Cipher cipher = Cipher.getInstance(\"AES/CBC/PKCS5Padding\");\n    spec = generateIv(cipher.getBlockSize());\n    cipher.init(Cipher.ENCRYPT_MODE, secretKeySpec, spec);\n\n    input = connection.getInputStream();\n    cis = new CipherInputStream(input, cipher);\n\n    String FILEPATH = context.getFilesDir().getParentFile().getPath();\n    File file = new File(FILEPATH, \"/download/\" + id + \"/\");\n       if (!file.exists()) {\n    file.mkdirs();\n    }\n\n    xmlFile = new File(FILEPATH + \"/download/\" + id + \"/\", \"xmldata.xml\");\n    output = new FileOutputStream(xmlFile);\n    cos = new CipherOutputStream(output, cipher);\n    byte data[] = new byte[4096];\n    int count;\n    while ((count = cis.read(data)) != -1) {\n       if (isCancelled()) throw new TaskCanceledException();\n          cos.write(data, 0, count);\n          progress = -1;\n          publishProgress();\n    }\n    if (isCancelled()) throw new TaskCanceledException();\n", "idx": 2118}
{"project": "cipher", "commit_id": "Snippet45971798_28074.java", "target": 0, "func": "public static void test() {\n    String stringToEncrypt = \"R\";\n    stringToEncrypt= Encryption.encrypt(stringToEncrypt);\n    System.out.println(stringToEncrypt);\n    stringToEncrypt= Encryption.decrypt(stringToEncrypt);\n    System.out.println(stringToEncrypt);\n}\n\npublic class Encryption {\n    private static final String key = \"ert25424o\";\n\n    public static String encrypt(String password){\n        try\n        {\n        Key clef = new SecretKeySpec(key.getBytes(\"ISO-8859-2\"),\"Blowfish\");\n        Cipher cipher=Cipher.getInstance(\"Blowfish\");\n        cipher.init(Cipher.ENCRYPT_MODE,clef);\n        return new String(cipher.doFinal(password.getBytes()));\n        }\n        catch (Exception e)\n        {\n            return null;\n        }\n    }\n\n    public static String decrypt(String password){\n        try\n        {\n            Key clef = new SecretKeySpec(key.getBytes(\"ISO-8859-2\"),\"Blowfish\");\n            Cipher cipher=Cipher.getInstance(\"Blowfish\");\n            cipher.init(Cipher.DECRYPT_MODE,clef);\n            return new String(cipher.doFinal(password.getBytes()));\n        }\n        catch (Exception e)\n        {\n            System.out.println(e);\n            return null;\n        }\n    }\n}\n", "idx": 1623}
{"project": "cipher", "commit_id": "Snippet23266933_5611.java", "target": 0, "func": "byte[] salt = { (byte) 0xc7, (byte) 0x73, (byte) 0x21, (byte) 0x8c,\n        (byte) 0x7e, (byte) 0xc8, (byte) 0xee, (byte) 0x99 };\nfileinputstrm = new FileInputStream(path);\n\nPBEKeySpec pbeKeySpec = new PBEKeySpec(\"pass\".toCharArray());\n\nPBEParameterSpec pbeParamSpec = new PBEParameterSpec(salt, 20);\nSecretKeyFactory keyFac = SecretKeyFactory.getInstance(\"PBEWithMD5AndDES\");\nSecretKey pbeKey = keyFac.generateSecret(pbeKeySpec);\n\nCipher pbeCipher = Cipher.getInstance(\"PBEWithMD5AndDES\");\npbeCipher.init(Cipher.DECRYPT_MODE, pbeKey, pbeParamSpec);\n\nFileInputStream fis=new FileInputStream(path);\nCipherInputStream cis=new CipherInputStream(fis, pbeCipher);\nBufferedInputStream bfi=new BufferedInputStream(cis);\nbfi.read();\ncis.close();\nFileOutputStream output1 = new FileOutputStream(path+\".jpeg\");\nByteArrayOutputStream baos=new ByteArrayOutputStream();\nBufferedOutputStream bfo=new BufferedOutputStream(output1);\noutput1.write(baos.toByteArray());\n", "idx": 1613}
{"project": "cipher", "commit_id": "Snippet31013532_13196.java", "target": 0, "func": "    SecretKeySpec sks = null;\n    try {\n        SecureRandom sr = SecureRandom.getInstance(\"SHA1PRNG\");\n        sr.setSeed(\"Complex Key for encryption\".getBytes());\n        KeyGenerator kg = KeyGenerator.getInstance(\"AES\");\n        kg.init(128, sr);\n        sks = new SecretKeySpec((kg.generateKey()).getEncoded(), \"AES\");\n    } catch (Exception e) {\n        Log.e(TAG, \"AES secret key spec error\");\n    }\n\n    // Encode the original data with AES\n    byte[] encodedBytes = null;\n    try {\n        Cipher c = Cipher.getInstance(\"AES\");\n        c.init(Cipher.ENCRYPT_MODE, sks);\n        encodedBytes = c.doFinal(theTestText.getBytes());\n    } catch (Exception e) {\n        Log.e(TAG, \"AES encryption error\");\n    }\n    TextView tvencoded = (TextView)findViewById(R.id.textitem2);\n    tvencoded.setText(\"[ENCODED]:\\n\" +\n            Base64.encodeToString(encodedBytes, Base64.DEFAULT) + \"\\n\");\n\n    // Decode the encoded data with AES\n    byte[] decodedBytes = null;\n    try {\n        Cipher c = Cipher.getInstance(\"AES\");\n        c.init(Cipher.DECRYPT_MODE, sks);\n        decodedBytes = c.doFinal(encodedBytes);\n    } catch (Exception e) {\n        Log.e(TAG, \"AES decryption error\");\n    }\n    TextView tvdecoded = (TextView)findViewById(R.id.textitem3);\n    tvdecoded.setText(\"[DECODED]:\\n\" + new String(decodedBytes) + \"\\n\");\n", "idx": 1740}
{"project": "cipher", "commit_id": "Snippet41073970_23022.java", "target": 1, "func": "try {\n    Calendar start = Calendar.getInstance();\n    Calendar end = Calendar.getInstance();\n    end.add(Calendar.YEAR, 1);\n\n    KeyPairGeneratorSpec spec = new KeyPairGeneratorSpec.Builder(this)\n        .setAlias(\"key1\")\n        .setSubject(new X500Principal(\"CN=Sample Name, O=Android Authority\"))\n        .setSerialNumber(BigInteger.ONE)\n        .setStartDate(start.getTime())\n        .setEndDate(end.getTime())\n        .build();\n\n    KeyPairGenerator generator = KeyPairGenerator.getInstance(\"RSA\", \"AndroidKeyStore\");\n    generator.initialize(spec);\n\n    // error in android 6: InvalidKeyException: Need RSA private or public key AndroidOpenSSL\n    // error in android 5: NoSuchProviderException: Provider not available: AndroidKeyStoreBCWorkaround\n    String provider = Build.VERSION.SDK_INT < Build.VERSION_CODES.M ? \"AndroidOpenSSL\" : \"AndroidKeyStoreBCWorkaround\";\n\n    KeyPair keyPair = generator.generateKeyPair();\n\n    Cipher inCipher = Cipher.getInstance(\"RSA/ECB/PKCS1Padding\", provider);\n    inCipher.init(Cipher.ENCRYPT_MODE, keyPair.getPublic());\n\n    Cipher outCipher = Cipher.getInstance(\"RSA/ECB/PKCS1Padding\", provider);\n    outCipher.init(Cipher.DECRYPT_MODE, keyPair.getPrivate());\n\n\n    ByteArrayOutputStream outputStream = new ByteArrayOutputStream();\n    CipherOutputStream cipherOutputStream = new CipherOutputStream(\n            outputStream, inCipher);\n\n    String plainText = \"This is a text\";\n\n    cipherOutputStream.write(plainText.getBytes(\"UTF-8\"));\n    cipherOutputStream.close();\n\n    String ecryptedText = Base64.encodeToString(outputStream.toByteArray(), Base64.DEFAULT);\n    Log.d(TAG, \"Encrypt = \" + ecryptedText);\n\n    String cipherText = ecryptedText;\n    CipherInputStream cipherInputStream = new CipherInputStream(\n            new ByteArrayInputStream(Base64.decode(cipherText, Base64.DEFAULT)), outCipher);\n\n    ArrayList<Byte> values = new ArrayList<>();\n    int nextByte;\n    while ((nextByte = cipherInputStream.read()) != -1) {\n        values.add((byte)nextByte);\n    }\n\n    byte[] bytes = new byte[values.size()];\n    for(int i = 0; i < bytes.length; i++) {\n        bytes[i] = values.get(i).byteValue();\n    }\n\n    String finalText = new String(bytes, 0, bytes.length, \"UTF-8\");\n    Log.d(TAG, \"Decrypt = \" + finalText);\n} catch (javax.crypto.NoSuchPaddingException e) {\n    Log.e(TAG, Log.getStackTraceString(e));\n} catch (IOException e) {\n    Log.e(TAG, Log.getStackTraceString(e));\n} catch (NoSuchAlgorithmException e) {\n    Log.e(TAG, Log.getStackTraceString(e));\n} catch (NoSuchProviderException e) {\n    Log.e(TAG, Log.getStackTraceString(e));\n} catch (InvalidAlgorithmParameterException e) {\n    Log.e(TAG, Log.getStackTraceString(e));\n} catch (InvalidKeyException e) {\n    Log.e(TAG, Log.getStackTraceString(e));\n} catch (UnsupportedOperationException e) {\n    Log.e(TAG, Log.getStackTraceString(e));\n}\n", "idx": 2025}
{"project": "cipher", "commit_id": "Snippet44048028_26114.java", "target": 0, "func": "import javax.crypto.Cipher;\nimport javax.crypto.KeyGenerator;\nimport javax.crypto.SecretKey;\n\npublic class Gen_DESAES_key{\n\n    public static void main(String[] args) {\n        byte[] message = \"Hello World\".getBytes();\n\n        KeyGenerator keygenerator = KeyGenerator.getInstance(\"DES\");\n        SecretKey desKey = keygenerator.generateKey();\n\n        Cipher desCipher = Cipher.getInstance(\"DES/ECB/PKCS5Padding\");\n        desCipher.init(Cipher.ENCRYPT_MODE,desKey);\n\n        byte[] encryptedMessage = desCipher.doFinal(message);\n    }\n}\n", "idx": 1790}
{"project": "cipher", "commit_id": "Snippet33619450_15690.java", "target": 1, "func": "byte[] keyBytes = Base64.decodeBase64(PUB_KEY);\ntry {\n        AlgorithmIdentifier rsaIdent = new AlgorithmIdentifier(PKCSObjectIdentifiers.rsaEncryption);\n        SubjectPublicKeyInfo kInfo = new SubjectPublicKeyInfo(rsaIdent, keyBytes);\n        ASN1Primitive primKey = kInfo.parsePublicKey();\n        byte[] encoded = primKey.getEncoded();\n        byte[] sessionBytes = Base64.decodeBase64(\"Zm/qR/FrkzawabBZYk7WfQJNMVZoZrwWTvfQwIhPMzAuqEO+y+sb/x9+TZwTbqmu45/GV4yhKv0bbDL8F6rif7RJap7iQUFQBDEIAraY42IGZ8pB6A0Q0RSnJWW+tLTLJg5cTrgZQ8sLoO+U03T6DE1wy73FU5h6XhXxZERo0tQ=\");\n        Security.addProvider(new BouncyCastleProvider());\n        X509EncodedKeySpec spec = new X509EncodedKeySpec(encoded);\n        KeyFactory factory = KeyFactory.getInstance(spec.getFormat());\n        Cipher cipher = Cipher.getInstance(\"RSA\", \"BC\");\n        cipher.init(Cipher.DECRYPT_MODE, factory.generatePublic(spec));\n        // ----- THIS IS WHERE IT BREAKS -----\n        byte[] decrypted = cipher.doFinal(sessionBytes);\n        String tada = new String(decrypted, StandardCharsets.UTF_8);\n} catch (Exception e) { ... }\n", "idx": 2101}
{"project": "cipher", "commit_id": "Snippet21995426_4428.java", "target": 0, "func": "String decodee = \"1234\";\nString key = \"oY3[r.Ri4oF\";\nString iv = \"\\0\\0\\0\\0\\0\\0\\0\\0\";\n\nSecretKeySpec keySpec = new SecretKeySpec(key.getBytes(), \"Blowfish\");\nIvParameterSpec ivSpec = new IvParameterSpec(iv.getBytes());\n\nCipher cipher = Cipher.getInstance(\"Blowfish/CFB/NoPadding\");\ncipher.init(Cipher.DECRYPT_MODE, keySpec, ivSpec);\n\nbyte[] res = cipher.doFinal(decodee.getBytes());\nString s = new String(res);  \nint[] x = new int[s.length()]; for (int i = 0 ; i < s.length() ; i++) x[i] = (int) s.charAt(i);\nSystem.out.println(Arrays.toString(x));\n", "idx": 1608}
{"project": "cipher", "commit_id": "Snippet43172704_25313.java", "target": 1, "func": "byte[] iv = new byte[16];\nbyte[] salt = new byte[32];\nbyte[] ctChunk = new byte[8192]; // not for whole ciphertext, just a buffer\n\nif (16 != fileInputStream.read(iv) || 32 != fileInputStream.read(salt)) {\n    throw new Exception(\"IV or salt too short\");\n}\n\nKeySpec keySpec = new PBEKeySpec(submittedPassword.toCharArray(), salt, 1000, 256);\nSecretKeyFactory keyFactory = SecretKeyFactory.getInstance(\"PBKDF2WithHmacSHA1\");\nbyte[] keyBytes = keyFactory.generateSecret(keySpec).getEncoded();\nSecretKey key = new SecretKeySpec(keyBytes, \"AES\");\nCipher cipher = Cipher.getInstance(\"AES/CBC/PKCS5Padding\");\nIvParameterSpec ivParams = new IvParameterSpec(iv);\ncipher.init(Cipher.DECRYPT_MODE, key, ivParams);\n\nint read;\nByteArrayOutputStream ctBaos = new ByteArrayOutputStream();\nwhile((read = fileInputStream.read(ctChunk)) > 0) {\n    ctBaos.write(cipher.update(cipherText, 0, read));\n}\nctBaos.write(cipher.doFinal());\n\nString plainrStr = new String(ctBaos.toByteArray(), \"UTF-8\");\ntextEdit.setText(plainrStr);\n", "idx": 2175}
{"project": "cipher", "commit_id": "Snippet15882476_38874.java", "target": 0, "func": "Cipher cipher = Cipher.getInstance(\"AES/ECB/NoPadding\");\n", "idx": 1712}
{"project": "cipher", "commit_id": "Snippet37646385_19594.java", "target": 0, "func": "public static void main(String[] args) {\n    String data = getData();\n    String key = generateKey();\n    byte[] encrypted = encryptData(data, key);\n    String str_encrypted = new String(encrypted);\n    String url = pushToServer(str_encrypted);\n}\n\nprivate static byte[] encryptData(String data, String key) {\n\n    try {\n        MessageDigest md = MessageDigest.getInstance(\"MD5\");\n\n        md.update(key.getBytes(\"UTF-8\"));\n        byte[] digest = md.digest();\n\n        Cipher c = Cipher.getInstance(\"AES\");\n        SecretKeySpec k = new SecretKeySpec(digest, \"AES\");\n        c.init(Cipher.ENCRYPT_MODE, k);\n\n        byte[] tobeencrypted = data.getBytes(\"UTF-8\");\n\n        return c.doFinal(tobeencrypted);\n    } catch (Exception e) {\n        e.printStackTrace();\n    }\n    return null;\n\n}\n", "idx": 1772}
{"project": "cipher", "commit_id": "Snippet17339677_575.java", "target": 1, "func": "private static byte[] INITIALIZATION_VECTOR = new byte[] { 0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00 };\npublic static String encrypt(String token) {\n    Cipher cipher = null;\n    SecretKey key = null;\n    String tokenAsHex = null;\n    byte[] encryptedToken = null;\n    byte[] sksKey = \"6iOmT2V6mnd0\".getBytes(); // SecretKeySpec key.\n\n    try {\n        key = new SecretKeySpec(sksKey, \"AES\");\n        AlgorithmParameterSpec paramSpec = new IvParameterSpec(INITIALIZATION_VECTOR);\n        cipher = Cipher.getInstance(\"AES/CBC/PKCS5Padding\"); \n        cipher.init(Cipher.ENCRYPT_MODE, key, paramSpec);\n        encryptedToken = cipher.doFinal(token.getBytes(\"UTF-8\"));\n    } catch (Exception e) {\n        e.printStackTrace();\n    }\n    return Base64.encodeBase64String(encryptedToken);\n}\n\npublic static String decrypt(String token) {\n    Cipher cipher = null;\n    SecretKey key = null;\n    byte[] decryptedToken = null;\n    byte[] sksKey = \"6iOmT2V6mnd0\".getBytes(); // SecretKeySpec key.\n    try {\n        key = new SecretKeySpec(sksKey, \"AES\");            \n        AlgorithmParameterSpec paramSpec = new IvParameterSpec(INITIALIZATION_VECTOR);\n        cipher = Cipher.getInstance(\"AES/CBC/PKCS5Padding\"); \n        cipher.init(Cipher.DECRYPT_MODE, key, paramSpec);\n        decryptedToken = cipher.doFinal(Base64.decodeBase64(token));\n    } catch(Exception e){\n        e.printStackTrace();    \n    }\n    if (decryptedToken == null) {\n         System.out.println(\"Unable to decrypt the following token: \" + token);\n    }\n    return new String(decryptedToken);\n}\n", "idx": 2301}
{"project": "cipher", "commit_id": "Snippet29748971_11821.java", "target": 1, "func": "public String encrypt(String message, String Modulus, String Exponent) {\n        String outputEncrypted = \"\";\n        try {\n             byte[] modulusBytes = Base64Coder.decode(Modulus);\n               byte[] exponentBytes = Base64Coder.decode(Exponent);\n               BigInteger modulus = new BigInteger(modulusBytes );               \n               BigInteger exponent = new BigInteger(exponentBytes);\n\n               RSAPublicKeySpec rsaPubKey = new RSAPublicKeySpec(modulus, exponent);\n               KeyFactory fact = KeyFactory.getInstance(\"RSA\");\n               PublicKey pubKey = fact.generatePublic(rsaPubKey);\n\n               Cipher cipher = Cipher.getInstance(\"RSA/ECB/PKCS1Padding\");\n               cipher.init(Cipher.ENCRYPT_MODE, pubKey);\n\n               byte[] plainBytes = new String(\"abc\").getBytes(\"UTF-8\");\n               byte[] cipherData = cipher.doFinal( plainBytes );\n               String encryptedString = new String(Base64Coder.encode(cipherData));\n               Log.i(this.getClass().getSimpleName(), \"encryptedString : \"+encryptedString);\n        } catch (Exception e) {\n            // TODO: handle exception\n        }\n        return outputEncrypted;\n    }\n", "idx": 2283}
{"project": "cipher", "commit_id": "Snippet33768305_15797.java", "target": 0, "func": "String key = \"012345678901234567890123\";\nString clearText = \"test\";\n\nMessageDigest md = MessageDigest.getInstance(\"md5\");\nbyte[] digestOfPassword = md.digest(key.getBytes(\"UTF-16LE\"));\n\nbyte[] keyBytes = Arrays.copyOf(digestOfPassword, 24);\nString byteText = Arrays.toString(keyBytes);\n\nfor (int j = 0, k = 16; j < 8;) {\n  keyBytes[k++] = keyBytes[j++];\n}\n\nSecretKey secretKey = new SecretKeySpec(keyBytes, 0, 24, \"DESede\");\n\nIvParameterSpec iv = new IvParameterSpec(new byte[8]);\nCipher cipher = Cipher.getInstance(\"DESede/CBC/PKCS5Padding\");\n\ncipher.init(Cipher.ENCRYPT_MODE, secretKey, iv);\n\nbyte[] plainTextBytes = clearText.getBytes(\"UTF-16LE\");\nbyte[] cipherText = cipher.doFinal(plainTextBytes);\n\nString output = Base64.encode(cipherText);\n", "idx": 1767}
{"project": "cipher", "commit_id": "Snippet26367225_8500.java", "target": 1, "func": "byteArrayMessage = plainMessage.getBytes(ENCODING);\nint keySize = keyMode;\nint maxBlockSize = (keySize / 8 - 11);\nint blocksCount = (int) Math.ceil((double) byteArrayMessage.length / maxBlockSize);\nbyte[][] blocksCollection = new byte[blocksCount][];\nKeyFactory kf = null;\nX509EncodedKeySpec pubSpec = new X509EncodedKeySpec(ConvertData.hexStringToByteArray(hexPubliKey));\nPublicKey pubKey = null;\nkf = KeyFactory.getInstance(\"RSA\");\npubKey = kf.generatePublic(pubSpec);\ncipher = Cipher.getInstance(\"RSA/ECB/PKCS1Padding\");\ncipher.init(Cipher.ENCRYPT_MODE, pubKey);\n\n// encoding\n        byte[] encrypted = null;\n        int i = 0;\n        int startIndex;\n        int endIndex;\n        int sizeOfBlocks = 0;\n        while (i < blocksCount) {\n            startIndex = i * (maxBlockSize);\n            endIndex = startIndex + maxBlockSize;\n            try {\n                encrypted = cipher.doFinal((Arrays.copyOfRange(byteArrayMessage, startIndex, endIndex)));\n                sizeOfBlocks += encrypted.length;\n            } catch (UnsupportedEncodingException e) {\n                e.printStackTrace();\n            }\n            blocksCollection[i] = encrypted;\n            i++;\n        }\n\n\n        i = 0;\n        int n = blocksCollection.length;\n        String gluedEncodedData = \"\";\n        String encodedChunk;\n        while (i < n) {\n            encodedChunk = (ConvertData.byteArrayToHexString(blocksCollection[i]));\n            gluedEncodedData += encodedChunk;\n            i++;\n        }\n        Logger.trace(\"Glued Encoded data \" + gluedEncodedData);\n        return gluedEncodedData;\n", "idx": 1986}
{"project": "cipher", "commit_id": "Snippet24322021_6593.java", "target": 1, "func": "public String RSAEncrypt (final String plain) throws Exception \n{\n    try{\n        String strModulus = \"tr82UfeGetV7yBKcOPjFTWs7pHqqr/5YKKWMUZ/HG4HnCmWrZsOhuR1FBnMZ/g2YiosoSlu0zd7Ukz9lX7wv2RLfWXfMvZYGpAAvfYWwzbyQ2i1q+tKE/thgKNscoSRellDD+uJcYn1H4hnaudVyYJH9miVhOKhKlExMzw8an6U=\";\n        String strExponent = \"AQAB\";\n        byte[] modulusBytes = strModulus.getBytes();\n        byte[] exponentBytes = strExponent.getBytes();\n        BigInteger modulus = new BigInteger(1, modulusBytes );               \n        BigInteger exponent = new BigInteger(1, exponentBytes);\n\n        RSAPublicKeySpec rsaPubKey = new RSAPublicKeySpec(modulus, exponent);\n        KeyFactory fact = KeyFactory.getInstance(\"RSA\");\n        PublicKey pubKey = fact.generatePublic(rsaPubKey);\n\n        Cipher cipher = Cipher.getInstance(\"RSA/ECB/PKCS1Padding\");\n        cipher.init(Cipher.ENCRYPT_MODE, pubKey);\n\n        byte[] plainBytes = new String(\"Manchester United\").getBytes(\"UTF-8\");\n        byte[] cipherData = cipher.doFinal(plainBytes);\n        encryptedString = Base64.encodeToString(cipherData, Base64.NO_PADDING);\n    }\n    catch(Exception e){\n        Log.e(\"Error\", e.toString());\n    }\n\n    return encryptedString;\n}\n", "idx": 2195}
{"project": "cipher", "commit_id": "Snippet15720077_38723.java", "target": 0, "func": "public class Cryptography {\nprivate static final String CRYPTOGRAPHY_ALGO_DES = \"DES\";\n\nprivate static Cipher cipher = null;\nprivate static DESKeySpec keySpec = null;\nprivate static SecretKeyFactory keyFactory = null;\n\npublic static String encrypt(String inputString, String commonKey)\n        throws InvalidKeyException, IllegalBlockSizeException,\n        BadPaddingException {\n\n    String encryptedValue = \"\";\n    SecretKey key = getSecretKey(commonKey);\n\n    cipher.init(Cipher.ENCRYPT_MODE, key);\n    byte[] inputBytes = inputString.getBytes();\n    byte[] outputBytes = cipher.doFinal(inputBytes);\n\n    encryptedValue =  new String(Base64.encodeBase64(outputBytes));\n    return encryptedValue;\n}\n\npublic static String decrypt(String encryptedString, String commonKey)\n    throws InvalidKeyException, IllegalBlockSizeException,\n    BadPaddingException, IOException {\n\nString decryptedValue = \"\";\nencryptedString = encryptedString.replace(' ', '+');\n\nSecretKey key = getSecretKey(commonKey);\n\ncipher.init(Cipher.DECRYPT_MODE, key); \n\nbyte[] decodeBytes=Base64.decodeBase64(encryptedString.getBytes());\n\ncipher.update(decodeBytes);\nbyte[] recoveredBytes = cipher.doFinal( );\nSystem.out.println(\" recovered bytes\\t\" + recoveredBytes);\ndecryptedValue = new String(recoveredBytes);\nSystem.out.println(\" decryptedvalue **strong text**\\t\" + decryptedValue);\nreturn decryptedValue;\n\n}\n\nprivate static SecretKey getSecretKey(String secretPassword) {\nSecretKey key = null;\ntry {\n    cipher = Cipher.getInstance(CRYPTOGRAPHY_ALGO_DES);\n    keySpec = new DESKeySpec(secretPassword.getBytes(\"UTF8\"));\n    keyFactory = SecretKeyFactory.getInstance(CRYPTOGRAPHY_ALGO_DES);\n    key = keyFactory.generateSecret(keySpec);\n} catch (Exception e) {\n    e.printStackTrace();\n    System.out.println(\"Error in generating the secret Key\");\n}\nreturn key;\n}\n\n}\n", "idx": 1734}
{"project": "cipher", "commit_id": "Snippet23821923_6126.java", "target": 0, "func": "import java.security.spec.AlgorithmParameterSpec;\nimport java.security.spec.KeySpec;\n\nimport javax.crypto.Cipher;\nimport javax.crypto.SecretKey;\nimport javax.crypto.SecretKeyFactory;\nimport javax.crypto.spec.PBEKeySpec;\nimport javax.crypto.spec.PBEParameterSpec;\n\nimport org.apache.commons.codec.binary.Base64;\nimport org.apache.commons.lang3.StringUtils;\nimport org.springframework.beans.factory.config.PropertyPlaceholderConfigurer;\n\npublic class EncryptedPropertyPlacementConfigurer extends PropertyPlaceholderConfigurer\n{\n    /** algorithm used for encrpytion and decryption */\n    private static final String ALGORITHM = \"PBEWithMD5AndDES\";\n\n    /** 8-byte Salt. */\n    private static final byte[] SALT = { ... };\n\n    /** Iteration count. */\n    private static final int ITERATION_COUNT = 19;\n\n    /** Stores parameter specification. */\n    private static final AlgorithmParameterSpec PARAM_SPEC = new PBEParameterSpec(SALT, ITERATION_COUNT);\n\n    //All properties starting with !! will be decrypted.\n    private static final String ENCRYPTIGION_LEADIN = \"!!\";\n\n    public static class EncrypterException extends RuntimeException\n    {\n        private static final long serialVersionUID = -7336009350594115318L;\n\n        public EncrypterException(final String message, final Throwable cause)\n        {\n            super(message, cause);\n        }\n\n        public EncrypterException(final String message)\n        {\n            super(message);\n        }\n    }\n\n    private static String decrypt(final String passPhrase, final String message)\n    {\n        // Create the key\n        final KeySpec keySpec = new PBEKeySpec(passPhrase.toCharArray(), SALT, ITERATION_COUNT);\n        SecretKey key;\n        try\n        {\n            key = SecretKeyFactory.getInstance(ALGORITHM).generateSecret(keySpec);\n        }\n        catch (final Exception e)\n        {\n            throw new EncrypterException(\"Error setting up encryption details.\", e);\n        }\n\n        if (!Base64.isBase64(message))\n        {\n            throw new EncrypterException(\"Message is not a valid base64 message.\");\n        }\n\n        final String result;\n        try\n        {\n            final Cipher cipher = Cipher.getInstance(ALGORITHM);\n\n            cipher.init(Cipher.DECRYPT_MODE, key, PARAM_SPEC);\n\n            final byte[] dec = Base64.decodeBase64(message);\n\n            result = new String(cipher.doFinal(dec), \"UTF-8\");\n        }\n        catch (final Exception e)\n        {\n            throw new EncrypterException(\"Error decrypting content.\", e);\n        }\n\n        return result;\n    }\n\n    @Override\n    protected String convertPropertyValue(final String originalValue)\n    {\n        if (StringUtils.isNotBlank(originalValue) && originalValue.startsWith(ENCRYPTIGION_LEADIN))\n        {\n            return decrypt(\"<Your magic password>\", originalValue.substring(2));\n        }\n        return super.convertPropertyValue(originalValue);\n    }\n\n}\n", "idx": 1704}
{"project": "cipher", "commit_id": "Snippet41521341_23446.java", "target": 1, "func": "    SecretKeySpec skeySpec = new SecretKeySpec(EclassExtend.b().getBytes(), \"AES\");\n    Cipher cipher;\n\n    byte[] decryptedData=null;\n    CipherInputStream cis=null;\n\n    try {\n        cipher = Cipher.getInstance(\"AES/CBC/PKCS5Padding\");\n        cipher.init(Cipher.DECRYPT_MODE, skeySpec, new IvParameterSpec(iv));\n\n        // Create CipherInputStream to read and decrypt the image data\n        cis = new CipherInputStream(fis, cipher);\n\n        // Write encrypted image data to ByteArrayOutputStream\n        ByteArrayOutputStream buffer = new ByteArrayOutputStream();\n        byte[] data = new byte[2048];\n\n        while ((cis.read(data)) != -1) {\n            buffer.write(data);\n        }\n        buffer.flush();\n        decryptedData = buffer.toByteArray();\n\n    }catch(Exception e){\n        e.printStackTrace();\n    }\n    finally{\n        try {\n            fis.close();\n            cis.close();\n        } catch (IOException e) {\n\n            e.printStackTrace();\n        }\n    }\n    return decryptedData;\n}\n", "idx": 2084}
{"project": "cipher", "commit_id": "Snippet15054877_38108.java", "target": 1, "func": "public String encrypt(String smsbody) {\n    try {\n\n        KeyPairGenerator kpg = KeyPairGenerator.getInstance(\"RSA\");\n\n        kpg.initialize(512);// initialize key pairs to 512 bits ,you can\n                            // also take 1024 or 2048 bits\n\n        KeyPair kp = kpg.genKeyPair();\n\n        PublicKey publi = kp.getPublic();\n        System.out.println(publi.serialVersionUID);\n        Cipher cipher = Cipher.getInstance(\"RSA\");\n\n        cipher.init(Cipher.ENCRYPT_MODE, publi);\n\n        byte[] src = smsbody.getBytes();// converting source data into byte\n                                        // array\n\n        byte[] cipherData = cipher.doFinal(src);// use this method to\n                                                // finally encrypt data\n\n        String srco = new String(cipherData);// converting byte array into\n                                                // string\n        // System.out.println();\n        // System.out.println(\"Encrypted data is:-\" + srco);\n\n        return srco;\n    } catch (Exception e) {\n        System.out.println(e.getMessage());\n    }\n    return \"\";\n}\n\npublic PrivateKey Privatekey() {\n\n    try {\n        kpg = KeyPairGenerator.getInstance(\"RSA\");\n\n        kpg.initialize(512);// initialize key pairs to 512 bits ,you can\n                            // also take 1024 or 2048 bits\n\n        KeyPair kp = kpg.genKeyPair();\n        privatei = kp.getPrivate();// Generating private key\n    } catch (NoSuchAlgorithmException e) {\n        // TODO Auto-generated catch block\n        e.printStackTrace();\n    }\n\n    return privatei;\n}\n\npublic String decrypt(String smsbody, PrivateKey privatei) {\n    try {\n\n        Cipher cipheri = Cipher.getInstance(\"RSA\");\n\n        cipheri.init(Cipher.DECRYPT_MODE, privatei);// Setting to\n                                                    // decrypt_mode\n\n\n        System.out.println(smsbody);\n\n        byte[] cipherDat = cipheri.doFinal(smsbody.getBytes());// Finally\n                                                                // decrypting\n        // data\n        System.out.println(cipherDat);\n        String decryptdata = new String(cipherDat);\n\n\n        return decryptdata;\n    } catch (Exception e) {\n        System.out.println(e.getMessage());\n    }\n    return \"\";\n} `\n", "idx": 2019}
{"project": "cipher", "commit_id": "Snippet15196101_38283.java", "target": 1, "func": "Cipher.getInstance(\"AES/CBC/PKCS5Padding\");", "idx": 1960}
{"project": "cipher", "commit_id": "Snippet9425913_33902.java", "target": 1, "func": "public class MCrypt {\n\nprivate String iv ;//Dummy iv (CHANGE IT!)\nprivate IvParameterSpec ivspec;\nprivate SecretKeySpec keyspec;\nprivate Cipher cipher;\n\nprivate String SecretKey = \"khaleed\";//Dummy secretKey (CHANGE IT!)\n\npublic MCrypt(String firstpar1)\n{\n    iv=firstpar1;//firstpar1 can be aroung 40-50 characters long\n\n        ivspec = new IvParameterSpec(iv.getBytes());\n\n        keyspec = new SecretKeySpec(SecretKey.getBytes(), \"AES\");\n\n        try {\n                cipher = Cipher.getInstance(\"AES/CBC/NoPadding\");\n        } catch (NoSuchAlgorithmException e) {\n                // TODO Auto-generated catch block\n                e.printStackTrace();\n        } catch (NoSuchPaddingException e) {\n                // TODO Auto-generated catch block\n                e.printStackTrace();\n        }\n        System.out.println(6666);\n}\n\npublic byte[] encrypt(String text) throws Exception\n{\n        if(text == null || text.length() == 0)\n                throw new Exception(\"Empty string\");\n\n        byte[] encrypted = null;\n\n        try {\n                cipher.init(Cipher.ENCRYPT_MODE, keyspec, ivspec);\n\n                encrypted = cipher.doFinal(padString(text).getBytes());\n        } catch (Exception e)\n        {                       \n                throw new Exception(\"[encrypt] \" + e.getMessage());\n        }\n\n        return encrypted;\n}\n\npublic byte[] decrypt(String code) throws Exception\n{\n        if(code == null || code.length() == 0)\n                throw new Exception(\"Empty string\");\n\n        byte[] decrypted = null;\n\n        try {\n                cipher.init(Cipher.DECRYPT_MODE, keyspec, ivspec);\n\n                decrypted = cipher.doFinal(hexToBytes(code));\n        } catch (Exception e)\n        {\n                throw new Exception(\"[decrypt] \" + e.getMessage());\n        }\n        return decrypted;\n}\n\n\n\npublic static String bytesToHex(byte[] data)\n{\n        if (data==null)\n        {\n                return null;\n        }\n\n        int len = data.length;\n        String str = \"\";\n        for (int i=0; i<len; i++) {\n                if ((data[i]&0xFF)<16)\n                        str = str + \"0\" + java.lang.Integer.toHexString(data[i]&0xFF);\n                else\n                        str = str + java.lang.Integer.toHexString(data[i]&0xFF);\n        }\n        return str;\n}\n\n\npublic static byte[] hexToBytes(String str) {\n        if (str==null) {\n                return null;\n        } else if (str.length() < 2) {\n                return null;\n        } else {\n                int len = str.length() / 2;\n                byte[] buffer = new byte[len];\n                for (int i=0; i<len; i++) {\n                        buffer[i] = (byte) Integer.parseInt(str.substring(i*2,i*2+2),16);\n                }\n                return buffer;\n        }\n}\n\n\n\nprivate static String padString(String source)\n{\n  char paddingChar = ' ';\n  int size = 16;\n  int x = source.length() % size;\n  int padLength = size - x;\n\n  for (int i = 0; i < padLength; i++)\n  {\n          source += paddingChar;\n  }\n\n  return source;\n}\n}\n", "idx": 2284}
{"project": "cipher", "commit_id": "Snippet39099542_20980.java", "target": 1, "func": "public byte[] encrypt(byte[] data, byte[] key) throws Exception {\n    SecretKeySpec keySpec = new SecretKeySpec(key, \"AES\");\n    byte[] iv = new byte[16];\n    IvParameterSpec ivSpec = new IvParameterSpec(iv);\n    Cipher acipher = Cipher.getInstance(\"AES/CBC/PKCS5Padding\");\n    byte[] arrayOfByte1;\n    acipher.init(Cipher.ENCRYPT_MODE, keySpec, ivSpec);\n    arrayOfByte1 = acipher.doFinal(data);\n    return arrayOfByte1;\n}\n", "idx": 2154}
{"project": "cipher", "commit_id": "Snippet22035187_4449.java", "target": 0, "func": "private static String decrypt_data(String encData)\n        throws NoSuchAlgorithmException, NoSuchPaddingException,\n        InvalidKeyException, IllegalBlockSizeException, BadPaddingException {\n    String key = \"bad8deadcafef00d\";\n    SecretKeySpec skeySpec = new SecretKeySpec(key.getBytes(), \"AES\");\n    Cipher cipher = Cipher.getInstance(\"AES\");\n\n    cipher.init(Cipher.DECRYPT_MODE, skeySpec);\n\n    System.out.println(\"Base64 decoded: \"\n            + Base64.decode(encData.getBytes()).length);\n    byte[] original = cipher\n            .doFinal(Base64.decode(encData.getBytes()));\n    return new String(original).trim();\n}\n\nprivate static String encrypt_data(String data)\n        throws Exception {\n    String key = \"bad8deadcafef00d\";\n    SecretKeySpec skeySpec = new SecretKeySpec(key.getBytes(), \"AES\");\n    Cipher cipher = Cipher.getInstance(\"AES\");\n\n    cipher.init(Cipher.ENCRYPT_MODE, skeySpec);\n\n    System.out.println(\"Base64 encoded: \"\n            + Base64.encode(data.getBytes()).length);\n\n    byte[] original = Base64.encode(cipher.doFinal(data.getBytes()));\n    return new String(original);\n}\n", "idx": 1816}
{"project": "cipher", "commit_id": "Snippet29535663_11569.java", "target": 1, "func": "private static String password;\nprivate static String salt;\nprivate static int pswdIterations = 65536  ;\nprivate static int keySize = 256;\nprivate byte[] ivBytes;\n\npublic void encryptOfFile(byte[] bytes, File out) throws Exception {  \n\n    byte[] saltBytes = salt.getBytes(\"UTF-8\");\n\n    System.out.println(\"Salt bfre:\" +salt);\n\n    // Derive the key\n    SecretKeyFactory factory = SecretKeyFactory.getInstance(\"PBKDF2WithHmacSHA1\");\n    PBEKeySpec spec = new PBEKeySpec(\n            password.toCharArray(),\n            saltBytes,\n            pswdIterations,\n            keySize\n            );\n\n    SecretKey secretKey = factory.generateSecret(spec);\n    SecretKeySpec secret = new SecretKeySpec(secretKey.getEncoded(), \"AES\");\n\n    //encrypt the message\n    Cipher cipher = Cipher.getInstance(\"AES/CBC/PKCS5Padding\");\n    cipher.init(Cipher.ENCRYPT_MODE, secret);\n    AlgorithmParameters params = cipher.getParameters();\n    ivBytes = params.getParameterSpec(IvParameterSpec.class).getIV();\n\n    //First copy the IVBytes at the beginning  of the file\n    System.out.println(\"IvBytes Bfore: \"  + DatatypeConverter.printHexBinary(ivBytes));\n    FileOutputStream os = new FileOutputStream(out, true);\n    os.write(ivBytes);\n\n    CipherOutputStream cos = new CipherOutputStream(os, cipher);\n    cos.write(bytes);\n\n    os.close();\n    cos.close();\n\n}\n\npublic byte[] decryptToBytes(File in) throws Exception {  \n    byte[] saltBytes = salt.getBytes(\"UTF-8\");\n    System.out.println(\"Salt afetr:\" +salt);\n\n    // Derive the key\n    SecretKeyFactory factory = SecretKeyFactory.getInstance(\"PBKDF2WithHmacSHA1\");\n    PBEKeySpec spec = new PBEKeySpec(\n            password.toCharArray(),\n            saltBytes,\n            pswdIterations,\n            keySize\n            );\n\n    SecretKey secretKey = factory.generateSecret(spec);\n    SecretKeySpec secret = new SecretKeySpec(secretKey.getEncoded(), \"AES\");\n\n\n    //Get IVBytes of the first 16 bytes of the file\n    System.out.println(\"File Size: \"  + in.length());\n\n    FileInputStream is = new FileInputStream(in);\n    byte [] ivBytesRecovered = new byte [16];\n    if (is.read(ivBytesRecovered) != ivBytesRecovered.length) {\n        //is.close();\n        throw new IllegalStateException(\"Too short file\");\n    }\n    System.out.println(\"IvBytes After: \"  + DatatypeConverter.printHexBinary(ivBytesRecovered));\n\n    // Decrypt the message\n    Cipher cipher = Cipher.getInstance(\"AES/CBC/PKCS5Padding\");\n    cipher.init(Cipher.DECRYPT_MODE, secret, new IvParameterSpec(ivBytesRecovered));        \n\n    byte[] encBytes = new byte[(int) in.length()-16];\n    is.read(encBytes);\n\n    byte[] decryptedBytes = null;\n    try {\n        decryptedBytes = cipher.doFinal(encBytes);\n    } catch (IllegalBlockSizeException | BadPaddingException e) {\n        e.printStackTrace();\n    }\n\n    is.close();\n\n    return decryptedBytes;\n\n}\n", "idx": 2176}
{"project": "cipher", "commit_id": "Snippet13933325_37371.java", "target": 1, "func": "String vParameter= \"Lq4aURUiyvKvEZBWMWpUr2wRSMu96E+J1UeHLTOhKEM=\";  //The string that needs to be decoded.\nbyte[] encryptedV = Base64.decodeBase64(vParameter.getBytes(\"ASCII\"));\nString salt = \"jkjkyt4\"; // the i parameter - user\u2019s id\nString password = \"^hjkh673!v@!a89mz+%5rT\"; // application specific\nMessageDigest digester = MessageDigest.getInstance(\"SHA-1\");\ndigester.update((salt + password).getBytes(\"UTF-8\"));\nbyte[] key = digester.digest();\nSecretKeySpec secretKey = new SecretKeySpec(key, 2, 16, \"AES\");\nString appIV = \"SampleIV12345678\";// application specific\nIvParameterSpec iv= new IvParameterSpec(appIV.getBytes(\"UTF-8\"));\nCipher cipher = Cipher.getInstance(\"AES/CBC/PKCS5Padding\");\ncipher.init(Cipher.DECRYPT_MODE, secretKey, iv);\nbyte[] decryptedV = cipher.doFinal(encryptedV, 0, encryptedV.length);\nString v = new String(decryptedV, \"UTF-8\");\nSystem.out.println(v); // foobarfoobarfoobarfoobarfoobar\n", "idx": 2162}
{"project": "cipher", "commit_id": "Snippet21553019_4021.java", "target": 1, "func": "javax.crypto.Cipher.getInstance(\"RSA/ECB/PKCS1Padding\");\n", "idx": 2308}
{"project": "cipher", "commit_id": "Snippet34634125_16618.java", "target": 0, "func": "    public class AdminKeyGenerator {\n\n    private static final String ALGORITHM = \"AES\";\n\n\n    public static SecretKey generateKey() throws NoSuchAlgorithmException,\n            NoSuchPaddingException {\n\n        KeyGenerator genarator = KeyGenerator.getInstance(ALGORITHM);\n        SecretKey secretkey = genarator.generateKey();\n\n        return secretkey;\n\n    }\n\n    public static void saveKey(SecretKey key) {\n\n        File keyFile = new File(\"/home/thamiz/workspace/keyFile.txt\");\n        try{\n\n            keyFile.createNewFile();\n            FileWriter keyWriter = new FileWriter(keyFile);\n            BufferedWriter buffKey = new BufferedWriter(keyWriter);\n\n            char[] hex = encodeHex( key.getEncoded() );\n\n            buffKey.write(hex);\n            buffKey.flush();\n            buffKey.close();\n\n\n        }catch(FileNotFoundException e){\n            System.out.println(\"Decryption fails\");\n\n        } catch (IOException e) {\n            System.out.println(\"Decryption fails\");\n        }\n\n    }\n\n\n\n    public static SecretKey loadKey() throws DecoderException{\n\n\n        File keyFile = new File(\"/home/thamiz/workspace/keyFile.txt\");\n        String data = null;\n        byte[] encoded = null;\n\n        try{\n        FileReader keyReader = new FileReader( keyFile );\n        BufferedReader buffKeyRead = new BufferedReader(keyReader);\n\n        data = buffKeyRead.readLine();\n        encoded = decodeHex(data.toCharArray());\n        buffKeyRead.close();\n\n\n        }catch( IOException e ){\n            System.out.println(\"Decryption fails\");\n        }\n\n\n        return new SecretKeySpec(encoded, ALGORITHM);\n\n\n\n    }\n\n\n    public static void main(String[] args) throws NoSuchAlgorithmException,\n            NoSuchPaddingException {\n\n        SecretKey secretkey = AdminKeyGenerator.generateKey();\n\n        AdminKeyGenerator.saveKey(secretkey);\n\n\n\n    }\n\n\nFollowing is the client side code. client used the admin key and encrypt his card details.\n\n\n private static String debitcardType;\n private static int debitCardNumber;\n private static int debitcardCVV;\n     private static Date debitcardExpiryDate;\n\n\n    public static void storeCardDetails() throws ParseException {\n\n    Scanner in = new Scanner(System.in);\n    boolean anotherCardDetail = false;\n    SimpleDateFormat expiry = new SimpleDateFormat(\"dd-MM-yyyy\");\n\n    do {\n\n        System.out.println(\"Enter your debit card type:\");\n        debitcardType = in.next();\n\n        System.out.println(\"Enter your debit card number:\");\n        debitCardNumber = in.nextInt();\n\n        System.out.println(\"Enter your debit card cvv number:\");\n        debitcardCVV = in.nextInt();\n\n        System.out.println(\"Enter your debit card expiry date in the format of dd-MM-yyyy:\");\n        String date = in.next();\n        debitcardExpiryDate = expiry.parse(date);\n\n        System.out.println(\"Do you want to enter another card detail\");\n        System.out.println(\"Enter 1 for another card details and 0 for exit \");\n        int option = in.nextInt();\n        if (!(option == 1) && (option == 0)) {\n            anotherCardDetail = true;\n            System.out.println(\"Exit from entering card details\");\n        }\n\n    } while (!anotherCardDetail);\n\n}\n\n        private static String encryptCardDetails(int cardNumber, int cardCVV,Date expiryDate, SecretKey key)\n        {\n\n    Cipher cipherencrypt = Cipher.getInstance(\"AES\");\n\n    byte[] plainCardNumber = String.valueOf(cardNumber).getBytes();\n    byte[] plainCardCVV = String.valueOf(cardCVV).getBytes();\n    byte[] plainExpiryDate = expiryDate.toString().getBytes();\n\n    cipherencrypt.init( cipherencrypt.ENCRYPT_MODE, key);\n    byte[] encryptedCardNumber = cipherencrypt.doFinal(plainCardNumber);\n    byte[] encryptedCardCVV = cipherencrypt.doFinal(plainCardCVV);\n    byte[] encryptedExpiryDate = cipherencrypt.doFinal(plainExpiryDate);\n\n    String encryptedCard = Base64.encodeBase64String(encryptedCardNumber)\n            + Base64.encodeBase64String(encryptedCardCVV)\n            + Base64.encodeBase64String(encryptedExpiryDate);\n\n    return encryptedCard;\n\n}\n\n\n   public static String decryptCardDetails( File file, SecretKey key ) {\n\n    byte[] finalString1 = null;\n    byte[] finalString2 = null;\n    byte[] finalString3 = null;\n\n    String final1 = null,final2 = null, final3 = null;\n    Cipher cipher = Cipher.getInstance(\"AES/ECB/NoPadding\");\n\n    try{\n    FileReader decryptFile = new FileReader(file);\n    BufferedReader buff = new BufferedReader(decryptFile);\n\n    String decryptcontent = buff.readLine();\n\n    Scanner scan = new Scanner(decryptcontent).useDelimiter(\",\");\n\n    String cardType = scan.next();\n    System.out.println(cardType);\n    String decryptString = scan.next();\n    System.out.println(decryptString);\n\n    byte[] decrypt1 = Base64.decodeBase64(decryptString);\n    cipher.init(Cipher.DECRYPT_MODE, key);\n\n    byte[] decryptedText = cipher.doFinal(decrypt1);\n\n    final3 = new String(decryptedText, \"UTF-8\");\n\n    decryptedCardNumber.toString()+decryptedCardCVV.toString()+decryptedExpiryDate.toString();\n\n    }catch( IOException e ) {\n        System.out.println(\"Decryption fails\");\n    }\n\n    return final3;\n\n\n}\n\npublic static void main(String[] args)  {\n\n    File cardDetailsFile = new File(\"/home/thamiz/workspace/cardFile.txt\");\n\n    try {\n        cardDetailsFile.createNewFile();\n\n        FileWriter fileOut = new FileWriter(cardDetailsFile);\n        BufferedWriter buffer = new BufferedWriter(fileOut);\n\n        ClientCardDetails.storeCardDetails();\n\n        AdminKeyGenerator.generateKey();\n\n\n        String card = ClientCardDetails.encryptCardDetails(debitCardNumber, debitcardCVV,\n                debitcardExpiryDate, AdminKeyGenerator.generateKey());\n\n        buffer.write(debitcardType);\n        buffer.write(\",\");\n        buffer.write(card);\n        buffer.newLine();\n        buffer.flush();\n\n        SecretKey key = AdminKeyGenerator.loadKey();\n        String card1 = ClientCardDetails.decryptCardDetails(cardDetailsFile, key );\n        System.out.println(\"Decryption sucessful\");\n        System.out.println(card1);\n\n\n    } catch (ParseException e) {\n        System.out.println(\"Enter incorrect card details\");\n    } catch (IOException e) {\n        System.out.println(\"Encryption fails\");\n    }\n\n}\n", "idx": 1670}
{"project": "cipher", "commit_id": "Snippet34940890_16915.java", "target": 1, "func": " public static String Encrypt(String text, String key)\n        throws Exception {\n    Cipher cipher = Cipher.getInstance(\"AES/CBC/PKCS5Padding\");\n    byte[] keyBytes= new byte[16];\n    byte[] b= key.getBytes(\"UTF-8\");\n    int len= b.length;\n    if (len > keyBytes.length) len = keyBytes.length;\n    System.arraycopy(b, 0, keyBytes, 0, len);\n    SecretKeySpec keySpec = new SecretKeySpec(keyBytes, \"AES\");\n    IvParameterSpec ivSpec = new IvParameterSpec(keyBytes);\n    cipher.init(Cipher.ENCRYPT_MODE,keySpec,ivSpec);\n\n    byte[] results = cipher.doFinal(text.getBytes(\"UTF-8\"));\n    BASE64Encoder encoder;\n    encoder = new BASE64Encoder();\n    return encoder.encode(results);\n}\n", "idx": 2174}
{"project": "cipher", "commit_id": "Snippet30154180_12308.java", "target": 1, "func": "public class CryptTest{\n    private static final String SALT = \"HARcodedRandomSaltCharacters\";\n    private static final String IV = \"somerandomcharacters\";\n\n    public static final String ALGORITHM = \"AES\";\n    public static final String SEC_KEY_TYPE = \"PBKDF2WithHmacSHA1\";\n    public static final String CIPHER = \"AES/CBC/PKCS5Padding\";\n    public static final String ENCODING = \"UTF-8\";\n\n    private static final byte[] getSalt(int size){\n        return getBytes(SALT, size);\n    }\n\n    private static final byte[] getIv(int size){\n        return getBytes(IV, size);\n    }\n\n    private static final byte[] getBytes(String s, int size){\n        while (s.length() < size){\n            s += s;\n        }\n        byte[] ret = new byte[size];\n        System.arraycopy(s.getBytes(Charset.forName(ENCODING)), 0,  ret, 0, size);\n        return ret;\n}\n\n    public static SecretKey genKey(String password) throws NoSuchAlgorithmException, InvalidKeySpecException\n             {\n        final int iterationCount = 666;\n        final int keyLength = 256;\n        final int saltLength = keyLength / 8; // same size as key output\n\n\n        byte[] salt = getSalt(saltLength);\n\n        KeySpec keySpec = new PBEKeySpec(password.toCharArray(), salt, iterationCount, keyLength);\n        SecretKeyFactory keyFactory = SecretKeyFactory.getInstance(SEC_KEY_TYPE);\n        byte[] keyBytes = keyFactory.generateSecret(keySpec).getEncoded();\n        SecretKey key = new SecretKeySpec(keyBytes, ALGORITHM);\n        return key;\n\n    }\n\n    public static byte[] encrypt(String password){\n        SecretKey key = genKey(password);\n\n        Cipher cipher = Cipher.getInstance(CIPHER);\n        int blockSize = cipher.getBlockSize();\n        byte[] iv = getIv(blockSize);\n        IvParameterSpec ivSpec = new IvParameterSpec(iv);\n\n        cipher.init(Cipher.ENCRYPT_MODE, key, ivSpec);\n\n        File inFile = new File(\"/path/to/test.txt\");\n        InputStream is = new InputStream(inFile);\n        byte[] fileContents = new byte[(int)inFile.length()];\n        is.read(fileContents);    \n\n        return cipher.doFinal(fileContents);\n    }\n}\n", "idx": 2090}
{"project": "cipher", "commit_id": "Snippet43424551_25524.java", "target": 0, "func": "package encrypt;\n\nimport java.security.Key;\nimport java.util.Scanner;\nimport javax.crypto.Cipher;\nimport javax.crypto.spec.SecretKeySpec;\n\npublic class PasswordEncrypt {\n\nString key = \"passwordencrypts\";\nCipher cipher;\nKey aesKey;\n\npublic PasswordEncrypt() {\n    try {\n        aesKey = new SecretKeySpec(key.getBytes(), \"AES\");\n        cipher = Cipher.getInstance(\"AES\");\n    } catch (Exception e) {\n        e.printStackTrace();\n    }\n}\n\npublic static void main(String[] args) {\n    PasswordEncrypt app = new PasswordEncrypt();\n    System.out.println(\"enter string\");\n    PasswordEncrypt encrypt = new PasswordEncrypt();\n    byte[] en = encrypt.encrypt(new Scanner(System.in).next());\n\n    System.out.println(en + \" encrypted\");\n    String de = encrypt.decrypt(en);\n    System.out.println(de + \"   decrypted\");\n\n}\n\nprivate String decrypt(byte[] en) {\n    String decrypted = \"\";\n    try {\n        cipher.init(Cipher.DECRYPT_MODE, aesKey);\n        decrypted = new String(cipher.doFinal(en));\n    } catch (Exception e) {\n        e.printStackTrace();\n    }\n    return decrypted;\n}\n\nprivate byte[] encrypt(String text) {\n    byte[] en = null;\n    try {\n        cipher.init(Cipher.ENCRYPT_MODE, aesKey);\n        en = cipher.doFinal(text.getBytes());\n    } catch (Exception e) {\n        e.printStackTrace();\n    }\n    return en;\n}\n}\n", "idx": 1799}
{"project": "cipher", "commit_id": "Snippet23783457_6088.java", "target": 1, "func": "import java.security.MessageDigest;\nimport java.util.Arrays;\nimport javax.crypto.KeyGenerator;\nimport javax.crypto.SecretKey;\nimport javax.crypto.spec.SecretKeySpec;\nimport javax.crypto.spec.IvParameterSpec;\n\nimport javax.crypto.Cipher;\nimport javax.crypto.spec.IvParameterSpec;\nimport javax.crypto.spec.SecretKeySpec;\n\npublic class AES {\nstatic String IV = \"AAAAAAAAAAAAAAAA\";\nstatic String encryptionKey = \"0123456789abcdef\";\n\npublic static byte[] encrypt(byte[] inputcum) throws Exception {\nCipher cipher = Cipher.getInstance(\"AES/CBC/NoPadding\", \"SunJCE\");\nSecretKeySpec key = new SecretKeySpec(encryptionKey.getBytes(\"UTF-8\"), \"AES\");\ncipher.init(Cipher.ENCRYPT_MODE, key,new IvParameterSpec(IV.getBytes(\"UTF-8\")));\nreturn cipher.doFinal(inputcum);\n}\n\npublic static byte[] decrypt(byte[] cipherSound) throws Exception{\nCipher cipher = Cipher.getInstance(\"AES/CBC/NoPadding\", \"SunJCE\");\nSecretKeySpec key = new SecretKeySpec(encryptionKey.getBytes(\"UTF-8\"), \"AES\");\ncipher.init(Cipher.DECRYPT_MODE, key,new IvParameterSpec(IV.getBytes(\"UTF-8\")));\nreturn cipher.doFinal(cipherSound);\n}\n}\n", "idx": 2127}
{"project": "cipher", "commit_id": "Snippet40006920_21946.java", "target": 1, "func": "Cipher.getInstance(\"AES/CFB8/NoPadding\");", "idx": 2257}
{"project": "cipher", "commit_id": "Snippet40485518_22333.java", "target": 0, "func": "  package encypt.com;\n\nimport java.io.BufferedReader;\nimport java.io.FileReader;\nimport java.security.*;\nimport java.security.spec.InvalidKeySpecException;\nimport javax.crypto.Cipher;\nimport javax.crypto.spec.SecretKeySpec;\nimport sun.misc.*;\n\npublic class Testing {\n\nprivate static final String ALGORITHM = \"AES\";\nprivate static final int ITERATIONS = 2;\nprivate static final byte[] keyValue = \n    new byte[] { 'T', 'h', 'i', 's', 'I', 's', 'A', 'S', 'e', 'c', 'r', 'e', 't', 'K', 'e', 'y'};\n\npublic static String encrypt(String value, String salt) throws Exception {\n    Key key = generateKey();\n    Cipher c = Cipher.getInstance(ALGORITHM);  \n    c.init(Cipher.ENCRYPT_MODE, key);\n\n    String valueToEnc = null;\n    String eValue = value;\n    for (int i = 0; i < ITERATIONS; i++) {\n        valueToEnc = salt + eValue;\n        byte[] encValue = c.doFinal(valueToEnc.getBytes());\n        eValue = new BASE64Encoder().encode(encValue);\n    }\n    return eValue;\n}\n\npublic static String decrypt(String value, String salt) throws Exception {\n    Key key = generateKey();\n    Cipher c = Cipher.getInstance(ALGORITHM);\n    c.init(Cipher.DECRYPT_MODE, key);\n\n    String dValue = null;\n    String valueToDecrypt = value;\n    for (int i = 0; i < ITERATIONS; i++) {\n        byte[] decordedValue = new BASE64Decoder().decodeBuffer(valueToDecrypt);\n        byte[] decValue = c.doFinal(decordedValue);\n        dValue = new String(decValue).substring(salt.length());\n        valueToDecrypt = dValue;\n    }\n    return dValue;\n}\n\nprivate static Key generateKey() throws Exception {\n    Key key = new SecretKeySpec(keyValue, ALGORITHM);\n    // SecretKeyFactory keyFactory = SecretKeyFactory.getInstance(ALGORITHM);\n    // key = keyFactory.generateSecret(new DESKeySpec(keyValue));\n    return key;\n}\n", "idx": 1890}
{"project": "cipher", "commit_id": "Snippet42856564_24964.java", "target": 1, "func": "private static String encryptNew(String key, String initVector, String dataToEncrypt) throws Exception{\n\n        byte[] plainTextbytes = dataToEncrypt.getBytes(\"UTF-8\");\n        byte[] keyBytes = key.getBytes(\"UTF-8\");\n        byte[] IvkeyBytes = initVector.getBytes(\"UTF-8\");\n\n        Cipher cipher = Cipher.getInstance(\"AES/CBC/PKCS7Padding\");\n        SecretKeySpec secretKeySpec = new SecretKeySpec(keyBytes, \"AES\");\n        IvParameterSpec ivParameterSpec = new IvParameterSpec(IvkeyBytes);\n        cipher.init(Cipher.ENCRYPT_MODE, secretKeySpec, ivParameterSpec);\n        plainTextbytes = cipher.doFinal(plainTextbytes);\n        return Base64.encodeToString(plainTextbytes, Base64.DEFAULT);\n    }\n\n    private static String decrypt(String key, String initVector, String dataToDecrypt) {\n            try {\n\n                byte[] cipheredBytes = Base64.decode(dataToDecrypt, Base64.DEFAULT);\n                byte[] keyBytes = key.getBytes(\"UTF-8\");\n                byte[] IvkeyBytes = initVector.getBytes(\"UTF-8\");\n\n                Cipher cipher = Cipher.getInstance(\"AES/CBC/PKCS7Padding\");\n                SecretKeySpec secretKeySpecy = new SecretKeySpec(keyBytes, \"AES\");\n                IvParameterSpec ivParameterSpec = new IvParameterSpec(IvkeyBytes);\n                cipher.init(Cipher.DECRYPT_MODE, secretKeySpecy, ivParameterSpec);\n                cipheredBytes = cipher.doFinal(cipheredBytes);\n\n                return new String(cipheredBytes,\"UTF-8\");\n            } catch (Exception ex) {\n                ex.printStackTrace();\n            }\n\n            return null;\n        }\n", "idx": 2235}
{"project": "cipher", "commit_id": "Snippet19534916_2288.java", "target": 0, "func": "import it.sauronsoftware.base64.Base64;\nimport java.security.InvalidKeyException;\nimport java.security.NoSuchAlgorithmException;\nimport javax.crypto.BadPaddingException;\nimport javax.crypto.Cipher;\nimport javax.crypto.IllegalBlockSizeException;\nimport javax.crypto.NoSuchPaddingException;\nimport javax.crypto.SecretKey;\nimport javax.crypto.spec.SecretKeySpec;\n\n\npublic class DES {\n\n    public static void main(String [] args) throws NoSuchAlgorithmException, InvalidKeyException, NoSuchPaddingException, IllegalBlockSizeException, BadPaddingException\n    {\n        String msg=\"This is a secret message\";\n        byte [] msgBytes=msg.getBytes();        \n        byte [] keyBytes  = {(byte)0xFE, (byte)0xDC, (byte)0xBA, (byte)0x98, (byte)0x76, (byte)0x54, (byte)0x32, (byte)0x10};\n        SecretKeySpec myDesKey = new SecretKeySpec(keyBytes, \"DES\");\n\n        //to encrypt a message\n        String cipher=encryptMsg(msgBytes, myDesKey);\n\n        //to decrypt a message\n        String plain = decryptMsg(cipher.getBytes(), myDesKey);\n\n        System.out.println(\"Original Message: \"+ msg);\n        System.out.println(\"Encrypted Message: \"+ cipher);\n        System.out.println(\"Decrypted Message: \"+ plain);\n\n    } //end main\n\n    //encryption function\n    public static String encryptMsg(byte [] msgBytes, SecretKey myDesKey) throws NoSuchAlgorithmException, NoSuchPaddingException, InvalidKeyException, IllegalBlockSizeException, BadPaddingException\n    {\n        Cipher desCipher;\n        // Create the cipher \n        desCipher = Cipher.getInstance(\"DES/ECB/NoPadding\");\n        desCipher.init(Cipher.ENCRYPT_MODE, myDesKey);\n        byte[] textEncrypted = desCipher.doFinal(msgBytes);\n\n        // converts to base64 for easier display.\n        byte[] base64Cipher = Base64.encode(textEncrypted);\n        return new String(base64Cipher);\n    } //end encryptMsg\n\n    public static String decryptMsg(byte [] cipherBytes, SecretKey myDesKey) throws NoSuchAlgorithmException, NoSuchPaddingException, InvalidKeyException, IllegalBlockSizeException, BadPaddingException\n    {\n        Cipher desCipher; \n        desCipher = Cipher.getInstance(\"DES/ECB/NoPadding\");\n        desCipher.init(Cipher.DECRYPT_MODE, myDesKey);\n        byte[] textDecrypted=desCipher.doFinal(cipherBytes);\n\n        // converts to base64 for easier display.\n        byte[] base64Plain = Base64.encode(textDecrypted);\n        return new String(base64Plain);\n    } //end decryptMsg\n} //end class\n", "idx": 1882}
{"project": "cipher", "commit_id": "Snippet27181971_9321.java", "target": 0, "func": "    public static byte[] encrypt(byte[] plaintext, String key) throws Exception {\n        char[] password = key.toCharArray();\n        byte[] salt = \"12345678\".getBytes();\n        SecretKeyFactory factory = SecretKeyFactory.getInstance(\"PBKDF2WithHmacSHA1\");\n        KeySpec spec = new PBEKeySpec(password, salt, 65536, 128);\n        SecretKey tmp = factory.generateSecret(spec);\n        SecretKey secret = new SecretKeySpec(tmp.getEncoded(), \"AES\");\n        Cipher cipher = Cipher.getInstance(\"AES/ECB/PKCS5Padding\");\n        cipher.init(Cipher.ENCRYPT_MODE, secret);\n        byte[] ciphertext = cipher.doFinal(plaintext);  \n        return ciphertext;\n    }\n\n    public static byte[] decrypt(byte[] ciphertext, String key) throws Exception {\n        char[] password = key.toCharArray();\n        byte[] salt = \"12345678\".getBytes();\n        SecretKeyFactory factory = SecretKeyFactory.getInstance(\"PBKDF2WithHmacSHA1\");\n        KeySpec spec = new PBEKeySpec(password, salt, 65536, 128);\n        SecretKey tmp = factory.generateSecret(spec);\n        SecretKey secret = new SecretKeySpec(tmp.getEncoded(), \"AES\");\n        Cipher cipher = Cipher.getInstance(\"AES/ECB/PKCS5Padding\");\n        cipher.init(Cipher.DECRYPT_MODE, secret);\n        byte[] plaintext = cipher.doFinal(ciphertext);  \n        return plaintext;\n    }\n", "idx": 1837}
{"project": "cipher", "commit_id": "Snippet45502635_27561.java", "target": 0, "func": "package encryption;\n\nimport java.io.*;\nimport java.net.*;\nimport java.security.*;\nimport javax.crypto.*;\n\npublic class CipherServer\n{\n    public static void main(String[] args) throws Exception \n    {\n        int port = 7999;\n        ServerSocket server = new ServerSocket(port);\n        Socket s = server.accept();\n\n        // -Read the key from the file generated by the client.\n        ObjectInputStream in = new ObjectInputStream(new FileInputStream(\"KeyFile.xx\"));\n        Key key = (Key)in.readObject();\n        in.close();\n\n        // -Use the key to decrypt the incoming message from socket s.    \n        Cipher cipher = Cipher.getInstance(\"DES/ECB/PKCS5Padding\");\n        cipher.init(Cipher.DECRYPT_MODE, key);\n\n        DataInputStream dIn = new DataInputStream(s.getInputStream());\n        int length = dIn.readInt();                    // read length of incoming message\n        if(length>0) \n        {\n            byte[] messageInBytes = new byte[length];\n            dIn.readFully(messageInBytes, 0, messageInBytes.length); // read the message\n\n            // -Print out the decrypt String to see if it matches the orignal message.\n            System.out.println(new String(cipher.doFinal(messageInBytes)));\n        }\n    }\n}\n", "idx": 1681}
{"project": "cipher", "commit_id": "Snippet19610476_2338.java", "target": 0, "func": "Cipher.getInstance(\"DES/ECB/PKCS5Padding\");\n", "idx": 1761}
{"project": "cipher", "commit_id": "Snippet29522452_11542.java", "target": 1, "func": "private static String password;\nprivate static String salt;\nprivate static int pswdIterations = 65536  ;\nprivate static int keySize = 256;\nprivate byte[] ivBytes;\npublic void encryptToFile(byte[] bytes, File out) throws Exception {  \n    byte[] saltBytes = salt.getBytes(\"UTF-8\");\n\n    System.out.println(\"Salt bfre:\" +salt);\n\n    // Derive the key\n    SecretKeyFactory factory = SecretKeyFactory.getInstance(\"PBKDF2WithHmacSHA1\");\n    PBEKeySpec spec = new PBEKeySpec(\n            password.toCharArray(),\n            saltBytes,\n            pswdIterations,\n            keySize\n            );\n\n    SecretKey secretKey = factory.generateSecret(spec);\n    SecretKeySpec secret = new SecretKeySpec(secretKey.getEncoded(), \"AES\");\n\n    //encrypt the message\n    Cipher cipher = Cipher.getInstance(\"AES/CBC/PKCS5Padding\");\n    cipher.init(Cipher.ENCRYPT_MODE, secret);\n    AlgorithmParameters params = cipher.getParameters();\n    ivBytes = params.getParameterSpec(IvParameterSpec.class).getIV();\n\n    CipherOutputStream os = new CipherOutputStream(new FileOutputStream(out, true), cipher);\n    os.write(bytes);\n    os.close();\n\n}\n\npublic byte[] decryptToFile(File in) throws Exception {  \n    byte[] saltBytes = salt.getBytes(\"UTF-8\");\n\n    // Derive the key\n    SecretKeyFactory factory = SecretKeyFactory.getInstance(\"PBKDF2WithHmacSHA1\");\n    PBEKeySpec spec = new PBEKeySpec(\n            password.toCharArray(),\n            saltBytes,\n            pswdIterations,\n            keySize\n            );\n\n    SecretKey secretKey = factory.generateSecret(spec);\n    SecretKeySpec secret = new SecretKeySpec(secretKey.getEncoded(), \"AES\");\n\n    // Decrypt the message\n    Cipher cipher = Cipher.getInstance(\"AES/CBC/PKCS5Padding\");\n    cipher.init(Cipher.DECRYPT_MODE, secret, new IvParameterSpec(ivBytes));\n\n    FileInputStream is = new FileInputStream(in);\n    byte[] encBytes = new byte[(int) in.length()];\n    is.read(encBytes);\nis.close();    \n\n    byte[] decryptedBytes = null;\n    try {\n        decryptedBytes = cipher.doFinal(encBytes);\n    } catch (IllegalBlockSizeException | BadPaddingException e) {\n        e.printStackTrace();\n    }\n\n    return decryptedBytes;\n\n}\n", "idx": 2163}
{"project": "cipher", "commit_id": "Snippet15373448_38427.java", "target": 1, "func": "public void encrypt(String original)\n{\n    SecureRandom sr = new SecureRandom();\n\n    byte [] key = new byte[16];\n    byte [] iv = new byte[16];\n\n    sr.nextBytes(key);\n    sr.nextBytes(iv);\n\n    Cipher cipher;\n\n    try \n    {\n        cipher = Cipher.getInstance(\"AES/CBC/PKCS5Padding\");\n        IvParameterSpec IV=new IvParameterSpec(iv);\n        cipher.init(Cipher.ENCRYPT_MODE, new SecretKeySpec(key,\"AES\"), IV);\n        byte[] utf8 = original.getBytes(\"UTF-8\");\n        byte []encryptedAES = cipher.doFinal(utf8);\n\n        KeyPairGenerator kpg = KeyPairGenerator.getInstance(\"RSA\");\n        kpg.initialize(128);//128 bits\n        KeyPair kp = kpg.genKeyPair();\n\n        Cipher publicKeyCipher = Cipher.getInstance(\"RSA/ECB/PKCS1PADDING\");\n        publicKeyCipher.init(Cipher.ENCRYPT_MODE, kp.getPublic());\n        byte [] encryptedRSA = publicKeyCipher.doFinal(encryptedAES); //error here\n\n        int length1=encryptedAES.length;\n        int length2=IV.getIV().length;\n        int length3=encryptedRSA.length;\n        int length=length1+length2+length3;\n        byte [] result= new byte[length];\n\n        int l=0,m=0;\n\n        for (int i=0; i<length; i++)\n        {\n            if(i<length1)\n            {\n                result[i] = encryptedAES[i];\n            }\n            else if(i>=length1 && i<length2)\n            {\n                result[i] = IV.getIV()[l];\n                l++;\n            }\n            else if(i>=length2)\n            {\n                result[i] = encryptedRSA[m];\n                m++;\n            }\n        }\n        Log.i(\"Encrypted\", \"done\");\n        this.encryptedMessage=Base64.encodeToString(result, false);\n        Log.i(\"Encrypted Message:\", this.encryptedMessage);\n\n    } catch (NoSuchAlgorithmException e) {\n        // TODO Auto-generated catch block\n        e.printStackTrace();\n    } catch (NoSuchPaddingException e) {\n        // TODO Auto-generated catch block\n        e.printStackTrace();\n    } catch (InvalidKeyException e) {\n        // TODO Auto-generated catch block\n        e.printStackTrace();\n    } catch (InvalidAlgorithmParameterException e) {\n        // TODO Auto-generated catch block\n        e.printStackTrace();\n    } catch (IllegalBlockSizeException e) {\n        // TODO Auto-generated catch block\n        e.printStackTrace();\n    } catch (BadPaddingException e) {\n        // TODO Auto-generated catch block\n        e.printStackTrace();\n    } catch (UnsupportedEncodingException e) {\n        // TODO Auto-generated catch block\n        e.printStackTrace();\n    } catch (IOException e) {\n        // TODO Auto-generated catch block\n        e.printStackTrace();\n    }\n}\n", "idx": 2040}
{"project": "cipher", "commit_id": "Snippet33681535_15734.java", "target": 0, "func": "Cipher iso = Cipher.getInstance(\"DESede/CBC/ISO7816-4Padding\");\n", "idx": 1607}
{"project": "cipher", "commit_id": "Snippet36677266_18537.java", "target": 1, "func": "public static boolean decryptFileFromUri(Context context, Uri file, String keyphrase) {\n    try {\n        File f = new File(getRealPathFromURI(context, file));\n        FileInputStream fis = new FileInputStream(f);\n\n        File ef = new File(f.toString().replace(\".epf\", \"\"));\n        FileOutputStream fos = new FileOutputStream(ef);\n\n        Log.d(\"HIDEMYPICS\",\"Decrypting: \" + f.toString());\n\n        byte[] rawKey = getRawKey(keyphrase.getBytes(\"UTF8\"));\n        /*KeyGenerator kgen = KeyGenerator.getInstance(\"AES\");\n        SecureRandom sr = SecureRandom.getInstance(\"SHA1PRNG\");\n        sr.setSeed(rawKey);\n        kgen.init(128, sr); // 192 and 256 bits may not be available\n        SecretKey skey = kgen.generateKey();\n        byte[] key = skey.getEncoded();*/\n        SecretKeySpec skeySpec = new SecretKeySpec(rawKey, \"AES\");\n        Cipher cipher = Cipher.getInstance(\"AES/CBC/PKCS5Padding\");\n        cipher.init(Cipher.DECRYPT_MODE, skeySpec);\n        // Wrap the output stream\n        CipherOutputStream cos = new CipherOutputStream(fos, cipher);\n        // Write bytes\n        int b;\n        byte[] d = new byte[8];\n        while ((b = fis.read(d)) != -1) {\n            cos.write(d, 0, b);\n        }\n        // Flush and close streams.\n        cos.flush();\n        cos.close();\n        fis.close();\n\n        Log.d(\"HIDEMYPICS\",\"Decrypted to: \" + ef.toString());\n        return true;\n    } catch (IOException e){\n        e.printStackTrace();\n    } catch (NoSuchPaddingException e) {\n        e.printStackTrace();\n    } catch (NoSuchAlgorithmException e) {\n        e.printStackTrace();\n    } catch (InvalidKeyException e) {\n        e.printStackTrace();\n    }\n    return false;\n}\n\npublic static boolean encryptFileFromUri(Context context, Uri file, String keyphrase) {\n    try {\n        File f = new File(getRealPathFromURI(context, file));\n        FileInputStream fis = new FileInputStream(f);\n\n        File ef = new File(f.toString() + \".epf\");\n        FileOutputStream fos = new FileOutputStream(ef);\n\n        Log.d(\"HIDEMYPICS\",\"Encrypting: \" + f.toString());\n\n        byte[] rawKey = getRawKey(keyphrase.getBytes(\"UTF8\"));\n        /*KeyGenerator kgen = KeyGenerator.getInstance(\"AES\");\n        SecureRandom sr = SecureRandom.getInstance(\"SHA1PRNG\");\n        sr.setSeed(rawKey);\n        kgen.init(128, sr); // 192 and 256 bits may not be available\n        SecretKey skey = kgen.generateKey();\n        byte[] key = skey.getEncoded();*/\n        SecretKeySpec skeySpec = new SecretKeySpec(rawKey, \"AES\");\n        Cipher cipher = Cipher.getInstance(\"AES/CBC/PKCS5Padding\");\n        cipher.init(Cipher.ENCRYPT_MODE, skeySpec);\n        // Wrap the output stream\n        CipherOutputStream cos = new CipherOutputStream(fos, cipher);\n        // Write bytes\n        int b;\n        byte[] d = new byte[8];\n        while ((b = fis.read(d)) != -1) {\n            cos.write(d, 0, b);\n        }\n        // Flush and close streams.\n        cos.flush();\n        cos.close();\n        fis.close();\n        Log.d(\"HIDEMYPICS\",\"Encrypted to: \" + ef.toString());\n        return true;\n    } catch (IOException e){\n        e.printStackTrace();\n    } catch (NoSuchPaddingException e) {\n        e.printStackTrace();\n    } catch (NoSuchAlgorithmException e) {\n        e.printStackTrace();\n    } catch (InvalidKeyException e) {\n        e.printStackTrace();\n    }\n    return false;\n}\n", "idx": 2240}
{"project": "cipher", "commit_id": "Snippet19856324_2542.java", "target": 1, "func": "Cipher dcipher;\n\nbyte[] salt = new String(\"12345678\").getBytes();\nint iterationCount = 1024;\nint keyStrength = 256;\nSecretKey key;\nbyte[] iv;\n\nDecrypter(String passPhrase) throws Exception {\n    SecretKeyFactory factory = SecretKeyFactory\n            .getInstance(\"PBKDF2WithHmacSHA1\");\n    System.out.println(\"factory +\" + factory);\n    KeySpec spec = new PBEKeySpec(passPhrase.toCharArray(), salt,\n            iterationCount, keyStrength);\n    System.out.println(\"spec  \" + spec);\n    SecretKey tmp = factory.generateSecret(spec);\n    System.out.println();\n    key = new SecretKeySpec(tmp.getEncoded(), \"AES\");\n    dcipher = Cipher.getInstance(\"AES/CBC/PKCS5Padding\");\n}\n\npublic String encrypt(String data) throws Exception {\n    dcipher.init(Cipher.ENCRYPT_MODE, key);\n    AlgorithmParameters params = dcipher.getParameters();\n    iv = params.getParameterSpec(IvParameterSpec.class).getIV();\n    byte[] utf8EncryptedData = dcipher.doFinal(data.getBytes());\n    String base64EncryptedData = new sun.misc.BASE64Encoder()\n            .encodeBuffer(utf8EncryptedData);\n\n    System.out.println(\"IV \"\n            + new sun.misc.BASE64Encoder().encodeBuffer(iv));\n    System.out.println(\"Encrypted Data \" + base64EncryptedData);\n    return base64EncryptedData;\n", "idx": 1982}
{"project": "cipher", "commit_id": "Snippet10202035_34523.java", "target": 1, "func": "ecipher = Cipher.getInstance(\"AES/CBC/PKCS5Padding\");\nbyte[] iv = new byte[IV_LENGTH];\nSecureRandom random = new SecureRandom();\nrandom.nextBytes(iv);\necipher.init(Cipher.ENCRYPT_MODE, secret, new IvParameterSpec(iv));\nbyte[] enc = ecipher.doFinal(utf8);\n", "idx": 2012}
{"project": "cipher", "commit_id": "Snippet19596002_2328.java", "target": 1, "func": "public static final int IV_LENGTH = 16;\nprivate static final String RANDOM_ALGORITHM = \"SHA1PRNG\";\n...\n    private static String translate(String clear, int mode) throws Exception {\n    if (mode != Cipher.ENCRYPT_MODE && mode != Cipher.DECRYPT_MODE)\n        throw new IllegalArgumentException(\n                \"Encryption invalid. Mode should be either Cipher.ENCRYPT_MODE or Cipher.DECRYPT_MODE\");\n    SecretKeySpec skeySpec = new SecretKeySpec(getRawKey(), \"AES\");\n    Cipher cipher = Cipher.getInstance(\"AES/CBC/PKCS5Padding\");\n    IvParameterSpec ivSpec = new IvParameterSpec(generateIv());\n    cipher.init(mode, skeySpec, ivSpec);\n    byte[] encrypted = cipher.doFinal(clear.getBytes());\n    return new String(encrypted);\n}\n...\n    private static byte[] generateIv() throws NoSuchAlgorithmException,\n        NoSuchProviderException {\n    SecureRandom random = SecureRandom.getInstance(RANDOM_ALGORITHM);\n    byte[] iv = new byte[IV_LENGTH];\n    random.nextBytes(iv);\n    return iv;\n}\n", "idx": 2267}
{"project": "cipher", "commit_id": "Snippet43066329_24993.java", "target": 1, "func": "Cipher.getInstance(\"RSA/ECB/PKCS1Padding\");", "idx": 2067}
{"project": "cipher", "commit_id": "Snippet31026904_13210.java", "target": 1, "func": "Cipher m_cipher = Cipher.getInstance(\"RSA\");\nm_cipher.init(Cipher.ENCRYPT_MODE, publicKey);\n\nbyte[] result = m_cipher.doFinal(dataNeedToCrypt);\n", "idx": 2132}
{"project": "cipher", "commit_id": "Snippet25324304_7712.java", "target": 0, "func": "  Cipher rc4Decrypt = Cipher.getInstance(\"RC4\");\n  rc4Decrypt.init(Cipher.DECRYPT_MODE, rc4Key);\n  byte [] clearText2 = rc4Decrypt.update(cipherText);\n", "idx": 1753}
{"project": "cipher", "commit_id": "Snippet35119827_17053.java", "target": 0, "func": "package com.openbravo.pos.util;\n\nimport java.io.UnsupportedEncodingException;\nimport java.security.*;\nimport javax.crypto.*;\n\n/**\n *\n * @author JG uniCenta\n */\npublic class AltEncrypter {\n\n    private Cipher cipherDecrypt;\n    private Cipher cipherEncrypt;\n\n    /** Creates a new instance of Encrypter\n     * @param passPhrase */\n    public AltEncrypter(String passPhrase) {\n\n        try {\n            SecureRandom sr = SecureRandom.getInstance(\"SHA1PRNG\");\n            sr.setSeed(passPhrase.getBytes(\"UTF8\"));\n            KeyGenerator kGen = KeyGenerator.getInstance(\"DESEDE\");\n            kGen.init(168, sr);\n            Key key = kGen.generateKey();\n\n            cipherEncrypt = Cipher.getInstance(\"DESEDE/ECB/PKCS5Padding\");\n            cipherEncrypt.init(Cipher.ENCRYPT_MODE, key);\n\n            cipherDecrypt = Cipher.getInstance(\"DESEDE/ECB/PKCS5Padding\");\n            cipherDecrypt.init(Cipher.DECRYPT_MODE, key);\n        } catch (UnsupportedEncodingException | NoSuchPaddingException | NoSuchAlgorithmException | InvalidKeyException e) {\n        }\n    }\n\n    /**\n     *\n     * @param str\n     * @return\n     */\n    public String encrypt(String str) {\n        try {\n            return StringUtils.byte2hex(cipherEncrypt.doFinal(str.getBytes(\"UTF8\")));\n        } catch (UnsupportedEncodingException | BadPaddingException | IllegalBlockSizeException e) {\n        }\n        return null;\n    }\n\n    /**\n     *\n     * @param str\n     * @return\n     */\n    public String decrypt(String str) {\n        try {\n            return new String(cipherDecrypt.doFinal(StringUtils.hex2byte(str)), \"UTF8\");\n        } catch (UnsupportedEncodingException | BadPaddingException | IllegalBlockSizeException e) {\n        }\n        return null;\n    }    \n}\n", "idx": 1643}
{"project": "cipher", "commit_id": "Snippet21955527_4375.java", "target": 0, "func": "SecretKey k = new SecretKeySpec(key.getBytes(), \"AES\");\nSecurity.addProvider(new org.bouncycastle.jce.provider.BouncyCastleProvider());\nCipher cipher = Cipher.getInstance(\"AES/ECB/PKCS7Padding\", \"BC\");\ncipher.init(Cipher.ENCRYPT_MODE, k);\nfinalStr = new String(Base64.encode(cipher.doFinal(originalStr.getBytes())));\n", "idx": 1845}
{"project": "cipher", "commit_id": "Snippet23809324_6115.java", "target": 1, "func": "String strEncrypted = null;\nCipher cipher = null;\nIvParameterSpec ivSpec = null;\nbyte[] btEncrypted = null;\n\ntry\n{\n    cipher = Cipher.getInstance(\"AES/CBC/PKCS5Padding\");\n    ivSpec = new IvParameterSpec(m_btIV);\n\n    cipher.init(Cipher.ENCRYPT_MODE, m_KeySpec, ivSpec);\n    btEncrypted = cipher.doFinal(strData.getBytes(m_strCharSet));\n    strEncrypted = Base64.encodeToString(btEncrypted, Base64.NO_PADDING | Base64.NO_WRAP);\n}\ncatch(Exception e)\n{\n    e.printStackTrace();\n}\n\nreturn strEncrypted;\n", "idx": 2026}
{"project": "cipher", "commit_id": "Snippet39682186_21572.java", "target": 1, "func": "File dbFile = new File(PATH_DB);\n\nFileInputStream fileInputStream = new FileInputStream(PATH_DB);\n\nFileOutputStream outputStream = new FileOutputStream(PATH_BKP);\n\nbyte[] s = Arrays.copyOf(KEY_DATABASE.getBytes(),16);\nSecretKeySpec sks = new SecretKeySpec(s, \"AES\");\n\nCipher cipher = Cipher.getInstance(\"AES/CBC/PKCS5PADDING\");\ncipher.init(Cipher.ENCRYPT_MODE, sks);\n\nCipherOutputStream cos = new CipherOutputStream(outputStream, cipher);\n\n//Transferencia dos dados do inputfile para o output\nbyte[] buffer = new byte[1024];\nint length;\nwhile ((length = fileInputStream.read(buffer))!= -1) {\n    cos.write(buffer,0,length);\n}\n\n//Fecha as streams\ncos.flush();\ncos.close();\nfileInputStream.close();\n", "idx": 2007}
{"project": "cipher", "commit_id": "Snippet10266078_34617.java", "target": 0, "func": "public class EncryptDecrypt \n\n{\npublic static String Password;\npublic static FileInputStream fileIn;\npublic static FileOutputStream fileOut;\npublic static boolean a = true;\n\npublic static void  Encrypt(String FileInName, String FileOutName ) throws    IOException, NoSuchAlgorithmException, InvalidKeySpecException, NoSuchPaddingException, InvalidKeyException, InvalidAlgorithmParameterException, IllegalBlockSizeException, BadPaddingException\n{\n\n    //There are three methods via which u can give a password. First direct input, second random text;\n    //third given by user during execution of the program.\n    //Password = \"ThisShoouldWork\"; // to Use the first method, un-comment this line and comment the rest of the methods.\n\n    Password = JOptionPane.showInputDialog(\"Set The Password\"); //To use second method , un-comment this line and comment the rest of the methods.\n\n    /*while(a)                      //to use third method, un-comment this \"block\" and comment the rest of the methods.\n    {\n\n    String setPassword = JOptionPane.showInputDialog(null, \"Enter Your Password\");\n    String confirmPassword = JOptionPane.showInputDialog(null, \"Re-Enter Your Password\");\n\n    if(setPassword.equals(confirmPassword))\n    {\n\n        Password = confirmPassword;\n        a = false;\n    }\n\n\n    else\n        JOptionPane.showMessageDialog(null, \"Passwords Dont Match !!\");\n\n    }*/\n\n\n    fileIn = new FileInputStream(FileInName);\n    fileOut = new FileOutputStream(FileOutName);\n\n    PBEKeySpec keySpec = new PBEKeySpec(Password.toCharArray());\n    SecretKeyFactory keyFactory = SecretKeyFactory.getInstance(\"PBEWithMD5AndDES\");\n    SecretKey passwordKey = keyFactory.generateSecret(keySpec);\n\n    byte[] salt = new byte[8];\n    Random rnd = new Random();\n    rnd.nextBytes(salt);\n    int iterations = 100;\n\n    PBEParameterSpec parameterSpec = new PBEParameterSpec(salt, iterations);\n\n    Cipher cipher = Cipher.getInstance(\"PBEWithMD5AndDES\");\n    cipher.init(Cipher.ENCRYPT_MODE, passwordKey, parameterSpec);\n    fileOut.write(salt);\n\n    byte[] input = new byte[64];\n    int bytesRead;\n\n        while ((bytesRead = fileIn.read(input)) != -1)\n        {\n\n             byte[] output = cipher.update(input, 0, bytesRead);\n             if (output != null) fileOut.write(output);\n        }\n\n    byte[] output = cipher.doFinal();\n\n        if (output != null) fileOut.write(output);\n\n    fileIn.close();\n    fileOut.flush();\n    fileOut.close();\n\n}\n", "idx": 1896}
{"project": "cipher", "commit_id": "Snippet20212056_2878.java", "target": 1, "func": "byte[] plaintext = ...;\nbyte[] key = ...;\n\n// get iv\nSecureRandom rnd = new SecureRandom();\nbyte[] iv = rnd.getBytes(16);\nIvParameterSpec ivSpec = new IvParameterSpec(iv);   \n\n// encrypt\nCipher cipher = Cipher.getInstance(\"AES/CBC/PKCS7Padding\");\ncipher.init(Cipher.ENCRYPT_MODE, key, ivSpec);\nbyte[] ciphertext = cipher.doFinal(plaintext);\n\n// copy to result\nbyte[] result = new byte[iv.length + ciphertext.length];\nSystem.arraycopy(iv, 0, result, 0, iv.length);\nSystem.arraycopy(ciphertext, 0 , result, iv.length, ciphertext.length);\n", "idx": 2143}
{"project": "cipher", "commit_id": "Snippet22047609_4465.java", "target": 1, "func": "public String encrypt(String key, String data) {\n    if (key == null || data == null)\n        return null;\n    try {\n        DESKeySpec desKeySpec = new DESKeySpec(key.getBytes(charsetName));\n        SecretKeyFactory secretKeyFactory = SecretKeyFactory.getInstance(algorithm);\n        SecretKey secretKey = secretKeyFactory.generateSecret(desKeySpec);\n        byte[] dataBytes = data.getBytes(charsetName);\n        Cipher cipher = Cipher.getInstance(algorithm);\n        cipher.init(Cipher.ENCRYPT_MODE, secretKey);\n        return Base64.encodeToString(cipher.doFinal(dataBytes), base64Mode);\n    } catch (Exception e) {\n        return null;\n    }\n}\n\npublic String decrypt(String key, String data) {\n    if (key == null || data == null)\n        return null;\n    try {\n        byte[] dataBytes = Base64.decode(data, base64Mode);\n        DESKeySpec desKeySpec = new DESKeySpec(key.getBytes(charsetName));\n        SecretKeyFactory secretKeyFactory = SecretKeyFactory.getInstance(algorithm);\n        SecretKey secretKey = secretKeyFactory.generateSecret(desKeySpec);\n        Cipher cipher = Cipher.getInstance(algorithm);\n        cipher.init(Cipher.DECRYPT_MODE, secretKey);\n        byte[] dataBytesDecrypted = (cipher.doFinal(dataBytes));\n        return new String(dataBytesDecrypted);\n    } catch (Exception e) {\n        return null;\n    }\n}\n", "idx": 2266}
{"project": "cipher", "commit_id": "Snippet14124370_37477.java", "target": 1, "func": "Cipher AESCipher = Cipher.getInstance(\"AES/CBC/PKCS5Padding\");\nAESCipher.init(Cipher.ENCRYPT_MODE, secretKey, secRandom);\n", "idx": 2064}
{"project": "cipher", "commit_id": "Snippet14494781_37775.java", "target": 0, "func": "FileInputStream fis = new FileInputStream(\"/sdcard/encrypted.apk\");\n\nFileOutputStream fos = new FileOutputStream(\"/sdcard/decrypted.apk\");\nSecretKeySpec sks = new SecretKeySpec(\"MyDifficultPassw\".getBytes(), \"AES\");\nCipher cipher = Cipher.getInstance(\"AES\");\ncipher.init(Cipher.DECRYPT_MODE, sks);\nCipherInputStream cis = new CipherInputStream(fis, cipher);\nint b;\nbyte[] d = new byte[8];\nwhile((b = cis.read(d)) != -1) {\n    fos.write(d, 0, b);\n}\nfos.flush();\nfos.close();\ncis.close();\n", "idx": 1636}
{"project": "cipher", "commit_id": "Snippet25313638_7697.java", "target": 1, "func": "    KeyPairGenerator keyPairGenerator = KeyPairGenerator.getInstance(\"RSA\");\n    keyPairGenerator.initialize(1024);\n    KeyPair keyPair = keyPairGenerator.generateKeyPair();\n\n    KeyGenerator keyGen = KeyGenerator.getInstance(\"AES\");\n    SecretKey sessionKey = keyGen.generateKey();\n\n    // Encrypt the session key with the RSA public key\n    Cipher rsaCipher = Cipher.getInstance(\"RSA\");\n    rsaCipher.init(Cipher.ENCRYPT_MODE, keyPair.getPublic());\n    byte[] encryptedSessionKey = rsaCipher.doFinal(sessionKey.getEncoded());\n\n    // Simulating other end user: Receive encrypted session key,\n    // decrypt it using your private key.\n    Cipher rsaDecryptCipher = Cipher.getInstance(\"RSA\");\n    rsaDecryptCipher.init(Cipher.DECRYPT_MODE, keyPair.getPrivate());\n    byte[] decryptedSessionKeyBytes = rsaCipher.doFinal(encryptedSessionKey);\n    System.out.println(\"Decrypted session key bytes\");\n    System.out.println(decryptedSessionKeyBytes);\n", "idx": 2208}
{"project": "cipher", "commit_id": "Snippet30539696_12721.java", "target": 1, "func": "package com.Encrypt;\n\nimport java.io.FileInputStream;\nimport java.io.IOException;\nimport java.security.InvalidKeyException;\nimport java.security.Key;\nimport java.security.KeyPair;\nimport java.security.KeyStore;\nimport java.security.KeyStoreException;\nimport java.security.NoSuchAlgorithmException;\nimport java.security.PrivateKey;\nimport java.security.PublicKey;\nimport java.security.UnrecoverableEntryException;\nimport java.security.UnrecoverableKeyException;\nimport java.security.KeyStore.PrivateKeyEntry;\nimport java.security.cert.Certificate;\nimport java.security.cert.CertificateException;\nimport javax.crypto.BadPaddingException;\nimport javax.crypto.Cipher;\nimport javax.crypto.IllegalBlockSizeException;\nimport javax.crypto.NoSuchPaddingException;\nimport org.apache.commons.codec.binary.Base64;\n\npublic class Encrypt {\n\npublic String encyptCard(String card) throws KeyStoreException, NoSuchAlgorithmException, CertificateException, IOException, NoSuchPaddingException, InvalidKeyException, IllegalBlockSizeException, BadPaddingException, UnrecoverableKeyException{\n        FileInputStream is = new FileInputStream(\"C:/Users/admin/Desktop/keystore/ksjksformat.jks\");    \n        String keystpassw = \"9801461740\";\n        String alias = \"ksjksformat\";       \n            KeyStore ks = KeyStore.getInstance(KeyStore.getDefaultType());                      \n            ks.load(is,keystpassw.toCharArray() );          \n            Certificate cert = ks.getCertificate(alias);            \n            PublicKey publicKey = cert.getPublicKey();          \n        Cipher cipher = Cipher.getInstance(\"RSA\");\n        cipher.init(Cipher.ENCRYPT_MODE, publicKey);\n        byte[] cipherData = cipher.doFinal(card.getBytes());        \n        String cipherData1 = Base64.encodeBase64String(cipherData);\n        return cipherData1;             \n    }\npublic String decrypte (String encCardNo) throws KeyStoreException, NoSuchAlgorithmException, CertificateException, IOException, UnrecoverableEntryException, NoSuchPaddingException, InvalidKeyException, IllegalBlockSizeException, BadPaddingException{\n    FileInputStream is = new FileInputStream(\"C:/Users/admin/Desktop/keystore/ksjksformat.jks\");    \n    String keystpassw = \"9801461740\";\n    String alias = \"ksjksformat\";       \n        KeyStore ks = KeyStore.getInstance(KeyStore.getDefaultType());                      \n        ks.load(is,keystpassw.toCharArray() );      \n        Key key = ks.getKey(alias, keystpassw.toCharArray());\n        Certificate cert = ks.getCertificate(alias);\n        PublicKey publicKey = cert.getPublicKey();\n        new KeyPair(publicKey, (PrivateKey) (key));     \n        KeyStore.ProtectionParameter protParam = new KeyStore.PasswordProtection(keystpassw.toCharArray());\n        KeyStore.PrivateKeyEntry pkentry = (PrivateKeyEntry) ks.getEntry(alias, protParam);\n        PrivateKey myPrivateKey =pkentry.getPrivateKey();\n        Cipher cipher = Cipher.getInstance(\"RSA\");\n        cipher.init(Cipher.DECRYPT_MODE, myPrivateKey); \n        byte[] cipherData = cipher.doFinal(encCardNo.getBytes());\n        String decrypted =Base64.decodeBase64(cipherData).toString();\n        return decrypted;\n}\n}\n", "idx": 2327}
{"project": "cipher", "commit_id": "Snippet18966480_1866.java", "target": 1, "func": "javax.crypto.Cipher.getInstance(\"RSA/None/PKCS1Padding\")", "idx": 2323}
{"project": "cipher", "commit_id": "Snippet20060563_2712.java", "target": 0, "func": "Cipher ciph = Cipher.getInstance(\"DES/ECB/NoPadding\");\nSecretKey blah = new SecretKeySpec(key, \"DES\");\n", "idx": 1779}
{"project": "cipher", "commit_id": "Snippet46449809_28558.java", "target": 0, "func": "Key key = generateKeyAES();\nCipher c = Cipher.getInstance(\"AES\");\nc.init(Cipher.ENCRYPT_MODE, key);\nbyte[] encVal = c.doFinal(data.getBytes());\nreturn new String(java.util.Base64.getEncoder().encode(encVal));\n", "idx": 1769}
{"project": "cipher", "commit_id": "Snippet28519570_10682.java", "target": 0, "func": "package aes;\n\nimport javax.crypto.*;\nimport java.security.*;\nimport javax.crypto.spec.SecretKeySpec;\nimport sun.misc.*;\n\n\npublic class AESencrpytion {\n\n  //private static final byte[] keyValue = new byte[]{'S','e','c','r','e','t'};\n\n\n  public static String encrypt(String data) throws Exception{\n    KeyGenerator keyGen = KeyGenerator.getInstance(\"AES\");\n    SecureRandom rand = new SecureRandom();\n    keyGen.init(rand);\n    Key key = keyGen.generateKey();\n    Cipher cipher = Cipher.getInstance(\"AES\");\n    cipher.init(Cipher.ENCRYPT_MODE, key);\n    byte[] encValue = cipher.doFinal(data.getBytes());\n    String encryptedValue = new BASE64Encoder().encode(encValue);\n    return encryptedValue;\n  }\n\n  public static String decrypt(String encData) throws Exception {\n    KeyGenerator keyGen = KeyGenerator.getInstance(\"AES\");\n    SecureRandom rand = new SecureRandom();\n    keyGen.init(rand);\n    Key key = keyGen.generateKey();\n    Cipher cipher = Cipher.getInstance(\"AES\");\n    cipher.init(Cipher.DECRYPT_MODE, key);\n    byte[] decodedValue = new BASE64Decoder().decodeBuffer(encData);\n    //ERROR HAPPENS HERE\n    byte[] decValue = cipher.doFinal(decodedValue);\n    String decryptedVal = new String(decValue);\n    return decryptedVal;\n  }\n", "idx": 1653}
{"project": "cipher", "commit_id": "Snippet20759555_3353.java", "target": 1, "func": "import java.io.BufferedInputStream;\nimport java.io.BufferedOutputStream;\nimport java.io.BufferedReader;\nimport java.io.FileInputStream;\nimport java.io.FileOutputStream;\nimport java.io.FileReader;\nimport java.io.IOException;\nimport java.io.InputStream;\nimport java.io.ObjectInputStream;\nimport java.io.ObjectOutputStream;\nimport java.math.BigInteger;\nimport java.security.Key;\nimport java.security.KeyFactory;\nimport java.security.KeyPair;\nimport java.security.KeyPairGenerator;\nimport java.security.PrivateKey;\nimport java.security.PublicKey;\nimport java.security.spec.KeySpec;\nimport java.security.spec.RSAPrivateKeySpec;\nimport java.security.spec.RSAPublicKeySpec;\nimport javax.crypto.Cipher;\nimport javax.crypto.CipherInputStream;\nimport javax.crypto.CipherOutputStream;\n\nclass RSA{\n\npublic static void main(String[] args) throws Exception {\n    generateKeys();\n    rsaEncrypt(\"plaintext.txt\", \"encrypted.txt\");\n    rsaDecrypt(\"encrypted.txt\", \"decrypted.txt\");\n}\n\npublic static void generateKeys() throws Exception {\n    KeyPairGenerator kpg = KeyPairGenerator.getInstance(\"RSA\");\n    kpg.initialize(2048);\n    KeyPair kp = kpg.genKeyPair();\n    PublicKey publicKey = kp.getPublic();\n    PrivateKey privateKey = kp.getPrivate();\n\n    System.out.println(\"keys created\");\n\n    KeyFactory fact = KeyFactory.getInstance(\"RSA\");\n    RSAPublicKeySpec pub = fact.getKeySpec(publicKey,\n            RSAPublicKeySpec.class);\n    RSAPrivateKeySpec priv = fact.getKeySpec(privateKey,\n            RSAPrivateKeySpec.class);\n\n    saveToFile(\"public.key\", pub.getModulus(), pub.getPublicExponent());\n    saveToFile(\"private.key\", priv.getModulus(), priv.getPrivateExponent());\n\n    System.out.println(\"keys saved\");\n}\n\npublic static void saveToFile(String fileName, BigInteger mod,\n        BigInteger exp) throws IOException {\n    ObjectOutputStream fileOut = new ObjectOutputStream(\n            new BufferedOutputStream(new FileOutputStream(fileName)));\n    try {\n        fileOut.writeObject(mod);\n        fileOut.writeObject(exp);\n    } catch (Exception e) {\n        throw new IOException(\"Unexpected error\");\n    } finally {\n        fileOut.close();\n        System.out.println(\"Closed writing file.\");\n    }\n}\n\n// Return the saved key\nstatic Key readKeyFromFile(String keyFileName) throws IOException {\n    InputStream in = new FileInputStream(keyFileName);\n    ObjectInputStream oin = new ObjectInputStream(new BufferedInputStream(\n            in));\n    try {\n        BigInteger m = (BigInteger) oin.readObject();\n        BigInteger e = (BigInteger) oin.readObject();\n        KeyFactory fact = KeyFactory.getInstance(\"RSA\");\n        if (keyFileName.startsWith(\"public\"))\n            return fact.generatePublic(new RSAPublicKeySpec(m, e));\n        else\n            return fact.generatePrivate(new RSAPrivateKeySpec(m, e));\n    } catch (Exception e) {\n        throw new RuntimeException(\"Spurious serialisation error\", e);\n    } finally {\n        oin.close();\n        System.out.println(\"Closed reading file.\");\n    }\n}\n\n// Use this PublicKey object to initialize a Cipher and encrypt some data\npublic static void rsaEncrypt(String file_loc, String file_des)\n        throws Exception {\n    FileReader file = new FileReader(\"C://myprograms//plaintext.txt\");\n    BufferedReader reader = new BufferedReader(file);\n    String text = \"\";\n    String line = reader.readLine();\n    while(line!= null)\n    {\n        text += line;\n    line = reader.readLine();\n    }\n    reader.close();\n    System.out.println(text);\n    byte[] data = new byte[32];\n    int i;\n\n    System.out.println(\"start encyption\");\n    Key pubKey = readKeyFromFile(\"public.key\");\n    Cipher cipher = Cipher.getInstance(\"RSA\");\n    cipher.init(Cipher.ENCRYPT_MODE, pubKey);\n\n    FileInputStream fileIn = new FileInputStream(file_loc);\n    FileOutputStream fileOut = new FileOutputStream(file_des);\n    CipherOutputStream cipherOut = new CipherOutputStream(fileOut, cipher);\n\n    // Read in the data from the file and encrypt it\n    while ((i = fileIn.read(data)) != -1) {\n        cipherOut.write(data, 0, i);\n    }\n\n    // Close the encrypted file\n    cipherOut.close();\n    fileIn.close();\n\n    System.out.println(\"encrypted file created\");\n}\n\n// Use this PublicKey object to initialize a Cipher and decrypt some data\npublic static void rsaDecrypt(String file_loc, String file_des)\n        throws Exception {\n    byte[] data = new byte[32];\n    int i;\n\n    System.out.println(\"start decyption\");\n\n    Key priKey = readKeyFromFile(\"private.key\");\n    Cipher cipher = Cipher.getInstance(\"RSA\");\n    cipher.init(Cipher.DECRYPT_MODE, priKey);\n\n    FileInputStream fileIn = new FileInputStream(file_loc);\n    CipherInputStream cipherIn = new CipherInputStream(fileIn, cipher);\n    FileOutputStream fileOut = new FileOutputStream(file_des);\n\n    // Write data to new file\n    while ((i = cipherIn.read()) != -1) {\n        fileOut.write(i);\n    }\n\n    // Close the file\n    fileIn.close();\n    cipherIn.close();\n    fileOut.close();\n\n    System.out.println(\"decrypted file created\");\n\n}\n}\n", "idx": 2111}
{"project": "cipher", "commit_id": "Snippet27785369_9954.java", "target": 1, "func": "import android.util.Base64;\nimport java.io.UnsupportedEncodingException;\nimport java.nio.charset.Charset;\nimport java.security.MessageDigest;\nimport java.security.NoSuchAlgorithmException;\nimport java.security.SecureRandom;\nimport java.util.Arrays;\nimport java.util.Random;\n\nimport javax.crypto.Cipher;\nimport javax.crypto.spec.IvParameterSpec;\nimport javax.crypto.spec.SecretKeySpec;\n/**\nAes encryption\n*/\npublic class AES\n{\n\n    private static SecretKeySpec secretKey ;\n    private static byte[] key ;\n    private static byte[] iv;\n    private static String decryptedString;\n    private static String encryptedString;\n\n    public static void setKey(String myKey){\n\n\n        MessageDigest sha = null;\n        try {\n            key = myKey.getBytes(\"UTF-8\");\n            System.out.println(key.length);\n            sha = MessageDigest.getInstance(\"SHA-1\");\n            key = sha.digest(key);\n            key = Arrays.copyOf(key, 16); // use only first 128 bit\n            secretKey = new SecretKeySpec(key, \"AES\");\n            iv = new byte[]{11,53,63,87,11,69,63,28,0,9,18,99,95,23,45,8};\n\n        } catch (NoSuchAlgorithmException e) {\n            // TODO Auto-generated catch block\n            e.printStackTrace();\n        } catch (UnsupportedEncodingException e) {\n            // TODO Auto-generated catch block\n            e.printStackTrace();\n        }\n\n\n\n    }\n\n    public static String getDecryptedString() {\n        return decryptedString;\n    }\n    public static void setDecryptedString(String decryptedString) {\n        AES.decryptedString = decryptedString;\n    }\n    public static String getEncryptedString() {\n        return encryptedString;\n    }\n    public static void setEncryptedString(String encryptedString) {\n        AES.encryptedString = encryptedString;\n    }\n    public static String encrypt(String strToEncrypt)\n    {\n        try\n        {\n            Cipher cipher = Cipher.getInstance(\"AES/CBC/PKCS7Padding\",\"BC\");\n            cipher.init(Cipher.ENCRYPT_MODE, secretKey,new IvParameterSpec(iv));\n            setEncryptedString(Base64.encodeToString(cipher.doFinal(strToEncrypt.getBytes(\"UTF-8\")),Base64.DEFAULT));\n\n        }\n        catch (Exception e)\n        {\n\n            System.out.println(\"Error while encrypting: \"+e.toString());\n        }\n        return null;\n    }\n    public static String decrypt(String strToDecrypt)\n    {\n        try\n        {\n            Cipher cipher = Cipher.getInstance(\"AES/CBC/PKCS7PADDING\",\"BC\");\n            cipher.init(Cipher.DECRYPT_MODE, secretKey,new IvParameterSpec(iv));\n            String decoded = new String(cipher.doFinal(Base64.decode(strToDecrypt,Base64.DEFAULT)), Charset.forName(\"UTF-8\"));\n            setDecryptedString(decoded);\n\n        }\n        catch (Exception e)\n        {\n\n            System.out.println(\"Error while decrypting: \"+e.toString());\n        }\n        return null;\n    }\n\n}\n", "idx": 2121}
{"project": "cipher", "commit_id": "Snippet38522214_20481.java", "target": 1, "func": "public class AES64 {\npublic static String encrypt(String key, String ivs, String value) {\n    try {\n        IvParameterSpec iv = new IvParameterSpec(ivs.getBytes(\"ISO-8859-1\"));\n\n        SecretKeySpec skeySpec = new SecretKeySpec(key.getBytes(\"ISO-8859-1\"),\n                \"AES\");\n        Cipher cipher = Cipher.getInstance(\"AES/CBC/PKCS5PADDING\");\n        cipher.init(Cipher.ENCRYPT_MODE, skeySpec, iv);\n        byte[] encrypted = cipher.doFinal(value.getBytes(\"ISO-8859-1\"));\n        String r = Base64.encodeToString(encrypted, Base64.DEFAULT);\n        return r;\n    } catch (Exception ex) {\n        ex.printStackTrace();\n    }\n    return null;\n}\n\npublic static String decrypt(String key, String ivs, String encrypted) {\n    try {\n        IvParameterSpec iv = new IvParameterSpec(ivs.getBytes(\"ISO-8859-1\"));\n\n        SecretKeySpec skeySpec = new SecretKeySpec(key.getBytes(\"ISO-8859-1\"),\n                \"AES\");\n        Cipher cipher = Cipher.getInstance(\"AES/CBC/PKCS5PADDING\");\n        cipher.init(Cipher.DECRYPT_MODE, skeySpec, iv);\n        byte[] original = cipher.doFinal(Base64.decode(encrypted.getBytes(\"ISO-8859-1\"), Base64.DEFAULT));\n\n        return new String(original);\n\n    } catch (Exception ex) {\n        ex.printStackTrace();\n        return ex.toString();\n    }\n  }\n}\n", "idx": 2151}
{"project": "cipher", "commit_id": "Snippet33802314_15808.java", "target": 1, "func": "    Security.addProvider(new BouncyCastleProvider());\n\n    byte[] key = Base64.getDecoder().decode(\"LLkRRMSAlD16lrfbRLdIELdj0U1+Uiap0ihQrRz7HSQ=\");\n    byte[] iv = Base64.getDecoder().decode(\"A23OFOSvsC4UyejA227d8g==\");\n    byte[] input = Base64.getDecoder().decode(\"D/e0UjAwBF+d8aVqZ0FpXA==\");\n\n    Cipher cipher = Cipher.getInstance(\"AES/CBC/NoPadding\");\n    cipher.init(Cipher.ENCRYPT_MODE, new SecretKeySpec(key, \"AES\"), new IvParameterSpec(iv));\n    byte[] output = cipher.doFinal(input);\n    System.out.println(\"[\" + new String(output) + \"] - \"+output.length);\n", "idx": 2114}
{"project": "cipher", "commit_id": "Snippet37614790_19570.java", "target": 0, "func": "public String encrypt(String plainPwd)\n{\n    byte[] outputBytes = new byte[] {};\n    String returnString = \"\";\n    try\n    {\n        byte[] raw = \"XXXXX@XXXXXX.XXX\".getBytes(\"UTF-8\");\n\n        SecretKeySpec skeySpec = new SecretKeySpec(raw, \"AES\");\n        Cipher cipher = Cipher.getInstance(\"AES\");\n        cipher.init(Cipher.ENCRYPT_MODE, skeySpec);\n\n        outputBytes = cipher.doFinal(plainPwd.getBytes(\"UTF-8\"));\n        if (null != outputBytes)\n        {\n            returnString = Base64Encrypter.getInstance().encode(outputBytes);\n        }\n        return returnString.trim();\n\n    }\n    catch (Exception e)\n    {\n        System.out.println(e);\n    }\n\n    return new String(outputBytes).trim();\n}\n\npublic String decrypt(String encryptedPwd)\n{\n    byte[] outputBytes = new byte[] {};\n    try\n    {\n        byte[] raw = \"XXXXX@XXXXXX.XXX\".getBytes(\"UTF-8\");\n\n        SecretKeySpec skeySpec = new SecretKeySpec(raw, \"AES\");\n        Cipher cipher = Cipher.getInstance(\"AES\");\n        cipher.init(Cipher.DECRYPT_MODE, skeySpec);\n\n        byte[] inputBytes = Base64Encrypter.getInstance().decode(encryptedPwd);\n        if (null != inputBytes)\n        {\n            outputBytes = cipher.doFinal(inputBytes);\n        }\n    }\n    catch (Exception e)\n    {\n        System.out.println(e);\n    }\n\n    return new String(outputBytes).trim();\n}\n", "idx": 1775}
{"project": "cipher", "commit_id": "Snippet39646722_21557.java", "target": 1, "func": "public static HashMap decryptSeedValue() throws Exception\n{\n\nString password = \"G?20R+I+3-/UcWIN\";\n\n\nString pbesalt = \"EW0h0yUcDX72WU9UiKiCwDpXsJg=\";\nString iv = \"aaaaaaaaaaaaaaaaaaaaaaaa\";\n\nint iteration = 128;\n\nString value = \"pM7VB/KomPjq2cKaxPr5cKT1tUZN5tGMI+u1XKJTG1la+ThraPpLKlL2plKk6vQE\";\nString valueDigest = \"lbu+9OcLArnj6mS7KYOKDa4zRU0=\";\n\n//YOU NEED THIS GUY BELOW TO VERIFY\nString macKey = \"jq/NdikC7AZf0Z+HEL5NrCICV8XW+ttzl/8687hVGHceoyJAaFws+111plQH6Mlg\";\n\nbyte[] cipherText = null;\n\n//some parameters need to decode from Base64 to byte[]\nbyte[] data = base64Decode(value.getBytes());\n//System.out.println(\"data(hex string) = \" + HexBin.encode(data));//debug\n\nbyte[] salt = base64Decode(pbesalt.getBytes());\n//System.out.println(\"salt(hex string) = \" + HexBin.encode(salt));//debug\n\nbyte[] initVec = base64Decode(iv.getBytes());\n//System.out.println(\"iv(hex string) = \" + HexBin.encode(initVec));//debug\n\n//perform PBE key generation and AES/CBC/PKCS5Padding decrpyption\nHashMap hs = myFunction(data, password, base64Decode(macKey.getBytes()), salt, iteration);\n\nString seedValue = (String) hs.get(\"DECRYPTED_SEED_VALUE\");\nbyte[] temp = (byte[]) hs.get(\"HASH_OUTPUT\");\n\n//System.out.println(\"hashed output(hex string) = \" + HexBin.encode(temp));//debug\n//perform Base64 Encode \nbyte[] out = base64Encode(temp);\n\nString output = new String((out));\nSystem.out.println(\"output = \" + output);\nSystem.out.println(\"valueD = \" + valueDigest);\n//System.out.println(\"hashed output(base64) = \" + output);\n\n//compare the result\nif (output.equals(valueDigest)) {\n  System.out.println(\"Hash verification successful for:-->\");\n  System.out.println(\"\\n\");\n\n  //hs.put(\"SEED_VALUE\", HexBin.encode(temp));\n  hs.put(\"SEED_VALUE\", seedValue);\n  return hs;\n\n} else {\n  System.out.println(\"Hash verification failed  for :-->\");\n\n  return null;\n\n}\n\n}\npublic static HashMap myFunction(byte[] data, String password, byte[] macData,\n      byte[] salt, int iteration) throws Exception\n{\n\nPKCS5S2ParametersGenerator generator = new PKCS5S2ParametersGenerator();\n\nbyte[] pBytes = password.getBytes();\n\ngenerator.init(pBytes, salt, iteration);\n\nbyte[] iv = new byte[16];\nint ivsize = iv.length;\nbyte[] encryptedData = new byte[data.length - ivsize];\nSystem.arraycopy(data, 0, iv, 0, iv.length);\nSystem.arraycopy(data, ivsize, encryptedData, 0, encryptedData.length);\n\nbyte[] maciv = new byte[16];\nbyte[] encryptedMac = new byte[macData.length - maciv.length];\nSystem.arraycopy(macData, 0, maciv, 0, maciv.length);\nSystem.arraycopy(macData, maciv.length, encryptedMac, 0, encryptedMac.length);\n\nint keysize = 128;//fixed at AES key of 16 bytes\n\nSecretKeyFactory factory = SecretKeyFactory.getInstance(\"PBKDF2WithHmacSHA1\");\nKeySpec spec = new PBEKeySpec(password.toCharArray(), salt, iteration, keysize);\nSecretKey tmp = factory.generateSecret(spec);\nSecretKey key = new SecretKeySpec(tmp.getEncoded(), \"AES\");\nCipher dcipher = Cipher.getInstance(\"AES/CBC/PKCS5Padding\");\n\ndcipher.init(Cipher.DECRYPT_MODE, key, new IvParameterSpec(iv));\n\nbyte[] decryptedData = dcipher.doFinal(encryptedData);\n// decryptedData is your token value!\n\ndcipher.init(Cipher.DECRYPT_MODE, key, new IvParameterSpec(maciv));\n\nbyte[] decryptedMac = dcipher.doFinal(encryptedMac);\n\n//display the 20 bytes secret of the token \n//System.out.println(\"token secret(hex string) = \" + HexBin.encode(secret));\n//perform HMAC-SHA-1\n\n//Use the decrypted MAC key here for hashing!\nbyte[] output = hmac_sha1(data, decryptedMac);\n\nHashMap hs = new HashMap();\n\nhs.put(\"ENCRYPTION_KEY\", password);\nhs.put(\"HASH_OUTPUT\", output);\n\nhs.put(\"DECRYPTED_SEED_VALUE\", HexBin.encode(decryptedData));\n\nreturn hs;\n}\n", "idx": 2082}
{"project": "cipher", "commit_id": "Snippet33807193_15860.java", "target": 1, "func": "import java.io.UnsupportedEncodingException;\nimport java.security.InvalidAlgorithmParameterException;\nimport java.security.InvalidKeyException;\nimport java.security.MessageDigest;\nimport java.security.NoSuchAlgorithmException;\nimport java.util.Arrays;\nimport javax.crypto.BadPaddingException;\n\nimport javax.crypto.Cipher;\nimport javax.crypto.IllegalBlockSizeException;\nimport javax.crypto.NoSuchPaddingException;\nimport javax.crypto.spec.IvParameterSpec;\nimport javax.crypto.spec.SecretKeySpec;\n\nimport org.apache.commons.codec.binary.Base64;\n\n\n\npublic class AES {  \n    private static SecretKeySpec secretKey ;\n    private static byte[] key ;  \n    private static String decryptedString;\n    private static String encryptedString;\n\n    public static void setKey(String myKey){ \n        MessageDigest sha = null;\n        try {\n                key = myKey.getBytes(\"UTF-8\");\n\n                sha = MessageDigest.getInstance(\"SHA-1\");\n                key = sha.digest(key);\n        key = Arrays.copyOf(key, 16); // use only first 128 bit\n\n       // System.out.println(new String(key,\"UTF-8\"));\n            secretKey = new SecretKeySpec(key, \"AES\");\n\n\n        } catch (NoSuchAlgorithmException | UnsupportedEncodingException e) {\n        }\n    }\n\n    public static String getDecryptedString() {\n        return decryptedString;\n    }\n\n    public static void setDecryptedString(String decryptedString) {\n        AES.decryptedString = decryptedString;\n    }\n\n    public static String getEncryptedString() {\n        return encryptedString;\n    }\n\n    public static void setEncryptedString(String encryptedString) {\n        AES.encryptedString = encryptedString;\n    }\n\n    public static String encrypt(String initVector, String strToEncrypt) throws InvalidAlgorithmParameterException\n    {\n        try\n        {\n            Cipher cipher = Cipher.getInstance(\"AES/CBC/PKCS5PADDING\");\n            IvParameterSpec iv = new IvParameterSpec(initVector.getBytes(\"UTF-8\"));\n            cipher.init(Cipher.ENCRYPT_MODE, secretKey, iv);\n\n\n            setEncryptedString(Base64.encodeBase64String(cipher.doFinal(strToEncrypt.getBytes(\"UTF-8\"))));\n\n        }\n        catch (NoSuchAlgorithmException | NoSuchPaddingException | InvalidKeyException | UnsupportedEncodingException | IllegalBlockSizeException | BadPaddingException e)\n        {\n\n            System.out.println(\"Error while encrypting: \"+e.toString());\n        }\n        return null;\n\n    }\n\n    public static String decrypt(String initVector, String strToDecrypt) throws InvalidAlgorithmParameterException, UnsupportedEncodingException\n    {\n        try\n        {\n            Cipher cipher = Cipher.getInstance(\"AES/CBC/PKCS5PADDING\");\n            IvParameterSpec iv = new IvParameterSpec(initVector.getBytes(\"UTF-8\"));\n            cipher.init(Cipher.DECRYPT_MODE, secretKey, iv);\n            setDecryptedString(new String(cipher.doFinal(Base64.decodeBase64(strToDecrypt))));\n\n        }\n        catch (NoSuchAlgorithmException | NoSuchPaddingException | InvalidKeyException | IllegalBlockSizeException | BadPaddingException e)\n        {\n\n            System.out.println(\"Error while decrypting: \"+e.toString());\n\n        }\n        return null;\n    }\n\n\n    public static void main(String args[]) throws InvalidAlgorithmParameterException, UnsupportedEncodingException\n    {\n                String initVector = \"Bw/+ctBXLE4=@f9t\"; // 16 bytes IV\n                final String strToEncrypt = \"12345657\";\n                final String strPssword = \"ViK#@Uef$#!BZFgAUW6qZiudgoQ==\";\n                AES.setKey(strPssword);\n\n                AES.encrypt(initVector, strToEncrypt.trim());\n\n                System.out.println(\"String to Encrypt: \" + strToEncrypt); \n                System.out.println(\"Encrypted: \" + AES.getEncryptedString());\n\n                final String strToDecrypt =  AES.getEncryptedString();\n                AES.decrypt(initVector, strToDecrypt.trim());\n\n                System.out.println(\"String To Decrypt : \" + strToDecrypt);\n                System.out.println(\"Decrypted : \" + AES.getDecryptedString());\n\n\n\n    }\n\n}\n", "idx": 2060}
{"project": "cipher", "commit_id": "Snippet41223999_23189.java", "target": 0, "func": "public class AESCrypt\n{\n    private static final String ALGORITHM = \"AES\";\n    private static final String KEY = \"1Hbfh667adfDEJ78\";\n\n    public static String encrypt(String value) throws Exception\n    {\n        Key key = generateKey();\n        Cipher cipher = Cipher.getInstance(AESCrypt.ALGORITHM);\n        cipher.init(Cipher.ENCRYPT_MODE, key);\n        byte [] encryptedByteValue = cipher.doFinal(value.getBytes(\"utf-8\"));\n        String encryptedValue64 = Base64.encodeToString(encryptedByteValue, Base64.DEFAULT);\n        return encryptedValue64;\n\n    }\n\n    public static String decrypt(String value) throws Exception\n    {\n        Key key = generateKey();\n        Cipher cipher = Cipher.getInstance(AESCrypt.ALGORITHM);\n        cipher.init(Cipher.DECRYPT_MODE, key);\n        byte[] decryptedValue64 = Base64.decode(value, Base64.DEFAULT);\n        byte [] decryptedByteValue = cipher.doFinal(decryptedValue64);\n        String decryptedValue = new String(decryptedByteValue,\"utf-8\");\n        return decryptedValue;\n\n    }\n\n    private static Key generateKey() throws Exception\n    {\n        Key key = new SecretKeySpec(AESCrypt.KEY.getBytes(),AESCrypt.ALGORITHM);\n        return key;\n    }\n}\n", "idx": 1915}
{"project": "cipher", "commit_id": "Snippet6393502_32111.java", "target": 0, "func": "/**\n * Warning, this gives a false sense of security.  If an attacker has enough access to\n * acquire your password store, then he almost certainly has enough access to acquire your\n * source binary and figure out your encryption key.  However, it will prevent casual\n * investigators from acquiring passwords, and thereby may prevent undesired negative\n * publicity.\n */\npublic class ObscuredSharedPreferences implements SharedPreferences {\n    protected static final String UTF8 = \"utf-8\";\n    private static final char[] SEKRIT = ... ; // INSERT A RANDOM PASSWORD HERE.\n                                               // Don't use anything you wouldn't want to\n                                               // get out there if someone decompiled\n                                               // your app.\n\n\n    protected SharedPreferences delegate;\n    protected Context context;\n\n    public ObscuredSharedPreferences(Context context, SharedPreferences delegate) {\n        this.delegate = delegate;\n        this.context = context;\n    }\n\n    public class Editor implements SharedPreferences.Editor {\n        protected SharedPreferences.Editor delegate;\n\n        public Editor() {\n            this.delegate = ObscuredSharedPreferences.this.delegate.edit();                    \n        }\n\n        @Override\n        public Editor putBoolean(String key, boolean value) {\n            delegate.putString(key, encrypt(Boolean.toString(value)));\n            return this;\n        }\n\n        @Override\n        public Editor putFloat(String key, float value) {\n            delegate.putString(key, encrypt(Float.toString(value)));\n            return this;\n        }\n\n        @Override\n        public Editor putInt(String key, int value) {\n            delegate.putString(key, encrypt(Integer.toString(value)));\n            return this;\n        }\n\n        @Override\n        public Editor putLong(String key, long value) {\n            delegate.putString(key, encrypt(Long.toString(value)));\n            return this;\n        }\n\n        @Override\n        public Editor putString(String key, String value) {\n            delegate.putString(key, encrypt(value));\n            return this;\n        }\n\n        @Override\n        public void apply() {\n            delegate.apply();\n        }\n\n        @Override\n        public Editor clear() {\n            delegate.clear();\n            return this;\n        }\n\n        @Override\n        public boolean commit() {\n            return delegate.commit();\n        }\n\n        @Override\n        public Editor remove(String s) {\n            delegate.remove(s);\n            return this;\n        }\n    }\n\n    public Editor edit() {\n        return new Editor();\n    }\n\n\n    @Override\n    public Map<String, ?> getAll() {\n        throw new UnsupportedOperationException(); // left as an exercise to the reader\n    }\n\n    @Override\n    public boolean getBoolean(String key, boolean defValue) {\n        final String v = delegate.getString(key, null);\n        return v!=null ? Boolean.parseBoolean(decrypt(v)) : defValue;\n    }\n\n    @Override\n    public float getFloat(String key, float defValue) {\n        final String v = delegate.getString(key, null);\n        return v!=null ? Float.parseFloat(decrypt(v)) : defValue;\n    }\n\n    @Override\n    public int getInt(String key, int defValue) {\n        final String v = delegate.getString(key, null);\n        return v!=null ? Integer.parseInt(decrypt(v)) : defValue;\n    }\n\n    @Override\n    public long getLong(String key, long defValue) {\n        final String v = delegate.getString(key, null);\n        return v!=null ? Long.parseLong(decrypt(v)) : defValue;\n    }\n\n    @Override\n    public String getString(String key, String defValue) {\n        final String v = delegate.getString(key, null);\n        return v != null ? decrypt(v) : defValue;\n    }\n\n    @Override\n    public boolean contains(String s) {\n        return delegate.contains(s);\n    }\n\n    @Override\n    public void registerOnSharedPreferenceChangeListener(OnSharedPreferenceChangeListener onSharedPreferenceChangeListener) {\n        delegate.registerOnSharedPreferenceChangeListener(onSharedPreferenceChangeListener);\n    }\n\n    @Override\n    public void unregisterOnSharedPreferenceChangeListener(OnSharedPreferenceChangeListener onSharedPreferenceChangeListener) {\n        delegate.unregisterOnSharedPreferenceChangeListener(onSharedPreferenceChangeListener);\n    }\n\n\n\n\n    protected String encrypt( String value ) {\n\n        try {\n            final byte[] bytes = value!=null ? value.getBytes(UTF8) : new byte[0];\n            SecretKeyFactory keyFactory = SecretKeyFactory.getInstance(\"PBEWithMD5AndDES\");\n            SecretKey key = keyFactory.generateSecret(new PBEKeySpec(SEKRIT));\n            Cipher pbeCipher = Cipher.getInstance(\"PBEWithMD5AndDES\");\n            pbeCipher.init(Cipher.ENCRYPT_MODE, key, new PBEParameterSpec(Settings.Secure.getString(context.getContentResolver(),Settings.Secure.ANDROID_ID).getBytes(UTF8), 20));\n            return new String(Base64.encode(pbeCipher.doFinal(bytes), Base64.NO_WRAP),UTF8);\n\n        } catch( Exception e ) {\n            throw new RuntimeException(e);\n        }\n\n    }\n\n    protected String decrypt(String value){\n        try {\n            final byte[] bytes = value!=null ? Base64.decode(value,Base64.DEFAULT) : new byte[0];\n            SecretKeyFactory keyFactory = SecretKeyFactory.getInstance(\"PBEWithMD5AndDES\");\n            SecretKey key = keyFactory.generateSecret(new PBEKeySpec(SEKRIT));\n            Cipher pbeCipher = Cipher.getInstance(\"PBEWithMD5AndDES\");\n            pbeCipher.init(Cipher.DECRYPT_MODE, key, new PBEParameterSpec(Settings.Secure.getString(context.getContentResolver(),Settings.Secure.ANDROID_ID).getBytes(UTF8), 20));\n            return new String(pbeCipher.doFinal(bytes),UTF8);\n\n        } catch( Exception e) {\n            throw new RuntimeException(e);\n        }\n    }\n\n}\n", "idx": 1876}
{"project": "cipher", "commit_id": "Snippet19423426_2213.java", "target": 0, "func": "import javax.crypto.*;    \nimport java.security.*;  \npublic class Java {\n\nprivate static SecretKey key = null;         \n   private static Cipher cipher = null; \n\n   public static void main(String[] args) throws Exception\n   {\n\n      Security.addProvider(new com.sun.crypto.provider.SunJCE());\n\n      KeyGenerator keyGenerator =\n         KeyGenerator.getInstance(\"DESede\");\n      keyGenerator.init(168);\n      SecretKey secretKey = keyGenerator.generateKey();\n      cipher = Cipher.getInstance(\"DESede\");\n\n      String clearText = \"I am an Employee\";\n      byte[] clearTextBytes = clearText.getBytes(\"UTF8\");\n\n      cipher.init(Cipher.ENCRYPT_MODE, secretKey);\n      byte[] cipherBytes = cipher.doFinal(clearTextBytes);\n      String cipherText = new String(cipherBytes, \"UTF8\");\n\n      cipher.init(Cipher.DECRYPT_MODE, secretKey);\n      byte[] decryptedBytes = cipher.doFinal(cipherBytes);\n      String decryptedText = new String(decryptedBytes, \"UTF8\");\n\n      System.out.println(\"Before encryption: \" + clearText);\n      System.out.println(\"After encryption: \" + cipherText);\n      System.out.println(\"After decryption: \" + decryptedText);\n   }\n}\n\n\n// Output\n\n/*\nBefore encryption: I am an Employee  \nAfter encryption: }?\uff7d?\uff7dj6?\uff7dm?\uff7dZyc?\uff7d?\uff7d*?\uff7d?\uff7dl#l?\uff7ddV  \nAfter decryption: I am an Employee  \n*/\n", "idx": 1802}
{"project": "cipher", "commit_id": "Snippet30553832_12770.java", "target": 1, "func": "Cipher cipher = Cipher.getInstance(\"RSA\");\n", "idx": 2037}
{"project": "cipher", "commit_id": "Snippet41461543_21526.java", "target": 1, "func": "cipher = Cipher.getInstance(\"RSA/ECB/PKCS1Padding\");\ncipher.init(Cipher.DECRYPT_MODE, mRSAPublicKey);\nfinal byte[] result = cipher.doFinal(data);\n", "idx": 1951}
{"project": "cipher", "commit_id": "Snippet35403878_17301.java", "target": 1, "func": "package com.jgarin.encryptingtestapp;\n\nimport android.util.Base64;\n\nimport java.io.UnsupportedEncodingException;\nimport java.security.InvalidAlgorithmParameterException;\nimport java.security.InvalidKeyException;\nimport java.security.MessageDigest;\nimport java.security.NoSuchAlgorithmException;\nimport java.security.SecureRandom;\n\nimport javax.crypto.BadPaddingException;\nimport javax.crypto.Cipher;\nimport javax.crypto.IllegalBlockSizeException;\nimport javax.crypto.NoSuchPaddingException;\nimport javax.crypto.spec.IvParameterSpec;\nimport javax.crypto.spec.SecretKeySpec;\n\n   /*****************************************************************\n    * CrossPlatform CryptLib\n    * \n    * <p>\n    * This cross platform CryptLib uses AES 256 for encryption. This library can\n    * be used for encryptoion and de-cryption of string on iOS, Android and Windows\n    * platform.<br/>\n    * Features: <br/>\n    * 1. 256 bit AES encryption\n    * 2. Random IV generation. \n    * 3. Provision for SHA256 hashing of key. \n    * </p>\n    * \n    * @since 1.0\n    * @author navneet\n    *****************************************************************/\n\npublic class CryptLib {\n\n   /**\n    * Encryption mode enumeration\n    */\n   private enum EncryptMode {\n      ENCRYPT, DECRYPT;\n   }\n\n   // cipher to be used for encryption and decryption\n   Cipher cipher;\n\n   // encryption key and initialization vector\n   byte[] key, iv;\n\n   public CryptLib() throws NoSuchAlgorithmException, NoSuchPaddingException {\n      // initialize the cipher with transformation AES/CBC/PKCS5Padding\n      cipher = Cipher.getInstance(\"AES/CBC/PKCS5Padding\");\n//    cipher = Cipher.getInstance(\"AES/CBC/NoPadding\");\n      key = new byte[16]; //256 bit key space\n      iv = new byte[16]; //128 bit IV\n   }\n\n   /**\n    * Note: This function is no longer used. \n    * This function generates md5 hash of the input string\n    * @param inputString\n    * @return md5 hash of the input string\n    */\n   public static final String md5(final String inputString) {\n       final String MD5 = \"MD5\";\n       try {\n           // Create MD5 Hash\n           MessageDigest digest = java.security.MessageDigest\n                   .getInstance(MD5);\n           digest.update(inputString.getBytes());\n           byte messageDigest[] = digest.digest();\n\n           // Create Hex String\n           StringBuilder hexString = new StringBuilder();\n           for (byte aMessageDigest : messageDigest) {\n               String h = Integer.toHexString(0xFF & aMessageDigest);\n               while (h.length() < 2)\n                   h = \"0\" + h;\n               hexString.append(h);\n           }\n           return hexString.toString();\n\n       } catch (NoSuchAlgorithmException e) {\n           e.printStackTrace();\n       }\n       return \"\";\n   }\n\n   /**\n    * \n    * @param inputData\n    *            Text to be encrypted or decrypted\n    * @param _encryptionKey\n    *            Encryption key to used for encryption / decryption\n    * @param _mode\n    *            specify the mode encryption / decryption\n    * @param _initVector\n    *           Initialization vector\n    * @return encrypted or decrypted string based on the mode\n    * @throws UnsupportedEncodingException\n    * @throws InvalidKeyException\n    * @throws InvalidAlgorithmParameterException\n    * @throws IllegalBlockSizeException\n    * @throws BadPaddingException\n    */\n      private byte[] encryptDecrypt(byte[] inputData, String _encryptionKey,\n         EncryptMode _mode, String _initVector) throws UnsupportedEncodingException,\n         InvalidKeyException, InvalidAlgorithmParameterException,\n         IllegalBlockSizeException, BadPaddingException {\n      byte[] _out = new byte[0];// output string\n\n      int len = _encryptionKey.getBytes(\"UTF-8\").length; // length of the key    provided\n\n      if (_encryptionKey.getBytes(\"UTF-8\").length > key.length)\n         len = key.length;\n\n      int ivlen = _initVector.getBytes(\"UTF-8\").length;\n\n      if(_initVector.getBytes(\"UTF-8\").length > iv.length)\n         ivlen = iv.length;\n\n      System.arraycopy(_encryptionKey.getBytes(\"UTF-8\"), 0, key, 0, len);\n      System.arraycopy(_initVector.getBytes(\"UTF-8\"), 0, iv, 0, ivlen);\n      //KeyGenerator _keyGen = KeyGenerator.getInstance(\"AES\");\n      //_keyGen.init(128);\n\n      SecretKeySpec keySpec = new SecretKeySpec(key, \"AES\"); // Create a new SecretKeySpec\n                           // for the\n                           // specified key\n                           // data and\n                           // algorithm\n                           // name.\n\n      IvParameterSpec ivSpec = new IvParameterSpec(iv); // Create a new\n                        // IvParameterSpec\n                        // instance with the\n                        // bytes from the\n                        // specified buffer\n                        // iv used as\n                        // initialization\n                        // vector.\n\n      // encryption\n      if (_mode.equals(EncryptMode.ENCRYPT)) {\n         // Potentially insecure random numbers on Android 4.3 and older.\n         // Read\n         // https://android-developers.blogspot.com/2013/08/some-securerandom-thoughts.html\n         // for more info.\n         cipher.init(Cipher.ENCRYPT_MODE, keySpec, ivSpec);// Initialize this cipher instance\n         _out = cipher.doFinal(inputData); // Finish\n                              // multi-part\n                              // transformation\n                              // (encryption)\n      }\n\n      // decryption\n      if (_mode.equals(EncryptMode.DECRYPT)) {\n         cipher.init(Cipher.DECRYPT_MODE, keySpec, ivSpec);// Initialize this cipher instance\n\n         _out = cipher.doFinal(inputData); // Finish\n                           // multi-part\n                           // transformation\n                           // (decryption)\n      }\n      System.out.println(_out);\n      return _out; // return encrypted/decrypted string\n   }\n\n   /***\n    * This function computes the SHA256 hash of input string\n    * @param text input text whose SHA256 hash has to be computed\n    * @param length length of the text to be returned\n    * @return returns SHA256 hash of input text \n    * @throws NoSuchAlgorithmException\n    * @throws UnsupportedEncodingException\n    */\n   public static String SHA256 (String text, int length) throws NoSuchAlgorithmException, UnsupportedEncodingException {\n\n       String resultStr;\n      MessageDigest md = MessageDigest.getInstance(\"SHA-256\");\n\n       md.update(text.getBytes(\"UTF-8\"));\n       byte[] digest = md.digest();\n\n       StringBuffer result = new StringBuffer();\n       for (byte b : digest) {\n           result.append(String.format(\"%02x\", b)); //convert to hex\n       }\n       //return result.toString();\n\n       if(length > result.toString().length())\n       {\n          resultStr = result.toString();\n       }\n       else \n       {\n          resultStr = result.toString().substring(0, length);\n       }\n\n       return resultStr;\n\n   }\n\n   /***\n    * This function encrypts the plain text to cipher text using the key\n    * provided. You'll have to use the same key for decryption\n    * \n    * @param _plainText\n    *            Plain text to be encrypted\n    * @param _key\n    *            Encryption Key. You'll have to use the same key for decryption\n    * @param _iv\n    *         initialization Vector\n    * @return returns encrypted (cipher) text\n    * @throws InvalidKeyException\n    * @throws UnsupportedEncodingException\n    * @throws InvalidAlgorithmParameterException\n    * @throws IllegalBlockSizeException\n    * @throws BadPaddingException\n    */\n\n   public String encrypt(String _plainText, String _key, String _iv)\n         throws InvalidKeyException, UnsupportedEncodingException,\n         InvalidAlgorithmParameterException, IllegalBlockSizeException,\n         BadPaddingException {\n\n        byte[] bytes = encryptDecrypt(_plainText.getBytes(\"UTF-8\"), _key, EncryptMode.ENCRYPT, _iv);\n        String result = Base64.encodeToString(bytes, Base64.DEFAULT); // ciphertext\n        return result;\n   }\n\n   public byte[] encrypt(byte[] data, String _key, String _iv)\n         throws InvalidKeyException, UnsupportedEncodingException,\n         InvalidAlgorithmParameterException, IllegalBlockSizeException,\n         BadPaddingException {\n      return encryptDecrypt(data, _key, EncryptMode.ENCRYPT, _iv);\n   }\n\n   /***\n    * This funtion decrypts the encrypted text to plain text using the key\n    * provided. You'll have to use the same key which you used during\n    * encryprtion\n    * \n    * @param data\n    *            Encrypted/Cipher text to be decrypted\n    * @param _key\n    *            Encryption key which you used during encryption\n    * @param _iv\n    *         initialization Vector\n    * @return encrypted value\n    * @throws InvalidKeyException\n    * @throws UnsupportedEncodingException\n    * @throws InvalidAlgorithmParameterException\n    * @throws IllegalBlockSizeException\n    * @throws BadPaddingException\n    */\n   public byte[] decrypt(byte[] data, String _key, String _iv)\n         throws InvalidKeyException, UnsupportedEncodingException,\n         InvalidAlgorithmParameterException, IllegalBlockSizeException,\n         BadPaddingException {\n      return encryptDecrypt(data, _key, EncryptMode.DECRYPT, _iv);\n   }\n\n   public String decrypt(String inputString, String _key, String _iv)\n         throws InvalidKeyException, UnsupportedEncodingException,\n         InvalidAlgorithmParameterException, IllegalBlockSizeException,\n         BadPaddingException {\n        byte[] decryptedVal = encryptDecrypt(Base64.decode(inputString, Base64.DEFAULT), _key, EncryptMode.DECRYPT, _iv);\n        String result = new String(decryptedVal, \"UTF-8\");\n        return result;\n   }\n\n   /**\n   * this function generates random string for given length\n   * @param length\n   *           Desired length\n   * * @return \n   */\n   public static String generateRandomIV(int length)\n   {\n      SecureRandom ranGen = new SecureRandom();\n      byte[] aesKey = new byte[16];\n      ranGen.nextBytes(aesKey);\n      StringBuffer result = new StringBuffer();\n       for (byte b : aesKey) {\n           result.append(String.format(\"%02x\", b)); //convert to hex\n       }\n       if(length> result.toString().length())\n       {\n          return result.toString();\n       }\n       else\n       {\n          return result.toString().substring(0, length);\n       }\n   }\n}\n", "idx": 2215}
{"project": "cipher", "commit_id": "Snippet13865655_37291.java", "target": 0, "func": "private byte[] encrypt(byte[] raw, byte[] clear) throws Exception {\n    SecretKeySpec skeySpec = new SecretKeySpec(raw, \"AES\");\n    Cipher cipher = Cipher.getInstance(\"AES\");\n    cipher.init(Cipher.ENCRYPT_MODE, skeySpec);\n\n    int offset = 0;\n    byte[] encrypted;\n\n    while(offset < clear.length()) {\n        final byte[] answer = cipher.update(clear, offset, 1024);\n        encrypted = Arrays.copyOf( encrypted, encrypted.length + 1024);\n        System.arrayCopy(answer, 0, encrypted, offset, 1024);\n        offset += 1024;\n    }\n    encrypted += cipher.doFinal(clear, offset, clear.length() - offset);\n    return encrypted;\n}\n", "idx": 1738}
{"project": "cipher", "commit_id": "Snippet7781348_32918.java", "target": 0, "func": "SecretKeySpec key = new SecretKeySpec(salt.getBytes(), \"AES\");\n    Cipher cipher = Cipher.getInstance(\"AES/ECB/PKCS5Padding\", \"SunJCE\");\n    cipher.init(Cipher.ENCRYPT_MODE, key);\n    String result = new String(cipher.doFinal(message.getBytes()));\n    System.out.println(\"Encrypted:\" + result);\n", "idx": 1665}
{"project": "cipher", "commit_id": "Snippet16940107_256.java", "target": 0, "func": "import java.security.SecureRandom;\n\nimport javax.crypto.Cipher;\nimport javax.crypto.KeyGenerator;\nimport javax.crypto.SecretKey;\nimport javax.crypto.spec.SecretKeySpec;\n\n/**\n * Usage:\n * <pre>\n * String crypto = SimpleCrypto.encrypt(masterpassword, cleartext)\n * ...\n * String cleartext = SimpleCrypto.decrypt(masterpassword, crypto)\n * </pre>\n * @author ferenc.hechler\n */\npublic class SimpleCrypto {\n\n\n    public static void main(String args[])\n    {\n\n\n        try {\n\n            String sr=encrypt(\"username\", \"The AsyncTask isn\u2019t the only way to do background processing in Android, though. The Loader class is a much newer construct in Android (although now it\u2019s getting a bit dated). It was released with Honeycomb(3.0) and is now included in the Support Library. The beauty of the Loader is that it handles some of the \u2018gotchas\u2019 that usually are missed when using the AsyncTask. Mainly, it handles activity configuration changes (IE when the user rotates the screen)\");\n            System.out.println(\" &&&& \" + sr);\n            System.out.println(\"88888 \"+decrypt(\"username\", sr));\n\n\n        } catch (Exception e) {\n            // TODO Auto-generated catch block\n            e.printStackTrace();\n        }\n    }\n        public static String encrypt(String seed, String cleartext) throws Exception {\n                byte[] rawKey = getRawKey(seed.getBytes());\n                byte[] result = encrypt(rawKey, cleartext.getBytes());\n                return toHex(result);\n        }\n\n        public static String decrypt(String seed, String encrypted) throws Exception {\n                byte[] rawKey = getRawKey(seed.getBytes());\n                byte[] enc = toByte(encrypted);\n                byte[] result = decrypt(rawKey, enc);\n                return new String(result);\n        }\n\n        private static byte[] getRawKey(byte[] seed) throws Exception {\n                KeyGenerator kgen = KeyGenerator.getInstance(\"AES\");\n                SecureRandom sr = SecureRandom.getInstance(\"SHA1PRNG\");\n                sr.setSeed(seed);\n            kgen.init(128, sr); // 192 and 256 bits may not be available\n            SecretKey skey = kgen.generateKey();\n            byte[] raw = skey.getEncoded();\n            return raw;\n        }\n\n\n        private static byte[] encrypt(byte[] raw, byte[] clear) throws Exception {\n            SecretKeySpec skeySpec = new SecretKeySpec(raw, \"AES\");\n                Cipher cipher = Cipher.getInstance(\"AES\");\n            cipher.init(Cipher.ENCRYPT_MODE, skeySpec);\n            byte[] encrypted = cipher.doFinal(clear);\n                return encrypted;\n        }\n\n        private static byte[] decrypt(byte[] raw, byte[] encrypted) throws Exception {\n            SecretKeySpec skeySpec = new SecretKeySpec(raw, \"AES\");\n                Cipher cipher = Cipher.getInstance(\"AES\");\n            cipher.init(Cipher.DECRYPT_MODE, skeySpec);\n            byte[] decrypted = cipher.doFinal(encrypted);\n                return decrypted;\n        }\n\n        public static String toHex(String txt) {\n                return toHex(txt.getBytes());\n        }\n        public static String fromHex(String hex) {\n                return new String(toByte(hex));\n        }\n\n        public static byte[] toByte(String hexString) {\n                int len = hexString.length()/2;\n                byte[] result = new byte[len];\n                for (int i = 0; i < len; i++)\n                        result[i] = Integer.valueOf(hexString.substring(2*i, 2*i+2), 16).byteValue();\n                return result;\n        }\n\n        public static String toHex(byte[] buf) {\n                if (buf == null)\n                        return \"\";\n                StringBuffer result = new StringBuffer(2*buf.length);\n                for (int i = 0; i < buf.length; i++) {\n                        appendHex(result, buf[i]);\n                }\n                return result.toString();\n        }\n        private final static String HEX = \"0123456789ABCDEF\";\n        private static void appendHex(StringBuffer sb, byte b) {\n                sb.append(HEX.charAt((b>>4)&0x0f)).append(HEX.charAt(b&0x0f));\n        }\n\n}\n", "idx": 1603}
{"project": "cipher", "commit_id": "Snippet22610761_5009.java", "target": 0, "func": "public class EncryptionUtils {\n\nprivate static final String AES_CIPHER_METHOD = \"AES\";\nprivate static final int AES_KEY_SIZE = 128;\n\npublic static byte[] generateAesKey() throws NoSuchAlgorithmException {\n    KeyGenerator keyGenerator = KeyGenerator.getInstance(AES_CIPHER_METHOD);\n    keyGenerator.init(AES_KEY_SIZE);\n    SecretKey key = keyGenerator.generateKey();\n    return key.getEncoded();\n}\n\npublic static SecretKeySpec createAesKeySpec(byte[] aesKey) {\n    return new SecretKeySpec(aesKey, AES_CIPHER_METHOD);\n}\n\npublic static void aesEncryptFile(File in, File out, SecretKeySpec aesKeySpec) throws InvalidKeyException, NoSuchAlgorithmException, NoSuchPaddingException, IOException {\n    Cipher aesCipher = Cipher.getInstance(AES_CIPHER_METHOD);\n    aesCipher.init(Cipher.ENCRYPT_MODE, aesKeySpec);\n    InputStream inputStream = new FileInputStream(in);\n    try {\n        OutputStream outputStream = new CipherOutputStream(new FileOutputStream(out), aesCipher);\n        try {\n            IOUtils.copy(inputStream , outputStream);\n        } finally {\n            outputStream.close();\n        }\n    } finally {\n        inputStream.close();\n    }\n}\n}\n\n\n//testcode\n@Test\npublic void testAesEncryptFile() throws IOException, InvalidKeyException, IllegalBlockSizeException, BadPaddingException, NoSuchAlgorithmException, NoSuchPaddingException {\n    byte[] aesKey = EncryptionUtils.generateAesKey();\n    SecretKeySpec aesKeySpec = EncryptionUtils.createAesKeySpec(aesKey);\n    EncryptionUtils.aesEncryptFile(new File(\"C:\\\\test\\\\test.txt\"), new File(\"C:\\\\test\\\\test-encrypted.txt\"), aesKeySpec);\n\n    FileOutputStream outputStream = new FileOutputStream(\"C:\\\\test\\\\aes.key\");\n    outputStream.write(aesKey);\n    outputStream.close();\n}\n\n@Test\npublic void testAesDecryptFile() throws IOException, InvalidKeyException, IllegalBlockSizeException, BadPaddingException, NoSuchAlgorithmException, NoSuchPaddingException {\n    FileInputStream keyFis = new FileInputStream(\"C:\\\\test\\\\aes.key\");\n    ByteArrayOutputStream keyBaos = new ByteArrayOutputStream();\n    IOUtils.copy(keyFis, keyBaos);\n\n    SecretKeySpec keySpec = new SecretKeySpec(keyBaos.toByteArray(), \"AES\");\n    Cipher cipher = Cipher.getInstance(\"AES\");\n    cipher.init(Cipher.DECRYPT_MODE, keySpec);\n\n    FileInputStream fileInputStream = new FileInputStream(\"C:\\\\test\\\\test-encrypted.txt\");\n    ByteArrayOutputStream baos = new ByteArrayOutputStream();\n    IOUtils.copy(fileInputStream, baos);\n\n    byte[] decrypted = cipher.doFinal(baos.toByteArray());\n    FileOutputStream outputStream = new FileOutputStream(\"C:\\\\test\\\\test-decrypted.txt\");\n    outputStream.write(decrypted);\n    outputStream.close();\n\n}\n", "idx": 1591}
{"project": "cipher", "commit_id": "Snippet15695977_38717.java", "target": 1, "func": "public class AES256Cipher {\n\n    public static byte[] ivBytes = { 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00 };\n\n\n    public static String AES_Encode(String str, String key) throws java.io.UnsupportedEncodingException, NoSuchAlgorithmException, NoSuchPaddingException, InvalidKeyException, InvalidAlgorithmParameterException, IllegalBlockSizeException, BadPaddingException {\n\n        byte[] textBytes = str.getBytes(\"UTF-8\");\n        AlgorithmParameterSpec ivSpec = new IvParameterSpec(ivBytes);\n             SecretKeySpec newKey = new SecretKeySpec(key.getBytes(\"UTF-8\"), \"AES\");\n             Cipher cipher = null;\n        cipher = Cipher.getInstance(\"AES/CBC/PKCS5Padding\");\n        cipher.init(Cipher.ENCRYPT_MODE, newKey, ivSpec);\n\n        return Base64.encodeToString(cipher.doFinal(textBytes), 0);\n    }\n\n    public static String AES_Decode(String str, String key) throws java.io.UnsupportedEncodingException, NoSuchAlgorithmException, NoSuchPaddingException, InvalidKeyException, InvalidAlgorithmParameterException, IllegalBlockSizeException, BadPaddingException {\n\n        byte[] textBytes =Base64.decode(str,0);\n        //byte[] textBytes = str.getBytes(\"UTF-8\");\n        AlgorithmParameterSpec ivSpec = new IvParameterSpec(ivBytes);\n        SecretKeySpec newKey = new SecretKeySpec(key.getBytes(\"UTF-8\"), \"AES\");\n        Cipher cipher = Cipher.getInstance(\"AES/CBC/PKCS5Padding\");\n        cipher.init(Cipher.DECRYPT_MODE, newKey, ivSpec);\n        return new String(cipher.doFinal(textBytes), \"UTF-8\");\n    }\n}\n", "idx": 2287}
{"project": "cipher", "commit_id": "Snippet14991632_38040.java", "target": 0, "func": "package com.test.encrypt;\n\nimport javax.crypto.Cipher;\nimport javax.crypto.SecretKey;\nimport javax.crypto.SecretKeyFactory;\nimport javax.crypto.spec.DESedeKeySpec;\nimport javax.crypto.spec.IvParameterSpec;\nimport org.apache.commons.codec.binary.Hex;\n\npublic class TrippleDESTest\n{\n    private Cipher ecipher;\n    private Cipher dcipher;\n    private String algorithm = \"DESede\";\n    private String transformation = \"DESede/CBC/PKCS5Padding\";\n    private String keyPhrase = \"123456789012345678901234\"; //your keyphrase 24 bit\n    private SecretKey key;\n    private IvParameterSpec iv;\n    private static TrippleDESTest cryptoUtil;\n    private String ENCODING = \"UTF-8\";\n\n    public static TrippleDESTest getInstance() throws Exception\n    {\n        if (cryptoUtil == null)\n        {\n            cryptoUtil = new TrippleDESTest();\n        }\n\n        return cryptoUtil;\n    }\n\n    private TrippleDESTest() throws Exception\n    {\n            DESedeKeySpec keySpec = new DESedeKeySpec(keyPhrase.getBytes());\n            key = SecretKeyFactory.getInstance(algorithm).generateSecret(keySpec);\n            iv = new IvParameterSpec(new byte[8]);\n            ecipher = Cipher.getInstance(transformation);\n            dcipher = Cipher.getInstance(transformation);\n            ecipher.init(Cipher.ENCRYPT_MODE, key, iv);\n            dcipher.init(Cipher.DECRYPT_MODE, key, iv);\n    }\n\n    public String encrypt(String str) throws Exception\n    {\n            byte[] utf8 = str.getBytes(ENCODING);    \n            byte[] enc = ecipher.doFinal(utf8);                \n            System.out.println(\"number of bites: \" + enc.length);    \n            return Hex.encodeHexString(enc);\n    }\n\n    public String decrypt(String str) throws Exception\n    {\n            byte[] dec = str.getBytes();\n            byte[] utf8 = dcipher.doFinal(dec);    \n            return Hex.encodeHexString(utf8);\n    }\n\n    public static void main(String[] args) throws Exception\n    {\n        TrippleDESTest test = TrippleDESTest.getInstance();        \n        String originalText = \"Abcdefgh\";        \n        System.out.println(\"originalText: \" + originalText);        \n        String cryptText = test.encrypt(originalText);        \n        System.out.println(\"cryptText: \" + cryptText);        \n        System.out.println(\"cryptText.length: \" + cryptText.length());\n        System.out.println(\"cryptText.getBytes().length: \" + cryptText.getBytes().length);        \n        System.out.println(\"decote text: \" + test.decrypt(cryptText));\n\n    }\n}// end class TrippleDESTest\n", "idx": 1751}
{"project": "cipher", "commit_id": "Snippet25135917_7489.java", "target": 0, "func": "public static String encrypt(String input, String key) throws Exception {\n    SecretKeySpec skeySpec = new SecretKeySpec(key.getBytes(), \"AES\");\n    Cipher cipher = Cipher.getInstance(\"AES/ECB/NoPadding\");\n    cipher.init(Cipher.ENCRYPT_MODE, skeySpec);\n    return DatatypeConverter.printHexBinary(cipher.doFinal(padToMultipleOf32(input.getBytes())));\n}\n\npublic static byte[] padToMultipleOf32(final byte[] bytes) {\n    int n16 = ((bytes.length + 31) / 32);\n    int paddedLen = n16 * 32;\n\n    byte[] result = new byte[paddedLen];\n\n    for (int i = 0; i < bytes.length; i++) {\n        result[i] = bytes[i];\n    }\n\n    for (int i = bytes.length; i < paddedLen; i++) {\n        result[i] = 0x00;\n    }\n\n    System.out.println(new String(result).length());\n\n    return result;\n}\n", "idx": 1796}
{"project": "cipher", "commit_id": "Snippet32887706_14945.java", "target": 1, "func": "byte[] keyBytes = Base64.decodeBase64(publicKeyData);\n// Get Public Key\nX509EncodedKeySpec rsaPublicKeySpec = new X509EncodedKeySpec(keyBytes);\nKeyFactory fact = KeyFactory.getInstance(\"RSA\");\nPublicKey publicKey = fact.generatePublic(rsaPublicKeySpec);\nCipher cipher = Cipher.getInstance(\"RSA/ECB/PKCS1Padding\");\ncipher.init(Cipher.ENCRYPT_MODE, pubKey);\nencryptedData = cipher.doFinal(dataToEncrypt);\ufeff   \n", "idx": 2237}
{"project": "cipher", "commit_id": "Snippet9613658_34067.java", "target": 0, "func": "dh=new data_helper(Resy.this);\n        mac_db=dh.getData();\n\n//        getdata=mac_db.toString();\n\n        KeyGenerator kgen;\n        try {\n            kgen = KeyGenerator.getInstance(\"AES\");\n\n             kgen.init(128); // 192 and 256 bits may not be available\n\n  // Generate the secret key specs.\n                SecretKey skey = kgen.generateKey();\n                byte[] raw = skey.getEncoded();\n\n                SecretKeySpec skeySpec = new SecretKeySpec(raw, \"AES\");\n\n\n                // Instantiate the cipher\n\n                Cipher cipher = Cipher.getInstance(\"AES\");\n                         getdata=mac_db.toString();\n//              byte g1[]=getdata.getBytes();\n//              System.out.println(g1);\n\n        byte b[]=hexStringToByteArray(getdata);\n        cipher.init(Cipher.DECRYPT_MODE, skeySpec);\n        byte[] m1=cipher.doFinal(b);   // here pad block corrupt exception came.\n                String originalString_mac = new String(original_macadress);\n                Toast.makeText(getApplicationContext(),\"Original : \" +originalString_mac + \" \" + asHex(original_macadress) , Toast.LENGTH_LONG).show();\n", "idx": 1720}
{"project": "cipher", "commit_id": "Snippet5048503_31454.java", "target": 1, "func": "char[] passphrase; // Actual passphrase\nPrivateKey privateKeyObj; // Actual Private Key\nbyte[] privateKeyBytes = privateKeyObj.getEncoded();\n\nbyte[] salt = new byte[8];\nnew SecureRandom().nextBytes(salt);\n\nSecretKeyFactory factory = SecretKeyFactory.getInstance(\"PBKDF2WithHmacSHA1\");\nKeySpec spec = new PBEKeySpec(passphrase, salt, 1024, 256);\nSecretKey tmp = factory.generateSecret(spec);\nSecretKey secret = new SecretKeySpec(tmp.getEncoded(), \"AES\");\n\nCipher cipher = Cipher.getInstance(\"AES/CBC/PKCS5Padding\");\ncipher.init(Cipher.ENCRYPT_MODE, secret);\nAlgorithmParameters params = cipher.getParameters();\nbyte[] iv = params.getParameterSpec(IvParameterSpec.class).getIV();\n\nbyte[] ciphertext = cipher.doFinal(privateKeyBytes);\n\nFileOutputStream outputFileStream = new FileOutputStream(outputFile);\noutputFileStream.write(salt);\noutputFileStream.write(iv);\noutputFileStream.write(ciphertext);\noutputFileStream.close();\n", "idx": 2222}
{"project": "cipher", "commit_id": "Snippet32531509_14644.java", "target": 0, "func": "import java.io.BufferedReader;\nimport java.io.BufferedWriter;\nimport java.io.File;\nimport java.io.FileNotFoundException;\nimport java.io.FileReader;\nimport java.io.FileWriter;\nimport java.io.IOException;\nimport java.security.InvalidKeyException;\nimport java.security.NoSuchAlgorithmException;\n\nimport javax.crypto.BadPaddingException;\nimport javax.crypto.Cipher;\nimport javax.crypto.IllegalBlockSizeException;\nimport javax.crypto.KeyGenerator;\nimport javax.crypto.NoSuchPaddingException;\nimport javax.crypto.SecretKey;\n\n\npublic class FileManagment {\n\n    static CreateAccountFrame caf = new CreateAccountFrame();\n\n    File file = new File(\"accounts.lockedfilecausewhynot\");\n\n    Cipher desCipher;\n\n    byte[] usernameEncrypted;\n    byte[] passwordEncrypted;\n    byte[] chosenUsername;\n    byte[] chosenPassword;\n    byte[] storedUsername;\n    byte[] storedPassword;\n    byte[] decryptedUsername;\n    byte[] decryptedPassword;\n\n    public void createAccountsFile(){\n        try {\n            if(!file.exists()){\n                file.createNewFile();\n            }\n        } catch (IOException e){\n                e.printStackTrace();\n        }\n    }\n\n    public void addEncryptedAccount(){\n        try {\n            KeyGenerator kg = KeyGenerator.getInstance(\"DES\");\n            SecretKey desKey = kg.generateKey();\n\n            desCipher = Cipher.getInstance(\"DES/ECB/PKCS5Padding\");\n            desCipher.init(Cipher.ENCRYPT_MODE, desKey);\n\n            chosenUsername = caf.chooseUsername.getText().getBytes(\"UTF-8\");\n            chosenPassword = caf.choosePassword.getText().getBytes(\"UTF-8\");\n            usernameEncrypted = desCipher.doFinal(chosenUsername);\n            passwordEncrypted = desCipher.doFinal(chosenPassword);\n\n            String encryptedUsername = new String(usernameEncrypted);\n            String encryptedPassword = new String(passwordEncrypted);\n\n            FileWriter fw = new FileWriter(file.getAbsoluteFile());\n            BufferedWriter bw= new BufferedWriter(fw);\n            bw.write(encryptedUsername);\n            bw.newLine();\n            bw.write(encryptedPassword);\n            bw.close(); \n        } catch (IOException | NoSuchAlgorithmException |InvalidKeyException \n            | NoSuchPaddingException | IllegalBlockSizeException | BadPaddingException e){\n            e.printStackTrace();\n    }\n}\n\n    public void readEcryptedText(){\n        try {\n            KeyGenerator kg = KeyGenerator.getInstance(\"DES\");\n            SecretKey desKey = kg.generateKey();\n\n            FileReader fr = new FileReader(file);\n            BufferedReader br = new BufferedReader(fr);\n\n            String encryptedText = br.readLine();\n            System.out.println(encryptedText);\n\n            storedUsername = encryptedText.getBytes(\"UTF-8\");\n\n            desCipher = Cipher.getInstance(\"DES/ECB/PKCS5Padding\");\n            desCipher.init(Cipher.DECRYPT_MODE, desKey);\n\n            decryptedUsername = desCipher.doFinal(storedUsername);\n\n            String decryptedText = new String(decryptedUsername).toString();\n            System.out.println(\"decryptedText\");\n\n        } catch (NoSuchAlgorithmException | NoSuchPaddingException \n            | InvalidKeyException | IOException | IllegalBlockSizeException | BadPaddingException e) {\n        e.printStackTrace();\n    }\n}\n", "idx": 1793}
{"project": "cipher", "commit_id": "Snippet37918352_19931.java", "target": 0, "func": "    private Key getAesKey() throws Exception {\n    return new SecretKeySpec(Arrays.copyOf(key.getBytes(\"UTF-8\"), 16), \"AES\");\n}\n\nprivate Cipher getMutual() throws Exception {\n    Cipher cipher = Cipher.getInstance(\"AES\");\n    return cipher;// cipher.doFinal(pass.getBytes());\n}\n\npublic byte[] getEncryptedPass(String pass) throws Exception {\n    Cipher cipher = getMutual();\n    cipher.init(Cipher.ENCRYPT_MODE, getAesKey());\n    byte[] encrypted = cipher.doFinal(pass.getBytes(\"UTF-8\"));\n    return encrypted;\n\n}\n\npublic String getDecryptedPass(byte[] encrypted) throws Exception {\n    Cipher cipher = getMutual();\n    cipher.init(Cipher.DECRYPT_MODE, getAesKey());\n    String realPass = new String(cipher.doFinal(encrypted));\n    return realPass;\n}\n", "idx": 1657}
{"project": "cipher", "commit_id": "Snippet25011238_7336.java", "target": 0, "func": "public class Decrypts {\n    private static final String password = \"haasd\";\n    private static final String ALGO = \"AES\";\n\n    public static String encrypt(String Data) throws Exception {\n        String SALT = generateSalt();\n        byte[] saltBytes = SALT.getBytes(\"UTF-8\");\n        System.out.println(\"Saltbytes ; \" + saltBytes);\n\n        SecretKeyFactory factory = SecretKeyFactory\n                .getInstance(\"PBKDF2WithHmacSHA1\");\n        PBEKeySpec spec = new PBEKeySpec(password.toCharArray(), saltBytes,\n                65536, 256);\n\n        SecretKey secretKey = factory.generateSecret(spec);\n        SecretKeySpec secret = new SecretKeySpec(secretKey.getEncoded(), \"AES\");\n        Cipher c = Cipher.getInstance(ALGO);\n        c.init(Cipher.ENCRYPT_MODE, secret);\n        byte[] encVal = c.doFinal(Data.getBytes());\n        byte[] encryptedValue = new Base64().encode(encVal);\n        String ency = new String(encryptedValue);\n        return ency;\n    }\n\n    @SuppressWarnings(\"static-access\")\n    public static String decrypt(String encryptedData) throws Exception {\n        String SALT = generateSalt();\n        byte[] saltBytes = SALT.getBytes(\"UTF-8\");\n        System.out.println(\"Saltbytes ; \" + saltBytes);\n\n        SecretKeyFactory factory = SecretKeyFactory\n                .getInstance(\"PBKDF2WithHmacSHA1\");\n        PBEKeySpec spec = new PBEKeySpec(password.toCharArray(), saltBytes,\n                65536, 256);\n\n        SecretKey secretKey = factory.generateSecret(spec);\n        SecretKeySpec secret = new SecretKeySpec(secretKey.getEncoded(), \"AES\");\n        Cipher c = Cipher.getInstance(ALGO);\n        c.init(Cipher.DECRYPT_MODE, secret);\n        byte[] decordedValue = new Base64().decodeBase64(encryptedData);\n        byte[] decValue = c.doFinal(decordedValue);\n        String decryptedValue = new String(decValue);\n        return decryptedValue;\n    }\n\n    public static String generateSalt() {\n        SecureRandom random = new SecureRandom(password.getBytes());\n        byte bytes[] = new byte[120];\n        random.nextBytes(bytes);\n        String s = new String(bytes);\n        System.out.println(\"Salt ; \" + s);\n        return s;\n    }\n}\n", "idx": 1766}
{"project": "cipher", "commit_id": "Snippet43664282_25787.java", "target": 0, "func": "    try{\n    String msgout = \"\";\n    msgout = msg_text.getText().trim();\n    aesKey = new SecretKeySpec(key.getBytes(), \"AES\");\n        cipher = Cipher.getInstance(\"AES\");\n        cipher.init(Cipher.ENCRYPT_MODE, aesKey);\n        encrypted = cipher.doFinal(msgout.getBytes());\n    String msgout1;\n        msgout1 = String.valueOf(encrypted);\n    dout.writeUTF(msgout1);\n    msg_area.setText(msg_area.getText().trim()+\"\\nYou:\\t\"+msgout);\n    }catch(Exception e){\n\n    }\n", "idx": 1587}
{"project": "cipher", "commit_id": "Snippet25622894_7956.java", "target": 1, "func": "Cipher rsa;\nrsa = Cipher.getInstance(\"RSA\");\nKeyFactory keyFactory = KeyFactory.getInstance(\"RSA\");\nX509EncodedKeySpec publicKeySpec = new X509EncodedKeySpec(pkey.getBytes());\nPublicKey pk = keyFactory.generatePublic(publicKeySpec);\nrsa.init(Cipher.DECRYPT_MODE, pk);\nbyte[] cipherDecrypt = rsa.doFinal(encryptedText.getBytes());\n", "idx": 1975}
{"project": "cipher", "commit_id": "Snippet761902_29744.java", "target": 0, "func": "public InputStream decrypt(InputStream is, byte[] password)\n  throws GeneralSecurityException, IOException\n{\n  /* Parse the \"salt\" value from the stream. */\n  byte[] header = new byte[16];\n  for (int idx = 0; idx < header.length;) {\n    int n = is.read(header, idx, header.length - idx);\n    if (n < 0)\n      throw new EOFException(\"File header truncated.\");\n    idx += n;\n  }\n  String magic = new String(header, 0, 8, \"US-ASCII\");\n  if (!\"Salted__\".equals(magic))\n    throw new IOException(\"Expected salt in header.\");\n\n  /* Compute the key and IV with OpenSSL's non-standard method. */\n  SecretKey secret;\n  IvParameterSpec iv;\n  byte[] digest = new byte[32];\n  try {\n    MessageDigest md5 = MessageDigest.getInstance(\"MD5\");\n    md5.update(password);\n    md5.update(header, 8, 8);\n    md5.digest(digest, 0, 16);\n    md5.update(digest, 0, 16);\n    md5.update(password);\n    md5.update(header, 8, 8);\n    md5.digest(digest, 16, 16);\n    iv = new IvParameterSpec(digest, 24, 8);\n    DESedeKeySpec keySpec = new DESedeKeySpec(digest);\n    SecretKeyFactory factory = SecretKeyFactory.getInstance(\"DESede\");\n    secret = factory.generateSecret(keySpec);\n  }\n  finally {\n    Arrays.fill(digest, (byte) 0);\n  }\n\n  /* Initialize the cipher. */\n  Cipher cipher = Cipher.getInstance(\"DESede/CBC/PKCS5Padding\");\n  cipher.init(Cipher.DECRYPT_MODE, secret, iv);\n  return new CipherInputStream(is, cipher);\n}\n", "idx": 1886}
{"project": "cipher", "commit_id": "Snippet16914043_238.java", "target": 1, "func": "import java.security.NoSuchAlgorithmException;\nimport java.util.HashMap;\n\nimport javax.crypto.Cipher;\nimport javax.crypto.Mac;\nimport javax.crypto.spec.IvParameterSpec;\nimport javax.crypto.spec.SecretKeySpec;\n\nimport org.apache.commons.codec.binary.Base64;\nimport org.bouncycastle.crypto.generators.PKCS5S2ParametersGenerator;\nimport org.bouncycastle.crypto.params.KeyParameter;\nimport org.bouncycastle.crypto.params.ParametersWithIV;\n\n\nimport com.sun.org.apache.xerces.internal.impl.dv.util.HexBin;\n\n\npublic class test {\n\n/**\n * @param args\n */\npublic static void main(String[] args) {\n    test te = new test();\n    try {\n        te.decryptSeedValue();\n    } catch (Exception e) {\n        // TODO Auto-generated catch block\n        System.out.println(e.getMessage());\n        e.printStackTrace();\n    }\n    // TODO Auto-generated method stub\n\n}\n\npublic static HashMap decryptSeedValue()throws Exception{\n\n\n\n    String password = \"G?20R+I+3-/UcWIN\";\n\n\n\n    String pbesalt =\"EW0h0yUcDX72WU9UiKiCwDpXsJg=\";\n    String iv = \"aaaaaaaaaaaaaaaaaaaaaaaa\";\n\n    int iteration = 128;\n\n\n\n\n    String value = \"pM7VB/KomPjq2cKaxPr5cKT1tUZN5tGMI+u1XKJTG1la+ThraPpLKlL2plKk6vQE\";\n    String valueDigest = \"lbu+9OcLArnj6mS7KYOKDa4zRU0=\";\n\n\n\n\n    byte[] cipherText =null;\n\n\n    //some parameters need to decode from Base64 to byte[]\n    byte[] data = base64Decode(value.getBytes());\n    //System.out.println(\"data(hex string) = \" + HexBin.encode(data));//debug\n\n    byte[] salt = base64Decode(pbesalt.getBytes());\n    //System.out.println(\"salt(hex string) = \" + HexBin.encode(salt));//debug\n\n    byte[] initVec = base64Decode(iv.getBytes());\n    //System.out.println(\"iv(hex string) = \" + HexBin.encode(initVec));//debug\n\n    //perform PBE key generation and AES/CBC/PKCS5Padding decrpyption\n\n    HashMap hs = myFunction(data, password, initVec, salt, iteration); \n\n    String seedValue = (String)hs.get(\"DECRYPTED_SEED_VALUE\");\n    byte[] temp = (byte[])hs.get(\"HASH_OUTPUT\");\n\n\n    //System.out.println(\"hashed output(hex string) = \" + HexBin.encode(temp));//debug\n\n    //perform Base64 Encode \n    byte[] out = base64Encode(temp);\n\n    String output = new String((out));\n    System.out.println(\"output = \"+output);\n    System.out.println(\"valueD = \"+valueDigest);\n    //System.out.println(\"hashed output(base64) = \" + output);\n\n    //compare the result\n    if(output.equals(valueDigest)){\n        System.out.println(\"Hash verification successful for:-->\"  );\n          System.out.println(\"\\n\");\n\n        //hs.put(\"SEED_VALUE\", HexBin.encode(temp));\n        hs.put(\"SEED_VALUE\", seedValue);\n        return hs;\n\n    }\n    else{\n        System.out.println(\"Hash verification failed  for :-->\");\n\n        return null;\n\n    }\n\n\n\n}\n\npublic static HashMap myFunction(byte[] data, String password, byte[] initVec,\n                              byte[] salt, int iteration) throws Exception{\n\n    PKCS5S2ParametersGenerator generator = new PKCS5S2ParametersGenerator();\n\n    byte[] pBytes = password.getBytes();\n\n    generator.init(pBytes, salt, iteration);\n\n    int keysize = 128;//fixed at AES key of 16 bytes\n    int ivsize = initVec.length;\n\n    ParametersWithIV params = (ParametersWithIV) generator.generateDerivedParameters(keysize, ivsize);\n\n    KeyParameter keyParam = (KeyParameter) params.getParameters();\n\n    //System.out.println(\"derived key = \" + HexBin.encode(keyParam.getKey()));\n\n    Cipher cipher = Cipher.getInstance(\"AES/CBC/PKCS5Padding\");\n\n    IvParameterSpec paramSpec = new IvParameterSpec(initVec);\n\n    SecretKeySpec key = new SecretKeySpec(keyParam.getKey(), \"AES\");\n\n    cipher.init(Cipher.DECRYPT_MODE, key, paramSpec);\n\n    //perform decryption\n    byte[] secret = cipher.doFinal(data);\n\n    //display the 20 bytes secret of the token \n    //System.out.println(\"token secret(hex string) = \" + HexBin.encode(secret));\n\n    //perform HMAC-SHA-1\n    byte[] output = hmac_sha1(secret, keyParam.getKey());\n\n    HashMap hs = new HashMap();\n\n    hs.put(\"ENCRYPTION_KEY\", HexBin.encode(keyParam.getKey()));\n    hs.put(\"HASH_OUTPUT\", output);\n\n    hs.put(\"DECRYPTED_SEED_VALUE\", HexBin.encode(secret));\n\n    return hs;\n}\n\npublic static byte[] base64Encode(byte[] passwordBytes) throws NoSuchAlgorithmException {\n    Base64 base64 = new Base64();\n    byte[] hashBytes2 = base64.encode(passwordBytes);\n    return hashBytes2;\n}\n\npublic static byte[] base64Decode(byte[] passwordBytes) throws NoSuchAlgorithmException {\n    Base64 base64 = new Base64();\n    byte[] hashBytes2 = base64.decode(passwordBytes);\n    return hashBytes2;\n}\n\npublic static byte[] hmac_sha1(byte[] dataByte, byte[] keyByte) throws Exception{\n    Mac hmacSha1;\n    hmacSha1 = Mac.getInstance(\"HmacSHA1\");\n\n    SecretKeySpec macKey = new SecretKeySpec(keyByte, \"HmacSHA1\");\n    hmacSha1.init(macKey);\n    byte[] result = hmacSha1.doFinal(dataByte);\n    return result;\n\n}\n/**\n * Convert a byte array of 8 bit characters into a String.\n * \n * @param bytes the array containing the characters\n * @param length the number of bytes to process\n * @return a String representation of bytes\n */\nprivate static String toString(\n    byte[] bytes,\n    int    length)\n{\n    char[]  chars = new char[length];\n\n    for (int i = 0; i != chars.length; i++)\n    {\n        chars[i] = (char)(bytes[i] & 0xff);\n    }\n\n    return new String(chars);\n}\n\n} \n", "idx": 2282}
{"project": "cipher", "commit_id": "Snippet12668838_36398.java", "target": 1, "func": "    public void onCreate(Bundle icicle)\n{\n    super.onCreate(icicle);\n    setContentView(R.layout.agapplogin);\n\n    TextView lblMobileNo = (TextView)findViewById(R.id.lblMobileNo);\n    lblMobileNo.setTextColor(getResources().getColor(R.color.text_color_red));\n\n    mobile = (EditText)findViewById(R.id.txtMobileNo);\n\n    TextView lblPinNo = (TextView)findViewById(R.id.lblPinNo);\n    lblPinNo.setTextColor(getResources().getColor(R.color.text_color_red));\n\n    pin = (EditText)findViewById(R.id.txtPinNo);\n\n    btnLogin = (Button)findViewById(R.id.btnLogin);\n    btnClear = (Button)findViewById(R.id.btnClear);\n\n    btnLogin.setOnClickListener(new OnClickListener() {\n         public void onClick(View view) {                \n             postLoginData();\n         }\n         });      \n\n                ;}  \n\npublic void postLoginData() \n\n   {\n             Intent i = new   \n   Intent(this.getApplicationContext(),new.class);\n             Bundle bundle = new Bundle();\n             bundle.putString(\"mno\", mobile.getText().toString());\n             bundle.putString(\"pinno\", pin.getText().toString());\n             i.putExtras(bundle);\n             startActivity(i);          }\n}\n\n\n            ///this is RSA code which i found\n\n\n\n\n\n   import java.io.BufferedOutputStream;\n   import java.io.FileOutputStream;\n   import java.io.IOException;\n   import java.io.ObjectOutputStream;\n   import java.math.BigInteger;\n   import java.security.Key;\n   import java.security.KeyFactory;\n   import java.security.KeyPair;\n   import java.security.KeyPairGenerator;\n   import java.security.NoSuchAlgorithmException;\n   import java.security.spec.RSAPrivateKeySpec;\n   import java.security.spec.RSAPublicKeySpec;\n\n        /**\n        * This class generates key pair and saves in file in current directory\n       * \n       * @author amit\n       * \n       */\n        public class RSAKeyGenerator {\n\npublic void generateKeyPair(String publicKeyFileName,\n        String privateKeyFileName) {\n    KeyPairGenerator kpg = null;\n    try {\n        kpg = KeyPairGenerator.getInstance(\"RSA\");\n    } catch (NoSuchAlgorithmException e) {\n        // TODO Auto-generated catch block\n        e.printStackTrace();\n    }\n    kpg.initialize(2048);\n    KeyPair kp = kpg.genKeyPair();\n    Key publicKey = kp.getPublic();\n    Key privateKey = kp.getPrivate();\n    try {\n        KeyFactory fact = KeyFactory.getInstance(\"RSA\");\n        RSAPublicKeySpec pub = fact.getKeySpec(publicKey,\n                RSAPublicKeySpec.class);\n        RSAPrivateKeySpec priv = fact.getKeySpec(privateKey,\n                RSAPrivateKeySpec.class);\n\n        saveToFile(publicKeyFileName, pub.getModulus(),\n                pub.getPublicExponent());\n        System.out.println(\"public key saved\");\n        saveToFile(privateKeyFileName, priv.getModulus(),\n                priv.getPrivateExponent());\n        System.out.println(\"private key saved\");\n    } catch (Exception e) {\n        System.out.println(\"error \");\n    }\n}\n\nprivate void saveToFile(String fileName, BigInteger mod, BigInteger exp)\n        throws IOException {\n    ObjectOutputStream oout = new ObjectOutputStream(\n            new BufferedOutputStream(new FileOutputStream(fileName)));\n    try {\n        oout.writeObject(mod);\n        oout.writeObject(exp);\n    } catch (Exception e) {\n        throw new IOException(\"Unexpected error\", e);\n    } finally {\n        oout.close();\n    }\n}\n\n/**\n * @param args\n */\npublic static void main(String[] args) {\n    // TODO Auto-generated method stub\n    RSAKeyGenerator t = new RSAKeyGenerator();\n    t.generateKeyPair(\"public.key\", \"private.key\");\n\n}\n\n        }\n\n\n\n\n\n\n\n\n        import javax.crypto.Cipher;\n\n         public class RSAEncDec {\n\nprivate PublicKey readPublicKeyFromFile(String fileloc) throws IOException {\n    InputStream in = new FileInputStream(new File(fileloc));\n\n    ObjectInputStream oin = new ObjectInputStream(new BufferedInputStream(\n            in));\n    try {\n        BigInteger m = (BigInteger) oin.readObject();\n        BigInteger e = (BigInteger) oin.readObject();\n        RSAPublicKeySpec keySpec = new RSAPublicKeySpec(m, e);\n        KeyFactory fact = KeyFactory.getInstance(\"RSA\");\n        PublicKey pubKey = fact.generatePublic(keySpec);\n        return pubKey;\n    } catch (Exception e) {\n        throw new RuntimeException(\"Spurious serialisation error\", e);\n    } finally {\n        oin.close();\n    }\n}\n\nprivate PrivateKey readPrivateKeyFromFile(String fileLoc)\n        throws IOException {\n    InputStream in = new FileInputStream(new File(fileLoc));\n\n    ObjectInputStream oin = new ObjectInputStream(new BufferedInputStream(\n            in));\n    try {\n        BigInteger m = (BigInteger) oin.readObject();\n        BigInteger e = (BigInteger) oin.readObject();\n        RSAPrivateKeySpec keySpec = new RSAPrivateKeySpec(m, e);\n        KeyFactory fact = KeyFactory.getInstance(\"RSA\");\n        PrivateKey prvKey = fact.generatePrivate(keySpec);\n        return prvKey;\n    } catch (Exception e) {\n        throw new RuntimeException(\"Spurious serialisation error\", e);\n    } finally {\n        oin.close();\n    }\n}\n\npublic byte[] rsaEncrypt(byte[] data, String fileLoc) {\n    try {\n        PublicKey pubKey = readPublicKeyFromFile(fileLoc);\n        Cipher cipher = Cipher.getInstance(\"RSA\");\n        cipher.init(Cipher.ENCRYPT_MODE, pubKey);\n        byte[] cipherData = cipher.doFinal(data);\n        return cipherData;\n    } catch (Exception e) {\n        System.out.println(\"some thing went wrong\");\n    }\n    return null;\n}\n\npublic byte[] rsaDecrypt(byte[] data, String fileLoc) {\n    try {\n        PrivateKey pubKey = readPrivateKeyFromFile(fileLoc);\n        Cipher cipher = Cipher.getInstance(\"RSA\");\n        cipher.init(Cipher.DECRYPT_MODE, pubKey);\n        byte[] cipherData = cipher.doFinal(data);\n        return cipherData;\n    } catch (Exception e) {\n        System.out.println(\"some thing went wrong\");\n    }\n    return null;\n}\n\n/*\n * string\n * \n * @param data (normal string)\n * \n * @return\n */\npublic String encrypt(String data, String fileLoc) {\n    byte[] enc = rsaEncrypt(data.getBytes(), fileLoc);\n    return Base64.encode(enc);\n}\n\n/**\n * return the normal string\n * \n * @param data\n *            (base64 encoded string)\n * @return\n * @throws Base64DecodingException\n */\npublic String decrypt(String data, String fileLoc)\n        throws Base64DecodingException {\n    byte[] enc = Base64.decode(data);\n    byte[] decryptedData = rsaDecrypt(enc, fileLoc);\n    return new String(decryptedData);\n}\n\n/**\n * \n * @param args\n */\npublic static void main(String[] args) {\n    // TODO Auto-generated method stub\n    RSAEncDec obj = new RSAEncDec();\n    String enc = obj.encrypt(\"hello world\", \"./public.key\");\n    System.out.println(enc);\n    String dat = null;\n    try {\n        dat = obj.decrypt(enc, \"./private.key\");\n    } catch (Base64DecodingException e) {\n        // TODO Auto-generated catch block\n        e.printStackTrace();\n    }\n    System.out.println(dat);\n\n        }\n\n       }\n", "idx": 1943}
{"project": "cipher", "commit_id": "Snippet22607772_5004.java", "target": 1, "func": "String key = \"ffce885876a617e7\";\n    String vector = \"9ee153a3df56965e7baf13a7fa1075cc\";\n\n\n    IvParameterSpec ivSpec = new IvParameterSpec(key.getBytes());\n    SecretKeySpec keySpec = new SecretKeySpec(vector.getBytes(), \"AES\");\n\n\n    Cipher cipher = Cipher.getInstance(\"AES/CBC/NoPadding\");\n    cipher.init(Cipher.DECRYPT_MODE, keySpec, ivSpec); //error occured in this line\n", "idx": 2178}
{"project": "cipher", "commit_id": "Snippet36787096_18454.java", "target": 1, "func": "//Get public key from cert\nRSAPublicKey eServer = (RSAPublicKey) cert.getPublicKey();\n\n//Encrypt with RSA as key generation algorithm \nCipher cipher = Cipher.getInstance(\"RSA/ECB/PKCS1Padding\");\ncipher.init(Cipher.ENCRYPT_MODE, eServer);\nbyte[] cipherText = cipher.doFinal(message.getBytes());\nSystem.out.println(\"Ciphertext: \" + cipherText);\nos.writeObject(cipherText);\nos.flush();\nos.close();\ns.close();\ninput.close();\n", "idx": 2081}
{"project": "cipher", "commit_id": "Snippet46158761_28266.java", "target": 0, "func": "    public void doSendGmail(){\n    Connection con = Functions.ConnectToDB();\n    try {\n        Statement stmt = con.createStatement();\n        String sqlQuery = \"select * from settings\";\n        ResultSet rs = stmt.executeQuery(sqlQuery);\n\n        while(rs.next()){\n            String email = rs.getString(\"Email\");\n            //String pass = rs.getString(\"Password\");\n            byte [] pass = rs.getBytes(\"Password\");\n\n            cipher = Cipher.getInstance(\"DES/CTR/PKCS5Padding\");\n            cipher.init(Cipher.DECRYPT_MODE, keySpec,ivspec);\n            byte [] plain_text = cipher.doFinal(pass);\n\n            from = email;\n            password = new String(plain_text);\n        }\n\n        con.close();// close the connection\n\n    } catch (Exception e) {\n        JOptionPane.showMessageDialog(this, \"Error retrieving email address and password\\n\"+e.toString(),\n                \"Error\",JOptionPane.ERROR_MESSAGE);\n    }\n\n    to = txtTo.getText();\n    cc = txtCC.getText();\n    bcc = txtBCC.getText();\n    subject = txtSubject.getText();\n    message_body = jtaMessage.getText();\n\n    Properties props = new Properties();\n    props.put(\"mail.smtp.starttls.enable\", \"true\");\n    props.put(\"mail.smtp.auth\", \"true\");\n    props.put(\"mail.smtp.host\", \"smtp.gmail.com\");\n    props.put(\"mail.smtp.port\", \"587\");\n\n\n    /*use authenticator as username and password are supplied 'on demand' i.e queried from database\n    or supplied via a login dialog*/\n    Session session = Session.getInstance(props,new javax.mail.Authenticator() {\n        protected PasswordAuthentication getPasswordAuthentication(){\n            return new PasswordAuthentication(from, password);\n        }\n    });\n\n    try {            \n        Message message = new MimeMessage(session);\n        message.setFrom(new InternetAddress(from));\n        message.setRecipients(Message.RecipientType.TO,InternetAddress.parse(to));\n        if(!cc.equals(\"\")){\n            message.setRecipients(Message.RecipientType.CC, InternetAddress.parse(cc));\n        }\n        if(!bcc.equals(\"\")){\n            message.setRecipients(Message.RecipientType.BCC, InternetAddress.parse(bcc));\n        }\n        message.setSubject(subject);\n\n        if(filePathList.isEmpty()){// if a file(s) have not been attached...\n            message.setText(message_body);\n            Transport.send(message);\n        }\n        else{// if a file(s) have been attached\n            MimeBodyPart textPart = new MimeBodyPart();\n            textPart.setText(message_body);// actual message\n            Multipart multipart = new MimeMultipart();// create multipart message\n            multipart.addBodyPart(textPart);//add the text message to the multipart\n\n            for(int i =0; i<filePathList.size(); i++){// use for loop to attach file(s)\n                MimeBodyPart attachmentPart = new MimeBodyPart();\n                DataSource source = new FileDataSource((String)filePathList.get(i));\n                attachmentPart.setDataHandler(new DataHandler(source));\n                attachmentPart.setFileName((String)fileList.get(i));\n                multipart.addBodyPart(attachmentPart);// add the attachment to the multipart\n                message.setContent(multipart);// add the multipart to the message\n            }\n            Transport.send(message);\n        }\n\n        JOptionPane.showMessageDialog(this, \"Message Sent!\",\"Sent\",JOptionPane.INFORMATION_MESSAGE);\n\n    } catch (Exception e) {\n        JOptionPane.showMessageDialog(this, \"Error sending email message\\n\"+e.toString(),\n                \"Error\",JOptionPane.ERROR_MESSAGE);\n    }\n} \n", "idx": 1682}
{"project": "cipher", "commit_id": "Snippet39865043_21773.java", "target": 0, "func": "public static String EncryptUrl(String parameters){\n\n    try{\n        String encodedStr = \"\";\n        Cipher cipher;\n        DESKeySpec keySpec = new DESKeySpec(key.getBytes(\"UTF8\"));\n        SecretKeyFactory keyFactory = SecretKeyFactory.getInstance(\"DES\");\n        cipher = Cipher.getInstance(\"DES\");\n        cipher.init(Cipher.ENCRYPT_MODE, keyFactory.generateSecret(keySpec));\n\n        encodedStr = Base64.encodeBase64String(cipher.doFinal(parameters.getBytes(\"UTF8\")));\n\n        try{\n            encodedStr = URLEncoder.encode(encodedStr, \"UTF-8\");\n        } catch (UnsupportedEncodingException e) {\n\n            throw new AssertionError(\"UTF-8 is unknown\");\n        }\n\n        return encodedStr;\n    }\n    catch(Exception ex){\n        return null;\n    }\n}\n", "idx": 1727}
{"project": "cipher", "commit_id": "Snippet32008047_14057.java", "target": 1, "func": "public String decrypt(String dataToDecrypt) throws NoSuchAlgorithmException, NoSuchPaddingException, InvalidKeyException, InvalidKeySpecException, IllegalBlockSizeException, BadPaddingException, InvalidAlgorithmParameterException, UnsupportedEncodingException \n{\n\n    byte[] encryptedCombinedBytes = Base64.decodeBase64(dataToDecrypt.getBytes());\n\n    String saltKey = \"dfkjsadfinewdfadsfkmeoinmsdflksdflk\";\n    String password = \"52\";\n    String IVKey = \"@EUBRHDFBFG8867\";\n\n    PBKDF2Parameters p = new PBKDF2Parameters(\"HmacSHA256\", \"ASCII\", saltKey.getBytes(), 8);\n\n    byte[] mEncryptedPassword = new PBKDF2Engine(p).deriveKey(password);\n\n\n    byte[] ivbytes = Arrays.copyOfRange(IVKey.getBytes(), 0, 16);\n\n    SecretKeySpec mSecretKeySpec = new SecretKeySpec(mEncryptedPassword, \"AES\");\n\n    Cipher mCipher = Cipher.getInstance(\"AES/CBC/NoPadding\");\n\n    mCipher.init(Cipher.DECRYPT_MODE, mSecretKeySpec, new IvParameterSpec(ivbytes));\n\n    byte[] encryptedTextBytes = Arrays.copyOfRange(encryptedCombinedBytes, 16, encryptedCombinedBytes.length);\n\n    byte[] decryptedTextBytes = mCipher.doFinal(encryptedTextBytes);\n\n    return new String(decryptedTextBytes, \"UTF-8\");\n}\n", "idx": 2091}
{"project": "cipher", "commit_id": "Snippet6206438_32004.java", "target": 0, "func": "<%@page contentType=\"text/html; charset=iso-8859-1\" language=\"java\" \nimport=\"java.security.*\"\nimport=\"javax.crypto.Cipher\"\nimport=\"javax.crypto.spec.SecretKeySpec\"\nimport=\"sun.misc.*\"\n%>\n\n<%\n  // Decrypt authenticated hash\n  String ALGORITHM = \"AES\";\n  byte[] keyValue = \"MY-SECRET-PASSWORD\".getBytes();\n\n  Key key = new SecretKeySpec(keyValue, ALGORITHM);\n  Cipher c = Cipher.getInstance(ALGORITHM);\n  c.init(Cipher.DECRYPT_MODE, key);\n  byte[] decodedValue = new BASE64Decoder().decodeBuffer(new String(request.getParameter(\"auth\")));\n  byte[] decValue = c.doFinal(decodedValue);\n  String decryptedValue = new String(decValue);\n%>\n\n<script type=\"text/javascript\">\n   var auth = '<%= decryptedValue%>';\n\n   function AJAX(url, callback) {\n\n      var req = init();\n      req.onreadystatechange = processRequest;\n\n      function init() {\n         if (window.XMLHttpRequest) {\n            return new XMLHttpRequest();\n         } else if (window.ActiveXObject) {\n            return new ActiveXObject(\"Microsoft.XMLHTTP\");\n         }\n      }\n\n      function processRequest () {\n         // readyState of 4 signifies request is complete\n         if (req.readyState == 4) {\n            // status of 200 signifies sucessful HTTP call\n            if (req.status == 200) {\n               if (callback) callback(req.responseXML);\n            }\n         }\n      }\n\n      this.doGet = function() {\n         req.open(\"GET\", url, true);\n         req.setRequestHeader(\"Authorization\", \"Basic \" + auth);\n         req.send(null);\n      }\n   }\n\n   var url = \"/pentaho/Home\";\n   var querystr = \"\";\n   var ajax = new AJAX(url, function(){\n      window.location = url;\n   });\n\n   ajax.doGet(querystr);\n\n</script>\n", "idx": 1850}
{"project": "cipher", "commit_id": "Snippet11893370_35872.java", "target": 0, "func": "    byte password[] = (WHAT YOUR WANT. STRING, NUMBER, etc.).getBytes();\n    DESKeySpec desKeySpec;\n    try {\n\n        desKeySpec = new DESKeySpec(password);\n        SecretKeyFactory keyFactory = SecretKeyFactory.getInstance(\"DES\");\n        SecretKey key = keyFactory.generateSecret(desKeySpec);\n\n        Cipher desCipher = Cipher.getInstance(\"DES/ECB/PKCS5Padding\");\n        desCipher.init(Cipher.ENCRYPT_MODE, key);\n\n        // Create stream\n        FileOutputStream fos = new FileOutputStream(\"Your file here\");\n        BufferedOutputStream bos = new BufferedOutputStream(fos);\n        CipherOutputStream cos = new CipherOutputStream(bos, desCipher);\n    }\n", "idx": 1640}
{"project": "cipher", "commit_id": "Snippet31800764_13872.java", "target": 1, "func": "  def encryptData(data: String) = {\n    val saltBytes = Array[Int](0x12, 0x34, 0x56, 0x78, 0x12, 0x34, 0x56, 0x78, 0x78, 0x90, 0x12, 0x34, 0x90, 0x12, 0x34, 0x56) map {_.asInstanceOf[Byte]}\n    val ivBytes = Array[Int](0x12, 0x34, 0x56, 0x78, 0x90, 0xab, 0xcd, 0xef, 0x12, 0x34, 0x56, 0x78, 0x90, 0x12, 0x34, 0x56) map {_.asInstanceOf[Byte]}\n    val ivParamSpec = new IvParameterSpec(ivBytes)\n    val secretKey = genSecretKey(\"somekey\", saltBytes)\n    val cipher = Cipher.getInstance(\"AES/CBC/PKCS5Padding\")\n    cipher.init(Cipher.ENCRYPT_MODE, secretKey, ivParamSpec)\n    val encryptedData = cipher.doFinal(data.getBytes(\"UTF-8\"))\n    val encodedData = (new BASE64Encoder()) encodeBuffer(encryptedData)\n    Json.obj(\n              \"salt\" -> DatatypeConverter.printHexBinary(saltBytes),\n              \"iv\" -> DatatypeConverter.printHexBinary(ivBytes),\n              \"data\" -> encodedData\n            )\n  }\n\n  def decryptData(encryptedData: EncryptedData) = {\n    val saltBytes = DatatypeConverter.parseHexBinary(encryptedData.salt)\n    val ivBytes = DatatypeConverter.parseHexBinary(encryptedData.iv)\n    val ivParamSpec = new IvParameterSpec(ivBytes)\n    val secretKey = genSecretKey(\"somekey\", saltBytes)\n    val cipher = Cipher.getInstance(\"AES/CBC/PKCS5Padding\")\n    cipher.init(Cipher.DECRYPT_MODE, secretKey, ivParamSpec)\n    val decodedValue = (new BASE64Decoder()) decodeBuffer(encryptedData.data)\n    val decryptedData = new String(cipher.doFinal(decodedValue))\n    decryptedData\n  }\n", "idx": 2108}
{"project": "cipher", "commit_id": "Snippet24209470_6496.java", "target": 1, "func": "            //ONE WAY OF SIGNING\n            byte[] signedInfoSha1Digest = sha1Digest(bSignedInfo);\n            //byte[] bytesCS = new byte[]{55,-59,-1,71,-62,26,57,126,76,7,120,53,-38,-51,8,38,127,-29,5,25};\n            String vSignedInfoSha1DigestString64 = Base64.encodeToString(signedInfoSha1Digest, Base64.DEFAULT);\n            byte[] signedInfoDerSha1Digest = mergeArrays(DER_SHA1_DIGEST_IDENTIFIER, signedInfoSha1Digest);\n            Cipher cipher = Cipher.getInstance(\"RSA/ECB/PKCS1Padding\",\"BC\");\n            cipher.init(Cipher.ENCRYPT_MODE, privateKey);\n            byte[] signatureBytes = cipher.doFinal(signedInfoDerSha1Digest);\n            String base64RsaSignature1 = base64encode(signatureBytes, true);\n            //String vFirma = bytesToHex(signatureBytes);\n\n            //ANOTHER WAY OF SIGNING\n            Signature instance2 = Signature.getInstance(\"SHA1withRSA\");\n            instance2.initSign(privateKey);\n            instance2.update(bSignedInfo);\n            byte[] bFirma3 = instance2.sign();\n            String base64RsaSignature2 = base64encode(bFirma3, true);\n            Log.i(\"Log\",\"nada\");\n\n            //VALIDATE THE RESULT\n            Signature instanceValida = Signature.getInstance(\"SHA1withRSA\");\n            instanceValida.initVerify(Certificado);\n            instanceValida.update(bSignedInfo);\n            if(instanceValida.verify(bFirma3)==true)\n                Log.i(\"Validacion\",\"La firma es valida\");\n            else\n                Log.i(\"Validacion\",\"La firma NO ES valida\");\n\n            return bFirma3;\n        } \n        catch (Throwable e) {\n            Log.e(LOG_TAG, \"Error generating signature for XML\", e);\n            throw e;\n        }\n    }\n", "idx": 2245}
{"project": "cipher", "commit_id": "Snippet41332833_23299.java", "target": 0, "func": "public static String encrypt(String encodeKey, String inputFile) throws Exception {\n\n    byte[] input = getStringFromFile(inputFile).toString().getBytes(\"utf-8\");\n\n    MessageDigest md = MessageDigest.getInstance(\"MD5\");\n    byte[] thedigest = md.digest(encodeKey.getBytes(\"UTF-8\"));\n    SecretKeySpec skc = new SecretKeySpec(thedigest, \"AES/ECB/PKCS5Padding\");\n    Cipher cipher = Cipher.getInstance(\"AES\");\n    cipher.init(Cipher.ENCRYPT_MODE, skc);\n\n    byte[] cipherText = new byte[cipher.getOutputSize(input.length)];\n    int ctLength = cipher.update(input, 0, input.length, cipherText, 0);\n    String data = Base64.encodeToString(cipherText, Base64.DEFAULT);\n\n    Log.d(\"Crypto | Length\", String.valueOf(ctLength));\n    Log.d(\"Crypto | Keypass\", encodeKey);\n\n    return data;\n}\n", "idx": 1904}
{"project": "cipher", "commit_id": "Snippet30626964_12828.java", "target": 0, "func": "String passphrase = \"test\";\nKeySpec keySpec = new PBEKeySpec(passphrase.toCharArray());\nSecretKey key = SecretKeyFactory.getInstance(\"PBEWithMD5AndDES\").generateSecret(keySpec);\necipher = Cipher.getInstance(\"PBEWithMD5AndDES\");\n...\necipher.init(Cipher.ENCRYPT_MODE, ket, paramSpec);\n", "idx": 1804}
{"project": "cipher", "commit_id": "Snippet19286076_2110.java", "target": 0, "func": "public static byte[] decryptAES(String message) throws Exception \n{  \nString secretKey = \"JohnIsAwesome!1!\";\nSecretKeySpec key = new SecretKeySpec(secretKey.getBytes(), \"AES\");\nCipher cipher = Cipher.getInstance(\"AES\");\ncipher.init(Cipher.DECRYPT_MODE, key);\nreturn cipher.doFinal(message.getBytes());  \n}\n", "idx": 1828}
{"project": "cipher", "commit_id": "Snippet42271758_24262.java", "target": 1, "func": " public static byte[] signHash(byte[] hashToSign) {\n        try {\n            KeyStore keyStore = KeyStore.getInstance(ANDROID_KEY_STORE);\n            keyStore.load(null);\n            KeyStore.PrivateKeyEntry keyEntry = (KeyStore.PrivateKeyEntry)keyStore.getEntry(MY_KEY_ALIAS, null);\n            PrivateKey privateKey = keyEntry.getPrivateKey();\n\n            DigestAlgorithmIdentifierFinder hashAlgorithmFinder = new DefaultDigestAlgorithmIdentifierFinder();\n            AlgorithmIdentifier hashingAlgorithmIdentifier = hashAlgorithmFinder.find(KeyProperties.DIGEST_SHA256);\n            DigestInfo digestInfo = new DigestInfo(hashingAlgorithmIdentifier, hashToSign);\n            byte[] hashToEncrypt = digestInfo.getEncoded();\n            Cipher cipher = Cipher.getInstance(\"RSA/ECB/Pkcs1Padding\");\n            cipher.init(Cipher.ENCRYPT_MODE, privateKey); // <= the exception is thrown here\n            return cipher.doFinal(hashToEncrypt);\n        } catch (Throwable e) {\n            Log.e(\"KeyStoreWrapper\", \"Error while signing: \", e);\n        }\n        return \"Could not sign the message.\".getBytes(StandardCharsets.UTF_16LE);\n    }\n", "idx": 2242}
{"project": "cipher", "commit_id": "Snippet39332210_21226.java", "target": 1, "func": "public String decrypt(String message, RSAPrivateKey key) {\n    try {\n\n        Cipher cipher = Cipher.getInstance(\"RSA\");\n        cipher.init(Cipher.DECRYPT_MODE, key);\n\n        byte[] dataEncripted =Base64.decodeBase64(message.getBytes());\n        byte[] data = cipher.doFinal(dataEncripted);\n        return new String(data,\"UTF-8\");\n    } catch (Exception e) {\n        e.printStackTrace();\n    }\n}\n", "idx": 2041}
{"project": "cipher", "commit_id": "Snippet39972028_21882.java", "target": 0, "func": "public class LastNameEncryption implements AttributeConverter<String,String> {\n\n    private static SecretKeySpec secretKey;\n    private final static String peselKey = \"somekey\";\n\n    @Override\n    public String convertToDatabaseColumn(String attribute) {\n        try\n        {\n            setKey();\n            Cipher cipher = Cipher.getInstance(\"AES/ECB/PKCS5Padding\");\n            cipher.init(Cipher.ENCRYPT_MODE, secretKey);\n            return Base64.getEncoder().encodeToString(cipher.doFinal(attribute.getBytes(\"UTF-8\")));\n        }\n        catch (Exception e)\n        {\n            System.out.println(\"Error while encrypting: \" + e.toString());\n        }\n        return null;\n\n    }\n\n    public String convertToEntityAttribute(String dbData) {\n        try {\n            setKey();\n            Cipher cipher = Cipher.getInstance(\"AES/ECB/PKCS5PADDING\");\n            cipher.init(Cipher.DECRYPT_MODE, secretKey);\n            return new String(cipher.doFinal(Base64.getDecoder().decode(dbData)));\n        }\n        catch (Exception e)\n        {\n            System.out.println(\"Error while decrypting: \" + e.toString());\n        }\n        return null;\n\n    }\n\n    public static void setKey() {\n        MessageDigest sha = null;\n        byte[] key;\n        try {\n            key = peselKey.getBytes(\"UTF-8\");\n            sha = MessageDigest.getInstance(\"SHA-1\");\n            key = sha.digest(key);\n            key = Arrays.copyOf(key, 16);\n            secretKey = new SecretKeySpec(key, \"AES\");\n        } catch (NoSuchAlgorithmException e) {\n            e.printStackTrace();\n        }  catch (UnsupportedEncodingException e) {\n            e.printStackTrace();\n        }\n    }\n\n}\n", "idx": 1644}
{"project": "cipher", "commit_id": "Snippet36869628_18843.java", "target": 0, "func": "public class AES\n{\nstatic String encryptionKey = \"48C3B4286FF421A4A328E68AD9E542A4\";\n    static String clearText = \"00000000000000000000000000000000\";\n\n    public static void main(String[] args) throws UnsupportedEncodingException, InvalidKeyException, NoSuchAlgorithmException, NoSuchPaddingException, IllegalBlockSizeException, BadPaddingException\n    {\n        encr();\n    }\n\n    public static String toHexString(byte[] ba)\n    {\n        StringBuilder sb = new StringBuilder();\n        for (int i = 0; i < ba.length; i++)\n        {\n            sb.append(String.format(\"%02X \", ba[i]));\n        }\n        return sb.toString();\n    }\n\n    public static void encr() throws InvalidKeyException, UnsupportedEncodingException, IllegalBlockSizeException, BadPaddingException, NoSuchAlgorithmException, NoSuchPaddingException\n    {\n        //Security.addProvider(new com.sun.crypto.provider.SunJCE());\n        SecretKeySpec secretKey = new SecretKeySpec(encryptionKey.getBytes(\"UTF-8\"), \"AES\");\n\n        byte[] clearTextBytes = clearText.getBytes(\"UTF8\");\n        Cipher cipher = Cipher.getInstance(\"AES\");\n        cipher.init(Cipher.ENCRYPT_MODE, secretKey);\n        byte[] cipherBytes = cipher.doFinal(clearTextBytes);\n\n        System.out.print(\"enc1:  \");\n        for (int i = 0; i < cipherBytes.length; i++)\n        {\n            System.out.print(cipherBytes[i]);\n        }\n        System.out.println(\"\");\n\n        String cipherText = new String(cipherBytes, \"UTF8\");\n        System.out.println(\"enc2: \" + cipherText);\n\n        System.out.println(\"enc3: \" + toHexString(cipherText.getBytes(\"UTF-8\")));\n    }\n}\n", "idx": 1583}
{"project": "cipher", "commit_id": "Snippet45085290_27212.java", "target": 0, "func": "public class EncryptUtil {\n    public static String getKey()\n    {\n        return \"somekeysomekey+)\"; //key length 16!Use this on nodejs\n    }\n\n    public static String encryptAES(String ID) throws Exception {\n\n        Key secretKeySpec = new SecretKeySpec(getKey().getBytes(), \"AES\"); \n\n\n        String transform = \"AES/ECB/ISO10126Padding\";\n        String output = \"\";\n\n        try {\n            javax.crypto.Cipher cipher = javax.crypto.Cipher.getInstance(transform);\n            cipher.init(javax.crypto.Cipher.ENCRYPT_MODE, secretKeySpec);\n            String originStr = ID;\n\n            byte[] input = originStr.getBytes(\"UTF8\");\n            byte[] output = cipher.doFinal(input);\n            sun.misc.BASE64Encoder encoder = new sun.misc.BASE64Encoder();\n            output = encoder.encode(output);\n        } catch (Exception e) {\n            System.out.println(\"ERROR: \" + e.getMessage());\n        }\n        return output;\n    }\n}\n\n//This is how to encrypt from above\n//String encryptText = (String) EncryptUtil.encryptAES(\"something\");\n//System.out.println(encryptText) ---> \"47gPeqm+0lvKb0VNXF29yQ==\";\n", "idx": 1812}
{"project": "cipher", "commit_id": "Snippet20796213_3386.java", "target": 0, "func": "Cipher AesCipher=Cipher.getInstance(\"AES\");\n", "idx": 1806}
{"project": "cipher", "commit_id": "Snippet41175253_23138.java", "target": 1, "func": "// This **DOES NOT** work\nfinal String AndroidOpenSSLString = \"AndroidOpenSSL\";\nfinal String AndroidKeyStoreBCWorkaroundString = \"AndroidKeyStoreBCWorkaround\";\nmProvider = Build.VERSION.SDK_INT < Build.VERSION_CODES.M ? AndroidOpenSSLString : AndroidKeyStoreBCWorkaroundString;\nCipher outCipher = Cipher.getInstance(\"RSA/ECB/PKCS1Padding\", mProvider);\noutCipher.init(Cipher.DECRYPT_MODE, mPrivateKey);\nfor (String chunkEncrypted : rsaEcryptedText.getChunkList()) {\n    byte[] cipherText = chunkEncrypted.getBytes(\"UTF-8\");\n    CipherInputStream cipherInputStream = new CipherInputStream(\n            new ByteArrayInputStream(Base64.decode(cipherText, Base64.NO_WRAP)), outCipher);\n    ArrayList<Byte> values = new ArrayList<>();\n    int nextByte;\n    while ((nextByte = cipherInputStream.read()) != -1) {\n        values.add((byte) nextByte);\n    }\n    byte[] bytes = new byte[values.size()];\n    for (int i = 0; i < bytes.length; i++) {\n        bytes[i] = values.get(i);\n    }\n    decryptedString += new String(bytes, 0, bytes.length, \"UTF-8\");\n    cipherInputStream.close();\n    cipherInputStream.reset();\n}\n", "idx": 1979}
{"project": "cipher", "commit_id": "Snippet28622438_10781.java", "target": 1, "func": "import java.security.AlgorithmParameters;\nimport java.security.NoSuchAlgorithmException;\nimport java.security.SecureRandom;\n\nimport javax.crypto.BadPaddingException;\nimport javax.crypto.Cipher;\nimport javax.crypto.IllegalBlockSizeException;\nimport javax.crypto.SecretKey;\nimport javax.crypto.SecretKeyFactory;\nimport javax.crypto.spec.IvParameterSpec;\nimport javax.crypto.spec.PBEKeySpec;\nimport javax.crypto.spec.SecretKeySpec;\nimport javax.xml.bind.DatatypeConverter;\n\npublic class EncryptionDecryption {\n\n    private static String salt;\n    private static int iterations = 65536  ;\n    private static int keySize = 256;\n    private static byte[] ivBytes;\n\n    public static void main(String []args) throws Exception {\n\n        char[] message = \"PasswordToEncrypt\".toCharArray();\n        System.out.println(\"Message: \" + message.toString());\n        System.out.println(\"Encrypted: \" + encrypt(message));\n        System.out.println(\"Decrypted: \" + decrypt(encrypt(message).toCharArray()));\n    }\n\n    public static String encrypt(char[] plaintext) throws Exception {\n\n        salt = getSalt();\n        byte[] saltBytes = salt.getBytes();\n\n        SecretKeyFactory skf = SecretKeyFactory.getInstance(\"PBKDF2WithHmacSHA1\");\n        PBEKeySpec spec = new PBEKeySpec(plaintext, saltBytes, iterations, keySize);\n        SecretKey secretKey = skf.generateSecret(spec);\n        SecretKeySpec secretSpec = new SecretKeySpec(secretKey.getEncoded(), \"AES\");\n\n        Cipher cipher = Cipher.getInstance(\"AES/CBC/PKCS5Padding\");\n        cipher.init(Cipher.ENCRYPT_MODE, secretSpec);\n        AlgorithmParameters params = cipher.getParameters();\n        ivBytes = params.getParameterSpec(IvParameterSpec.class).getIV();\n        byte[] encryptedTextBytes = cipher.doFinal(plaintext.toString().getBytes(\"UTF-8\"));\n\n        return DatatypeConverter.printBase64Binary(encryptedTextBytes);\n    }\n\n    public static String decrypt(char[] encryptedText) throws Exception {\n\n        byte[] saltBytes = salt.getBytes(\"UTF-8\");\n        byte[] encryptedTextBytes = DatatypeConverter.parseBase64Binary(encryptedText.toString());\n\n        SecretKeyFactory skf = SecretKeyFactory.getInstance(\"PBKDF2WithHmacSHA1\");\n        PBEKeySpec spec = new PBEKeySpec(encryptedText, saltBytes, iterations, keySize);\n        SecretKey secretkey = skf.generateSecret(spec);\n        SecretKeySpec secretSpec = new SecretKeySpec(secretkey.getEncoded(), \"AES\");\n\n        Cipher cipher = Cipher.getInstance(\"AES/CBC/PKCS5Padding\");\n        cipher.init(Cipher.DECRYPT_MODE, secretSpec, new IvParameterSpec(ivBytes));\n\n        byte[] decryptedTextBytes = null;\n\n        try {\n            decryptedTextBytes = cipher.doFinal(encryptedTextBytes);\n        }   catch (IllegalBlockSizeException e) {\n            e.printStackTrace();\n        }   catch (BadPaddingException e) {\n            e.printStackTrace();\n        }\n\n        return decryptedTextBytes.toString();\n\n    }\n\n    public static String getSalt() throws Exception {\n\n        SecureRandom sr = SecureRandom.getInstance(\"SHA1PRNG\");\n        byte[] salt = new byte[20];\n        sr.nextBytes(salt);\n        return salt.toString();\n    }\n}\n", "idx": 2251}
{"project": "cipher", "commit_id": "Snippet22864127_5275.java", "target": 1, "func": "public String getEncrypt(final byte[] iv, final String message) throws GeneralSecurityException, NullPointerException {\n  if (key.isEmpty())\n    throw new NullPointerException();\n\n  final byte[] rawData = key.getBytes(Charset.forName(\"US-ASCII\"));\n  if (rawData.length != 16) {\n    // If this is not 16 in length, there's a problem with the key size, nothing to do here\n    throw new IllegalArgumentException(\"You've provided an invalid key size\");\n  }\n\n  final SecretKeySpec seckeySpec = new SecretKeySpec(rawData, \"AES\");\n  final Cipher ciph = Cipher.getInstance(\"AES/CBC/PKCS5Padding\");\n\n  ciph.init(Cipher.ENCRYPT_MODE, seckeySpec, new IvParameterSpec(iv));\n\n  byte[] encryptedBA = ciph.doFinal(message.getBytes(Charset.forName(\"US-ASCII\")));\n  try {\n    final String encryptedText = new String(Base64.encode(encryptedBA, Base64.DEFAULT), \"UTF-8\");\n    return encryptedText.toString();\n  } \n  catch (final UnsupportedEncodingException e1) { }\n  return \"\";\n}\n", "idx": 2280}
{"project": "cipher", "commit_id": "Snippet43798966_25911.java", "target": 1, "func": "public static byte[] encrypt(byte[] text, PublicKey key) throws Exception\n    {\n        byte[] cipherText = null;\n        //\n        // get an RSA cipher object and print the provider\n        Cipher cipher = Cipher.getInstance(\"RSA/ECB/PKCS1Padding\");\n\n        // encrypt the plain text using the public key\n        cipher.init(Cipher.ENCRYPT_MODE, key);\n        cipherText = cipher.doFinal(text);\n        return cipherText;\n    }\n", "idx": 1996}
{"project": "cipher", "commit_id": "Snippet11190114_35385.java", "target": 1, "func": "    package com.giggsey.test;\n\n\n    import java.security.NoSuchAlgorithmException;\n\n    import javax.crypto.Cipher;\n    import javax.crypto.NoSuchPaddingException;\n    import javax.crypto.spec.IvParameterSpec;\n    import javax.crypto.spec.SecretKeySpec;\n\n    import android.util.Log;\n\n\n    public class SimpleCrypto {\n\n            private String iv = \"fedcba9876543210\";//Dummy iv (CHANGE IT!)\n            private IvParameterSpec ivspec;\n            private SecretKeySpec keyspec;\n            private Cipher cipher;\n\n            private String SecretKey = \"0123456789abcdef\";//Dummy secretKey (CHANGE IT!)\n\n            public void doKey(String key)\n            {\n                    ivspec = new IvParameterSpec(iv.getBytes());\n\n                    key = padRight(key,16);\n\n                    Log.d(\"hi\",key);\n\n                    keyspec = new SecretKeySpec(key.getBytes(), \"AES\");\n\n                    try {\n                            cipher = Cipher.getInstance(\"AES/CBC/NoPadding\");\n                    } catch (NoSuchAlgorithmException e) {\n                            // TODO Auto-generated catch block\n                            e.printStackTrace();\n                    } catch (NoSuchPaddingException e) {\n                            // TODO Auto-generated catch block\n                            e.printStackTrace();\n                    }\n            }\n\n            public byte[] encrypt(String text,String key) throws Exception\n            {\n                    if(text == null || text.length() == 0)\n                            throw new Exception(\"Empty string\");\n\n                    doKey(key);\n\n                    byte[] encrypted = null;\n\n                    try {\n                            cipher.init(Cipher.ENCRYPT_MODE, keyspec, ivspec);\n\n                            encrypted = cipher.doFinal(padString(text).getBytes());\n                    } catch (Exception e)\n                    {                       \n                            throw new Exception(\"[encrypt] \" + e.getMessage());\n                    }\n\n                    return encrypted;\n            }\n\n            public byte[] decrypt(String code,String key) throws Exception\n            {\n                    if(code == null || code.length() == 0)\n                            throw new Exception(\"Empty string\");\n\n                    byte[] decrypted = null;\n\n                    doKey(key);\n\n                    try {\n                            cipher.init(Cipher.DECRYPT_MODE, keyspec, ivspec);\n\n                            decrypted = cipher.doFinal(hexToBytes(code));\n                    } catch (Exception e)\n                    {\n                            throw new Exception(\"[decrypt] \" + e.getMessage());\n                    }\n                    return decrypted;\n            }\n\n\n\n            public static String bytesToHex(byte[] data)\n            {\n                    if (data==null)\n                    {\n                            return null;\n                    }\n\n                    int len = data.length;\n                    String str = \"\";\n                    for (int i=0; i<len; i++) {\n                            if ((data[i]&0xFF)<16)\n                                    str = str + \"0\" + java.lang.Integer.toHexString(data[i]&0xFF);\n                            else\n                                    str = str + java.lang.Integer.toHexString(data[i]&0xFF);\n                    }\n                    return str;\n            }\n\n\n            public static byte[] hexToBytes(String str) {\n                    if (str==null) {\n                            return null;\n                    } else if (str.length() < 2) {\n                            return null;\n                    } else {\n                            int len = str.length() / 2;\n                            byte[] buffer = new byte[len];\n                            for (int i=0; i<len; i++) {\n                                    buffer[i] = (byte) Integer.parseInt(str.substring(i*2,i*2+2),16);\n                            }\n                            return buffer;\n                    }\n            }\n\n\n\n            private static String padString(String source)\n            {\n              char paddingChar = ' ';\n              int size = 16;\n              int x = source.length() % size;\n              int padLength = size - x;\n\n              for (int i = 0; i < padLength; i++)\n              {\n                      source += paddingChar;\n              }\n\n              return source;\n            }\n\n            public static String padRight(String s, int n) {\n                return String.format(\"%1$-\" + n + \"s\", s);  \n              }\n    }\n", "idx": 2216}
{"project": "cipher", "commit_id": "Snippet26723118_8843.java", "target": 0, "func": "    String message = \"Hello world 123456\";\n\n    // Creating Key. Key of size = 128\n    byte [] raw ={-49, -44, 51, -114, 58, 79, 83, -38, 107, 64, 67, -108, -52, 109, 85, 77};\n    SecretKeySpec skeySpec = new SecretKeySpec(raw, \"AES\");\n    Cipher cipher = Cipher.getInstance(\"AES\");\n    cipher.init(Cipher.ENCRYPT_MODE, skeySpec);\n\n    // Encript\n    byte[] encrypted = cipher.doFinal(message.getBytes());\n    System.out.println(\"encripted: \" + Arrays.toString(encrypted));\n    System.out.println(\"encripted: \"+ asHex(encrypted));\n\n    cipher.init(Cipher.DECRYPT_MODE, skeySpec);\n    byte[] decript = cipher.doFinal(encrypted, 0, 32);\n", "idx": 1763}
{"project": "cipher", "commit_id": "Snippet16130098_39096.java", "target": 1, "func": "public class UltimateEncryptor {\n\n  private static final String CIPHER_ALGORITHM = \"AES/CBC/PKCS5Padding\";\n  private static final String RANDOM_GENERATOR_ALGORITHM = \"AES\";\n\n\n  // Encrypts string and encodes in Base64\n  public String encrypt( String password, String data ) throws Exception \n  {\n    byte[] secretKey = password.getBytes();\n    byte[] clear = data.getBytes();\n\n    SecretKeySpec secretKeySpec = new SecretKeySpec( secretKey, CIPHER_ALGORITHM );\n    Cipher cipher = Cipher.getInstance( CIPHER_ALGORITHM );\n    cipher.init( Cipher.ENCRYPT_MODE, secretKeySpec );\n\n    byte[] encrypted = cipher.doFinal( clear );\n    String encryptedString = Base64.encodeToString( encrypted, Base64.DEFAULT );\n\n    return encryptedString;\n  }\n\n  // Decrypts string encoded in Base64\n  public String decrypt( String password, String encryptedData ) throws Exception \n  {\n    byte[] secretKey = password.getBytes();\n    SecretKeySpec secretKeySpec = new SecretKeySpec( secretKey, CIPHER_ALGORITHM );\n    Cipher cipher = Cipher.getInstance( CIPHER_ALGORITHM );\n    cipher.init( Cipher.DECRYPT_MODE, secretKeySpec );\n\n    byte[] encrypted = Base64.decode( encryptedData, Base64.DEFAULT );\n    byte[] decrypted = cipher.doFinal( encrypted );\n\n    return new String( decrypted );\n  }\n}\n", "idx": 2228}
{"project": "cipher", "commit_id": "Snippet11292413_35446.java", "target": 0, "func": "Cipher cipher = Cipher.getInstance(\"DESede/CBC/PKCS5Padding\");\n\nbyte[] encypted = new byte[cipher.getOutputSize(fileData.length)];\nint len = cipher.update(fileData, 0, fileData.length, encypted, 0);\nlen += cipher.doFinal(encypted, len);\n", "idx": 1749}
{"project": "cipher", "commit_id": "Snippet26200303_7964.java", "target": 1, "func": "Cipher c = Cipher.getInstance(\"AES/CBC/NoPadding\");", "idx": 2177}
{"project": "cipher", "commit_id": "Snippet3271912_30705.java", "target": 0, "func": "decryptCipher = Cipher.getInstance(\"DES/ECB/PKCS5Padding\");\ndecryptCipher.init(2, getKey(0));\ndecryptCipher.doFinal(data);\n", "idx": 1679}
{"project": "cipher", "commit_id": "Snippet17798597_919.java", "target": 1, "func": "public static byte[] encrypt(String text, PublicKey key) {\n\n    byte[] cipherText = null;\n    try {\n        // get an RSA cipher object and print the provider\n        final Cipher cipher = Cipher.getInstance(ALGORITHM);\n        // encrypt the plain text using the public key\n        cipher.init(Cipher.ENCRYPT_MODE, key);\n        cipherText = cipher.doFinal(text.getBytes());\n\n    } catch (Exception e) {\n        e.printStackTrace();\n    }\n    return cipherText;\n}\n", "idx": 2250}
{"project": "cipher", "commit_id": "Snippet10537263_34878.java", "target": 1, "func": "cipher = Cipher.getInstance(\"RSA/ECB/PKCS1Padding\");", "idx": 2302}
{"project": "cipher", "commit_id": "Snippet34206699_16215.java", "target": 1, "func": "         Cipher cipher = Cipher.getInstance(\"AES/GCM/NoPadding\", \"BC\");\n\n         cipher.init(\n                 Cipher.DECRYPT_MODE,\n                 new SecretKeySpec(keyMaterial, \"AES\"), //C# version??\n                 new IvParameterSpec(iv)\n         );\n", "idx": 2119}
{"project": "cipher", "commit_id": "Snippet25760433_8054.java", "target": 0, "func": "try\n    {\n        // Get the URL for the servlet.\n        URL url = new URL(getCodeBase(), \"editCriteriaServlet\");\n\n        HttpURLConnection connection = (HttpURLConnection) url.openConnection();\n\n        connection.setDoInput(true);\n        connection.setDoOutput(true);\n        connection.setUseCaches(false);\n        connection.setRequestMethod(\"POST\");\n        connection.setRequestProperty(\"Content-Type\", \"text/plain\");\n        connection.setRequestProperty(\"Cookie\", \"JSESSIONID=\" + sessionID);\n\n        ObjectOutputStream out = new ObjectOutputStream(connection.getOutputStream());\n        out.writeObject(\"Request criteria Object\");\n        out.flush();\n        out.close();\n\n        // Read in the search criteria object.\n        ObjectInputStream in = new ObjectInputStream(connection.getInputStream());\n        SealedObject sealedObject = (SealedObject)in.readObject();\n        in.close();\n\n        // Decrypt the sealed object and get the zipped data.\n        SecretKey key = buildSecretKey(crypKeyString);\n        Cipher cipher = Cipher.getInstance(\"DES/ECB/PKCS5Padding\");\n        cipher.init(Cipher.DECRYPT_MODE, key);\n        byte[] baos = (byte[]) sealedObject.getObject(cipher);\n        ByteArrayInputStream gis = new ByteArrayInputStream(baos);\n\n        // Unzip and recover the original object.\n        GZIPInputStream unzipped = new GZIPInputStream(gis);\n        ObjectInputStream ois = new ObjectInputStream(unzipped);\n        tempMultipleSlideDataObject = (MultipleSlideDataObject15) ois.readObject();            \n    }\n    catch (MalformedURLException ex)\n    {\n        errorMessage = \"Submit criteria file Malformed URL.\" + ex.toString();\n        fireActionPerformed(new ActionEvent(this, ActionEvent.ACTION_PERFORMED, \"showErrorMessageDialog_\"));\n        System.out.println(\"Model_CriteriaInterface: loadCriteriaObject: MalformedURLException occurred\");\n    }\n    catch (Exception e)\n    {\n        errorMessage = \"Submit criteria file ERROR exception:\" + e.toString();\n        fireActionPerformed(new ActionEvent(this, ActionEvent.ACTION_PERFORMED, \"showErrorMessageDialog_\"));\n        System.out.println(\"Model_CriteriaInterface: loadCriteriaObject: Submit criteria file ERROR exception: \" + e.toString());\n    }\n", "idx": 1797}
{"project": "cipher", "commit_id": "Snippet1962976_30173.java", "target": 0, "func": " KeyGenerator kg = KeyGenerator.getInstance(\"DES\");\n kg.init(new SecureRandom());\n SecretKey key = kg.generateKey();\n SecretKeyFactory skf = SecretKeyFactory.getInstance(\"DES\");\n Class spec = Class.forName(\"javax.crypto.spec.DESKeySpec\");\n DESKeySpec ks = (DESKeySpec) skf.getKeySpec(key, spec);\n ObjectOutputStream oos = new ObjectOutputStream(new FileOutputStream(\"keyfile\"));\n oos.writeObject(ks.getKey());\n\n Cipher c = Cipher.getInstance(\"DES/CFB8/NoPadding\");\n c.init(Cipher.ENCRYPT_MODE, key);\n CipherOutputStream cos = new CipherOutputStream(new FileOutputStream(\"ciphertext\"), c);\n PrintWriter pw = new PrintWriter(new OutputStreamWriter(cos));\n pw.println(\"Stand and unfold yourself\");\n pw.close();\n oos.writeObject(c.getIV());\n oos.close();\n", "idx": 1865}
{"project": "cipher", "commit_id": "Snippet41925353_23925.java", "target": 0, "func": "private File dencryptKeysFile() throws NoSuchAlgorithmException, NoSuchPaddingException, InvalidKeyException, IllegalBlockSizeException, IOException, ClassNotFoundException, BadPaddingException{\n    SecretKey key64 = new SecretKeySpec( new byte[] { 0x00, 0x01, 0x02, 0x03, 0x04, 0x05, 0x06, 0x07 }, \"Blowfish\" );\n    Cipher cipher = Cipher.getInstance( \"Blowfish\" );\n    cipher.init( Cipher.DECRYPT_MODE, key64 );\n    CipherInputStream cipherInputStream = new CipherInputStream(new BufferedInputStream(new FileInputStream(fileName)),cipher);\n    ObjectInputStream inputStream = new ObjectInputStream(cipherInputStream);\n    SealedObject sealedObject = (SealedObject)inputStream.readObject();\n    inputStream.close();\n\n    File keysFile =(File)sealedObject.getObject(cipher);\n    this.keysFile = keysFile;\n    return keysFile;\n}\n", "idx": 1719}
{"project": "cipher", "commit_id": "Snippet40210451_22125.java", "target": 0, "func": "private String encrypt(String value) {\n    try {\n        final byte[] bytes = value != null ? value.getBytes(UTF8) : new byte[0];\n        SecretKeyFactory keyFactory = SecretKeyFactory.getInstance(\"PBEWithMD5AndDES\");\n        SecretKey key = keyFactory.generateSecret(new PBEKeySpec(SEKRIT));\n        Cipher pbeCipher = Cipher.getInstance(\"PBEWithMD5AndDES\");\n        pbeCipher.init(Cipher.ENCRYPT_MODE, key, new PBEParameterSpec(Settings.Secure.getString(context.getContentResolver(), Settings.Secure.ANDROID_ID).getBytes(UTF8), 20));\n        return new String(Base64.encode(pbeCipher.doFinal(bytes), Base64.NO_WRAP), UTF8);\n    } catch (Exception e) {\n        throw new RuntimeException(e);\n    }\n}\nprivate String decrypt(String value) {\n    try {\n        final byte[] bytes = value != null ? Base64.decode(value, Base64.DEFAULT) : new byte[0];\n        SecretKeyFactory keyFactory = SecretKeyFactory.getInstance(\"PBEWithMD5AndDES\");\n        SecretKey key = keyFactory.generateSecret(new PBEKeySpec(SEKRIT));\n        Cipher pbeCipher = Cipher.getInstance(\"PBEWithMD5AndDES\");\n        pbeCipher.init(Cipher.DECRYPT_MODE, key, new PBEParameterSpec(Settings.Secure.getString(context.getContentResolver(), Settings.Secure.ANDROID_ID).getBytes(UTF8), 20));\n        return new String(pbeCipher.doFinal(bytes), UTF8);\n    } catch (Exception e) {\n        throw new RuntimeException(e);\n    }\n}\n", "idx": 1878}
{"project": "cipher", "commit_id": "Snippet33795543_15838.java", "target": 1, "func": "  public String encrypt(String plainText) throws Exception {   \n\n    //get salt\n    salt = generateSalt();      \n    byte[] saltBytes = salt.getBytes(\"UTF-8\");\n\n    // Derive the key\n    SecretKeyFactory factory =        SecretKeyFactory.getInstance(\"PBKDF2WithHmacSHA1\");\n    PBEKeySpec spec = new PBEKeySpec(\n            password.toCharArray(), \n            saltBytes, \n            pswdIterations, \n            keySize\n            );\n\n    SecretKey secretKey = factory.generateSecret(spec);\n    SecretKeySpec secret = new SecretKeySpec(secretKey.getEncoded(), \"AES\");\n\n    //encrypt the message\n    Cipher cipher = Cipher.getInstance(\"AES/CBC/PKCS5Padding\");\n    cipher.init(Cipher.ENCRYPT_MODE, secret);\n    AlgorithmParameters params = cipher.getParameters();\n    ivBytes = params.getParameterSpec(IvParameterSpec.class).getIV();\n    byte[] encryptedTextBytes = cipher.doFinal(plainText.getBytes(\"UTF-8\"));\n    return new Base64().encodeAsString(encryptedTextBytes);\n  }\n", "idx": 2017}
{"project": "cipher", "commit_id": "Snippet14622767_37840.java", "target": 1, "func": "Cipher pbeCipher = Cipher.getInstance(\"AES/CTS/NoPadding\");\n// Initialize cipher\npbeCipher.init(Cipher.DECRYPT_MODE, keySpec, ivSpec);\ndoFinal(data);\n", "idx": 1969}
{"project": "cipher", "commit_id": "Snippet6907822_32447.java", "target": 0, "func": "import javax.crypto.Cipher;\nimport javax.crypto.SecretKey;\nimport javax.crypto.SecretKeyFactory;\nimport javax.crypto.spec.DESKeySpec;\n\npublic class DES \n{\n    SecretKey key;\n    DES(byte []  KEY) throws Exception\n    {\n        key = readKey(KEY);\n    }\n\n    public SecretKey readKey(byte[] rawkey) throws Exception\n    {\n         DESKeySpec keyspec = new DESKeySpec(rawkey);\n         SecretKeyFactory keyfactory = SecretKeyFactory.getInstance(\"DES\");\n         SecretKey key = keyfactory.generateSecret(keyspec);\n         return key;\n    }\n\n    public byte[] encrypt(byte[] plain ) throws Exception\n    {\n        Cipher cipher = Cipher.getInstance(\"DES\");\n        cipher.init(Cipher.ENCRYPT_MODE, key);\n        byte[] encrypted = cipher.doFinal(plain);\n        return encrypted;\n    }\n    public byte[] decrypt(byte[] cipher ) throws Exception\n    {\n        Cipher dcipher = Cipher.getInstance(\"DES\");\n        dcipher.init(Cipher.DECRYPT_MODE, key);\n        byte[] decrypted = dcipher.doFinal(cipher);\n        return decrypted;\n    }  \n}\n", "idx": 1714}
{"project": "cipher", "commit_id": "Snippet42350093_24334.java", "target": 1, "func": "public static String AESEncrypt(String text, String key, String iv) throws Exception {\n     Cipher cipher = Cipher.getInstance(\"AES/CBC/PKCS5Padding\");\n     byte[] keyBytes = new byte[16];\n     byte[] b = key.getBytes(\"UTF-8\");\n     int len = b.length;\n     if (len > keyBytes.length)\n         len = keyBytes.length;\n     System.arraycopy(b, 0, keyBytes, 0, len);\n\n     byte[] keyBytesiv = new byte[16];\n     byte[] biv = iv.getBytes(\"UTF-8\");\n     int leniv = biv.length;\n     if (leniv > keyBytesiv.length)\n         leniv = keyBytesiv.length;\n     System.arraycopy(biv, 0, keyBytes, 0, len);\n     SecretKeySpec keySpec = new SecretKeySpec(keyBytes, \"AES\");\n     IvParameterSpec ivSpec = new IvParameterSpec(keyBytesiv);\n\n     cipher.init(Cipher.ENCRYPT_MODE, keySpec, ivSpec);\n\n     byte[] results = cipher.doFinal(text.getBytes(\"UTF-8\"));\n     BASE64Encoder encoder = new BASE64Encoder();\n     return encoder.encode(results);\n }\n", "idx": 2332}
{"project": "cipher", "commit_id": "Snippet6873325_32433.java", "target": 1, "func": "package decryption;\n\nimport java.io.*;\nimport javax.crypto.*;\nimport javax.crypto.spec.*;\n\n    public class Decryption {\n      public static void main(String args[]) throws Exception {\n\n\n          File file = new File(\"ecryption.pdf\");\n          System.out.println(file.getAbsolutePath());\n          System.out.println(\"user.dir is: \" + System.getProperty(\"user.dir\"));\n\n        Cipher cipher = Cipher.getInstance(\"AES/CBC/NoPadding\");\n        SecretKeySpec keySpec = new SecretKeySpec(\"01234567890abcde\".getBytes(), \"AES\");\n        IvParameterSpec ivSpec = new IvParameterSpec(\"fedcba9876543210\".getBytes());\n        cipher.init(Cipher.DECRYPT_MODE, keySpec, ivSpec);\n\n        FileInputStream fis   = new FileInputStream(new File(\"ecrypted.pdf\"));\n        long start = System.currentTimeMillis();\n        System.out.print(start+\"           \");\n        CipherInputStream cis = new CipherInputStream(fis, cipher);\n        FileOutputStream fos  = new FileOutputStream(new File(\"decrypted.pdf\"));\n        long end = System.currentTimeMillis();\n        System.out.print(end);\n\n\n        byte[] b = new byte[8];\n        int i;\n\n        while ((i = cis.read(b)) != -1) {\n          fos.write(b, 0, i);\n        }\n        fos.flush(); fos.close();\n        cis.close(); fis.close();       \n      }\n}\n", "idx": 2273}
{"project": "cipher", "commit_id": "Snippet20401655_3036.java", "target": 0, "func": "import java.security.*;\nimport javax.crypto.*;\n\nCipher aes = Cipher.getInstance(\"AES/ECB/PKCS5Padding\");\naes.init(Cipher.ENCRYPT_MODE, key);\nbyte[] ciphertext = aes.doFinal(\"my cleartext\".getBytes());\n\naes.init(Cipher.DECRYPT_MODE, key);\nString cleartext = new String(aes.doFinal(ciphertext));\n", "idx": 1706}
{"project": "cipher", "commit_id": "Snippet6037897_31899.java", "target": 1, "func": "    public static final String FILE_EXTENSION = \".serpent\";\n    public static final String PROVIDER = \"BC\"; // Bouncy Castle\n    public static final String BLOCK_CIPHER = \"Serpent\";\n    public static final String TRANSFORMATION = \"Serpent/CBC/PKCS7Padding\";\n    public static final String KEY_ALGORITHM = \"PBKDF2WithHmacSHA1\";\n    public static final String PRNG_ALGORITHM = \"SHA1PRNG\";\n\n    public static final int BLOCK_SIZE = 128; // bits\n    public static final int KEY_SIZE = 256; // bits\n    public static final int ITERATION_COUNT = 1024; // for PBE\n\n    /** Performs the encryption of a file. */\n    public void encrypt(String pathname, char[] password, byte[] salt) {\n        // Use bouncy castle as our provider\n        Security.addProvider(new org.bouncycastle.jce.provider.BouncyCastleProvider());\n\n        // Convert the file into a byte array\n        byte[] plaintext = fileToBytes(new File(pathname));\n\n        // Generate a 256-bit key\n        SecretKey key = generateSecretKey(password,salt);\n\n        // Generate a 128-bit secure random IV\n        byte[] iv = generateIV();\n\n        // Setup the cipher and perform the encryption\n        Cipher cipher = null;\n        byte[] ciphertext = null;\n        try {\n            cipher = Cipher.getInstance(TRANSFORMATION, PROVIDER);\n            cipher.init(Cipher.ENCRYPT_MODE, key, new IvParameterSpec(iv));\n            ciphertext = cipher.doFinal(plaintext);\n        } catch (Exception e) {\n            e.printStackTrace();\n        }\n\n        // Append the IV to the ciphertext\n        byte[] temp = new byte[iv.length+ciphertext.length];\n        System.arraycopy(iv, 0, temp, 0, iv.length);\n        System.arraycopy(ciphertext, 0, temp, iv.length, ciphertext.length);\n        ciphertext = temp;\n\n        // Store the encrypted file in the same directory we found it\n        if (Environment.getExternalStorageDirectory().canWrite()) {\n            bytesToFile(ciphertext, pathname+FILE_EXTENSION);\n            File file = new File(pathname);\n            file.delete();\n        }       \n    }\n", "idx": 1938}
{"project": "cipher", "commit_id": "Snippet16472877_39421.java", "target": 1, "func": "private Spinner spinner;\nprivate SpinAdapter adapter;\nprivate Cipher cipher;\nprivate ArrayList<ConnectionProfile> connectionProfiles;\nprivate KeyGenerator keygen;\nprivate SecretKey key;\n\npublic void createCipher() throws Exception{\n    cipher = Cipher.getInstance(\"AES/CBC/PKCS5Padding\");\n    keygen = KeyGenerator.getInstance(\"AES\");\n    key = keygen.generateKey();\n}\n\npublic void saveProfiles() {\n    try {\n        if (cipher == null) {createCipher();}\n        cipher.init(Cipher.ENCRYPT_MODE, key);\n        FileOutputStream fos = openFileOutput(\"connProfiles.bin\", Context.MODE_PRIVATE);\n        BufferedOutputStream bos = new BufferedOutputStream(fos);\n        CipherOutputStream cos = new CipherOutputStream(bos, cipher);\n        ObjectOutputStream oos = new ObjectOutputStream(cos);\n        oos.writeObject(connectionProfiles);\n        oos.flush();\n        oos.close();\n    } catch (Exception e) {\n        e.printStackTrace();\n    }\n}\n\npublic void readProfiles() {\n    try {\n        if (cipher == null) {createCipher();}\n        cipher.init(Cipher.ENCRYPT_MODE, key);\n        FileInputStream fis = openFileInput(\"connProfiles.bin\");\n        BufferedInputStream bis = new BufferedInputStream(fis);\n        CipherInputStream cis = new CipherInputStream(bis, cipher);\n        ObjectInputStream ois = new ObjectInputStream(cis);\n        connectionProfiles = (ArrayList<ConnectionProfile>) ois.readObject();\n        ois.close();\n    } catch (Exception e) {\n        e.printStackTrace();\n        ;\n    }\n}\n", "idx": 2202}
{"project": "cipher", "commit_id": "Snippet45420936_27495.java", "target": 1, "func": "public class KeyStoreHelper {\n\n    public static byte[] decryptAES(FileInputStream fis, byte[] key) throws IOException {\n\n        CipherInputStream cin = null;\n        try {\n\n            byte[] keyBytes = getKeyBytes(key);\n            Cipher aesCipher = Cipher.getInstance(\"AES/CBC/PKCS5Padding\");\n            SecretKeySpec secretKeySpec = new SecretKeySpec(keyBytes, \"AES\");\n            IvParameterSpec ivParameterSpec = new IvParameterSpec(keyBytes);\n            aesCipher.init(Cipher.DECRYPT_MODE, secretKeySpec, ivParameterSpec);\n\n            byte[] buffer = new byte[1024];\n\n            ByteArrayInputStream cipherIn = new ByteArrayInputStream(buffer);\n            ByteArrayOutputStream cipherOut = new ByteArrayOutputStream();\n            cin = new CipherInputStream(cipherIn, aesCipher);\n\n            int length;\n            while ((length = fis.read(buffer)) != -1) {\n                cin.read(buffer, 0, length);\n                cipherOut.write(buffer);\n            }\n\n            return cipherOut.toByteArray();\n        } catch (InvalidKeyException | NoSuchAlgorithmException\n                | NoSuchPaddingException e) {\n            throw new RuntimeException(e);\n        } catch (Exception e) {\n            e.printStackTrace();\n        } finally {\n            if (cin != null) {\n                cin.close();\n            }\n            if (fis != null) {\n                fis.close();\n            }\n        }\n        return new byte[1];\n    }\n\n    public static void encryptAES(FileOutputStream fos, byte[] plainText, byte[] key) throws IOException {\n\n        CipherOutputStream cos = null;\n        try {\n            byte[] keyBytes = getKeyBytes(key);\n            Cipher aesCipher = Cipher.getInstance(\"AES/CBC/PKCS5Padding\");\n            SecretKeySpec secretKeySpec = new SecretKeySpec(keyBytes, \"AES\");\n            IvParameterSpec ivParameterSpec = new IvParameterSpec(keyBytes);\n            aesCipher.init(Cipher.ENCRYPT_MODE, secretKeySpec, ivParameterSpec);\n\n            cos = new CipherOutputStream(fos, aesCipher);\n            cos.write(plainText);\n            cos.flush();\n\n        } catch (InvalidKeyException | NoSuchAlgorithmException\n                | NoSuchPaddingException e) {\n            throw new RuntimeException(e);\n        } catch (InvalidAlgorithmParameterException e) {\n            e.printStackTrace();\n        } catch (Exception e) {\n            e.printStackTrace();\n        } finally {\n            if (cos != null) {\n                cos.close();\n            }\n            if (fos != null) {\n                fos.flush();\n                fos.close();\n            }\n        }\n    }\n\n    private static byte[] getKeyBytes(final byte[] key) throws Exception {\n        byte[] keyBytes = new byte[16];\n        System.arraycopy(key, 0, keyBytes, 0, Math.min(key.length, keyBytes.length));\n        return keyBytes;\n    }\n}\n", "idx": 2034}
{"project": "cipher", "commit_id": "Snippet36883971_18867.java", "target": 0, "func": "import java.security.SecureRandom;\nimport javax.crypto.Cipher;\nimport javax.crypto.KeyGenerator;\nimport javax.crypto.SecretKey;\nimport javax.crypto.spec.SecretKeySpec;\n\n/**\n * Usage:\n *\n\n * String crypto = SimpleCrypto.encrypt(masterpassword, cleartext)\n * ...\n * String cleartext = SimpleCrypto.decrypt(masterpassword, crypto)\n *\n\n * @author ferenc.hechler\n */\n\npublic class SimpleCrypto {\n\n    public static String encrypt(String seed, String cleartext) throws Exception {\n        byte[] rawKey = getRawKey(seed.getBytes());\n        byte[] result = encrypt(rawKey, cleartext.getBytes());\n        return toHex(result);\n    }\n\n    public static String decrypt(String seed, String encrypted) throws Exception {\n        byte[] rawKey = getRawKey(seed.getBytes());\n        byte[] enc = toByte(encrypted);\n        byte[] result = decrypt(rawKey, enc);\n        return new String(result);\n    }\n\n    private static byte[] getRawKey(byte[] seed) throws Exception {\n        KeyGenerator kgen = KeyGenerator.getInstance(\"AES\");\n        SecureRandom sr = SecureRandom.getInstance(\"SHA1PRNG\");\n        sr.setSeed(seed);\n        kgen.init(128, sr); // 192 and 256 bits may not be available\n        SecretKey skey = kgen.generateKey();\n        byte[] raw = skey.getEncoded();\n        return raw;\n    }\n\n\n    private static byte[] encrypt(byte[] raw, byte[] clear) throws Exception {\n        SecretKeySpec skeySpec = new SecretKeySpec(raw, \"AES\");\n        Cipher cipher = Cipher.getInstance(\"AES\");\n        cipher.init(Cipher.ENCRYPT_MODE, skeySpec);\n        byte[] encrypted = cipher.doFinal(clear);\n        return encrypted;\n    }\n\n    private static byte[] decrypt(byte[] raw, byte[] encrypted) throws Exception {\n        SecretKeySpec skeySpec = new SecretKeySpec(raw, \"AES\");\n        Cipher cipher = Cipher.getInstance(\"AES\");\n        cipher.init(Cipher.DECRYPT_MODE, skeySpec);\n        byte[] decrypted = cipher.doFinal(encrypted);\n        return decrypted;\n    }\n\n    public static String toHex(String txt) {\n        return toHex(txt.getBytes());\n    }\n    public static String fromHex(String hex) {\n        return new String(toByte(hex));\n    }\n\n    public static byte[] toByte(String hexString) {\n        int len = hexString.length()/2;\n        byte[] result = new byte[len];\n        for (int i = 0; i < len; i++)\n            result[i] = Integer.valueOf(hexString.substring(2*i, 2*i+2), 16).byteValue();\n        return result;\n    }\n\n    public static String toHex(byte[] buf) {\n        if (buf == null)\n            return \"\";\n        StringBuffer result = new StringBuffer(2*buf.length);\n        for (int i = 0; i < buf.length; i++) {\n            appendHex(result, buf[i]);\n        }\n        return result.toString();\n    }\n    private final static String HEX = \"0123456789ABCDEF\";\n    private static void appendHex(StringBuffer sb, byte b) {\n        sb.append(HEX.charAt((b>>4)&0x0f)).append(HEX.charAt(b&0x0f));\n    }\n}\n", "idx": 1634}
{"project": "cipher", "commit_id": "Snippet5244950_31517.java", "target": 0, "func": "          // create a key generator based upon the Blowfish cipher\n    KeyGenerator keygenerator = KeyGenerator.getInstance(\"Blowfish\");\n\n    // create a key\n    SecretKey secretkey = keygenerator.generateKey();\n\n    // create a cipher based upon Blowfish\n    Cipher cipher = Cipher.getInstance(\"Blowfish\");\n\n    // initialise cipher to with secret key\n    cipher.init(Cipher.ENCRYPT_MODE, secretkey);\n\n    // get the text to encrypt\n    String inputText = \"MyTextToEncrypt\";\n\n    // encrypt message\n    byte[] encrypted = cipher.doFinal(inputText.getBytes());\n", "idx": 1829}
{"project": "cipher", "commit_id": "Snippet35934850_17785.java", "target": 1, "func": "Cipher        c;\nProvider      p;\nStringBuilder bldr;\n\nc    = Cipher.getInstance(\"RSA\");\np    = cipher.getProvider();\nbldr = new StringBuilder();\n\nbldr.append(_p.getName())\n  .append(\" \").append(_p.getVersion())\n  .append(\" (\").append(_p.getInfo()).append(\")\");\nLog.i(\"test\", bldr.toString());\n", "idx": 2046}
{"project": "cipher", "commit_id": "Snippet5520640_31681.java", "target": 0, "func": "    String algorithm = \"DES\";\n    SecretKeyFactory keyFactory = SecretKeyFactory.getInstance(algorithm);\n\n    byte[] encBytes = \"12345678\".getBytes(\"UTF8\");\n    byte[] decBytes = \"56781234\".getBytes(\"UTF8\");\n\n    DESKeySpec keySpecEncrypt = new DESKeySpec(encBytes);\n    DESKeySpec keySpecDecrypt = new DESKeySpec(decBytes);\n\n\n    SecretKey keyEncrypt = keyFactory.generateSecret(keySpecEncrypt);\n    SecretKey keyDecrypt = keyFactory.generateSecret(keySpecDecrypt);\n\n    Cipher cipherEncrypt = Cipher.getInstance(algorithm);\n    Cipher cipherDecrypt = Cipher.getInstance(algorithm);\n\n    String input = \"john doe\";\n\n    cipherEncrypt.init(Cipher.ENCRYPT_MODE, keyEncrypt);\n    byte[] inputBytes = cipherEncrypt.doFinal(input.getBytes());\n    System.out.println(\"inputBytes: \" + new String(inputBytes));\n\n    cipherDecrypt.init(Cipher.DECRYPT_MODE, keyDecrypt);\n    byte[] outputBytes = cipherDecrypt.doFinal(inputBytes);\n    System.out.println(\"outputBytes: \" + new String(outputBytes));\n", "idx": 1765}
{"project": "cipher", "commit_id": "Snippet44481142_26547.java", "target": 1, "func": "def encryption(text) {\n   String publicKeyModulus = \"MODULUS_GOES_HERE\";\n   String exponent = \"65537\";\n   RSAPublicKeySpec publicKeySpec = new RSAPublicKeySpec(new BigInteger(publicKeyModulus, 16), new BigInteger(exponent, 10));\n   KeyFactory publicKeyFactory = KeyFactory.getInstance(\"RSA\");\n   publicKey = publicKeyFactory.generatePublic(publicKeySpec);\n\n   Cipher cipher = Cipher.getInstance(\"RSA\");\n   cipher.init(Cipher.ENCRYPT_MODE, publicKey);\n   byte[] cipherData = cipher.doFinal(text.getBytes());\n\n   return cipherData.encodeBase64().toString()\n}\n", "idx": 2217}
{"project": "cipher", "commit_id": "Snippet45737528_27772.java", "target": 0, "func": "    public static String encrypt(String sessionId)\n{\n    try\n    {\n        Cipher cipher = Cipher.getInstance(\"AES/ECB/PKCS5Padding\");\n        final SecretKeySpec secretKey = new SecretKeySpec(key, \"AES\");\n        cipher.init(Cipher.ENCRYPT_MODE, secretKey);\n        final String encryptedSessionId = Base64.encodeBase64String(cipher.doFinal(sessionId.getBytes()));\n        return encryptedSessionId;\n    }\n    catch (Exception e)\n    {\n        e.printStackTrace();\n    }\n    return null;\n\n}\n", "idx": 1709}
{"project": "cipher", "commit_id": "Snippet22829354_5228.java", "target": 1, "func": "   ...     \n\n   Cipher cipher = Cipher.getInstance(\"AES/CBC/PKCS5Padding\", \"BC\");\n   cipher.init(Cipher.DECRYPT_MODE, secKey, ivSpec);\n\n    File file = new File(\"D_\" + filename); // D_ for decrypted\n    FileOutputStream fos = null;\n    if (!file.exists()) {\n        file.createNewFile();\n        fos = new FileOutputStream(file);\n    }\n\n    try (FileInputStream fis = new FileInputStream(filename)) {\n        do {\n            byte[] buf = new byte[4096];\n            int n = fis.read(buf);\n            if (n < 0) {\n                System.out.println(\"Read error\");\n                fis.close();\n                return false;\n            }\n\n            byte[] cipherBuf = cipher.doFinal(buf);  // ERROR HERE\n            System.out.println(\"IS THIS WORKING WTF: \" + new String(cipherBuf));\n            fos.write(cipherBuf, 0, n);\n\n        } while (fis.available() > 0);\n        fis.close();\n        fos.close();\n        return true;\n", "idx": 1989}
{"project": "cipher", "commit_id": "Snippet16837260_176.java", "target": 0, "func": "public class MyClassActivity extends Activity {\n\nVideoView mVideoView; \nLocalSingleHttpServer mServer ;\n\n@Override \nprotected void onCreate(Bundle savedInstanceState) { \n  super.onCreate(savedInstanceState);\n\n  SecretKey sk = encryptVideo(\"/mnt/sdcard/input.mp4\", \"/mnt/sdcard/enc.mp4\");\n\n  playENCVideo(sk,\"/mnt/sdcard/enc.mp4\");\n}\n\npublic void playENCVideo(SecretKey skey, String path) {\n\n   Cipher decipher = null;\n\n   decipher = Cipher.getInstance(\"AES\");\n\n   decipher.init(Cipher.DECRYPT_MODE, skey);\n\n   mServer = new LocalSingleHttpServer();\n\n   mServer.setCipher(decipher);\n   mServer.start();\n\n   path = mServer.getURL(path);\n\n  mVideoView = (VideoView) findViewById(R.id.vid_view);\n  mVideoView.setVideoPath(path);\n  mVideoView.setOnPreparedListener(this);\n  mVideoView.setOnCompletionListener(this);\n  mVideoView.setMediaController(new MediaController(this));\n  mVideoView.start();\n} //playENCVideo()\n\nencryptVideo() {\n\n}\n\ndecryptVideo() {\n\n}\n} //MyClassActivity\n", "idx": 1768}
{"project": "cipher", "commit_id": "Snippet39194690_21059.java", "target": 1, "func": "public class AES2 {\n    private static final String algo = \"AES/CBC/PKCS5Padding\";\n    private static final byte[] keyValue = \n        new byte[] { 'T', 'h', 'e', 'B', 'e', 's', 't','S', 'e', 'c', 'r','e', 't', 'K', 'e', 'y' };\n\n    public static String encrypt(String Data) throws Exception {\n\n        //KeyGenerator KeyGen = KeyGenerator.getInstance(\"AES\");\n        //KeyGen.init(128);\n\n        //SecretKey SecKey = KeyGen.generateKey();\n        Key key=generateKey();\n\n        //generar IV\n        byte[] iv = new byte[16];\n        SecureRandom random = new SecureRandom();\n        random.nextBytes(iv);\n        IvParameterSpec ivParameterSpec = new IvParameterSpec(iv);\n\n        //cifrar\n        Cipher c = Cipher.getInstance(algo);\n        c.init(Cipher.ENCRYPT_MODE, key, ivParameterSpec);\n\n        byte[] encVal = c.doFinal(Data.getBytes());\n        String encryptedValue = new BASE64Encoder().encode(encVal);\n        return encryptedValue;\n    }\n\n    public static String decrypt(String encryptedData) throws Exception {\n        Key key = generateKey();\n\n        byte[] iv = new byte[16];\n        SecureRandom random = new SecureRandom();\n        random.nextBytes(iv);\n        IvParameterSpec ivParameterSpec = new IvParameterSpec(iv);\n\n        Cipher c = Cipher.getInstance(algo);\n        c.init(Cipher.DECRYPT_MODE, key,ivParameterSpec);\n\n        byte[] decordedValue = new BASE64Decoder().decodeBuffer(encryptedData);\n        byte[] decValue = c.doFinal(decordedValue);\n        String decryptedValue = new String(decValue);\n        return decryptedValue;\n    }\n\n    private static Key generateKey() throws Exception {\n        Key key = new SecretKeySpec(keyValue, \"AES\");\n        return key;\n}\n}\n\nMain class:\n\npublic class aesMain {\n\n    /**\n     * @param args the command line arguments\n     */\n    public static void main(String[] args) throws Exception {\n\n        String texto = \"hola mama\";\n        String encryptedText=AES2.encrypt(texto);\n        String decryptedText=AES2.decrypt(encryptedText);\n\n\n        System.out.println(\"Plain text : \" + texto);\n        System.out.println(\"Encrypted Text : \" + encryptedText);\n        System.out.println(\"Decrypted Text : \" + decryptedText);\n    }\n\n}\n", "idx": 1957}
{"project": "cipher", "commit_id": "Snippet47313892_29303.java", "target": 1, "func": "public static void perturbacaoAES() throws Exception {\n    Security.addProvider(new FlexiCoreProvider());\n\n    Cipher cipher = Cipher.getInstance(\"AES128_CBC\", \"FlexiCore\");\n    KeyGenerator keyGen = KeyGenerator.getInstance(\"AES\", \"FlexiCore\");\n    SecretKey secKey = keyGen.generateKey();\n\n    cipher.init(Cipher.ENCRYPT_MODE, secKey);\n\n    FileInputStream fis = new FileInputStream(\"Zero.txt\");\n    FileOutputStream fos = new FileOutputStream(\"ZeroCifrado.txt\");\n    try (CipherOutputStream cos = new CipherOutputStream(fos, cipher)) {\n        byte[] block = new byte[8];\n        int i;\n        while ((i = fis.read(block)) != -1) {\n            cos.write(block, 0, i);\n        }\n    }\n    fis.close();\n    fos.close();\n\n    byte[] newKey = secKey.getEncoded();\n\n    newKey[0] ^= 1 << 1;\n\n    secKey = new SecretKeySpec(newKey, \"AES128_CBC\");\n\n    cipher.init(Cipher.ENCRYPT_MODE, secKey);\n\n    FileInputStream nfis = new FileInputStream(\"Zero.txt\");\n    FileOutputStream nfos = new FileOutputStream(\"ZeroChaveCifrado.txt\");\n    try (CipherOutputStream cos = new CipherOutputStream(nfos, cipher)) {\n        byte[] block = new byte[8];\n        int i;\n        while ((i = nfis.read(block)) != -1) {\n            cos.write(block, 0, i);\n        }\n    }\n\n}\n", "idx": 2027}
{"project": "cipher", "commit_id": "Snippet37989430_20017.java", "target": 0, "func": "public static void main(String[] args) {\n        String s = \"with the lights out is less dangerous here we are now entertain us\";\n        s = cripta(s);\n        System.out.println(s);\n        s = decripta(s);\n        System.out.println(s);\n    }\n\n    public static String cripta(String s) {\n        System.out.println(\"lunghezza stringa:\" + s.length());\n        byte[] input = s.getBytes();\n        byte[] keyBytes = hexStringToByteArray(\"AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA\");\n        String out = \"\";\n\n        SecretKeySpec key = new SecretKeySpec(keyBytes, \"DESede\");\n        try {\n            Cipher cp = Cipher.getInstance(\"DESede/ECB/PKCS5Padding\");\n            cp.init(Cipher.ENCRYPT_MODE, key);\n            byte[] criptati = cp.doFinal(input);\n            out = new String(Base64.getEncoder().encode(criptati));\n        } catch (NoSuchAlgorithmException e) {\n            e.printStackTrace();\n        } catch (NoSuchPaddingException e) {\n            e.printStackTrace();\n        } catch (InvalidKeyException e) {\n            e.printStackTrace();\n        } catch (IllegalBlockSizeException e) {\n            e.printStackTrace();\n        } catch (BadPaddingException e) {\n            e.printStackTrace();\n        }\n\n        return out;\n    }\n\n    public static String decripta(String s) {\n\n        byte[] input = Base64.getDecoder().decode(s.getBytes());\n        byte[] keyBytes = hexStringToByteArray(\"AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA\");\n        String out = \"\";\n\n        try {\n            SecretKeySpec key = new SecretKeySpec(keyBytes, \"DESede\");\n            Cipher cp = Cipher.getInstance(\"DESede/ECB/NoPadding\");\n            cp.init(Cipher.DECRYPT_MODE, key);\n            byte[] decrypt = cp.doFinal(input);\n            out = new String(decrypt);\n        } catch (NoSuchAlgorithmException | NoSuchPaddingException e) {\n            e.printStackTrace();\n        } catch (InvalidKeyException e) {\n            e.printStackTrace();\n        } catch (IllegalBlockSizeException e) {\n            e.printStackTrace();\n        } catch (BadPaddingException e) {\n            e.printStackTrace();\n        }\n        return out;\n    }\n", "idx": 1737}
{"project": "cipher", "commit_id": "Snippet44059064_26143.java", "target": 0, "func": "    byte[] pt = new byte[16];\n    SecretKeyFactory fact = SecretKeyFactory.getInstance(\"DESede\");\n    Cipher desEDE = Cipher.getInstance(\"DESede/ECB/NoPadding\");\n\n    {\n        // usual 2-key triple DES:\n        byte[] keyData = Hex.decode(\"112233445566778811223344556677881122334455667788\");\n        SecretKey generatedSecret = fact.generateSecret(new SecretKeySpec(keyData, \"DESede\"));\n        desEDE.init(Cipher.ENCRYPT_MODE, generatedSecret);\n        byte[] ct = desEDE.doFinal(pt);\n        System.out.println(Hex.toHexString(ct)); // result: 6FB23EAD0534752B \n    }\n\n    {\n        // \"zero padded\" 2-key triple DES:\n        byte[] keyData = Hex.decode(\"112233445566778811223344556677880000000000000000\");\n        SecretKey generatedSecret = fact.generateSecret(new SecretKeySpec(keyData, \"DESede\"));\n        desEDE.init(Cipher.ENCRYPT_MODE, generatedSecret);\n        byte[] ct = desEDE.doFinal(pt);\n        System.out.println(Hex.toHexString(ct)); // result: 8ca64de9c1b123a7 \n    }\n", "idx": 1795}
{"project": "cipher", "commit_id": "Snippet22231051_4639.java", "target": 0, "func": "public static String encryptString(String password, String source, String fileName, String fileDir) throws NoSuchAlgorithmException, NoSuchPaddingException, InvalidKeyException, FileNotFoundException, IOException {\n    FileOutputStream fos = null;\n    CipherInputStream cis;\n\n    byte key[] = password.getBytes();\n    SecretKeySpec secretKey = new SecretKeySpec(key, \"DES\");\n\n    Cipher encrypt = Cipher.getInstance(\"DES/ECB/PKCS5Padding\");\n    encrypt.init(Cipher.ENCRYPT_MODE, secretKey);\n\n    InputStream fileInputStream = new ByteArrayInputStream(source.getBytes());//Here I am getting file data as byte array. You can convert your file data to InputStream  by other way too.\n\n    File dataFile = new File(fileDir, fileName); //dataDir is location where my file is stored\n    if (!dataFile.exists()) {\n        cis = new CipherInputStream(fileInputStream, encrypt);\n        try {\n            fos = new FileOutputStream(dataFile);\n            byte[] b = new byte[32];\n            int i;\n            while ((i = cis.read(b)) != -1) {\n                fos.write(b, 0, i);\n            }\n            return fileName;\n        } finally {\n            try {\n                if (fos != null) {\n                    fos.flush();\n                    fos.close();\n                }\n                cis.close();\n                fileInputStream.close();\n            } catch (IOException e) {\n                //IOException\n            }\n        }\n    }\n    return \"\";\n}\n", "idx": 1635}
{"project": "cipher", "commit_id": "Snippet19388587_2197.java", "target": 1, "func": "String password = \"secretPassphrase\";  \nString text = \"text to encrypt\";  \nMessageDigest md = MessageDigest.getInstance(\"MD5\");  \nmd.update(password.getBytes(\"UTF-8\"), 0, password.length());  \nbyte[] rawKey = md.digest();  \nbyte[] iv = {0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0};  \nIvParameterSpec ivSpec = new IvParameterSpec(iv);  \nSecretKeySpec skeySpec = new SecretKeySpec(rawKey, \"AES\");  \nCipher cipher = Cipher.getInstance(\"AES/CBC/PKCS5Padding\", \"SunJCE\");  \ncipher.init(Cipher.ENCRYPT_MODE, skeySpec, ivSpec);  \nbyte[] encrypted = cipher.doFinal(text.getBytes(\"UTF-8\"));  \nSystem.out.println(toHex(encrypted));\n", "idx": 2005}
{"project": "cipher", "commit_id": "Snippet39131630_21010.java", "target": 1, "func": "InputStream fileInputStream = getClass().getResourceAsStream(\n                    \"/private.txt\");\n            byte[] bytes = IOUtils.toByteArray(fileInputStream);\n\n\n\nprivate String decrypt(String inputString, byte[] keyBytes) {\n        String resultStr = null;\n        PrivateKey privateKey = null;\n        try {\n            KeyFactory keyFactory = KeyFactory.getInstance(\"RSA\");\n            EncodedKeySpec privateKeySpec = new PKCS8EncodedKeySpec(keyBytes);\n            privateKey = keyFactory.generatePrivate(privateKeySpec);\n        } catch (Exception e) {\n            System.out.println(\"Exception privateKey:::::::::::::::::  \"\n                    + e.getMessage());\n            e.printStackTrace();\n        }\n        byte[] decodedBytes = null;\n        try {\n            Cipher c = Cipher.getInstance(\"RSA/ECB/NoPadding\");\n            c.init(Cipher.DECRYPT_MODE, privateKey);\n            decodedBytes = c.doFinal(Base64.decodeBase64(inputString));\n\n        } catch (Exception e) {\n            System.out\n                    .println(\"Exception while using the cypher:::::::::::::::::  \"\n                            + e.getMessage());\n            e.printStackTrace();\n        }\n        if (decodedBytes != null) {\n            resultStr = new String(decodedBytes);\n            resultStr = resultStr.split(\"MNSadm\")[0];\n            // System.out.println(\"resultStr:::\" + resultStr + \":::::\");\n            // resultStr = resultStr.replace(salt, \"\");\n        }\n        return resultStr;\n\n    }\n", "idx": 2146}
{"project": "cipher", "commit_id": "Snippet8877185_33574.java", "target": 0, "func": "FileInputStream fis = new FileInputStream(new File(\"D:/Shashank/Test123.txt\"));\n        File outfile = new File(\"D:/Shashank/encTest1234.txt\");\n        int read;\n        if(!outfile.exists())\n            outfile.createNewFile();\n        File decfile = new File(\"D:/Shashank/dec123.txt\");\n        if(!decfile.exists())\n            decfile.createNewFile();\n        FileOutputStream fos = new FileOutputStream(outfile);\n        FileInputStream encfis = new FileInputStream(outfile);\n        FileOutputStream decfos = new FileOutputStream(decfile);\n        Cipher encipher = Cipher.getInstance(\"AES\");\n        Cipher decipher = Cipher.getInstance(\"AES\");\n        KeyGenerator kgen = KeyGenerator.getInstance(\"AES\");\n        SecretKey skey = kgen.generateKey();\n        encipher.init(Cipher.ENCRYPT_MODE, skey);\n        CipherInputStream cis = new CipherInputStream(fis, encipher);\n        decipher.init(Cipher.DECRYPT_MODE, skey);\n        CipherOutputStream cos = new CipherOutputStream(decfos,decipher);\n        while((read = cis.read())!=-1)\n                {\n                    fos.write((char)read);\n                    fos.flush();\n                }   \n        fos.close();\n        while((read=encfis.read())!=-1)\n        {\n            cos.write(read);\n            cos.flush();\n        }\n    cos.close();\n", "idx": 1692}
{"project": "cipher", "commit_id": "Snippet34001023_16065.java", "target": 0, "func": "public class Cryptographer {\nprivate static final String ALGORITHM = \"AES\";\n\nprivate final static String ALGO_RANDOM_NUM_GENERATOR = \"SHA1PRNG\";\n\npublic static int encrypt(String key, File inputFile, File outputFile)\n        throws CryptographyException {\n    if(!outputFile.getParentFile().exists())outputFile.getParentFile().mkdir();\n    return StartCryptography(Cipher.ENCRYPT_MODE, key, inputFile, outputFile);\n}\n\npublic static int decrypt(String key, File inputFile, File outputFile)\n        throws CryptographyException {\n    if(!outputFile.getParentFile().exists())outputFile.getParentFile().mkdir();\n    return StartCryptography(Cipher.DECRYPT_MODE, key, inputFile, outputFile);\n}\n\nprivate static int StartCryptography(int cipherMode, String key, File inputFile,\n                                     File outputFile) throws CryptographyException {\n    int performance = -1;\n    try {\n        SecureRandom random = SecureRandom.getInstance(ALGO_RANDOM_NUM_GENERATOR);\n        random.setSeed(key.getBytes());\n        KeyGenerator generator = KeyGenerator.getInstance(ALGORITHM);\n        generator.init(random);\n        SecretKey key1 = generator.generateKey();\n\n        Cipher cipher = Cipher.getInstance(ALGORITHM);\n        cipher.init(cipherMode, key1);\n\n        FileInputStream inputStream = new FileInputStream(inputFile);\n        byte[] inputBytes = new byte[(int) inputFile.length()];\n        inputStream.read(inputBytes);\n\n        byte[] outputBytes = cipher.doFinal(inputBytes);\n\n        FileOutputStream outputStream = new FileOutputStream(outputFile);\n        outputStream.write(outputBytes);\n\n        inputStream.close();\n        outputStream.close();\n        performance = 1;\n\n    } catch (NoSuchPaddingException | NoSuchAlgorithmException\n            | InvalidKeyException | BadPaddingException\n            | IllegalBlockSizeException | IOException ex) {\n        throw new CryptographyException(\"Error encrypting/decrypting file\", ex);\n    } finally {\n        return performance;\n    }\n\n }\n}\n", "idx": 1776}
{"project": "cipher", "commit_id": "Snippet38201687_20172.java", "target": 0, "func": "Cipher cipher = Cipher.getInstance(\"AES/ECB/PKCS7Padding\");\n", "idx": 1722}
{"project": "cipher", "commit_id": "Snippet22908767_5305.java", "target": 1, "func": "import java.io.File;\nimport java.io.FileInputStream;\nimport java.io.FileNotFoundException;\nimport java.io.FileOutputStream;\nimport java.io.IOException;\nimport java.security.InvalidAlgorithmParameterException;\nimport java.security.InvalidKeyException;\nimport java.security.Key;\nimport java.security.NoSuchAlgorithmException;\nimport java.util.Arrays;\nimport java.util.Date;\nimport javax.crypto.Cipher;\nimport javax.crypto.CipherInputStream;\nimport javax.crypto.CipherOutputStream;\nimport javax.crypto.KeyGenerator;\nimport javax.crypto.NoSuchPaddingException;\nimport javax.crypto.spec.IvParameterSpec;\n\n\npublic class AES_Cipher_Test {\n\n\n    public String pLocalRef = \"E:\\\\Test.txt\";\n    public String pLocalRefOutput = \"E:\\\\Test-crypted.txt\";\n    public String pLocalCopyOutput = \"E:\\\\Test-Neu.txt\";\n    public Key pKeyAES = null;\n    public int pBitKey = 128;\n    public Cipher pCipher;  \n    public FileOutputStream pFos;\n    public FileInputStream pFis;\n    public CipherOutputStream pCos;\n    public CipherInputStream pCis;\n    public File pInputFile = new File(this.pLocalRef);\n    public File pOutputFile = new File(this.pLocalRefOutput);\n    public File pGeneratedFile = new File(this.pLocalCopyOutput);\n\n    public AES_Cipher_Test() {\n        crypt_decrypt_write_File();\n    }\n\n    public void crypt_decrypt_write_File() {\n        byte[] lLoadedFile = null;\n        byte[] lGeneratedFileByte = null;\n        try {\n\n            // generate new random AES Key\n            KeyGenerator lKeygen = KeyGenerator.getInstance(\"AES\");\n            lKeygen.init(this.pBitKey);\n            this.pKeyAES = lKeygen.generateKey();\n\n\n            // read input File\n            this.pFis = new FileInputStream(this.pInputFile);\n            FileInputStream tempStream = new FileInputStream(this.pInputFile);\n            int count = 0;\n            while (tempStream.read() != -1){\n                count ++;\n            }\n            lLoadedFile = new byte[count]; // new byte[this.pFis.available()]\n            this.pFis.read(lLoadedFile);\n            System.err.println(\"lLoadedFile.legth  \" + lLoadedFile.length);\n            this.pFis.close();\n\n            //init Cipher with AES Encrypt Mode CFB8 oder CTR\n            this.pCipher = Cipher.getInstance(\"AES/CTR/PKCS5Padding\");\n            this.pCipher.init(Cipher.ENCRYPT_MODE, this.pKeyAES);\n\n\n            // build cipher stream from FileOutputStream\n            this.pFos = new FileOutputStream(this.pOutputFile);\n            this.pCos = new CipherOutputStream(this.pFos, this.pCipher);\n\n            //write encrypted Data to stream\n            this.pCos.write(lLoadedFile);\n            this.pCos.close();\n            this.pFos.close();\n\n            // init Cipher for decrypt Mode\n            this.pCipher.init(Cipher.DECRYPT_MODE, this.pKeyAES, new IvParameterSpec(this.pCipher.getIV()));\n\n\n            // read just written localFile and decrypt\n            this.pFis = new FileInputStream(this.pOutputFile);\n            tempStream = new FileInputStream(this.pOutputFile);\n            count = 0;\n            while (tempStream.read() != -1){\n                count ++;\n            }\n            byte[] lBytes = new byte[count];// new byte[this.pFis.available()]\n            this.pCis = new CipherInputStream(this.pFis, this.pCipher);\n            int lBytesRead = this.pCis.read(lBytes);\n            while (lBytesRead > -1) {\n                lBytesRead = this.pCis.read(lBytes);\n            }\n            this.pCis.close();\n            this.pFis.close();\n            System.err.println(\"lBytes.length \" + lBytes.length);\n\n            // write new not crypted File to see if procedure works\n            this.pFos = new FileOutputStream(this.pLocalCopyOutput);\n            this.pFos.write(lBytes);\n            this.pFos.close();\n\n\n            //compare Input File and Output File\n            this.pFis = new FileInputStream(this.pGeneratedFile);\n            tempStream = new FileInputStream(this.pGeneratedFile);\n            count = 0;\n            while (tempStream.read() != -1){\n                count ++;\n            }\n            lGeneratedFileByte = new byte[count]; // new byte[this.pFis.available()]\n            int i = this.pFis.read(lGeneratedFileByte);\n            this.pFis.close();\n\n            System.err.println(\"lGeneratedFileByte.length \" + i);\n            System.err.println(\"Test if initial File and new File are identical = \" + Arrays.equals(lGeneratedFileByte, lLoadedFile));\n\n\n        } catch (FileNotFoundException e) {\n            throw new RuntimeException(\"FILE_DOES_NOT_EXIST\", e);\n        } catch (NoSuchAlgorithmException e) {\n            // TODO Auto-generated catch block\n            e.printStackTrace();\n        } catch (IOException e) {\n            // TODO Auto-generated catch block\n            e.printStackTrace();\n        } catch (NoSuchPaddingException e) {\n            // TODO Auto-generated catch block\n            e.printStackTrace();\n        } catch (InvalidKeyException e) {\n            // TODO Auto-generated catch block\n            e.printStackTrace();\n        } catch (InvalidAlgorithmParameterException e) {\n            // TODO Auto-generated catch block\n            e.printStackTrace();\n        }\n    }\n\n\n    public static void main(String args[]) {\n        System.err.println(\"Start AES_Cipher_Test\");\n        long start = new Date().getTime();\n        new AES_Cipher_Test();\n        long runningTime = new Date().getTime() - start;\n        System.err.println(\"End AES_Cipher_Test\");\n        System.err.println(\"Runtime: \" + runningTime);\n\n    }\n}\n", "idx": 2028}
{"project": "cipher", "commit_id": "Snippet19596002_2326.java", "target": 0, "func": "public class CryptoTranslator {\nprivate static SecretKey SEC_KEY;\n\n\n\n/**\n * @return the sEC_KEY\n */\npublic static SecretKey getSEC_KEY() {\n    return SEC_KEY;\n}\n\npublic static String getSEC_KEY_String(){\n    return Base64.encodeToString(SEC_KEY.getEncoded(), Base64.DEFAULT);\n}\n\n/**\n * @param sEC_KEY the sEC_KEY to set\n */\npublic static void setSEC_KEY(SecretKey sEC_KEY) {\n    SEC_KEY = sEC_KEY;\n}\n\npublic static void setSEC_KEY_STRING(String sEC_KEY){\n    byte[] key = Base64.decode(sEC_KEY, Base64.DEFAULT);\n    SEC_KEY = new SecretKeySpec(key, 0, key.length, \"AES\");\n}\n\npublic static void generateKey() throws NoSuchAlgorithmException {\n    // Generate a 256-bit key\n    final int outputKeyLength = 256;\n    SecureRandom secureRandom = new SecureRandom();\n    // Do *not* seed secureRandom! Automatically seeded from system entropy.\n    KeyGenerator keyGenerator = KeyGenerator.getInstance(\"AES\");\n    keyGenerator.init(outputKeyLength, secureRandom);\n    SecretKey key = keyGenerator.generateKey();\n    SEC_KEY = key;\n}\n\nprivate static byte[] getRawKey() throws Exception {\n    if (SEC_KEY == null){\n        generateKey();\n    }\n    byte[] raw = SEC_KEY.getEncoded();\n    return raw;\n    }\n\n/**\n * \n * \n * @param clear clear text string\n * @param mode this should either be Cipher.ENCRYPT_MODE or Cipher.DECRYPT_MODE\n * @return\n * @throws Exception\n */\nprivate static String translate(String clear, int mode) throws Exception {\n    if(mode != Cipher.ENCRYPT_MODE && mode != Cipher.DECRYPT_MODE)\n        throw new IllegalArgumentException(\"Encryption invalid. Mode should be either Cipher.ENCRYPT_MODE or Cipher.DECRYPT_MODE\");\n    SecretKeySpec skeySpec = new SecretKeySpec(getRawKey(), \"AES\");\n            Cipher cipher = Cipher.getInstance(\"AES\");\n            cipher.init(mode, skeySpec);\n            byte[] encrypted = cipher.doFinal(clear.getBytes());\n            return new String(encrypted);\n    }\n\npublic static String encrypt(String clear) throws Exception {\n    return translate(clear,Cipher.ENCRYPT_MODE);\n    }\npublic static String decrypt(String encrypted) throws Exception {\n    return translate(encrypted,Cipher.DECRYPT_MODE);\n    }\n\n}\n", "idx": 1810}
{"project": "cipher", "commit_id": "Snippet40915418_22827.java", "target": 1, "func": "public String decryptRSA(String text)\n{\n    try {\n        final Cipher cipher = Cipher.getInstance(\"RSA/ECB/PKCS1Padding\");\n        cipher.init(Cipher.DECRYPT_MODE, privateKey);\n\n        byte[] dec = Base64.decodeBase64(text);\n        byte[] utf8 = cipher.doFinal(dec);\n\n        return Base64.encodeBase64String(utf8);\n    }\n    catch (Exception ex) {\n        ex.printStackTrace();\n    }\n\n    return null;\n}\n", "idx": 2347}
{"project": "cipher", "commit_id": "Snippet10128261_34473.java", "target": 1, "func": "Cipher cipherDec = Cipher.getInstance(\"RSA/ECB/PKCS1Padding\");\ncipherDec.init(Cipher.DECRYPT_MODE, key.getPrivate());\nbyte[] decodedText = new BASE64Decoder().decodeBuffer(encodedText);\nbyte[] decryptedText = cipherDec.doFinal(decodedText);\nString finalValue = new String(decryptedText, \"UTF-8\");\n", "idx": 2290}
{"project": "cipher", "commit_id": "Snippet521101_29713.java", "target": 1, "func": "// Generate new key\nKeyPair keyPair = KeyPairGenerator.getInstance(\"RSA\").generateKeyPair();\nPrivateKey privateKey = keyPair.getPrivate();\nString plaintext = \"This is the message being signed\";\n\n// Compute signature\nSignature instance = Signature.getInstance(\"SHA1withRSA\");\ninstance.initSign(privateKey);\ninstance.update((plaintext).getBytes());\nbyte[] signature = instance.sign();\n\n// Compute digest\nMessageDigest sha1 = MessageDigest.getInstance(\"SHA1\");\nbyte[] digest = sha1.digest((plaintext).getBytes());\n\n// Encrypt digest\nCipher cipher = Cipher.getInstance(\"RSA\");\ncipher.init(Cipher.ENCRYPT_MODE, privateKey);\nbyte[] cipherText = cipher.doFinal(digest);\n\n// Display results\nSystem.out.println(\"Input data: \" + plaintext);\nSystem.out.println(\"Digest: \" + bytes2String(digest));\nSystem.out.println(\"Cipher text: \" + bytes2String(cipherText));\nSystem.out.println(\"Signature: \" + bytes2String(signature));\n", "idx": 2024}
{"project": "cipher", "commit_id": "Snippet39701301_21608.java", "target": 0, "func": "package aes;\n\nimport java.security.*;\nimport java.security.spec.InvalidKeySpecException;\nimport javax.crypto.*;\nimport javax.crypto.spec.SecretKeySpec;\nimport sun.misc.*;\n\npublic class AESencrp {\n\n     private static final String ALGO = \"AES\";\n    private static final byte[] keyValue = \n        new byte[] { 'T', 'h', 'e', 'B', 'e', 's', 't', 'S', 'e', 'c', 'r','e', 't', 'K', 'e', 'y' };\n\npublic static String encrypt(String Data) throws Exception {\n        Key key = generateKey();\n        Cipher c = Cipher.getInstance(ALGO);\n        c.init(Cipher.ENCRYPT_MODE, key);\n        byte[] encVal = c.doFinal(Data.getBytes());\n\n\n        // Encryption:\n\n        String encryptedValue = new BASE64Encoder().encode(encVal);\n        return encryptedValue;\n    }\n\n    public static String decrypt(String encryptedData) throws Exception {\n        Key key = generateKey();\n        Cipher c = Cipher.getInstance(ALGO);\n        c.init(Cipher.DECRYPT_MODE, key);\n        byte[] decordedValue = new BASE64Decoder().decodeBuffer(encryptedData);\n        byte[] decValue = c.doFinal(decordedValue);\n        String decryptedValue = new String(decValue);\n        return decryptedValue;\n    }\n    private static Key generateKey() throws Exception {\n        Key key = new SecretKeySpec(keyValue, ALGO);\n        return key;\n} }\n", "idx": 1715}
{"project": "cipher", "commit_id": "Snippet21495944_3986.java", "target": 1, "func": "    final EditText productid = (EditText) findViewById(R.id.editText1);\n    Button encryptButton = (Button) findViewById(R.id.encrypt);\n    final TextView value = (TextView) findViewById(R.id.value);\n    encryptButton.setOnClickListener(new OnClickListener() {\n\n        @Override\n        public void onClick(View v) {\n\n            String valid_productid = productid.getText().toString();\n            ivspec = new IvParameterSpec(iv.getBytes());\n\n            keyspec = new SecretKeySpec(SecretKey.getBytes(), \"AES\");\n\n            try {\n                    cipher = Cipher.getInstance(\"AES/CBC/NoPadding\");\n                    //encrypt(valid_productid);\n\n                    byte[] cipher = encrypt(valid_productid);\n\n                    System.out.print(\"cipher:  \");\n                    for (int i=0; i<cipher.length; i++)\n                      System.out.print(new Integer(cipher[i])+\" \");\n                      System.out.println(\"\");\n                      System.out.println(cipher);\n\n                      /*String decrypted = decrypt(cipher);\n                      System.out.println(\"decrypt: \" + decrypted);\n                          value.setText(cipher);*/\n\n            } catch (NoSuchAlgorithmException e) {\n                    // TODO Auto-generated catch block\n                    e.printStackTrace();\n            } catch (NoSuchPaddingException e) {\n                    // TODO Auto-generated catch block\n                    e.printStackTrace();\n            } catch (Exception e) {\n                // TODO Auto-generated catch block\n                e.printStackTrace();\n            }\n        }\n    });  \npublic byte[] encrypt(String text) throws Exception\n{\n        if(text == null || text.length() == 0)\n                throw new Exception(\"Empty string\");\n\n        byte[] encrypted = null;\n\n        try {\n                cipher.init(Cipher.ENCRYPT_MODE, keyspec, ivspec);\n\n                encrypted = cipher.doFinal(padString(text).getBytes());\n        } catch (Exception e)\n        {                       \n                throw new Exception(\"[encrypt] \" + e.getMessage());\n        }\n\n        return encrypted;\n}\n\npublic byte[] decrypt(String code) throws Exception\n{\n        if(code == null || code.length() == 0)\n                throw new Exception(\"Empty string\");\n\n        byte[] decrypted = null;\n\n        try {\n                cipher.init(Cipher.DECRYPT_MODE, keyspec, ivspec);\n\n                decrypted = cipher.doFinal(hexToBytes(code));\n        } catch (Exception e)\n        {\n                throw new Exception(\"[decrypt] \" + e.getMessage());\n        }\n        return decrypted;\n}\n\n\n\npublic static String bytesToHex(byte[] data)\n{\n        if (data==null)\n        {\n                return null;\n        }\n\n        int len = data.length;\n        String str = \"\";\n        for (int i=0; i<len; i++) {\n                if ((data[i]&0xFF)<16)\n                        str = str + \"0\" + java.lang.Integer.toHexString(data[i]&0xFF);\n                else\n                        str = str + java.lang.Integer.toHexString(data[i]&0xFF);\n        }\n        return str;\n}\n\n\npublic static byte[] hexToBytes(String str) {\n        if (str==null) {\n                return null;\n        } else if (str.length() < 2) {\n                return null;\n        } else {\n                int len = str.length() / 2;\n                byte[] buffer = new byte[len];\n                for (int i=0; i<len; i++) {\n                        buffer[i] = (byte) Integer.parseInt(str.substring(i*2,i*2+2),16);\n                }\n                return buffer;\n        }\n}\n\n\n\nprivate static String padString(String source)\n{\n  char paddingChar = ' ';\n  int size = 16;\n  int x = source.length() % size;\n  int padLength = size - x;\n\n  for (int i = 0; i < padLength; i++)\n  {\n          source += paddingChar;\n  }\n\n  return source;\n}\n", "idx": 2171}
{"project": "cipher", "commit_id": "Snippet35357244_17281.java", "target": 1, "func": "private byte[] generateIv(int size) {\n    byte[] iv = new byte[size];\n    randomSecureRandom.nextBytes(iv);\n    return iv;\n}\n\n@Override\npublic byte[] encryptData(byte[] iv, byte[] in, Key key) throws CryptoException {\n    try {\n        Cipher c = Cipher.getInstance(\"AES/CTR/PKCS5Padding\");\n        c.init(Cipher.ENCRYPT_MODE, key, new IvParameterSpec(iv));\n        return c.doFinal(in);\n    } catch (Exception ex) {\n        throw new CryptoException(ex);\n    }\n}\n\n@Override\npublic byte[] decryptData(byte[] iv, byte[] in, Key key) throws CryptoException {\n    try {\n        Cipher c = Cipher.getInstance(\"AES/CTR/PKCS5Padding\");\n        c.init(Cipher.DECRYPT_MODE,key, new IvParameterSpec(iv));\n        return c.doFinal(in);\n    } catch(Exception ex) {\n        throw new CryptoException(ex);\n    }\n}\n\n@Override\npublic byte[] createHMAC(byte[] pauload, Key sigKey) throws CryptoException {\n    try {\n        Mac mac = Mac.getInstance(\"HMACSHA256\");  \n        mac.init(sigKey);\n        byte[] digest = mac.doFinal(pauload);\n        return digest;\n    } catch (Exception e) {\n        throw new CryptoException(\"unable to create HMAC\",e);\n    }\n}\n", "idx": 2278}
{"project": "cipher", "commit_id": "Snippet39979158_21908.java", "target": 1, "func": "Cipher c = Cipher.getInstance(\"PBEWithHmacSHA256AndAES_128\");\nc.init(Cipher.ENCRYPT_MODE, secretKey);\n", "idx": 2260}
{"project": "cipher", "commit_id": "Snippet13493364_37039.java", "target": 1, "func": "        byte[] encoded = {(byte) 0xA9, (byte) 0x9B, (byte) 0xC8, (byte) 0x32, (byte) 0x56, (byte) 0x35, (byte) 0xE3, (byte) 0x03,\n                (byte) 0xA9, (byte) 0x9B, (byte) 0xC8, (byte) 0x32, (byte) 0x56, (byte) 0x35, (byte) 0xE3, (byte) 0x03};\n        SecretKeySpec secretKeySpec = new SecretKeySpec(encoded, \"AES\");\n\n        Cipher c = Cipher.getInstance(\"AES/CBC/PKCS5Padding\");//AES/CBC/PKCS5Padding\n        System.out.println(\"swapnil:\"+c.getAlgorithm()+\" BlockSize:\"+c.getBlockSize());\n            c.init(Cipher.ENCRYPT_MODE, secretKeySpec);\n            byte[] input = \"Hello\".getBytes();\n            byte[] output = c.doFinal(input);\n            System.out.println(\"Swapnil: \" + new String(output));\n", "idx": 2325}
{"project": "cipher", "commit_id": "Snippet20554389_3149.java", "target": 1, "func": "    public static byte[] RSADecrypt(final byte[] encryptedBytes)\n        throws NoSuchAlgorithmException, NoSuchPaddingException,\n        InvalidKeyException, IllegalBlockSizeException, BadPaddingException {\n\n    Cipher cipher1 = Cipher.getInstance(\"RSA\");\n\n    System.out.println(\"RSA Encryption key: \" + privateKey.getAlgorithm());\n    System.out.println(\"RSA Encryption key: \" + privateKey.getEncoded());\n\n    cipher1.init(Cipher.DECRYPT_MODE, privateKey);\n    byte[] decryptedBytes = cipher1.doFinal(encryptedBytes);\n    return decryptedBytes;\n}\n", "idx": 2087}
{"project": "cipher", "commit_id": "Snippet36305043_18158.java", "target": 1, "func": " public void decryptString(String alias) \n {\n     try\n    {\n        KeyStore.PrivateKeyEntry privateKeyEntry = (KeyStore.PrivateKeyEntry)keyStore.getEntry(alias, null);\n        RSAPrivateKey privateKey = (RSAPrivateKey) privateKeyEntry.getPrivateKey();\n\n        Cipher output = Cipher.getInstance(\"RSA/ECB/PKCS1Padding\", \"AndroidOpenSSL\");\n        output.init(Cipher.DECRYPT_MODE, privateKey);\n\n        String cipherText = encryptedText.getText().toString();\n        CipherInputStream cipherInputStream = new CipherInputStream(new ByteArrayInputStream(Base64.decode(cipherText, Base64.DEFAULT)), output);\n        ArrayList<Byte> values = new ArrayList<>();\n        int nextByte;\n        while ((nextByte = cipherInputStream.read()) != -1) {\n            values.add((byte)nextByte);\n        }\n\n        byte[] bytes = new byte[values.size()];\n        for(int i = 0; i < bytes.length; i++) {\n            bytes[i] = values.get(i).byteValue();\n        }\n\n        String finalText = new String(bytes, 0, bytes.length, \"UTF-8\");\n        decryptedText.setText(finalText);\n\n    } \n    catch (Exception e) {\n        Toast.makeText(this, \"Exception \" + e.getMessage() + \" occured\", Toast.LENGTH_LONG).show();\n        Log.e(TAG, Log.getStackTraceString(e));\n    }\n}\n", "idx": 2210}
{"project": "cipher", "commit_id": "Snippet1009996_29850.java", "target": 0, "func": "import java.util.Random;\nimport javax.crypto.Cipher;\nimport javax.crypto.SecretKey;\nimport javax.crypto.SecretKeyFactory;\nimport javax.crypto.spec.PBEKeySpec;\nimport javax.crypto.spec.PBEParameterSpec;\n\n...\n\nbyte[] salt = new byte[8];\nRandom rand = new Random();\nrand.nextBytes(salt);\n\nPBEKeySpec keySpec = new PBEKeySpec(password.toCharArray());\nSecretKeyFactory keyFactory = SecretKeyFactory.getInstance(\"PBEWithSHAAndTwofish-CBC\");\nSecretKey key = keyFactory.generateSecret(keySpec);\nPBEParameterSpec paramSpec = new PBEParameterSpec(salt, 1000);\n\nCipher cipher = Cipher.getInstance(\"PBEWithSHAAndTwofish-CBC\");\ncipher.init(Cipher.ENCRYPT_MODE, key, paramSpec);\nbyte[] ciphertext = cipher.doFinal(plaintext);\n", "idx": 1789}
{"project": "cipher", "commit_id": "Snippet16205076_39168.java", "target": 1, "func": "Cipher.getInstance(\"RSA/ECB/PKCS1Padding\")", "idx": 2248}
{"project": "cipher", "commit_id": "Snippet43141905_25270.java", "target": 1, "func": "public static byte[] encryptWithRSA(byte[] data,PublicKey clientKey) throws Exception {\n    byte[] cipherText = null;\n    try {\n        System.out.println(\"Start encryptWithRSA \");\n        Cipher encrypt = Cipher.getInstance(\"RSA/ECB/NoPadding\", \"BC\");\n        encrypt.init(Cipher.ENCRYPT_MODE, clientKey);\n        cipherText = encrypt.doFinal(data); \n    } catch (Exception ex) {\n        System.err.println(ex.getMessage);\n        throw ex;\n    }\n    return cipherText;\n}\n\npublic static byte[] decryptWithRSA(byte[] encryptedMessage,PrivateKey serverKey) throws Exception {\n    byte[] decryptedMessage = null;\n    try {\n        System.out.println(\"Start decryptWithRSA \");\n        Cipher decrypt = Cipher.getInstance(\"RSA/ECB/NoPadding\", \"BC\");\n        decrypt.init(Cipher.DECRYPT_MODE, serverKey);\n        decryptedMessage = decrypt.doFinal(encryptedMessage);\n    } catch (Exception ex) {\n        System.err.println(ex.getMessage);\n        throw ex;\n    }\n    return decryptedMessage;\n}\n", "idx": 2093}
{"project": "cipher", "commit_id": "Snippet10562577_34895.java", "target": 0, "func": "  public static byte[] decrypted_Data(byte[] crypt) throws Exception {\n\n  String seed = \"SuperSecretPassword\";\n\n  KeyGenerator keygen = KeyGenerator.getInstance(\"AES\");\n\n  SecureRandom secrand = SecureRandom.getInstance(\"SHA1PRNG\");\n\n  secrand.setSeed(seed.getBytes());\n\n  keygen.init(128, secrand);\n\n  SecretKey seckey = keygen.generateKey();\n\n  byte[] rawKey = seckey.getEncoded();\n\n SecretKeySpec skeySpec = new SecretKeySpec(rawKey, \"AES\");\n\n Cipher cipher = Cipher.getInstance(\"AES\");\n\n cipher.init(Cipher.DECRYPT_MODE, skeySpec);\n\n byte[] decrypted = cipher.doFinal(crypt);\n\n  return decrypted;\n}\n", "idx": 1678}
{"project": "cipher", "commit_id": "Snippet21232312_3755.java", "target": 1, "func": "Security.addProvider(new BouncyCastleProvider());\n\n    KeyPairGenerator kpg = (KeyPairGenerator) KeyPairGenerator.getInstance(\"ECIES\", \"BC\");\n\n    kpg.initialize(192, new SecureRandom());\n\n    KeyPair keyPair = kpg.generateKeyPair();\n    PublicKey pubKey = keyPair.getPublic();\n    PrivateKey privKey = keyPair.getPrivate();\n\n    byte[] d = new byte[]{1, 2, 3, 4, 5, 6, 7, 8}; // 1. can someone tell me what this parameters does?\n    byte[] e = new byte[]{8, 7, 6, 5, 4, 3, 2, 1};\n\n    IESParameterSpec param = new IESParameterSpec(d, e, 192); // 2. and this parameters?\n    IEKeySpec c1Key = new IEKeySpec(privKey, pubKey);\n    System.out.println(c1Key.getPublic());\n\n    Cipher cipher = Cipher.getInstance(\"ECIES\", \"BC\");\n    cipher.init(Cipher.ENCRYPT_MODE, c1Key, param);\n    System.out.println(cipher.doFinal(\"test12345678900987654321\".getBytes()));\n", "idx": 1976}
{"project": "cipher", "commit_id": "Snippet44640282_26760.java", "target": 0, "func": "// defined outside the below method; this algorithm works:\nprivate static String ALGORITHM = \"PBEWITHSHA1ANDDESEDE\";\n\n// the new version, which fails:\n//private static String ALGORITHM = \"PBEWithHmacSHA512AndAES_128\";\n\nprivate static Cipher getCipher(int mode, String password) throws NoSuchAlgorithmException, InvalidKeySpecException,\n    NoSuchPaddingException, InvalidKeyException, InvalidAlgorithmParameterException {\n\n    // Create secret key using password\n    PBEKeySpec pbeKeySpec = new PBEKeySpec(password.toCharArray());\n    SecretKeyFactory secretKeyFactory = SecretKeyFactory.getInstance(ALGORITHM);\n    SecretKey secretKey = secretKeyFactory.generateSecret(pbeKeySpec);\n\n    // Create the cipher\n    byte[] salt = new byte[SALT_SIZE];\n    salt = password.getBytes();\n\n    PBEParameterSpec pbeParameterSpec = new PBEParameterSpec(salt, PBEPARAMETERSPEC_ITERATION_COUNT);\n    Cipher cipher = Cipher.getInstance(ALGORITHM);\n\n    // this original line causes crash with the new algorithm, reporting:\n    // Exception in thread \"main\" java.security.InvalidAlgorithmParameterException: Missing parameter type: IV expected\n    // solved as per this S.O. post:\n    // https://stackoverflow.com/questions/29215274/how-do-i-properly-use-the-pbewithhmacsha512andaes-256-algorithm\n    cipher.init(mode, secretKey, pbeParameterSpec);\n\n    // this new line causes the encryption/decryption to apparently fail, giving results that look like this:\n    // \ufffd0\ufffd.\ufffd\ufffd\ufffd\ufffd\ufffdj\ufffd\"\ufffd\ufffd\u06d7P#o\u02fe\ufffd\ufffd\ufffdIYc\ufffd \ufffdwe\ufffd\ufffd\ufffd\ufffd)\ufffdTq(f\ufffdC\ufffd\ufffd\ufffd.\ufffd\ufffdnjDt\ufffd.pG\ufffd\ufffd\n    //cipher.init(mode, secretKey, cipher.getParameters());\n    return cipher;\n}\n", "idx": 1647}
{"project": "cipher", "commit_id": "Snippet43076644_25183.java", "target": 0, "func": "public String decodeInputString(String inputString) throws NoSuchAlgorithmException, InvalidKeyException, IllegalBlockSizeException, BadPaddingException, NoSuchPaddingException {\n        byte[] salt = \"MyKey\".getBytes();\n        SecretKey secretKey = new SecretKeySpec(salt, 0, 16, \"AES\");\n        byte[] encryptedTextByte = Base64.decode(inputString);\n        cipher = Cipher.getInstance(\"AES\");\n        cipher.init(Cipher.DECRYPT_MODE, secretKey);\n        byte[] decryptedByte = cipher.doFinal(encryptedTextByte);\n        String decryptedText = new String(decryptedByte);\n        return decryptedText;\n\n}\n", "idx": 1822}
{"project": "cipher", "commit_id": "Snippet37966464_19996.java", "target": 0, "func": "try {\n    String key = Password.getText();\n\n    if (key.length() < 8 || key.length() > 8 || !key.equals(\"Password\")) {\n\n        JOptionPane.showMessageDialog(null, \"Not a valid key\");\n\n    } else {\n\n        DESKeySpec dks = new DESKeySpec(key.getBytes());\n        SecretKeyFactory skf = SecretKeyFactory.getInstance(\"DES\");\n        SecretKey desKey = skf.generateSecret(dks);\n\n        AlgorithmParameterSpec paramSpec = new IvParameterSpec(iv);\n\n        Code.dcipher = Cipher.getInstance(\"DES/CBC/PKCS5Padding\");\n\n        Code.dcipher.init(Cipher.DECRYPT_MODE, desKey, paramSpec);\n\n        Code.decrypt(new FileInputStream(\"encrypted.txt\"),\n                new FileOutputStream(\"cleartext-reversed.txt\"));\n\n        BufferedReader br = new BufferedReader(new FileReader(\n                \"cleartext-reversed.txt\"));\n        try {\n            StringBuilder sb = new StringBuilder();\n            String line = br.readLine();\n\n            while (line != null) {\n                sb.append(line);\n                line = br.readLine();\n            }\n            String decrypted = sb.toString();\n            DisplayArea2.setText(decrypted);\n        } catch (IOException ex) {\n            Logger.getLogger(MainApp.class.getName()).log(Level.SEVERE,\n                    null, ex);\n        } finally {\n            try {\n                br.close();\n            } catch (IOException ex) {\n                Logger.getLogger(MainApp.class.getName()).log(\n                        Level.SEVERE, null, ex);\n            }\n        }\n\n    }\n\n} catch (InvalidKeyException | NoSuchAlgorithmException\n        | InvalidKeySpecException | NoSuchPaddingException\n        | InvalidAlgorithmParameterException | FileNotFoundException ex) {\n    Logger.getLogger(MainApp.class.getName()).log(Level.SEVERE, null,\n            ex);\n}\n", "idx": 1791}
{"project": "cipher", "commit_id": "Snippet10228138_34573.java", "target": 0, "func": "import java.io.FileInputStream;\nimport java.io.FileOutputStream;\nimport java.io.InputStream;\nimport java.io.OutputStream;\nimport javax.crypto.Cipher;\nimport javax.crypto.CipherInputStream;\nimport javax.crypto.SecretKey;\nimport javax.crypto.spec.SecretKeySpec;\n\npublic class AESDecrypter\n{\n        Cipher dcipher;\n\n        public AESDecrypter(SecretKey key)\n        {\n\n                try\n                {\n                        dcipher = Cipher.getInstance(\"AES\");\n                        dcipher.init(Cipher.DECRYPT_MODE, key);\n                }\n                catch (Exception e)\n                {\n                        e.printStackTrace();\n                }\n        }\n\n        byte[] buf = new byte[1024];\n\n        public void decrypt(InputStream in, OutputStream out)\n        {\n            System.out.println(\"decrypting\");\n            try\n                {\n                        in = new CipherInputStream(in, dcipher);\n                        int numRead = 0;\n                        while ((numRead = in.read(buf)) >= 0)\n                        {\n                                out.write(buf, 0, numRead);\n                        }\n                        out.close();\n                }\n                catch (java.io.IOException e)\n                {\n                }\n        }\n\n        public static void main(String args[])\n        {\n                try\n                {\n                        byte[] keystr ={(byte) 0x12,(byte) 0x34,0x55,(byte) 0x66,0x67,(byte)0x88,(byte)0x90,0x12,(byte) 0x23,0x45,0x67,(byte)0x89,0x12,0x33,(byte) 0x55,0x74};\n                        SecretKeySpec sks = new SecretKeySpec(keystr,\"AES\");                        \n                        AESDecrypter encrypter = new AESDecrypter(sks);\n                        encrypter.decrypt(new FileInputStream(\"sqllogenc.log\"),new FileOutputStream(\"sqllogdec.log\"));\n                }\n                catch (Exception e)\n                {\n                        e.printStackTrace();\n                }\n        }\n}\n", "idx": 1774}
{"project": "cipher", "commit_id": "Snippet26614822_8742.java", "target": 0, "func": "    public void send( OutputStream op, \n                        FileInputStream filetoprocess, \n                        long l) throws Throwable\n{\n\n    byte[] inputBytes = new byte[(int) l];\n    int iRead = filetoprocess.read(inputBytes);\n    if (iRead != l)\n    {\n        System.out.println(\"Read error.\");\n        return;\n    }\n    byte[] ivBytes = \"1234567812345678\".getBytes();\n    DESKeySpec desKeySpec = new DESKeySpec(ivBytes);\n    SecretKeyFactory keyFactory = SecretKeyFactory.getInstance(\"DES\");\n    SecretKey sKey = keyFactory.generateSecret(desKeySpec);\n    Cipher ecipher = Cipher.getInstance(\"DES\");\n    ecipher.init(Cipher.ENCRYPT_MODE, sKey);\n    byte[] outputBytes = ecipher.doFinal(inputBytes);\n\n    // Send the file's size, 4 bytes.\n    // Use an 8 byte buffer to send big files > 2GB.\n    byte[] fileSize = new byte[4];\n    fileSize[0] = (byte) ((iRead & 0xff000000) >> 24);\n    fileSize[1] = (byte) ((iRead & 0x00ff0000) >> 16);\n    fileSize[2] = (byte) ((iRead & 0x0000ff00) >>  8);\n    fileSize[3] = (byte)  (iRead & 0x000000ff);\n    op.write(fileSize, 0, 4);\n\n    // Now send the file's data\n    op.write(outputBytes);\n    op.flush();\n\n    System.out.println(\"File sent\");\n\n}\n\npublic static void receive(\n                    InputStream ip, \n                    File fname, \n                    PrintWriter output2) throws Throwable\n{\n\n    byte[] ivBytes = \"1234567812345678\".getBytes();\n\n    DESKeySpec desKeySpec = new DESKeySpec(ivBytes);\n    SecretKeyFactory keyFactory = SecretKeyFactory.getInstance(\"DES\");\n    SecretKey sKey = keyFactory.generateSecret(desKeySpec);\n\n    Cipher dcipher = Cipher.getInstance(\"DES\");\n    dcipher.init(Cipher.DECRYPT_MODE, sKey);\n\n    ByteArrayOutputStream out = new ByteArrayOutputStream();\n\n    // Receive the file's size first  \n    byte[] bSize = new byte[4];\n    ip.read(bSize, 0, 4);\n    int fileSize=0;\n    fileSize = (int) (bSize[0]) << 24 | (int) (bSize[1]) << 16 | \n               (int) (bSize[2]) << 8 | (int) (bSize[3]);\n\n    // use a 4 or 8K buffer for better performance\n    byte[] buffer = new byte[8*1024];\n    int length;\n\n    // Read up to the file size\n    while (fileSize > 0)\n    {\n        if (fileSize > buffer.length) length=buffer.length;\n        else length=fileSize;\n        int iRead = ip.read(buffer, 0, length);\n        if (iRead > 0) \n        {\n            out.write(buffer, 0, iRead);\n            fileSize -= iRead;              \n        }\n    }\n\n    byte[] result = out.toByteArray();\n\n    byte[] outputBytes = dcipher.doFinal(result);\n\n    FileOutputStream outputStream = new FileOutputStream(fname);\n    outputStream.write(outputBytes);\n    outputStream.close();\n\n    System.out.println(\"File received\");\n\n}\n", "idx": 1592}
{"project": "cipher", "commit_id": "Snippet17042590_331.java", "target": 1, "func": " Cipher cipher = Cipher.getInstance(\"AES/CBC/NoPadding\");\n String keyString = \"keykeykeykeykeykeykeykey\";\n byte[] keyBytes = keyString.getBytes(\"UTF-8\"); \ncipher.init(Cipher.ENCRYPT_MODE, new SecretKeySpec(keyBytes, \"AES\"), new IvParameterSpec(new byte[16])); \nbyte[] resultBytes = cipher.doFinal(\"Hallo Welt!\".getBytes(\"UTF8\")); \nFileOutputStream out = new FileOutputStream(new File(\"encryptedFileJava\")); \nout.write(resultBytes); out.close();\n", "idx": 2015}
{"project": "cipher", "commit_id": "Snippet45859052_27936.java", "target": 0, "func": "try\n        {\n            byte[] PinBytes = Base64.decodeBase64(encryptedText);\n            byte[] VectorBytes = Base64.decodeBase64(vectorKey);\n            byte[] SecretKeyBytes = Base64.decodeBase64(secretKey);\n         // initialize the vector with the one you receive               \n            IvParameterSpec spec = new IvParameterSpec(VectorBytes);\n\n            // create the key. DESede should be correct, but if it doesn't work try also with DES\n            Key key = new SecretKeySpec(SecretKeyBytes, \"DESede\");\n\n            // Initialize the cipher\n            Cipher c = Cipher.getInstance(\"DESede/CBC/PKCS5Padding\");\n\n            // decrypt the string\n            c.init(Cipher.DECRYPT_MODE, key, spec);\n            byte[] decodedDecryptedBytes = c.doFinal(PinBytes);\n            return new String(decodedDecryptedBytes, \"UTF-8\");      \n        }\n        catch (java.security.InvalidAlgorithmParameterException e) { System.out.println(\"Invalid Algorithm\"); }\n        catch (javax.crypto.NoSuchPaddingException e) { System.out.println(\"No Such Padding\"); }\n        catch (java.security.NoSuchAlgorithmException e) { System.out.println(\"No Such Algorithm\"); }\n        catch (java.security.InvalidKeyException e) { System.out.println(\"InvalidKeyException : Invalid Key\"); }\n        catch (BadPaddingException e) { System.out.println(\"BadPaddingException : Invalid Key\");}\n        catch (IllegalBlockSizeException e) { System.out.println(\"IllegalBlockSizeException : Invalid Key\");}\n        catch (UnsupportedEncodingException e) { System.out.println(\"UnsupportedEncodingException : Invalid Key\");}     \n        catch (IOException e) {\n            // TODO Auto-generated catch block\n            e.printStackTrace();\n        }\n        return null;\n", "idx": 1620}
{"project": "cipher", "commit_id": "Snippet27798812_9975.java", "target": 0, "func": "private static final String PASSWORD = \"46dkaKLKKJLjdkdk;akdjafj\";\n\nprivate static final byte[] SALT = { 0x26, 0x19, (byte) 0x81, 0x4E,\n        (byte) 0xA0, 0x6D, (byte) 0x95, 0x34 };\n\npublic static void main(String[] args) throws Exception {\n    final Cipher desEDE = Cipher.getInstance(\"DESede/CBC/PKCS5Padding\");\n\n    final PasswordDeriveBytes myPass = new PasswordDeriveBytes(PASSWORD, SALT);\n    final SecretKeyFactory kf = SecretKeyFactory.getInstance(\"DESede\");\n    final byte[] key = myPass.getBytes(192 / Byte.SIZE);\n    final SecretKey desEDEKey = kf.generateSecret(new DESedeKeySpec(key));\n\n    final byte[] iv = myPass.getBytes(desEDE.getBlockSize());\n\n    desEDE.init(Cipher.ENCRYPT_MODE, desEDEKey, new IvParameterSpec(iv));\n\n    final byte[] ct = desEDE.doFinal(\"owlstead\".getBytes(US_ASCII));\n}\n", "idx": 1847}
{"project": "cipher", "commit_id": "Snippet40446130_22312.java", "target": 1, "func": "package Encriptacion;\nimport javax.crypto.*;\nimport java.io.*;\nimport java.nio.*;\nimport java.nio.channels.*;\nimport javax.crypto.spec.*;\npublic class EncriptadorAES {\n    private SecretKey CLAVESECRETA=null;\n    private final int AES_KEYLENGTH = 128;\n    private IvParameterSpec IV=null;\n    public EncriptadorAES() throws Exception{\n        //generarIV();\n        if(new File(\"initvectoraes.iv\").exists()){\n            this.IV=new IvParameterSpec(obtenerIV());\n        }\n    }\n    public void setCLAVESECRETA(String clave){\n        this.CLAVESECRETA=generarClaveSecreta(clave);\n    }\n    public void guardarClave(String clave,String ruta)throws Exception{\n        try{\n            byte[]bytesClave=generarClaveSecreta(clave).getEncoded();\n            FileChannel canalSalida=new RandomAccessFile(new File(ruta), \"rw\").getChannel();\n            ByteBuffer bufferSalida=ByteBuffer.wrap(bytesClave);\n            canalSalida.write(bufferSalida);\n            canalSalida.close();\n        }catch(Exception ex){\n            throw new Exception(\"No se pudo guardar la clave\\n\"+ex);\n        }\n    }\n    public SecretKey cargarClave(String ruta)throws Exception{\n        try{\n            File archivo=new File(ruta);\n            byte[]bytesClave=new byte[(int)archivo.length()];\n            FileChannel canalEntrada=new RandomAccessFile(archivo, \"r\").getChannel();\n            ByteBuffer bufferEntrada=ByteBuffer.allocate(bytesClave.length);\n            canalEntrada.read(bufferEntrada);\n            bufferEntrada.flip();\n            bufferEntrada.get(bytesClave);\n            canalEntrada.close();\n            return new SecretKeySpec(bytesClave, \"AES\");\n        }catch(Exception ex){\n            throw new Exception(\"No se pudo cargar la clave secreta\\n\"+ex);\n        }\n    }\n    public void encriptarArchivo(String ruta,SecretKey clave) throws Exception{\n        File archivo=null;\n        try {\n            archivo=new File(ruta);\n            if(archivo.isFile()&&archivo.exists()&&archivo.length()<=700248752){\n                //LECTURA\n                byte[] bytesArchivo=new byte[(int)archivo.length()];\n                int tama\u00f1oBloque=AES_KEYLENGTH/8;\n                int numBloques=((int)archivo.length()%tama\u00f1oBloque==0)?(int)archivo.length()/tama\u00f1oBloque:((int)archivo.length()/tama\u00f1oBloque)+1;\n                int tama\u00f1oEncriptado=((bytesArchivo.length/tama\u00f1oBloque)+1)*tama\u00f1oBloque;\n                FileChannel canalEntrada=new RandomAccessFile(archivo, \"r\").getChannel();\n                ByteBuffer bufferEntrada=ByteBuffer.allocate((int)archivo.length());\n                canalEntrada.read(bufferEntrada);\n                bufferEntrada.flip();\n                bufferEntrada.get(bytesArchivo);\n                canalEntrada.close();\n                //CIFRADO clave sim\u00e9trica\n                ByteBuffer bufferSalida=ByteBuffer.allocate(tama\u00f1oEncriptado);\n                Cipher cifradorAES = Cipher.getInstance(\"AES/CBC/PKCS5Padding\");\n                cifradorAES.init(Cipher.ENCRYPT_MODE, clave,this.IV);\n                bufferSalida.put(cifradorAES.doFinal(bytesArchivo));\n                bufferSalida.flip();\n                //ESCRITURA\n                if(archivo.delete()){\n                    FileChannel canalSalida=new RandomAccessFile(archivo,\"rw\").getChannel();\n                    canalSalida.write(bufferSalida);\n                    canalSalida.close();\n                }else throw new Exception(\"No se pudo borrar el archivo \"+archivo.getName()+\", si lo tiene abierto, ci\u00e9rrelo.\");\n            }else{\n                if(!archivo.exists())throw new Exception(\"El archivo \"+archivo.getName()+\" no existe\");\n                if(!archivo.isFile())throw new Exception(\"No puede encriptar un directorio, trate\\nde comprimirlo antes para luego encriptar los archivos\");\n                if(archivo.length()>700248752)throw new Exception(\"No se puede encriptar el archivo \"+archivo.getName()+\" porque ha superado el tama\u00f1o m\u00e1ximo\\nde capacidad de memoria del JVM\");\n            }\n        }\n        catch (Exception ex){\n            throw new Exception(\"Hubo un error al encriptar el archivo\\n\"+ archivo.getName() +\"\\n\"+ex);\n        }\n    }\n    public void desencriptarArchivo(String ruta,SecretKey clave)throws Exception{\n        File archivoEncriptado=null;\n        try{\n            archivoEncriptado=new File(ruta);\n            if(archivoEncriptado.exists()){\n                //LECTURA\n                byte[]bytesArchivoEncriptado=new byte[(int)archivoEncriptado.length()];\n                int tama\u00f1oBloque=AES_KEYLENGTH/8;\n                int numBloques=((int)archivoEncriptado.length()%tama\u00f1oBloque==0)?(int)archivoEncriptado.length()/tama\u00f1oBloque:((int)archivoEncriptado.length()/tama\u00f1oBloque)+1;\n                FileChannel canalEntrada=new RandomAccessFile(archivoEncriptado, \"r\").getChannel();\n                ByteBuffer bufferEntrada=ByteBuffer.allocate((int)archivoEncriptado.length());\n                canalEntrada.read(bufferEntrada);\n                bufferEntrada.flip();\n                bufferEntrada.get(bytesArchivoEncriptado);\n                canalEntrada.close();\n                //DESCRIFRADO\n                ByteBuffer bufferSalida=ByteBuffer.allocate((int)archivoEncriptado.length());\n                if(comprobarKeys(clave)){\n                    Cipher descifradorAES = Cipher.getInstance(\"AES/CBC/PKCS5Padding\");\n                    descifradorAES.init(Cipher.DECRYPT_MODE,clave,this.IV);\n                    bufferSalida.put(descifradorAES.doFinal(bytesArchivoEncriptado));\n                    bufferSalida.flip();\n                }\n                else{\n                    System.gc();\n                    throw new Exception(\"La clave ingresada es incorrecta\");\n                }\n                //ESCRITURA            \n                if(archivoEncriptado.delete()){\n                    FileChannel canalSalida=new RandomAccessFile(ruta, \"rw\").getChannel();\n                    canalSalida.write(bufferSalida);\n                    canalSalida.close();\n                }else throw new Exception(\"No se pudo eliminar el archivo \"+archivoEncriptado.getName()+\", si lo tiene abierto, ci\u00e9rrelo.\");\n            }else{\n                if(!archivoEncriptado.exists())throw new Exception(\"El archivo \"+archivoEncriptado.getName()+\" no existe\");\n            }\n        }\n        catch (Exception ex){\n            System.gc();\n            throw new Exception(\"Hubo un error al desencriptar\\n\"+archivoEncriptado.getName()+\":\\n\"+ex.getMessage());\n        }\n    }    \n    public SecretKey generarClaveSecreta(String clave){\n        byte[]key=rellenarBytesClave(clave);\n        SecretKey claveGenerada=new SecretKeySpec(key, \"AES\");\n        return claveGenerada;\n    }\n    private byte[] rellenarBytesClave(String clave){\n        byte[]key=clave.getBytes();\n        while(key.length!=AES_KEYLENGTH/8){\n            if(key.length<AES_KEYLENGTH/8){\n                clave+=\"0\";\n                key=clave.getBytes();\n            }\n            if(key.length>AES_KEYLENGTH/8){\n                clave=clave.substring(0,AES_KEYLENGTH/8);\n                key=clave.getBytes();\n            }\n        }\n        return key;\n    }\n    private boolean comprobarKeys(SecretKey clave){\n        return this.CLAVESECRETA.equals(clave);\n    }\n    public void generarIV() throws Exception{\n        try{\n            byte[]VECTOR={1,6,1,2,1,9,9,7,7,9,9,1,2,1,6,1};\n            FileChannel canalsalida=new RandomAccessFile(new File(\"initvectoraes.iv\"), \"rw\").getChannel();\n            MappedByteBuffer buffersalida=canalsalida.map(FileChannel.MapMode.READ_WRITE, 0, 16);\n            buffersalida.put(VECTOR);\n            buffersalida.force();\n            canalsalida.close();\n        }catch(Exception ex){\n            throw new Exception(\"Error al generar el Vector de Inicializaci\u00f3n de AES\\n\"+ex.getMessage());\n        }\n    }\n    private byte[]obtenerIV()throws Exception{\n        byte[]vectorcargado=null;\n        try{\n            FileChannel canalentrada=new RandomAccessFile(new File(\"initvectoraes.iv\"), \"r\").getChannel();\n            MappedByteBuffer bufferentrada=canalentrada.map(FileChannel.MapMode.READ_ONLY, 0, 16);\n            vectorcargado=new byte[16];\n            bufferentrada.get(vectorcargado);\n            bufferentrada.load();\n            canalentrada.close();\n        }\n        catch(Exception ex){\n            throw new Exception(\"Error al obtener el Vector de Inicializaci\u00f3n de AES\\n\"+ex.getMessage());\n        }\n        return vectorcargado;\n    }\n}\n", "idx": 2013}
{"project": "cipher", "commit_id": "Snippet33092642_15140.java", "target": 1, "func": "public static final String TAG = KeyStoreManager.class.getName();\n\nstatic final String CIPHER_TYPE = \"RSA/ECB/PKCS1Padding\";\nstatic final String CIPHER_PROVIDER = \"AndroidOpenSSL\";\npublic static final String PHRASE_ALIAS = \"phrase\";\npublic static final String ANDROID_KEY_STORE = \"AndroidKeyStore\";\npublic static final String MIHAIL_GUTAN_X500 = \"CN=some name\";\n\n\npublic static boolean setKeyStoreString(String fileName, String strToStore, String alias, Context context) {\n\n    try {\n        KeyStore keyStore = KeyStore.getInstance(ANDROID_KEY_STORE);\n        keyStore.load(null);\n\n        int nBefore = keyStore.size();\n\n        // Create the keys if necessary\n        if (!keyStore.containsAlias(alias)) {\n\n            Calendar notBefore = Calendar.getInstance();\n            Calendar notAfter = Calendar.getInstance();\n            notAfter.add(Calendar.YEAR, 1);\n\n            KeyPairGenerator generator = KeyPairGenerator.getInstance(\n                    KeyProperties.KEY_ALGORITHM_RSA, ANDROID_KEY_STORE);\n\n            KeyPairGeneratorSpec spec = new KeyPairGeneratorSpec.Builder(context)\n                        .setAlias(alias)\n                        .setKeyType(KeyProperties.KEY_ALGORITHM_RSA)\n                        .setKeySize(2048)\n                        .setSubject(new X500Principal(MIHAIL_GUTAN_X500))\n                        .setSerialNumber(BigInteger.ONE)\n                        .setStartDate(notBefore.getTime())\n                        .setEndDate(notAfter.getTime())\n                        .build();\n\n            generator.initialize(spec);\n\n\n            KeyPair keyPair = generator.generateKeyPair(); // needs to be here\n            Log.v(TAG, \"The keypair\" + keyPair.toString());\n        }\n        int nAfter = keyStore.size();\n        Log.v(TAG, \"Before = \" + nBefore + \" After = \" + nAfter);\n\n        // Retrieve the keys\n        KeyStore.PrivateKeyEntry privateKeyEntry = (KeyStore.PrivateKeyEntry) keyStore.getEntry(alias, null);\n        RSAPrivateKey privateKey = (RSAPrivateKey) privateKeyEntry.getPrivateKey();\n        RSAPublicKey publicKey = (RSAPublicKey) privateKeyEntry.getCertificate().getPublicKey();\n\n        Log.v(TAG, \"private key = \" + privateKey.toString());\n        Log.v(TAG, \"public key = \" + publicKey.toString());\n\n        // Encrypt the text\n        String dataDirectory = context.getApplicationInfo().dataDir;\n        String filesDirectory = context.getFilesDir().getAbsolutePath();\n        String encryptedDataFilePath = filesDirectory + File.separator + fileName;\n\n        Log.v(TAG, \"strPhrase = \" + strToStore);\n        Log.v(TAG, \"dataDirectory = \" + dataDirectory);\n        Log.v(TAG, \"filesDirectory = \" + filesDirectory);\n        Log.v(TAG, \"encryptedDataFilePath = \" + encryptedDataFilePath);\n\n        Cipher inCipher = Cipher.getInstance(CIPHER_TYPE, CIPHER_PROVIDER);\n        inCipher.init(Cipher.ENCRYPT_MODE, publicKey);\n\n        CipherOutputStream cipherOutputStream =\n                new CipherOutputStream(\n                        new FileOutputStream(encryptedDataFilePath), inCipher);\n        cipherOutputStream.write(strToStore.getBytes(\"UTF-8\"));\n        cipherOutputStream.close();\n        return true;\n    } catch (NoSuchAlgorithmException e) {\n        Log.e(TAG, Log.getStackTraceString(e));\n    } catch (NoSuchProviderException e) {\n        Log.e(TAG, Log.getStackTraceString(e));\n    } catch (InvalidAlgorithmParameterException e) {\n        Log.e(TAG, Log.getStackTraceString(e));\n    } catch (KeyStoreException e) {\n        Log.e(TAG, Log.getStackTraceString(e));\n    } catch (CertificateException e) {\n        Log.e(TAG, Log.getStackTraceString(e));\n    } catch (IOException e) {\n        Log.e(TAG, Log.getStackTraceString(e));\n    } catch (UnrecoverableEntryException e) {\n        Log.e(TAG, Log.getStackTraceString(e));\n    } catch (NoSuchPaddingException e) {\n        Log.e(TAG, Log.getStackTraceString(e));\n    } catch (InvalidKeyException e) {\n        Log.e(TAG, Log.getStackTraceString(e));\n    } catch (UnsupportedOperationException e) {\n        Log.e(TAG, Log.getStackTraceString(e));\n    }\n    return false;\n}\n", "idx": 2199}
{"project": "cipher", "commit_id": "Snippet34923553_16873.java", "target": 0, "func": "public byte[] decryptData(byte input[], String password) throws Exception {\n    byte[] result = null;\n    //Cipher cipher = Cipher.getInstance(\"DES/CBC/PKCS5Padding\");\n    Cipher cipher = Cipher.getInstance(\"DES/CBC/NoPadding\");\n    //byte[] iv = { 0, 0, 0, 0, 0, 0, 0, 0 };\n    byte[] iv = { -128, -128, -128, -128, -128, -128, -128, -128 };\n    IvParameterSpec ivspec = new IvParameterSpec(iv);\n    cipher.init(Cipher.DECRYPT_MODE, generateSecretKey(passwordToKey(password)), ivspec);\n    result = cipher.doFinal(input);\n    return result;\n}\n\nprotected SecretKey generateSecretKey(byte[] key) throws Exception {\n    SecretKeyFactory factory = SecretKeyFactory.getInstance(\"DES\");\n    KeySpec keySpec = new DESKeySpec(key);\n    SecretKey secretKey = factory.generateSecret(keySpec);\n    return secretKey;\n}\n\npublic byte[] passwordToKey(String password) throws Exception\n{\n    if (password == null)\n        throw new IllegalArgumentException(\"password\");\n    if (password == \"\")\n        throw new IllegalArgumentException(\"password\");\n\n    byte[] key = new byte[8];\n\n    for (int i = 0; i < password.length(); i++)\n    {\n        int c = (int)password.charAt(i);\n        if ((i % 16) < 8)\n        {\n            key[i % 8] ^= (byte)(c << 1);\n        }\n        else\n        {\n            // reverse bits e.g. 11010010 -> 01001011\n            c = (((c << 4) & 0xf0) | ((c >> 4) & 0x0f));\n            c = (((c << 2) & 0xcc) | ((c >> 2) & 0x33));\n            c = (((c << 1) & 0xaa) | ((c >> 1) & 0x55));\n            key[7 - (i % 8)] ^= (byte)c;\n        }\n    }\n\n    addOddParity(key);\n\n    byte[] target = new byte[8];\n    ByteArrayOutputStream outputStream = new ByteArrayOutputStream( );\n    outputStream.write(password.getBytes(\"US-ASCII\"));\n    outputStream.write(new byte[8]);\n    byte[] temp = outputStream.toByteArray();\n    outputStream = new ByteArrayOutputStream( );\n    for (int i = 0; i < (password.length() + (8 - (password.length() % 8)) % 8); ++i) {\n        outputStream.write(temp[i]);\n    }\n    byte[] passwordBuffer = outputStream.toByteArray(); \n\n    Cipher cipher = Cipher.getInstance(\"DES/CBC/NoPadding\");\n    //byte[] iv = { 0, 0, 0, 0, 0, 0, 0, 0 };\n    byte[] iv = { -128, -128, -128, -128, -128, -128, -128, -128 };\n    IvParameterSpec ivspec = new IvParameterSpec(iv);\n    cipher.init(Cipher.ENCRYPT_MODE, generateSecretKey(key), ivspec);\n    for (int x = 0; x < passwordBuffer.length / 8; ++x)\n    {\n        cipher.update(passwordBuffer, 8 * x, 8, target, 0);\n    }\n\n    addOddParity(target);\n\n    return target;\n}\n\nprivate void addOddParity(byte[] buffer)\n{\n    for (int i = 0; i < buffer.length; ++i)\n    {\n        buffer[i] = _oddParityTable[buffer[i] & 0xFF];\n    }\n}\n\nprivate static byte[] _oddParityTable = {\n   -127,-127,-126,-126,-124,-124,-121,-121,-120,-120,-117,-117,-115,-115,-114,-114,\n   -112,-112,-109,-109,-107,-107,-106,-106,-103,-103,-102,-102,-100,-100, -97, -97,\n    -96, -96, -93, -93, -91, -91, -90, -90, -87, -87, -86, -86, -84, -84, -81, -81,\n    -79, -79, -78, -78, -76, -76, -73, -73, -72, -72, -69, -69, -67, -67, -66, -66,\n    -64, -64, -61, -61, -59, -59, -58, -58, -55, -55, -54, -54, -52, -52, -49, -49,\n    -47, -47, -46, -46, -44, -44, -41, -41, -40, -40, -37, -37, -35, -35, -34, -34,\n    -31, -31, -30, -30, -28, -28, -25, -25, -24, -24, -21, -21, -19, -19, -18, -18,\n    -16, -16, -13, -13, -11, -11, -10, -10,  -7,  -7,  -6,  -6,  -4,  -4,  -1,  -1,\n      0,   0,   3,   3,   5,   5,   6,   6,   9,   9,  10,  10,  12,  12,  15,  15,\n     17,  17,  18,  18,  20,  20,  23,  23,  24,  24,  27,  27,  29,  29,  30,  30,\n     33,  33,  34,  34,  36,  36,  39,  39,  40,  40,  43,  43,  45,  45,  46,  46,\n     48,  48,  51,  51,  53,  53,  54,  54,  57,  57,  58,  58,  60,  60,  63,  63,\n     65,  65,  66,  66,  68,  68,  71,  71,  72,  72,  75,  75,  77,  77,  78,  78,\n     80,  80,  83,  83,  85,  85,  86,  86,  89,  89,  90,  90,  92,  92,  95,  95,\n     96,  96,  99,  99, 101, 101, 102, 102, 105, 105, 106, 106, 108, 108, 111, 111,\n    113, 113, 114, 114, 116, 116, 119, 119, 120, 120, 123, 123, 125, 125, 126, 126\n};\n", "idx": 1698}
{"project": "cipher", "commit_id": "Snippet35686005_17560.java", "target": 1, "func": "package cryptography;\n\nimport java.security.AlgorithmParameters;\nimport java.security.InvalidAlgorithmParameterException;\nimport java.security.InvalidKeyException;\nimport java.security.Key;\nimport java.security.NoSuchAlgorithmException;\nimport java.security.spec.InvalidKeySpecException;\nimport java.security.spec.InvalidParameterSpecException;\nimport java.security.spec.KeySpec;\n\nimport javax.crypto.Cipher;\nimport javax.crypto.NoSuchPaddingException;\nimport javax.crypto.SecretKey;\nimport javax.crypto.SecretKeyFactory;\nimport javax.crypto.spec.IvParameterSpec;\nimport javax.crypto.spec.PBEKeySpec;\nimport javax.crypto.spec.SecretKeySpec;\n\nimport java.util.Base64;\nimport java.util.Base64.Decoder;\nimport java.util.Base64.Encoder;\n\npublic class BasicAESEncrypt {\nprivate final byte[] SALT = {\n        (byte) 0xA9, (byte) 0x9B, (byte) 0xC8, (byte) 0x32,\n        (byte) 0x56, (byte) 0x35, (byte) 0xE3, (byte) 0x03\n    };\n\nprivate Cipher ecipher;\nprivate Cipher dcipher;\nEncoder encoder = Base64.getEncoder();\nDecoder decoder = Base64.getDecoder();\n\n\nBasicAESEncrypt(String password) throws NoSuchAlgorithmException, InvalidKeySpecException, NoSuchPaddingException, InvalidKeyException, InvalidParameterSpecException, InvalidAlgorithmParameterException{\n    SecretKeyFactory factory = SecretKeyFactory.getInstance(\"PBKDF2WithHmacSHA1\");\n\n    KeySpec spec = new PBEKeySpec(password.toCharArray(), SALT, 65536, 256);\n    SecretKey tmp = factory.generateSecret(spec);        \n\n    SecretKey secret = new SecretKeySpec(tmp.getEncoded(), \"AES\");\n\n    ecipher = Cipher.getInstance(\"AES/CBC/PKCS5Padding\");\n    ecipher.init(Cipher.ENCRYPT_MODE, secret);\n\n    AlgorithmParameters params = ecipher.getParameters();\n    byte[] iv = params.getParameterSpec(IvParameterSpec.class).getIV();\n\n    dcipher = Cipher.getInstance(\"AES/CBC/PKCS5Padding\");\n    dcipher.init(Cipher.DECRYPT_MODE, secret, new IvParameterSpec(iv));\n}\n\npublic String encrypt(String encrypt) throws Exception {\n    byte[] bytes = encrypt.getBytes(\"UTF8\");\n    byte[] encrypted = encrypt(bytes);\n    return encoder.encodeToString(encrypted);\n}\n\npublic byte[] encrypt(byte[] plain) throws Exception {\n    return ecipher.doFinal(plain);\n}\n\npublic String decrypt(String encrypt) throws Exception {\n    byte[] decodedData = decoder.decode(encrypt);\n    byte[] decrypted = decrypt(decodedData);\n    return new String(decrypted, \"UTF8\");\n}\n\npublic byte[] decrypt(byte[] encrypt) throws Exception {\n    return dcipher.doFinal(encrypt);\n}\n\npublic static void main(String[] args) throws Exception {\n    String message = \"Wire message for encryption\";\n    String password  = \"TopSecretKey\";\n\n    try {\n        BasicAESEncrypt app = new BasicAESEncrypt(password);\n\n        String encrypted = app.encrypt(message);\n        System.out.println(\"Encrypted string is: \" + encrypted);\n\n        String decrypted = app.decrypt(encrypted);\n        System.out.println(\"Decrypted string is: \" + decrypted);\n    } catch (InvalidKeyException | NoSuchAlgorithmException | InvalidKeySpecException | NoSuchPaddingException\n            | InvalidParameterSpecException | InvalidAlgorithmParameterException e1) {\n        e1.printStackTrace();\n    }\n    try {\n    } catch (Exception e) {\n        e.printStackTrace();\n    }\n}\n", "idx": 2321}
{"project": "cipher", "commit_id": "Snippet11065183_35286.java", "target": 1, "func": "Cipher c = Cipher.getInstance(\"AES/CBC/PKCS5Padding\");\nc.init(Cipher.ENCRYPT_MODE, k, iv);\nbyte[] someData = c.update(textData);\nbyte[] moreData = c.doFinal();\n\nSystem.out.println(\"E: \" + (someData.length + moreData.length));\n\nc = Cipher.getInstance(\"AES/CBC/PKCS5Padding\");\nc.init(Cipher.DECRYPT_MODE, k, iv);\nbyte[] someDecrypted = c.update(someData);\nbyte[] moreDecrypted = c.doFinal(moreData);\n\nSystem.out.println(\"R: \" + (someDecrypted.length + moreDecrypted.length));\n", "idx": 2312}
{"project": "cipher", "commit_id": "Snippet27965798_10023.java", "target": 1, "func": "Cipher cipher = Cipher.getInstance(\"AES/CBC/PKCS5Padding\" /*, here may be Provider parameter*/);\n", "idx": 2172}
{"project": "cipher", "commit_id": "Snippet37210227_19153.java", "target": 1, "func": "def decode(input:String) = {\n    val keyBytes = Hex.decodeHex(\"someKey\".toCharArray)\n    val inputWithoutPadding = input.substring(0,input.size - 2)\n    val inputArr:Seq[Byte] = Hex.decodeHex(inputWithoutPadding.toCharArray)\n\n    val skSpec = new SecretKeySpec(keyBytes, \"AES\")\n    val iv = new IvParameterSpec(inputArr.slice(0,16).toArray)\n    val dataToDecrypt = inputArr.slice(16,inputArr.size)\n\n    val cipher = Cipher.getInstance(\"AES/CFB/NoPadding\")\n    cipher.init(Cipher.DECRYPT_MODE, skSpec, iv)\n    cipher.doFinal(dataToDecrypt.toArray)\n}\n", "idx": 2186}
{"project": "cipher", "commit_id": "Snippet7331684_32692.java", "target": 1, "func": "public byte[] encryptRSA(final InputStream publicKeyFile, String in) throws IOException, NoSuchAlgorithmException,\n    InvalidKeySpecException, InvalidKeyException, NoSuchPaddingException, IllegalBlockSizeException,\n    BadPaddingException {\n    byte[] encodedKey = new byte[5000];\n    publicKeyFile.read(encodedKey);\n    X509EncodedKeySpec publicKeySpec = new X509EncodedKeySpec(encodedKey);\n    KeyFactory kf = KeyFactory.getInstance(\"RSA\");\n    PublicKey pkPublic = kf.generatePublic(publicKeySpec);\n    // Encrypt\n    Cipher pkCipher = Cipher.getInstance(\"RSA/ECB/PKCS1PADDING\");\n    pkCipher.init(Cipher.ENCRYPT_MODE, pkPublic);\n    return pkCipher.doFinal(in.getBytes());\n}\n", "idx": 2136}
{"project": "cipher", "commit_id": "Snippet45250892_27389.java", "target": 1, "func": "Cipher cipher = Cipher.getInstance(\"EC\", \"SunEC\"); \n", "idx": 2291}
{"project": "cipher", "commit_id": "Snippet31090303_13271.java", "target": 0, "func": "Cipher cipher = Cipher.getInstance(\"AES/ECB/PKCS5Padding\");\n", "idx": 1602}
{"project": "cipher", "commit_id": "Snippet40570416_22436.java", "target": 1, "func": "public String RSAEncryptString(String strInputString, int dwKeySize, PublicKey p) {\n    StringBuilder stringBuilder = null;\n    try {\n        int keySize = dwKeySize / 8;\n        byte[] bytes = strInputString.getBytes(\"UTF-32LE\");\n        int maxLength = keySize - 42;\n        int dataLength = bytes.length;\n        int iterations = dataLength / maxLength;\n        stringBuilder = new StringBuilder();\n        Cipher cipher = Cipher.getInstance(\"RSA/ECB/OAEPWithSHA1AndMGF1Padding\");//4.4\n        cipher.init(Cipher.ENCRYPT_MODE, p);\n        //cipher.init(Cipher.DECRYPT_MODE, p, new OAEPParameterSpec(\"SHA-256\", \"MGF1\", MGF1ParameterSpec.SHA256, PSource.PSpecified.DEFAULT));\n        for (int i = 0; i <= iterations; i++) {\n            int index = (dataLength - maxLength * i > maxLength) ? maxLength : dataLength - maxLength * i;\n            int offset = maxLength * i;\n            byte[] tempBytes = new byte[index];\n            System.arraycopy(bytes, offset, tempBytes, 0, tempBytes.length);\n            byte[] encryptedBytes = cipher.doFinal(tempBytes);\n            byte[] encryptedBytes1 = onReverse(encryptedBytes);\n            stringBuilder.append(Base64.encodeToString(encryptedBytes1, Base64.NO_WRAP));\n        }\n    } catch (Exception e) {\n        e.printStackTrace();\n    }\n    return stringBuilder.toString();\n}\n", "idx": 2188}
{"project": "cipher", "commit_id": "Snippet17234359_484.java", "target": 0, "func": "package com.tb.module.service;\nimport java.security.Key;\nimport java.security.spec.InvalidKeySpecException;\n\nimport javax.crypto.Cipher;\nimport javax.crypto.spec.SecretKeySpec;\n\nimport sun.misc.*;\n\n/**\n * This class is used for encrypt and decrypt the  password field.\n *\n */\npublic class PswdEnc {\n\n    private static final String ALGO = \"AES\";\n    private static final byte[] keyValue = new byte[] { 'T', 'h', 'e', 'B', 'e', 's', 't','S', 'e', 'c', 'r','e', 't', 'K', 'e', 'y' };\n\n    public static String encrypt(String Data) throws Exception {\n        Key key = generateKey();\n        Cipher c = Cipher.getInstance(ALGO);\n        c.init(Cipher.ENCRYPT_MODE, key);\n        byte[] encVal = c.doFinal(Data.getBytes());\n        String encryptedValue = new BASE64Encoder().encode(encVal);\n        return encryptedValue;\n    }\n\n    public static String decrypt(String encryptedData) throws Exception {\n        Key key = generateKey(); \n        Cipher c = Cipher.getInstance(ALGO);\n        c.init(Cipher.DECRYPT_MODE, key);\n        byte[] decordedValue = new BASE64Decoder().decodeBuffer(encryptedData);\n        byte[] decValue = c.doFinal(decordedValue);\n        String decryptedValue = new String(decValue);\n        return decryptedValue;\n    }\n\n\n    private static Key generateKey() throws Exception {\n        Key key = new SecretKeySpec(keyValue, ALGO);\n        return key;\n    }\n\n}\n", "idx": 1689}
{"project": "cipher", "commit_id": "Snippet40869756_22748.java", "target": 0, "func": "public class UUDES {\n\n    public static void main (String[] args) throws Exception\n    {                                   \n        String password = \"xxxxxx\";\n        String pathToUUEencodedEncryptedFile = \"C:\\DES\\path-to-decoded-and-encrypted-file\";\n\n        byte[] secretKey = passwordToKey(password);\n        byte[] iv = new byte[8];        \n        byte[] uuEncodedFile = Files.readAllBytes(Paths.get(pathToUUEencodedEncryptedFile));\n\n        SecretKey key = new SecretKeySpec(secretKey, \"DES\");\n\n        Cipher decryptor = Cipher.getInstance(\"DES/CBC/NoPadding\");\n        decryptor.init(Cipher.DECRYPT_MODE, key, new IvParameterSpec(iv));          \n\n        ByteArrayOutputStream bout = new ByteArrayOutputStream();\n        InputStream in = null;      \n        try {\n            in = MimeUtility.decode(new ByteArrayInputStream(uuEncodedFile), \"uuencode\");\n            byte[] buf = new byte[1024];\n            int length;\n            while (true) {\n                length = in.read(buf);\n                if (length == -1) {\n                    break;\n                }\n                bout.write(buf, 0, length);\n            }\n\n            byte[] bytesDecrypted = decryptor.doFinal(bout.toByteArray());\n\n            ByteArrayInputStream bais = new ByteArrayInputStream(bytesDecrypted);\n            GZIPInputStream gzis = new GZIPInputStream(bais);\n            InputStreamReader reader = new InputStreamReader(gzis);\n            BufferedReader buffer = new BufferedReader(reader);\n\n            String readed;\n            while ((readed = buffer.readLine()) != null) {\n                System.out.println(readed);\n            }                              \n        }\n        finally {\n            if (in != null) {\n                try {\n                    in.close();\n                }\n                catch (IOException e) {\n                    System.out.println(e.getMessage());\n                }\n            }\n        }                                   \n    }\n\n    static SecretKey generateSecretKey(byte[] key) throws Exception {\n        SecretKeyFactory factory = SecretKeyFactory.getInstance(\"DES\");\n        KeySpec keySpec = new DESKeySpec(key);\n        SecretKey secretKey = factory.generateSecret(keySpec);\n        return secretKey;\n    }\n\n    static byte[] passwordToKey(String password) throws Exception\n    {\n        if (password == null)\n            throw new IllegalArgumentException(\"password\");\n        if (password == \"\")\n            throw new IllegalArgumentException(\"password\");\n\n        byte[] key = new byte[8];\n\n        for (int i = 0; i < password.length(); i++)\n        {\n            int c = (int)password.charAt(i);\n            if ((i % 16) < 8)\n            {\n                key[i % 8] ^= (byte)(c << 1);\n            }\n            else\n            {\n                // reverse bits e.g. 11010010 -> 01001011\n                c = (((c << 4) & 0xf0) | ((c >> 4) & 0x0f));\n                c = (((c << 2) & 0xcc) | ((c >> 2) & 0x33));\n                c = (((c << 1) & 0xaa) | ((c >> 1) & 0x55));\n                key[7 - (i % 8)] ^= (byte)c;\n            }\n        }\n\n        addOddParity(key);\n\n        byte[] target = new byte[8];\n        ByteArrayOutputStream outputStream = new ByteArrayOutputStream( );\n        outputStream.write(password.getBytes(\"US-ASCII\"));\n        outputStream.write(new byte[8]);\n        byte[] temp = outputStream.toByteArray();\n        outputStream = new ByteArrayOutputStream( );\n        for (int i = 0; i < (password.length() + (8 - (password.length() % 8)) % 8); ++i) {\n            outputStream.write(temp[i]);\n        }\n        byte[] passwordBuffer = outputStream.toByteArray(); \n\n        Cipher cipher = Cipher.getInstance(\"DES/CBC/NoPadding\");\n        byte[] iv = key;\n\n        IvParameterSpec ivspec = new IvParameterSpec(iv);\n        cipher.init(Cipher.ENCRYPT_MODE, generateSecretKey(key), ivspec);\n        for (int x = 0; x < passwordBuffer.length / 8; ++x)\n        {\n            cipher.update(passwordBuffer, 8 * x, 8, target, 0);\n        }\n\n        addOddParity(target);\n\n        return target;\n    }\n\n    static void addOddParity(byte[] buffer)\n    {\n        for (int i = 0; i < buffer.length; ++i)\n        {\n            buffer[i] = _oddParityTable[buffer[i] & 0xFF];\n        }\n    }\n\n    static byte[] _oddParityTable = {\n            (byte)1,(byte)1,(byte)2,(byte)2,(byte)4,(byte)4,(byte)7,(byte)7,(byte)8,(byte)8,(byte)11,(byte)11,(byte)13,(byte)13,(byte)14,(byte)14,\n            (byte)16,(byte)16,(byte)19,(byte)19,(byte)21,(byte)21,(byte)22,(byte)22,(byte)25,(byte)25,(byte)26,(byte)26,(byte)28,(byte)28,(byte)31,(byte)31,\n           (byte)32,(byte)32,(byte)35,(byte)35,(byte)37,(byte)37,(byte)38,(byte)38,(byte)41,(byte)41,(byte)42,(byte)42,(byte)44,(byte)44,(byte)47,(byte)47,\n           (byte)49,(byte)49,(byte)50,(byte)50,(byte)52,(byte)52,(byte)55,(byte)55,(byte)56,(byte)56,(byte)59,(byte)59,(byte)61,(byte)61,(byte)62,(byte)62,\n           (byte)64,(byte)64,(byte)67,(byte)67,(byte)69,(byte)69,(byte)70,(byte)70,(byte)73,(byte)73,(byte)74,(byte)74,(byte)76,(byte)76,(byte)79,(byte)79,\n           (byte)81,(byte)81,(byte)82,(byte)82,(byte)84,(byte)84,(byte)87,(byte)87,(byte)88,(byte)88,(byte)91,(byte)91,(byte)93,(byte)93,(byte)94,(byte)94,\n           (byte)97,(byte)(byte)97,(byte)(byte)98,(byte)(byte)98,(byte)100,(byte)100,(byte)103,(byte)103,(byte)104,(byte)104,(byte)107,(byte)107,(byte)109,(byte)109,(byte)110,(byte)110,\n           (byte)112,(byte)112,(byte)115,(byte)115,(byte)117,(byte)117,(byte)118,(byte)118,(byte)121,(byte)121,(byte)122,(byte)122,(byte)124,(byte)124,(byte)127,(byte)127,\n           (byte)128,(byte)128,(byte)131,(byte)131,(byte)133,(byte)133,(byte)134,(byte)134,(byte)137,(byte)137,(byte)138,(byte)138,(byte)140,(byte)140,(byte)143,(byte)143,\n           (byte)145,(byte)145,(byte)146,(byte)146,(byte)148,(byte)148,(byte)151,(byte)151,(byte)152,(byte)152,(byte)155,(byte)155,(byte)157,(byte)157,(byte)158,(byte)158,\n           (byte)161,(byte)161,(byte)162,(byte)162,(byte)164,(byte)164,(byte)167,(byte)167,(byte)168,(byte)168,(byte)171,(byte)171,(byte)173,(byte)173,(byte)174,(byte)174,\n           (byte)176,(byte)176,(byte)179,(byte)179,(byte)181,(byte)181,(byte)182,(byte)182,(byte)185,(byte)185,(byte)186,(byte)186,(byte)188,(byte)188,(byte)191,(byte)191,\n           (byte)193,(byte)193,(byte)194,(byte)194,(byte)196,(byte)196,(byte)199,(byte)199,(byte)200,(byte)200,(byte)203,(byte)203,(byte)205,(byte)205,(byte)206,(byte)206,\n           (byte)208,(byte)208,(byte)211,(byte)211,(byte)213,(byte)213,(byte)214,(byte)214,(byte)217,(byte)217,(byte)218,(byte)218,(byte)220,(byte)220,(byte)223,(byte)223,\n           (byte)224,(byte)224,(byte)227,(byte)227,(byte)229,(byte)229,(byte)230,(byte)230,(byte)233,(byte)233,(byte)234,(byte)234,(byte)236,(byte)236,(byte)239,(byte)239,\n           (byte)241,(byte)241,(byte)242,(byte)242,(byte)244,(byte)244,(byte)247,(byte)247,(byte)248,(byte)248,(byte)251,(byte)251,(byte)253,(byte)253,(byte)254,(byte)254};    \n}\n", "idx": 1815}
{"project": "cipher", "commit_id": "Snippet44048908_26130.java", "target": 0, "func": "Cipher c = Cipher.getInstance(\"DES/CBC/PKCS7Padding\");\n", "idx": 1699}
{"project": "cipher", "commit_id": "Snippet22872004_5277.java", "target": 0, "func": "import java.security.*;\nimport javax.crypto.*;\nimport javax.crypto.spec.*;\npublic class Crypto\n{\n    public Crypto(){\n\n    }\n\n    public static void main(String args[]){\n        Crypto crypto = new Crypto();\n        byte encrypted[] = crypto.encrypt(\"test encryption\");\n        System.out.println(encrypted);\n        String decrypted = crypto.decrypt(encrypted);\n        System.out.println(decrypted);\n\n    }\n\n    public byte[] encrypt(String input){\n        try{\n            Crypto crypto = new Crypto();\n            SecretKeySpec key = crypto.hashPhrase();\n            Cipher aes = Cipher.getInstance(\"AES/ECB/PKCS5Padding\");\n            aes.init(Cipher.ENCRYPT_MODE, key);\n            return aes.doFinal(input.getBytes());\n        }\n        catch(Exception e){\n            return null;\n        }\n    }\n\n    public SecretKeySpec hashPhrase(){\n        try{\n            String code = \"some code\";\n            MessageDigest digest = MessageDigest.getInstance(\"SHA\");\n            digest.update(code.getBytes());\n            return new SecretKeySpec(digest.digest(), 0, 16, \"AES\");\n        }\n        catch(Exception e){\n            return null;\n        }\n    }\n\n    public String decrypt(byte[] input){\n        try{\n            Crypto crypto = new Crypto();\n            SecretKeySpec key = crypto.hashPhrase();\n            Cipher aes = Cipher.getInstance(\"AES/ECB/PKCS5Padding\");\n            aes.init(Cipher.DECRYPT_MODE, key);\n            return new String(aes.doFinal(input));\n        }\n        catch(Exception e){\n            return null;\n        }\n    }\n}\n", "idx": 1617}
{"project": "cipher", "commit_id": "Snippet45502635_27557.java", "target": 0, "func": "package encryption;\n\nimport java.io.*;\nimport java.net.*;\nimport java.security.*;\nimport javax.crypto.*;\n\npublic class CipherServer\n{\n    public static void main(String[] args) throws Exception \n    {\n        int port = 7999;\n        ServerSocket server = new ServerSocket(port);\n        Socket s = server.accept();\n\n        // -Read the key from the file generated by the client.\n        ObjectInputStream in = new ObjectInputStream(new FileInputStream(\"KeyFile.xx\"));\n        Key key = (Key)in.readObject();\n        System.out.println(key.getClass().getName());\n        in.close();\n\n        // -Use the key to decrypt the incoming message from socket s.      \n        Cipher cipher = Cipher.getInstance(\"DES/ECB/PKCS5Padding\");\n        cipher.init(Cipher.DECRYPT_MODE, key);\n        CipherInputStream cipherIn = new CipherInputStream(s.getInputStream(), cipher);\n        byte[] stringInBytes = new byte[44];\n        cipherIn.read(stringInBytes);\n        String string = new String(stringInBytes);\n\n        // -Print out the decrypt String to see if it matches the orignal message.\n        System.out.println(string);\n    }\n}\n", "idx": 1839}
{"project": "cipher", "commit_id": "Snippet17925969_985.java", "target": 1, "func": "String Decrypt(String text, String key) throws Exception {\n    Cipher cipher = Cipher.getInstance(\"AES/CBC/PKCS5Padding\");\n    byte[] keyBytes = new byte[16];\n    byte[] b = key.getBytes(\"UTF-8\");\n    int len = b.length;\n    if (len > keyBytes.length)\n        len = keyBytes.length;\n    System.arraycopy(b, 0, keyBytes, 0, len);\n    SecretKeySpec keySpec = new SecretKeySpec(keyBytes, \"AES\");\n    IvParameterSpec ivSpec = new IvParameterSpec(keyBytes);\n    cipher.init(Cipher.DECRYPT_MODE, keySpec,ivSpec);\n\n    BASE64Decoder decoder = new BASE64Decoder();\n    byte[] results = cipher.doFinal(decoder.decode(text));\n    return new String(results, \"UTF-8\");\n}\n", "idx": 2169}
{"project": "cipher", "commit_id": "Snippet44205888_26250.java", "target": 1, "func": "      public String decryptString(String alias, String decrypted) {\n    try {\n\n        KeyStore.Entry entry;\n        //ERROR HAPPENS HERE.\n        entry = keyStore.getEntry(alias, null);\n\n        KeyStore.PrivateKeyEntry privateKeyEntry = (KeyStore.PrivateKeyEntry) entry;\n\n        Cipher output = Cipher.getInstance(\"RSA/ECB/PKCS1Padding\");\n        output.init(Cipher.DECRYPT_MODE, privateKeyEntry.getPrivateKey());\n\n\n        CipherInputStream cipherInputStream = new CipherInputStream(\n                new ByteArrayInputStream(Base64.decode(decrypted, Base64.DEFAULT)), output);\n        ArrayList<Byte> values = new ArrayList<>();\n        int nextByte;\n        while ((nextByte = cipherInputStream.read()) != -1) {\n            values.add((byte) nextByte);\n        }\n\n        byte[] bytes = new byte[values.size()];\n        for (int i = 0; i < bytes.length; i++) {\n            bytes[i] = values.get(i);\n        }\n\n        String finalText = new String(bytes, 0, bytes.length, \"UTF-8\");\n        return finalText;\n\n    } catch (IOException | KeyStoreException | NoSuchPaddingException | UnrecoverableEntryException | InvalidKeyException | NoSuchAlgorithmException e) {\n        e.printStackTrace();\n    }\n    return \"Error\";\n}\n", "idx": 2134}
{"project": "cipher", "commit_id": "Snippet24618698_6969.java", "target": 0, "func": "public class MainActivity extends Activity {\n\nstatic byte[] keyValue = {'T', 'h', 'e', 'B', 'e', 's', 't', 'S', 'e', 'c', 'r','e', 't', 'K', 'e', 'y'};\n\n@Override\nprotected void onCreate(Bundle savedInstanceState) {\n\n    super.onCreate(savedInstanceState);\n    setContentView(R.layout.activity_main);\n\n    ImageView imgView = (ImageView) findViewById(R.id.imageView1);\n\n    Bitmap picture = getBitmapFromAsset(\"result.jpg\");\n    Bitmap resultPic = picture.copy(Bitmap.Config.ARGB_8888, true);\n    picture.recycle();\n\n    int width = resultPic.getWidth();\n    int height = resultPic.getHeight();\n\n    int[] pixels = new int[width * height];\n\n    resultPic.getPixels(pixels, 0, width, 0, 0, width, height);\n\n    //--------- perform encryption\n\n    byte[] content = intArrToByteArr(pixels);\n\n    try {\n\n        content = decrypt(content);\n\n    } catch (Exception e) { }\n\n    pixels = byteArrToIntArr(content);\n\n    //--------------------------------------------\n\n    resultPic.setPixels(pixels, 0, width, 0, 0, width, height);\n\n    imgView.setImageBitmap(resultPic);\n\n    File file = new File(Environment.getExternalStorageDirectory().toString() + \"/result.jpg\");\n\n    try {\n\n        FileOutputStream fOut = new FileOutputStream(file);\n        resultPic.compress(Bitmap.CompressFormat.JPEG, 100, fOut);\n        fOut.close();\n    }\n    catch (Exception e) { }\n}\n\npublic static byte[] encrypt(byte[] Data) throws Exception {\n\n    Key key = generateKey();\n    Cipher c = Cipher.getInstance(\"RC4\");\n    c.init(Cipher.ENCRYPT_MODE, key);\n\n    byte[] encVal = c.doFinal(Data);\n\n    return encVal;\n}\n\npublic static byte[] decrypt(byte[] encryptedData) throws Exception {\n\n    Key key = generateKey();\n    Cipher c = Cipher.getInstance(\"RC4\");\n    c.init(Cipher.DECRYPT_MODE, key);\n\n    byte[] decValue = c.doFinal(encryptedData);\n\n    return decValue;\n}\n\nprivate static Key generateKey() throws Exception {\n\n    Key key = new SecretKeySpec(keyValue, \"RC4\");\n\n    return key;\n}\n\npublic static byte[] intArrToByteArr(int[] input){\n\n    ByteBuffer byteBuffer = ByteBuffer.allocate(input.length * 4);\n    IntBuffer intBuffer = byteBuffer.asIntBuffer();\n    intBuffer.put(input);\n\n    byte[] array = byteBuffer.array();\n\n    return array;\n}\n\npublic static int[] byteArrToIntArr(byte[] input){\n\n    IntBuffer intBuf = ByteBuffer.wrap(input).order(ByteOrder.BIG_ENDIAN).asIntBuffer();\n    int[] array = new int[intBuf.remaining()];\n    intBuf.get(array);\n\n    return array;\n}\n\nprivate Bitmap getBitmapFromAsset(String strName) {\n\n    AssetManager assetManager = getAssets();\n    InputStream istr = null;\n\n    try {\n\n        istr = assetManager.open(strName);\n    } catch (IOException e) { }\n\n    Bitmap bitmap = BitmapFactory.decodeStream(istr);\n\n    return bitmap;\n}\n", "idx": 1630}
{"project": "cipher", "commit_id": "Snippet22198856_4593.java", "target": 0, "func": "    static public byte[] dec(byte data[]){\n\n    byte[] ret = null;\n\n    SecretKeyFactory keyFac;\n\n    keyFac = SecretKeyFactory.getInstance(\"DESede\");\n\n    DESedeKeySpec keySpec = new DESedeKeySpec(passwd.getBytes());\n    SecretKey secKey = keyFac.generateSecret(keySpec);\n    Cipher cipher = Cipher.getInstance(\"DESede\");\n    cipher.init(Cipher.DECRYPT_MODE, secKey);\n\n    ret = cipher.doFinal(data);\n    return ret;\n}\n", "idx": 1594}
{"project": "cipher", "commit_id": "Snippet20744367_3333.java", "target": 0, "func": "import javax.crypto.Cipher;\nimport javax.crypto.SecretKey;\nimport javax.crypto.spec.SecretKeySpec;\n\npublic class CipherHelper {\n\n    // Algorithm used\n    private final static String ALGORITHM = \"DES\";\n\n    /**\n     * Encrypt data\n     * @param secretKey -   a secret key used for encryption\n     * @param data      -   data to encrypt\n     * @return  Encrypted data\n     * @throws Exception\n     */\n    public static String cipher(String secretKey, String data) throws Exception {\n        // Key has to be of length 8\n        if (secretKey == null || secretKey.length() != 8)\n            throw new Exception(\"Invalid key length - 8 bytes key needed!\");\n\n        SecretKey key = new SecretKeySpec(secretKey.getBytes(), ALGORITHM);\n        Cipher cipher = Cipher.getInstance(ALGORITHM);\n        cipher.init(Cipher.ENCRYPT_MODE, key);\n\n        return toHex(cipher.doFinal(data.getBytes()));\n    }\n\n    /**\n     * Decrypt data\n     * @param secretKey -   a secret key used for decryption\n     * @param data      -   data to decrypt\n     * @return  Decrypted data\n     * @throws Exception\n     */\n    public static String decipher(String secretKey, String data) throws Exception {\n        // Key has to be of length 8\n        if (secretKey == null || secretKey.length() != 8)\n            throw new Exception(\"Invalid key length - 8 bytes key needed!\");\n\n        SecretKey key = new SecretKeySpec(secretKey.getBytes(), ALGORITHM);\n        Cipher cipher = Cipher.getInstance(ALGORITHM);\n        cipher.init(Cipher.DECRYPT_MODE, key);\n\n        return new String(cipher.doFinal(toByte(data)));\n    }\n\n    // Helper methods\n\n    private static byte[] toByte(String hexString) {\n        int len = hexString.length()/2;\n\n        byte[] result = new byte[len];\n\n        for (int i = 0; i < len; i++)\n            result[i] = Integer.valueOf(hexString.substring(2*i, 2*i+2), 16).byteValue();\n        return result;\n    }\n\n    public static String toHex(byte[] stringBytes) {\n        StringBuffer result = new StringBuffer(2*stringBytes.length);\n\n        for (int i = 0; i < stringBytes.length; i++) {\n            result.append(HEX.charAt((stringBytes[i]>>4)&0x0f)).append(HEX.charAt(stringBytes[i]&0x0f));\n        }\n\n        return result.toString();\n    }\n\n    private final static String HEX = \"0123456789ABCDEF\";\n\n    // Helper methods - end\n\n    /**\n     * Quick test\n     * @param args\n     */\n    public static void main(String[] args) {\n        try {\n\n            String secretKey    = \"01234567\";\n            String data=\"test\";\n            String encryptedData = cipher(secretKey, data);\n\n            System.out.println(\"encryptedData: \" + encryptedData);\n\n            String decryptedData = decipher(secretKey, encryptedData);\n\n            System.out.println(\"decryptedData: \" + decryptedData);\n\n        } catch (Exception e) {\n            e.printStackTrace();\n        }\n    }\n\n}\n", "idx": 1614}
{"project": "cipher", "commit_id": "Snippet28026325_10175.java", "target": 0, "func": "Cipher cipher = Cipher.getInstance(\"AES/ECB/PKCS5Padding\");\n", "idx": 1764}
{"project": "cipher", "commit_id": "Snippet5531542_31692.java", "target": 0, "func": "import java.io.*;\nimport javax.crypto.*;\nimport javax.crypto.spec.SecretKeySpec;\n\nclass Blowfish {\n    public static void main(String[] args) throws Exception {\n        String s;\n        BufferedReader br = new BufferedReader(new InputStreamReader(System.in));\n        Cipher encrypt = Cipher.getInstance(\"DES\");\n        Cipher decrypt = Cipher.getInstance(\"DES\");\n        System.out.print(\"Enter the key: \");\n        s = br.readLine();\n        /*\n         * Names of algorithms used \"Blowfish\" \"DES\" 64 bit key ie. 8 bytes\n         * \"AES\" key size has to be 16 bytes ie. 128 bits\n         */\n\n        byte key[] = new byte[8];\n        for (int i = 0; i < s.length() && i < 8; i++)\n            key[i] = (byte) s.charAt(i);\n\n        encrypt.init(Cipher.ENCRYPT_MODE, new SecretKeySpec(key, \"DES\"));\n        FileInputStream fin = new FileInputStream(\"test.txt\");\n        FileOutputStream out = new FileOutputStream(\"encrypted.p4e\");\n        CipherOutputStream cout = new CipherOutputStream(out, encrypt);\n\n        int input = 0;\n        while ((input = fin.read()) != -1) {\n            cout.write(input);\n        }\n\n        out.close();\n        cout.close();\n        System.out.println(\"Starting the decryption\");\n        System.out.print(\"Enter the key: \");\n        s = br.readLine();\n\n        byte key2[] = new byte[8];\n        for (int i = 0; i < s.length() && i < 8; i++)\n            key2[i] = (byte) s.charAt(i);\n\n        decrypt.init(Cipher.DECRYPT_MODE, new SecretKeySpec(key2, \"DES\"));\n        fin = new FileInputStream(\"encrypted.p4e\");\n        out = new FileOutputStream(\"test2.txt\");\n        CipherInputStream in = new CipherInputStream(fin, decrypt);\n        input = 0;\n        while ((input = in.read()) != -1) {\n            out.write(input);\n        }\n        out.close();\n        in.close();\n    }\n}\n", "idx": 1762}
{"project": "cipher", "commit_id": "Snippet7418007_32722.java", "target": 0, "func": "public static String encrypt(String src, String key) {\n    try {\n        Cipher cipher = Cipher.getInstance(\"DES/CBC/PKCS5Padding\");\n\n        DESKeySpec dks = new DESKeySpec(key.substring(0, 8).getBytes());\n\n        SecretKeyFactory keyFactory = SecretKeyFactory.getInstance(\"DES\");\n        SecretKey securekey = keyFactory.generateSecret(dks);\n        IvParameterSpec iv = new IvParameterSpec(key.substring(0, 8)\n                .getBytes());\n\n        cipher.init(Cipher.ENCRYPT_MODE, securekey, iv);\n        StringBuilder builder = new StringBuilder();\n        byte[] bytes = cipher.doFinal(src.getBytes(\"UTF-8\"));\n        for (byte b : bytes) {\n            System.out.println(b);\n                            builder.append(b);\n        }\n\n        return builder.toString().toUpperCase();\n    } catch (Exception e) {\n        e.printStackTrace();\n    }\n    return \"\";\n}\n", "idx": 1626}
{"project": "cipher", "commit_id": "Snippet33297274_15353.java", "target": 1, "func": "// add instance of provider class\nSecurity.addProvider(new BouncyCastleProvider());\n\n// initializing parameter specs secp256r1/prime192v1\nECParameterSpec ecSpec = ECNamedCurveTable.getParameterSpec(\"prime192v1\");\n\n// key pair generator to generate public and private key\nKeyPairGenerator generator = KeyPairGenerator.getInstance(\"ECDH\", new BouncyCastleProvider());\n\n// initialize key pair generator\ngenerator.initialize(ecSpec);\n\n// Key pair to store public and private key\nKeyPair keyPair = generator.generateKeyPair();\n\nCipher iesCipher = Cipher.getInstance(\"ECIES\", new BouncyCastleProvider());\niesCipher.init(Cipher.ENCRYPT_MODE, keyPair.getPublic());\n", "idx": 2086}
{"project": "cipher", "commit_id": "Snippet24907530_7245.java", "target": 0, "func": "public String cryptString(String s) throws NoSuchPaddingException, NoSuchAlgorithmException, InvalidKeyException, UnsupportedEncodingException, BadPaddingException, IllegalBlockSizeException {\n    byte[] KeyData = this.cryptKey.getBytes();\n    SecretKeySpec KS = new SecretKeySpec(KeyData, \"Blowfish\");\n    Cipher cipher = Cipher.getInstance(\"Blowfish\");\n    cipher.init(Cipher.ENCRYPT_MODE, KS);\n    String ret = new String(cipher.doFinal(s.getBytes(\"UTF-8\")));\n    return ret;\n}\n\npublic String decryptString(byte[] s) throws NoSuchPaddingException, NoSuchAlgorithmException, InvalidKeyException, BadPaddingException, IllegalBlockSizeException {\n    byte[] KeyData = this.cryptKey.getBytes();\n    SecretKeySpec KS = new SecretKeySpec(KeyData, \"Blowfish\");\n    Cipher cipher = Cipher.getInstance(\"Blowfish\");\n    cipher.init(Cipher.DECRYPT_MODE, KS);\n    String ret = new String(cipher.doFinal(s));\n    return ret;\n}\n", "idx": 1625}
{"project": "cipher", "commit_id": "Snippet5505418_31668.java", "target": 1, "func": "  KeyGenerator kgen = KeyGenerator.getInstance(\"AES\");\n          kgen.init(128);\n          key = kgen.generateKey();\n\n    byte[] ivar = new byte[]\n                      {\n                          0x00, 0x01, 0x02, 0x03, 0x04, 0x05, 0x06, 0x07, 0x08, 0x09,0x0a, 0x0b, 0x0c, 0x0d, 0x0e, 0x0f\n                  };\nAlgorithmParameterSpec params = new IvParameterSpec(ivar );\ndcipher = Cipher.getInstance(\"AES/CBC/PKCS5Padding\");\ndcipher.init(Cipher.DECRYPT_MODE, key, params );\n", "idx": 2110}
{"project": "cipher", "commit_id": "Snippet11987641_35944.java", "target": 0, "func": "        private void encript(byte[] data, byte[] clear) {\n\n        byte[] keyBytes = new byte[] { 0x00, 0x01, 0x02, 0x03, 0x04, 0x05, 0x06, 0x07, 0x08, 0x09,\n        0x0a, 0x0b, 0x0c, 0x0d, 0x0e, 0x0f, 0x10, 0x11, 0x12, 0x13, 0x14, 0x15, 0x16, 0x17 };\n        SecretKeySpec key = new SecretKeySpec(keyBytes, \"AES\");\n        Cipher cipher = null;\n\n        try {\n\n        cipher = Cipher.getInstance(\"AES/ECB/PKCS7Padding\", \"BC\");\n\n        }    catch (NoSuchAlgorithmException e) {\n\n        e.printStackTrace();\n        }    catch (NoSuchProviderException e) {\n\n        e.printStackTrace();\n\n        } catch (NoSuchPaddingException e) {\n\n        e.printStackTrace();\n        }\n        try {\n        cipher.init(Cipher.ENCRYPT_MODE, key);\n\n        } catch (InvalidKeyException e) {\n\n        // TODO Auto-generated catch block\n        e.printStackTrace();\n        }\n\n        byte[] cipherText = new byte[cipher.getOutputSize(data.length)];\n\n       // int ctLength = cipher.update(data, 0, data.length, cipherText, 0);\n\n        byte[] input = null;\n\n        try { \n        input = cipher.doFinal(cipherText);\n        } catch (IllegalBlockSizeException e) {\n        // TODO Auto-generated catch block\n        e.printStackTrace();\n        } catch (BadPaddingException e) {\n        // TODO Auto-generated catch block\n\n\n        e.printStackTrace();\n        }\n        try{\n        if(input.length>0){\n        Toast.makeText(getApplicationContext(), \"Image successfully encripted\", 3000).show();\n        }\n        ByteArrayInputStream bis = new ByteArrayInputStream(input);\n\n        ObjectInputStream ois = new ObjectInputStream(bis);\n\n     File encriptedfile = (File) ois.readObject();//This is the file which i want to Move to App folder\n\n            bis.close();\n        ois.close();\n        } catch (StreamCorruptedException e) {\n        // TODO Auto-generated catch block\n        e.printStackTrace();\n       } catch (IOException e) {\n        // TODO Auto-generated catch block\n        e.printStackTrace();\n       } catch (ClassNotFoundException e) {\n        // TODO Auto-generated catch block\n        e.printStackTrace();\n       }\n    return;\n    }\n     //Code for copy  image into app folder......\n    File outputFolder = new File(Environment.getExternalStorageDirectory().getAbsolutePath() + File.separator + \".map\");\n         try {\n          FileUtils.copyFile (encriptedfile, outputFolder);\n          } \n          catch (IOException e) {\n          Log.e(\"photomover\", e.toString());\n          }\n}\n", "idx": 1852}
{"project": "cipher", "commit_id": "Snippet47516485_29522.java", "target": 0, "func": "//imports here\npublic class Main \n\n    public static void main(String[] args) {\n\n\n        try {\n            String text = \"this text will be encrypted\";\n\n            String key = \"Bar12345Bar12345\";\n\n            //Create key and cipher\n            Key aesKey = new SecretKeySpec(key.getBytes(), \"AES\");\n            Cipher cipher = Cipher.getInstance(\"AES\");\n\n            //encrypt text\n            cipher.init(Cipher.ENCRYPT_MODE, aesKey);\n            byte[] encrypted = cipher.doFinal(text.getBytes());\n            write(new String(encrypted));\n\n        } catch (NoSuchAlgorithmException | NoSuchPaddingException | InvalidKeyException | IllegalBlockSizeException | BadPaddingException e) {\n            e.printStackTrace();\n        }\n\n    }\n\n    public static void write(String message) {\n        BufferedWriter bw = null;\n        FileWriter fw = null;\n\n        try {\n\n            String data = message;\n\n            File file = new File(FILENAME);\n            if (!file.exists()) {\n                file.createNewFile();\n            }\n\n\n            fw = new FileWriter(file.getAbsoluteFile(), true);\n            bw = new BufferedWriter(fw);\n\n            bw.write(data);\n\n        } catch (IOException e) {\n\n            e.printStackTrace();\n\n        } finally {\n\n            try {\n\n                if (bw != null)\n                    bw.close();\n\n                if (fw != null)\n                    fw.close();\n\n            } catch (IOException ex) {\n\n                ex.printStackTrace();\n\n            }\n        }\n    }\n\n}\n", "idx": 1590}
{"project": "cipher", "commit_id": "Snippet12076851_36026.java", "target": 1, "func": "Cipher cipher = Cipher.getInstance(\"AES/CBC/PKCS5Padding\");\ncipher.init(Cipher.ENCRYPT_MODE, sKey);\nString ivBase64 = Base64.encodeBytes(cipher.getParameters().getEncoded());\n", "idx": 2002}
{"project": "cipher", "commit_id": "Snippet39209818_21080.java", "target": 0, "func": "public static void encryptFile(String inFileName, String outFileName, char[] pass) throws IOException, GeneralSecurityException {\n    Cipher cipher = PasswordProtectFile.makeCipher(pass, true);\n    try (CipherOutputStream cipherOutputStream = new CipherOutputStream(new FileOutputStream(outFileName), cipher);\n            BufferedInputStream bis = new BufferedInputStream(new FileInputStream(inFileName))) {\n        int i;\n        while ((i = bis.read()) != -1) {\n            cipherOutputStream.write(i);\n        }\n    }\n}\n\npublic static void decryptFile(String inFileName, String outFileName, char[] pass) throws GeneralSecurityException, IOException {\n    Cipher cipher = PasswordProtectFile.makeCipher(pass, false);\n    try (CipherInputStream cipherInputStream = new CipherInputStream(new FileInputStream(inFileName), cipher);\n            BufferedOutputStream bos = new BufferedOutputStream(new FileOutputStream(outFileName))) {\n        int i;\n        while ((i = cipherInputStream.read()) != -1) {\n            bos.write(i);\n        }\n    }\n}\n\nprivate static Cipher makeCipher(char[] pass, Boolean decryptMode) throws GeneralSecurityException {\n\n    // Use a KeyFactory to derive the corresponding key from the passphrase:\n    PBEKeySpec keySpec = new PBEKeySpec(pass);\n    SecretKeyFactory keyFactory = SecretKeyFactory.getInstance(\"PBEWithMD5AndDES\");\n    SecretKey key = keyFactory.generateSecret(keySpec);\n\n    // Create parameters from the salt and an arbitrary number of iterations:\n    PBEParameterSpec pbeParamSpec = new PBEParameterSpec(salt, 43);\n\n    // Set up the cipher:\n    Cipher cipher = Cipher.getInstance(\"PBEWithMD5AndDES\");\n\n    // Set the cipher mode to decryption or encryption:\n    if (decryptMode) {\n        cipher.init(Cipher.ENCRYPT_MODE, key, pbeParamSpec);\n    } else {\n        cipher.init(Cipher.DECRYPT_MODE, key, pbeParamSpec);\n    }\n\n    return cipher;\n}\n", "idx": 1677}
{"project": "cipher", "commit_id": "Snippet34025053_16083.java", "target": 1, "func": "cipher = Cipher.getInstance(\"AES/CBC/PKCS5Padding\"); // or better \"AES/GCM/NoPadding\"\nstream = new CipherInputStream(cipher);\n", "idx": 2078}
{"project": "cipher", "commit_id": "Snippet6692671_32290.java", "target": 1, "func": "public class Fileencrypt {\n\n     public static void main(String args[])  throws IOException, InvalidKeyException, java.security.InvalidKeyException, NoSuchAlgorithmException, NoSuchPaddingException, KeyStoreException, CertificateException, CertificateEncodingException, IllegalStateException, NoSuchProviderException, SignatureException, UnrecoverableKeyException{   \n     try{ \n\n         byte[] plainData;\n         byte[] encryptedData = null;\n\n         KeyPairGenerator kpg = KeyPairGenerator.getInstance(\"RSA\");\n         kpg.initialize(2048);\n         KeyPair kp = kpg.genKeyPair();\n         PublicKey publicKey = kp.getPublic();\n         PrivateKey privateKey = kp.getPrivate();\n\n\n\n         Cipher cipher = Cipher.getInstance(\"RSA\");\n         cipher.init(Cipher.ENCRYPT_MODE, publicKey);\n\n         try { \n         X509EncodedKeySpec x509EncodedKeySpec = new X509EncodedKeySpec(publicKey.getEncoded());\n        FileOutputStream fos = new FileOutputStream(\"C:\\\\Output\\\\Publickey.txt\");\n        fos.write(x509EncodedKeySpec.getEncoded());\n        fos.close();\n        // Store Private Key.\n        PKCS8EncodedKeySpec pkcs8EncodedKeySpec = new PKCS8EncodedKeySpec(privateKey.getEncoded());\n        fos = new FileOutputStream(\"C:\\\\Output\\\\Privatekey.txt\");\n        fos.write(pkcs8EncodedKeySpec.getEncoded());\n        fos.close();\n        } catch (IOException e) {\n            System.out.println(e.getMessage());\n        }\n\n\n\n\n\n         File f = new File(\"C:\\\\Output\\\\text.txt\");\n         FileInputStream in = new FileInputStream(f);\n         plainData = new byte[(int)f.length()];\n         in.read(plainData);\n\n         try {\n            encryptedData = cipher.doFinal(plainData);\n        } catch (IllegalBlockSizeException e) {\n\n            e.printStackTrace();\n        } catch (BadPaddingException e) {\n\n            e.printStackTrace();\n        }\n\n        System.out.println(encryptedData); \n        FileOutputStream target = new FileOutputStream(new File(\"C:\\\\Output\\\\encrypted.txt\"));\n         target.write(encryptedData);\n         target.close();   \n     }   \n     catch(IOException e){e.printStackTrace();}   \n     catch(InvalidKeyException ei){ei.printStackTrace();\n     }   \n     }   \n   }\n", "idx": 2095}
{"project": "cipher", "commit_id": "Snippet7523169_32757.java", "target": 0, "func": "import java.security.*;\nimport java.security.cert.*;\nimport java.security.interfaces.*;\nimport java.security.spec.*;\nimport javax.crypto.*;\nimport javax.crypto.interfaces.*;\nimport javax.crypto.spec.*;\nimport java.io.*;\n/**\n *  AES\n */\npublic class SymmetricAES {\n\n    public SymmetricAES() {\n    }\n\n    public static void main(String args[]){\n        BufferedReader ch = new BufferedReader(new InputStreamReader(System.in));\n        char[] toCode;\n        byte[] toCode2;\n        byte[] Coded;\n        char[] Coded2;\n        byte[] decoded;\n        char[] deco2;\n\n        try{\n            System.out.print(\"Text to Encrypt : \");\n            String toMake = ch.readLine();\n\n            /** Arxikopoihsh antikeimenou KeyGenerator gia AES\n             *  kai dhmhourgia Kleidioy */\n            KeyGenerator keyGen = KeyGenerator.getInstance(\"AES\");\n            SecretKey aesKey = keyGen.generateKey();\n\n            /* Arxikopoihsh aesCipher gia AES */\n            Cipher aesCipher = Cipher.getInstance(\"AES\");\n\n            /* Orismos aesCipher se ENCRYPT_MODE me to aesKey */\n            aesCipher.init(Cipher.ENCRYPT_MODE, aesKey);\n            System.out.println(\"The Key : \" + aesKey.getEncoded());\n\n            /* Metatroph antikeimenou String se pinaka Char\n             * kai o ka8e xarakthras gineta Cast se Byte kai eisagwgh\n             * se pinaka Byte isou mege8ous me ton prwto pinaka */\n            toCode = toMake.toCharArray();\n            toCode2 = new byte[toCode.length];\n            Coded = new byte[toCode.length];\n            for(int i=0;i<toCode.length;i++)\n                toCode2[i] = (byte)toCode[i];\n\n            /* Teliko stadio Kryptografhshs */\n            Coded = aesCipher.doFinal(toCode2);\n\n            /* byte[] --> char[] kai ektypwsh*/\n            Coded2 = new char[Coded.length];\n            for(int i=0;i<Coded.length;i++)\n                Coded2[i] = (char)Coded[i];\n            System.out.println(\"Test Encrypt: \" + new String(Coded2));\n\n\n            Cipher aesCipher2 = Cipher.getInstance(\"AES\");\n\n            /* Orismos aesCipher2 se DECRYPT_MODE me to aesKey */\n            aesCipher2.init(Cipher.DECRYPT_MODE, aesKey);\n\n            decoded = aesCipher2.doFinal(Coded);\n\n            /* byte[] --> char[] kai ektypwsh*/\n            deco2 = new char[decoded.length];\n            for(int i=0;i<decoded.length;i++)\n                deco2[i] = (char)decoded[i];\n            System.out.println(\"Test Decrypt: \" + new String(deco2));\n        }\n        catch(Exception e){\n            System.out.println(e);\n        }   \n    }\n}\n", "idx": 1787}
{"project": "cipher", "commit_id": "Snippet31853378_13914.java", "target": 0, "func": " public String encrypt(String value) throws GeneralSecurityException {\n    Cipher encryptCipher = Cipher.getInstance(\"DES\");\n    SecretKeyFactory  keyFactory = SecretKeyFactory.getInstance(\"DES\");\n    String salt=\"\";\n    SecretKey sk = keyFactory.generateSecret(new DESKeySpec(salt.getBytes()));\n    encryptCipher.init(Cipher.ENCRYPT_MODE, sk);\n    return new String(Base64.encodeBase64(encryptCipher.doFinal(value.getBytes())));\n}\n", "idx": 1739}
{"project": "cipher", "commit_id": "Snippet15427383_38471.java", "target": 1, "func": "public class Main extends Activity {\n\n    // Decrypt tester\n\n    @Override\n    protected void onCreate(Bundle savedInstanceState) {\n        // TODO Auto-generated method stub\n        super.onCreate(savedInstanceState);\n        setContentView(R.layout.activity_main);\n        String plainText = \"hello\";\n        // Base64 Encoded\n        String encryptedText = \"SWfL6wpS87SsvByIfLO1W5Gg/gOMqtplNtqBrDELfQav0ipCy0BddHpTlmlgQO+6HRY2JWsw6hp5rlmmBJG722Ujc4Rm5MZr8BbKWMgX89rvmvUG/YeswTjHZsrzbx6k6krChM55dsJCU3JSXPMIcTTgRxVValgLeCfX1SwoOpNZ2m4WQAhX6NrSYwSXGLUHfrguQogTpU5wEcDQ0HR4vBlQO5fU8z2MwoP50Vs8f+4EysEwSy9ezsYHWDtW8M9t3EuF8Roq++/Y8GLASrYZxuAA0IPHGvR9Qufa04i7HlAAsDu9LQuOGUf35KkpFoCx0XyuA0qppccGdqHuK5IIoQ==\";\n        try {\n            String encrypted = encrypt(getAssets().open(\"public_key.der\"), plainText);\n            Log.d(\"Encrypted\", encrypted);\n            // Returns a base64 encoded string.\n\n            Log.d(\"TAG\", \"Decryption start\");\n\n            String decrypted = decrypt(getAssets().open(\"public_key.der\"), encryptedText);\n            Log.d(\"Decrypted\", decrypted);\n        } catch (Exception e) {\n            Log.e(\"TEST\", Log.getStackTraceString(e));\n        }\n    }\n\n    public static String encrypt(InputStream stream, String plaintext) throws IOException, NoSuchAlgorithmException, InvalidKeySpecException,\n            NoSuchPaddingException, InvalidKeyException, IllegalBlockSizeException, BadPaddingException {\n\n        byte[] encodedKey = new byte[stream.available()];\n        stream.read(encodedKey);\n        X509EncodedKeySpec publicKeySpec = new X509EncodedKeySpec(encodedKey);\n        KeyFactory kf = KeyFactory.getInstance(\"RSA\");\n        PublicKey pkPublic = kf.generatePublic(publicKeySpec);\n\n        Cipher pkCipher = Cipher.getInstance(\"RSA/ECB/PKCS1PADDING\");\n        pkCipher.init(Cipher.ENCRYPT_MODE, pkPublic);\n        byte[] encryptedInByte = pkCipher.doFinal(plaintext.getBytes());\n\n        String encryptedInString = new String(Base64Coder.encode(encryptedInByte));\n\n        return encryptedInString;\n    }\n\n    public static String decrypt(InputStream stream, String encrypted) throws IOException, NoSuchAlgorithmException, InvalidKeySpecException,\n            NoSuchPaddingException, InvalidKeyException, IllegalBlockSizeException, BadPaddingException {\n\n        byte[] encodedKey = new byte[stream.available()];\n        stream.read(encodedKey);\n        X509EncodedKeySpec publicKeySpec = new X509EncodedKeySpec(encodedKey);\n        KeyFactory kf = KeyFactory.getInstance(\"RSA\");\n        PublicKey pkPublic = kf.generatePublic(publicKeySpec);\n\n        Cipher pkCipher = Cipher.getInstance(\"RSA/ECB/PKCS1PADDING\");\n        pkCipher.init(Cipher.DECRYPT_MODE, pkPublic);\n        byte[] decryptedInByte = pkCipher.doFinal(encrypted.getBytes());\n        String decryptedInString = new String(Base64Coder.encode(decryptedInByte));\n        return decryptedInString;\n    }\n}\n", "idx": 1954}
{"project": "cipher", "commit_id": "Snippet19219685_2047.java", "target": 1, "func": "public class MyCrypter {\n\nprivate static String TAG = \"MyCrypter\";\n\npublic MyCrypter() {\n\n}\n\n/**\n * Encodes a String in AES-128 with a given key\n * \n * @param context\n * @param password\n * @param text\n * @return String Base64 and AES encoded String\n * @throws NoPassGivenException\n * @throws NoTextGivenException\n */\npublic String encode(Context context, String password, String text)\n        throws NoPassGivenException, NoTextGivenException {\n    if (password.length() == 0 || password == null) {\n        throw new NoPassGivenException(\"Please give Password\");\n    }\n\n    if (text.length() == 0 || text == null) {\n        throw new NoTextGivenException(\"Please give text\");\n    }\n\n    try {\n        SecretKeySpec skeySpec = getKey(password);\n        byte[] clearText = text.getBytes(\"UTF8\");\n\n        //IMPORTANT TO GET SAME RESULTS ON iOS and ANDROID\n        final byte[] iv = new byte[16];\n        Arrays.fill(iv, (byte) 0x00);\n        IvParameterSpec ivParameterSpec = new IvParameterSpec(iv);\n\n        // Cipher is not thread safe\n        Cipher cipher = Cipher.getInstance(\"AES/CBC/PKCS7Padding\");\n        cipher.init(Cipher.ENCRYPT_MODE, skeySpec, ivParameterSpec);\n\n        String encrypedValue = Base64.encodeToString(\n                cipher.doFinal(clearText), Base64.DEFAULT);\n        Log.d(TAG, \"Encrypted: \" + text + \" -> \" + encrypedValue);\n        return encrypedValue;\n\n    } catch (InvalidKeyException e) {\n        e.printStackTrace();\n    } catch (UnsupportedEncodingException e) {\n        e.printStackTrace();\n    } catch (NoSuchAlgorithmException e) {\n        e.printStackTrace();\n    } catch (BadPaddingException e) {\n        e.printStackTrace();\n    } catch (NoSuchPaddingException e) {\n        e.printStackTrace();\n    } catch (IllegalBlockSizeException e) {\n        e.printStackTrace();\n    } catch (InvalidAlgorithmParameterException e) {\n        e.printStackTrace();\n    }\n    return \"\";\n}\n\n/**\n * Decodes a String using AES-128 and Base64\n * \n * @param context\n * @param password\n * @param text\n * @return desoded String\n * @throws NoPassGivenException\n * @throws NoTextGivenException\n */\npublic String decode(Context context, String password, String text)\n        throws NoPassGivenException, NoTextGivenException {\n\n    if (password.length() == 0 || password == null) {\n        throw new NoPassGivenException(\"Please give Password\");\n    }\n\n    if (text.length() == 0 || text == null) {\n        throw new NoTextGivenException(\"Please give text\");\n    }\n\n    try {\n        SecretKey key = getKey(password);\n\n        //IMPORTANT TO GET SAME RESULTS ON iOS and ANDROID\n        final byte[] iv = new byte[16];\n        Arrays.fill(iv, (byte) 0x00);\n        IvParameterSpec ivParameterSpec = new IvParameterSpec(iv);\n\n        byte[] encrypedPwdBytes = Base64.decode(text, Base64.DEFAULT);\n        // cipher is not thread safe\n        Cipher cipher = Cipher.getInstance(\"AES/CBC/PKCS7Padding\");\n        cipher.init(Cipher.DECRYPT_MODE, key, ivParameterSpec);\n        byte[] decrypedValueBytes = (cipher.doFinal(encrypedPwdBytes));\n\n        String decrypedValue = new String(decrypedValueBytes);\n        Log.d(TAG, \"Decrypted: \" + text + \" -> \" + decrypedValue);\n        return decrypedValue;\n\n    } catch (InvalidKeyException e) {\n        e.printStackTrace();\n    } catch (UnsupportedEncodingException e) {\n        e.printStackTrace();\n    } catch (NoSuchAlgorithmException e) {\n        e.printStackTrace();\n    } catch (BadPaddingException e) {\n        e.printStackTrace();\n    } catch (NoSuchPaddingException e) {\n        e.printStackTrace();\n    } catch (IllegalBlockSizeException e) {\n        e.printStackTrace();\n    } catch (InvalidAlgorithmParameterException e) {\n        e.printStackTrace();\n    }\n    return \"\";\n}\n\n/**\n * Generates a SecretKeySpec for given password\n * @param password\n * @return SecretKeySpec\n * @throws UnsupportedEncodingException\n */\npublic SecretKeySpec getKey(String password)\n        throws UnsupportedEncodingException {\n\n\n    int keyLength = 128;\n    byte[] keyBytes = new byte[keyLength / 8];\n    // explicitly fill with zeros\n    Arrays.fill(keyBytes, (byte) 0x0);\n\n    // if password is shorter then key length, it will be zero-padded\n    // to key length\n    byte[] passwordBytes = password.getBytes(\"UTF-8\");\n    int length = passwordBytes.length < keyBytes.length ? passwordBytes.length\n            : keyBytes.length;\n    System.arraycopy(passwordBytes, 0, keyBytes, 0, length);\n    SecretKeySpec key = new SecretKeySpec(keyBytes, \"AES\");\n    return key;\n}\n\npublic class NoTextGivenException extends Exception {\n    public NoTextGivenException(String message) {\n        super(message);\n    }\n\n}\n\npublic class NoPassGivenException extends Exception {\n    public NoPassGivenException(String message) {\n        super(message);\n    }\n\n}\n\n}\n", "idx": 1953}
{"project": "cipher", "commit_id": "Snippet36253719_18117.java", "target": 1, "func": "// Generate key pair.\nKeyPairGenerator kpg = KeyPairGenerator.getInstance(\"RSA\");\nkpg.initialize(1024, new SecureRandom());\nKeyPair keyPair = kpg.genKeyPair();\nPublicKey publicKey = keyPair.getPublic();\nPrivateKey privateKey = keyPair.getPrivate();\n\n// Data to encode/decode.\nbyte[] original = \"The quick brown fox jumps over the lazy dog.\".getBytes(\"UTF8\");\n\n// Encode data with public key.\nCipher cipherEncoder = Cipher.getInstance(\"RSA/ECB/PKCS1Padding\");\ncipherEncoder.init(Cipher.ENCRYPT_MODE, publicKey);\nbyte[] encodedData = cipherEncoder.doFinal(original);\n\n// Decode data with private key.\nCipher cipherDecoder = Cipher.getInstance(\"RSA/ECB/PKCS1Padding\");\ncipherDecoder.init(Cipher.DECRYPT_MODE, privateKey);\nbyte[] decodedData = cipherDecoder.doFinal(encodedData);\n\n// Output.\nSystem.out.println(new String(\"Original data:   \" + new String(original, \"UTF8\")));\nSystem.out.println(new String(\"Encoded/decoded: \" + new String(decodedData, \"UTF8\")));\n", "idx": 2311}
{"project": "cipher", "commit_id": "Snippet25036826_7358.java", "target": 0, "func": "public class AESencrp {\n\n     private static final String ALGO = \"AES\";\n    private static final byte[] keyValue = \n        new byte[] { 'T', 'h', 'e', 'B', 'e', 's', 't',\n'S', 'e', 'c', 'r','e', 't', 'K', 'e', 'y' };\n\npublic static String encrypt(String Data) throws Exception {\n        Key key = generateKey();\n        Cipher c = Cipher.getInstance(ALGO);\n        c.init(Cipher.ENCRYPT_MODE, key);\n        byte[] encVal = c.doFinal(Data.getBytes());\n        String encryptedValue = new BASE64Encoder().encode(encVal);\n        return encryptedValue;\n    }\n\n    public static String decrypt(String encryptedData) throws Exception {\n        Key key = generateKey();\n        Cipher c = Cipher.getInstance(ALGO);\n        c.init(Cipher.DECRYPT_MODE, key);\n        byte[] decordedValue = new BASE64Decoder().decodeBuffer(encryptedData);\n        byte[] decValue = c.doFinal(decordedValue);\n        String decryptedValue = new String(decValue);\n        return decryptedValue;\n    }\n    private static Key generateKey() throws Exception {\n        Key key = new SecretKeySpec(keyValue, ALGO);\n        return key;\n}\n\n}\n", "idx": 1771}
{"project": "cipher", "commit_id": "Snippet27839578_9993.java", "target": 0, "func": "public AES()\n    {\n        try\n        {\n            Security.addProvider(new BouncyCastleProvider());\n            cipher = Cipher.getInstance(\"AES/ECB/PKCS7Padding\", \"BC\");\n\n        } catch (NoSuchProviderException e) {\n            e.printStackTrace();\n        } catch (NoSuchPaddingException e) {\n            e.printStackTrace();\n        } catch (NoSuchAlgorithmException e) {\n            e.printStackTrace();\n        }\n    }\n\n\n    public String doDecrypt(String key, String cipherText)\n    {\n        try\n        {\n            byte[] raw = key.getBytes(Charset.forName(\"UTF-8\"));\n            SecretKeySpec skey = new SecretKeySpec(raw, \"AES\");\n            cipher.init(Cipher.DECRYPT_MODE, skey );\n            return new String(cipher.doFinal(Base64.decode(cipherText,Base64.DEFAULT)), Charset.forName(\"UTF-8\"));\n\n        } catch (BadPaddingException e) {\n            e.printStackTrace();\n        } catch (IllegalBlockSizeException e) {\n            e.printStackTrace();\n        } catch (InvalidKeyException e) {\n            e.printStackTrace();\n        }\n        return null;\n    }\n\n    public String doEncrypt(String key, String plainText)\n    {\n        try\n        {\n            byte[] raw = key.getBytes(Charset.forName(\"UTF-8\"));\n            SecretKeySpec skey = new SecretKeySpec(raw, \"AES\");\n            cipher.init(Cipher.ENCRYPT_MODE, skey );\n            return Base64.encodeToString(cipher.doFinal(plainText.getBytes(Charset.forName(\"UTF-8\"))),Base64.DEFAULT);\n\n        } catch (BadPaddingException e) {\n            e.printStackTrace();\n        } catch (IllegalBlockSizeException e) {\n            e.printStackTrace();\n        } catch (InvalidKeyException e) {\n            e.printStackTrace();\n        }\n        return null;\n    }\n}\n", "idx": 1913}
{"project": "cipher", "commit_id": "Snippet46704765_28785.java", "target": 0, "func": "public static byte[] decodeFile(byte[] key, byte[] fileData) {\n    SecretKeySpec skeySpec = new SecretKeySpec(key, \"AES\");\n    byte[] decrypted = null;\n    try {\n        Cipher cipher = Cipher.getInstance(\"AES\");\n        cipher.init(Cipher.DECRYPT_MODE, skeySpec);\n        decrypted = cipher.doFinal(fileData);\n    } catch (NoSuchAlgorithmException | NoSuchPaddingException e) {\n        // TODO Auto-generated catch block\n        e.printStackTrace();\n    } catch (InvalidKeyException e) {\n        // TODO Auto-generated catch block\n        e.printStackTrace();\n    } catch (IllegalBlockSizeException | BadPaddingException e) {\n        // TODO Auto-generated catch block\n        e.printStackTrace();\n    } catch(Exception e){\n        // for all other exception\n        e.printStackTrace();\n    }\n    return decrypted;\n}\n", "idx": 1588}
{"project": "cipher", "commit_id": "Snippet42010078_23978.java", "target": 0, "func": "    public String decode(AssetManager assets) throws GeneralSecurityException, UnsupportedEncodingException {\n    String encryptedText = null;\n    Security.addProvider(new org.bouncycastle.jce.provider.BouncyCastleProvider());\n    SecretKeySpec key = new SecretKeySpec(\"testPass\".getBytes(), \"Blowfish\");\n    try {\n        byte[] encryptedBytes = readFile(\"RequestManager/RM.dat\", assets).getBytes(\"UTF-8\");\n        Cipher cipher = Cipher.getInstance(\"Blowfish/ECB/PKCS5Padding\");\n        cipher.init(Cipher.DECRYPT_MODE, key);\n        byte[] decrypted = cipher.doFinal(org.bouncycastle.util.encoders.Base64.decode(encryptedBytes));\n        return new String(decrypted);\n    } catch (Exception e) {\n        e.printStackTrace();\n        return null; }\n}\n", "idx": 1821}
{"project": "cipher", "commit_id": "Snippet46570108_28703.java", "target": 1, "func": "var encrypted_str = \"N0dHcFM3MnQrcW1HUk9UTGwxeUJsZmlCNzcwUGhrdUdtbE9YWnUxamZFST0tLUVUcUlIU2k1ZHIvTmlDRUgzM2FsS0E9PQ==--1ede80eb2b498ddf5133f8f3a45a82db2476c740\"\n\nval parts = encrypted_str.split(\"--\");\n\nval encryptedData = Base64.decodeBase64(parts(0))\n\nval iv = Base64.decodeBase64(parts(1))\n\nval cipher = Cipher.getInstance(\"AES/CBC/PKCS5Padding\");\ncipher.init(Cipher.DECRYPT_MODE, aesKey, new IvParameterSpec(iv.take(16)));\n\nval result = cipher.doFinal(encryptedData);\nprintln(new String(result, \"UTF-8\"))\n", "idx": 1985}
{"project": "cipher", "commit_id": "Snippet22156779_4561.java", "target": 0, "func": "import java.io.ByteArrayOutputStream;\nimport java.io.UnsupportedEncodingException;\nimport java.math.BigInteger;\nimport java.nio.charset.Charset;\nimport javax.crypto.*;\nimport java.security.*;\nimport java.util.Arrays;\nimport javax.crypto.spec.*;\nimport org.apache.commons.codec.DecoderException;\nimport org.apache.commons.codec.binary.Base64;\n\nimport org.apache.commons.codec.binary.Hex;\n\npublic class AESCrypto2 {\n\nprivate Cipher AEScipher;\nprivate KeyGenerator AESgen;\nprivate SecretKeySpec AESkey;\nprivate SecretKeySpec decodeKey;\nprivate String hexDecodeKey;\nprivate String decodeKey64;\nprivate byte[] cipherData;\nprivate String msg;\nprivate String encMsg;\n\npublic static void main(String[] args) {\n    try {\n        AESCrypto2 a = new AESCrypto2();\n        a.encrypt(\"Hello!\");\n        try {\n            a.decrypt(a.getEncryptedMsg(), a.getDecodeKey());\n        } catch (DecoderException ex) {\n            ex.printStackTrace();\n        }\n    } catch (NoSuchAlgorithmException ex) {\n        ex.printStackTrace();\n    } catch (NoSuchPaddingException ex) {\n        ex.printStackTrace();\n    } catch (InvalidKeyException ex) {\n        ex.printStackTrace();\n    } catch (UnsupportedEncodingException ex) {\n        ex.printStackTrace();\n    } catch (IllegalBlockSizeException ex) {\n        ex.printStackTrace();\n    } catch (BadPaddingException ex) {\n        ex.printStackTrace();\n    }\n\n}\n\npublic AESCrypto2() throws NoSuchAlgorithmException, NoSuchPaddingException,\n        UnsupportedEncodingException {\n    AESgen = KeyGenerator.getInstance(\"AES\");\n    AESgen.init(128);\n    AESkey = (SecretKeySpec) AESgen.generateKey();\n    decodeKey = new SecretKeySpec(AESkey.getEncoded(), \"AES\");\n    hexDecodeKey = keyToString(decodeKey);\n    AEScipher = Cipher.getInstance(\"AES/ECB/NoPadding\");\n}\n\npublic AESCrypto2(String msg) throws NoSuchAlgorithmException,\n        NoSuchPaddingException, InvalidKeyException,\n        UnsupportedEncodingException, IllegalBlockSizeException,\n        BadPaddingException {\n    this();\n    encrypt(msg);\n}\n\npublic String encrypt(String msg) throws NoSuchAlgorithmException,\n        InvalidKeyException, UnsupportedEncodingException,\n        IllegalBlockSizeException, BadPaddingException, NoSuchPaddingException {\n    AEScipher.init(Cipher.ENCRYPT_MODE, AESkey);\n    cipherData = AEScipher.doFinal(handleString(msg.getBytes(\"UTF-8\")));\n\n    this.msg = msg;\n    encMsg = stringToHex(new String(cipherData));\n    return encMsg;\n}\n\npublic String decrypt(String msg, String hexDecodeKey) throws\n        InvalidKeyException, IllegalBlockSizeException,\n        BadPaddingException, UnsupportedEncodingException,\n        NoSuchAlgorithmException, NoSuchPaddingException, DecoderException {\n    AEScipher.init(Cipher.DECRYPT_MODE, stringToKey(hexDecodeKey));\n    byte[] decryptedData = AEScipher.doFinal(handleString(hexToString(msg).getBytes(\"UTF-8\")));\n    encMsg = msg;\n    msg = new String(decryptedData);\n    System.out.println(msg);\n    return msg;\n}\n\npublic String getEncryptedMsg() {\n    return encMsg;\n}\n\npublic String getDecryptedMsg() {\n    return msg;\n}\n\npublic String getDecodeKey() {\n    return hexDecodeKey;\n}\n\npublic SecretKeySpec getKey() {\n    return decodeKey;\n}\n\n//AEScipher requires that 16 divides the length of b\npublic static byte[] handleString(byte[] b) throws UnsupportedEncodingException {\n    byte[] temp = b;\n    if (temp.length % 16 != 0) {\n        byte[] byteMsg = Arrays.copyOf(temp, temp.length + 16 - (temp.length % 16));\n        return byteMsg;\n    }\n    return temp;\n}\n\npublic static String keyToString(SecretKeySpec key) {\n    String decoded = Hex.encodeHexString(key.getEncoded());\n    return decoded;\n}\n\npublic static SecretKeySpec stringToKey(String key) throws DecoderException {\n    byte[] decodedKey = Hex.decodeHex(key.toCharArray());\n    return new SecretKeySpec(decodedKey, 0, decodedKey.length, \"AES\");\n}\n\npublic static String stringToHex(String msg) throws UnsupportedEncodingException {\n    return Hex.encodeHexString(msg.getBytes(\"UTF-8\"));\n}\n\npublic static String hexToString(String msg) throws DecoderException {\n    return new String(Hex.decodeHex(msg.toCharArray()));\n}\n", "idx": 1733}
{"project": "cipher", "commit_id": "Snippet16192140_39149.java", "target": 0, "func": "Cipher aes = Cipher.getInstance(\"AES/ECB/PKCS5Padding\"); //I am passing the padding too\naes.init(Cipher.DECRYPT_MODE, generateKey());\nbyte[] ciphertext = aes.doFinal(rawPassword.getBytes());\n", "idx": 1752}
{"project": "cipher", "commit_id": "Snippet27070108_9234.java", "target": 1, "func": "    byte[] dataToEncrypt = temp.getBytes(StandardCharsets.UTF_8); //temp is a String\n    byte[] encryptedData = null;\n\n    Cipher cipher = Cipher.getInstance(\"RSA\");\n    //cipher.init(Cipher.ENCRYPT_MODE, serverPubKey);\n    cipher.init(Cipher.ENCRYPT_MODE, pubKey);\n    encryptedData = cipher.doFinal(dataToEncrypt);\n    String cipherStr = Base64.encodeToString(encryptedData,Base64.DEFAULT);\n", "idx": 2181}
{"project": "cipher", "commit_id": "Snippet46576918_28705.java", "target": 0, "func": "public static KeyGenerator key_gen = null;\npublic static SecretKey sec_key = null;\npublic static byte[] raw = null;\nprivate static SecretKeySpec sec_key_spec = null;\nprivate static Cipher sec_cipher = null;\n\n//for DSA\nprivate static KeyPairGenerator keypairgen = null;\nprivate static KeyPair keypair = null;\nprivate static DSAPrivateKey private_key = null;\nprivate static DSAPublicKey public_key = null;\nprivate static Signature dsa_sig = null;\nprivate static SecureRandom secRan = null;\n\npublic static void main(String args[]){\n    FileInputStream in_file = null;\n    FileInputStream in_file2 = null;\n    FileOutputStream out_file = null;\n    byte[] sha_hash = null;\n    //byte[] hmac_hash = null;\n    byte[] aes_ciphertext = null;\n    int read_bytes = 0;\n\n    try{\n        //open files\n        in_file = new FileInputStream(args[0]);\n        out_file = new FileOutputStream(\"CipherText.txt\");\n        byte[] seed = args[1].getBytes();\n\n        //read file into a byte array\n        byte[] msg = new byte[in_file.available()];\n        read_bytes = in_file.read(msg);\n\n        //SHA-1 Hash\n        sha_hash = sha1_hash(msg);\n        byte[] concatenatedMSG = new byte[msg.length + sha_hash.length];\n\n        for (int i = 0; i < concatenatedMSG.length; i++)\n        {\n            if(i < msg.length)\n                concatenatedMSG[i] = msg[i];\n            else\n                concatenatedMSG[i] = sha_hash[i - msg.length];\n\n        }\n\n        //print out hash in hex\n        System.out.println(\"SHA-1 Hash: \" + toHexString(sha_hash));\n\n        //encrypt file with AES\n        //key setup - generate 128 bit key\n\n        SecureRandom rand = new SecureRandom();\n        rand.setSeed(seed);\n\n        key_gen = KeyGenerator.getInstance(\"AES\");\n        key_gen.init(128, rand);\n        sec_key = key_gen.generateKey();\n\n        //get key material in raw form\n        raw = sec_key.getEncoded();\n        sec_key_spec = new SecretKeySpec(raw, \"AES\");\n\n        //create the cipher object that uses AES as the algorithm\n        sec_cipher = Cipher.getInstance(\"AES\"); \n\n        //do AES encryption\n        aes_ciphertext = aes_encrypt(concatenatedMSG);\n        out_file.write(aes_ciphertext);\n        out_file.close();\n    }\n    catch(Exception e){\n        e.printStackTrace();\n    }\n    finally{\n\n        try{\n            if (in_file != null){\n                in_file.close();\n            }\n            if(out_file != null){\n                out_file.close();\n            }\n            if(in_file2 != null){\n                in_file2.close();\n            }\n        }catch(Exception e)\n        {\n            e.printStackTrace();\n        }\n\n    }\n}\n", "idx": 1811}
{"project": "cipher", "commit_id": "Snippet17465732_661.java", "target": 0, "func": "import java.security.MessageDigest;\nimport java.util.Arrays;\n\nimport javax.crypto.Cipher;\nimport javax.crypto.SecretKey;\nimport javax.crypto.spec.IvParameterSpec;\nimport javax.crypto.spec.SecretKeySpec;\n\npublic class TripleDESTest {\n\n    public static void main(String[] args) throws Exception {\n\n        String text = \"kyle boon\";\n\n        byte[] codedtext = new TripleDESTest().encrypt(text);\n        String decodedtext = new TripleDESTest().decrypt(codedtext);\n\n        System.out.println(codedtext); // this is a byte array, you'll just see a reference to an array\n        System.out.println(decodedtext); // This correctly shows \"kyle boon\"\n    }\n\n    public byte[] encrypt(String message) throws Exception {\n        final MessageDigest md = MessageDigest.getInstance(\"SHA-1\");\n        final byte[] digestOfPassword = md.digest(\"HG58YZ3CR9\"\n                .getBytes(\"utf-8\"));\n        final byte[] keyBytes = Arrays.copyOf(digestOfPassword, 24);\n        for (int j = 0, k = 16; j < 8;) {\n            keyBytes[k++] = keyBytes[j++];\n        }\n\n        final SecretKey key = new SecretKeySpec(keyBytes, \"DESede\");\n        final IvParameterSpec iv = new IvParameterSpec(new byte[8]);\n        final Cipher cipher = Cipher.getInstance(\"DESede/CBC/PKCS5Padding\");\n        cipher.init(Cipher.ENCRYPT_MODE, key, iv);\n\n        final byte[] plainTextBytes = message.getBytes(\"utf-8\");\n        final byte[] cipherText = cipher.doFinal(plainTextBytes);\n        // final String encodedCipherText = new sun.misc.BASE64Encoder()\n        // .encode(cipherText);\n\n        return cipherText;\n    }\n\n    public String decrypt(byte[] message) throws Exception {\n        final MessageDigest md = MessageDigest.getInstance(\"SHA-1\");\n        final byte[] digestOfPassword = md.digest(\"HG58YZ3CR9\"\n                .getBytes(\"utf-8\"));\n        final byte[] keyBytes = Arrays.copyOf(digestOfPassword, 24);\n        for (int j = 0, k = 16; j < 8;) {\n            keyBytes[k++] = keyBytes[j++];\n        }\n\n        final SecretKey key = new SecretKeySpec(keyBytes, \"DESede\");\n        final IvParameterSpec iv = new IvParameterSpec(new byte[8]);\n        final Cipher decipher = Cipher.getInstance(\"DESede/CBC/PKCS5Padding\");\n        decipher.init(Cipher.DECRYPT_MODE, key, iv);\n\n        // final byte[] encData = new\n        // sun.misc.BASE64Decoder().decodeBuffer(message);\n        final byte[] plainText = decipher.doFinal(message);\n\n        return new String(plainText, \"UTF-8\");\n    }\n}\n", "idx": 1650}
{"project": "cipher", "commit_id": "Snippet41333727_23302.java", "target": 0, "func": "package main;\n\nimport java.io.UnsupportedEncodingException;\nimport java.security.InvalidKeyException;\nimport java.security.NoSuchAlgorithmException;\nimport javax.crypto.BadPaddingException;\nimport javax.crypto.Cipher;\nimport javax.crypto.IllegalBlockSizeException;\nimport javax.crypto.NoSuchPaddingException;\nimport javax.crypto.spec.IvParameterSpec;\nimport javax.crypto.spec.SecretKeySpec;\nimport javax.xml.bind.DatatypeConverter;\n\npublic class ForTest {\n    public static void main(String[] args) throws NoSuchAlgorithmException, NoSuchPaddingException, InvalidKeyException, IllegalBlockSizeException, BadPaddingException, UnsupportedEncodingException {\n        String message= \"0123456789012345\";//Message to encode\u00a0 \n        String key = \"2222222222222222\";\u00a0 \n        // 128 bit key\u00a0 -this key is processed as ASCII values\u00a0 \n        System.out.println(\"Processing 3.0 AES-128 ECB Encryption/Decryption Example\");\n        System.out.println(\"++++++++++++++++++++++++++++++++\");\n        System.out.println(\"Original Message: \" + message);\n        System.out.println(\"Key: \" + key);\n        System.out.println(\"key in bytes: \"+key.getBytes(\"UTF-8\"));\n        System.out.println(\"==========================\");           \n        //Encrypter\n        SecretKeySpec skeySpec_encode = new SecretKeySpec(key.getBytes(\"UTF-8\"), \"AES\");\n        Cipher cipher_encode  = Cipher.getInstance(\"AES/ECB/NoPadding\");\n        //          Cipher cipher_encode = Cipher.getInstance(\"AES/ECB/PKCS5PADDING\"); //AES-CBC with IV encoding, ECB is used without the IV, example shown on <a href=\"http://aesencryption.net/\" target=\"_blank\" rel=\"nofollow\">http://aesencryption.net/</a> \n        cipher_encode.init(Cipher.ENCRYPT_MODE, skeySpec_encode);\n        byte[] encrypted = cipher_encode.doFinal(message.getBytes());\n        System.out.println(\"Encrypted String (base 64): \"\n                + DatatypeConverter.printBase64Binary(encrypted));\n        //encode without padding: Base64.getEncoder().withoutPadding().encodeToString(encrypted));\n        //encode with padding:\u00a0 Base64.getEncoder().encodeToString(encrypted));\n        String base64_encrypted = DatatypeConverter.printBase64Binary(encrypted);\n        //Decrypter\n        SecretKeySpec skeySpec_decode = new SecretKeySpec(key.getBytes(\"UTF-8\"), \"AES\");\n        Cipher cipher_decode  = Cipher.getInstance(\"AES/ECB/NoPadding\");\n        //          Cipher cipher_decode = Cipher.getInstance(\"AES/ECB/PKCS5PADDING\");\n        cipher_decode.init(Cipher.DECRYPT_MODE, skeySpec_decode);\n        System.out.println(\"length: \"+\"Ouril+UTDF8htLzE\".length());\n        byte[] decrypted_original = cipher_decode.doFinal(DatatypeConverter.parseBase64Binary(\"Ouril+UTDF8htLzEhiRj7wA=\"));\n        String decrypt_originalString = new String(decrypted_original);\n        System.out.println(\"Decrypted String: \" + decrypt_originalString);\n    }\n}\n", "idx": 1716}
{"project": "cipher", "commit_id": "Snippet44041037_26106.java", "target": 1, "func": "private String decryptWithKey(String myKey, byte[] strToDecrypt) throws Exception\n{\n    MessageDigest sha = null;\n    try {\n        key = myKey.getBytes(CHAR_SCHEME);\n        sha = MessageDigest.getInstance(\"SHA-256\");\n\n        key = sha.digest(key);\n        key = Arrays.copyOf(key, 32); \n        secretKey = new SecretKeySpec(key, ALGO);\n\n        Cipher cipher = Cipher.getInstance(\"AES/CBC/NoPadding\");\n\n        byte[] ivByte = new byte[cipher.getBlockSize()];\n\n\n        ivByte = hexStringToByteArray(\"0716A494177F29F102AF33AFD0253BA1\");;\n\n        System.out.println(new String(ivByte));\n", "idx": 2192}
{"project": "cipher", "commit_id": "Snippet20071012_2739.java", "target": 0, "func": "import java.net.URLEncoder;\nimport java.security.MessageDigest;\nimport java.util.Arrays;\nimport java.io.*;\nimport java.lang.*;\nimport javax.crypto.Cipher;\nimport javax.crypto.SecretKey;\nimport javax.crypto.spec.IvParameterSpec;\nimport javax.crypto.spec.SecretKeySpec;\n\n\n    public class TRIPPLE_DES {\n\n\n        public static void main(String[] args) throws Exception {\n\n\n    String text = \"cardNumber=28293939493330&securityCode=123&cardExpiryMonth=07&cardExpiryYear=2013&cardHolderName=Test&transactionAmount=50.00&currencyCode=356&customerReferenceNo=9393938393938&cardProvider=VISA&name=Test&mobileNo=983345123412&email=test@test.com&contactNo=983345123412&password=wyzgames&amount=100&remoteIP=10.10.10.50&checkSum=92be84d25b60b3f9f233c074d12ade1ddef158cb369a0734afff3fb6adc9d7ddb4b26f7e6001563747a8d47457e713750e5802b4871cfbe70baca9304d4c385f\";\n\n\n         String codedtext = new TRIPPLE_DES().encrypt(text);\n         String decodedtext = new TRIPPLE_DES().decrypt(codedtext);\n\n\n         String encodedurl = URLEncoder.encode(codedtext,\"UTF-8\");\n         System.out.println(encodedurl);\n         System.out.println(decodedtext);\n        }\n\n\n        public String encrypt(String message) throws Exception {\n         final MessageDigest md = MessageDigest.getInstance(\"md5\");\n         final byte[] digestOfPassword = md.digest(\"HG58YZ3CR9\".getBytes(\"utf-8\"));\n         final byte[] keyBytes = Arrays.copyOf(digestOfPassword, 24);\n\n\n         for (int j = 0, k = 16; j < 8;) {\n          keyBytes[k++] = keyBytes[j++];\n         }\n\n\n         final SecretKey key = new SecretKeySpec(keyBytes, \"DESede\");\n         final IvParameterSpec iv = new IvParameterSpec(new byte[8]);\n         final Cipher cipher = Cipher.getInstance(\"DESede/CBC/PKCS5Padding\");\n         cipher.init(Cipher.ENCRYPT_MODE, key, iv);\n\n\n         final byte[] plainTextBytes = message.getBytes(\"utf-8\");\n         final byte[] cipherText = cipher.doFinal(plainTextBytes);\n\n         return Base64.encodeBase64String(cipherText);\n        }\n\n\n        public String decrypt(String message) throws Exception\n        {\n         final MessageDigest md = MessageDigest.getInstance(\"md5\");\n         final byte[] digestOfPassword = md.digest(\"HG58YZ3CR9\".getBytes(\"utf-8\"));\n         final byte[] keyBytes = Arrays.copyOf(digestOfPassword, 24);\n         for (int j = 0, k = 16; j < 8;) {\n          keyBytes[k++] = keyBytes[j++];\n         }\n\n\n         final SecretKey key = new SecretKeySpec(keyBytes, \"DESede\");\n         final IvParameterSpec iv = new IvParameterSpec(new byte[8]);\n         final Cipher decipher = Cipher.getInstance(\"DESede/CBC/PKCS5Padding\");\n         decipher.init(Cipher.DECRYPT_MODE, key, iv);\n\n\n\n         byte[] byteMessage= Base64.decodeBase64(message);\n         final byte[] plainText = decipher.doFinal(byteMessage);\n\n\n         return new String(plainText, \"UTF-8\");\n        }\n    }\n", "idx": 1894}
{"project": "cipher", "commit_id": "Snippet8771246_33494.java", "target": 1, "func": "package com.myclass.util;\n\nimport java.io.UnsupportedEncodingException;\nimport java.nio.charset.Charset;\nimport java.security.InvalidAlgorithmParameterException;\nimport java.security.InvalidKeyException;\nimport java.security.NoSuchAlgorithmException;\nimport java.security.NoSuchProviderException;\nimport java.security.spec.InvalidParameterSpecException;\nimport java.util.regex.Pattern;\nimport javax.crypto.BadPaddingException;\nimport javax.crypto.Cipher;\nimport javax.crypto.IllegalBlockSizeException;\nimport javax.crypto.KeyGenerator;\nimport javax.crypto.NoSuchPaddingException;\nimport javax.crypto.SecretKey;\nimport javax.crypto.spec.IvParameterSpec;\nimport javax.crypto.spec.SecretKeySpec;\n\n   public class AES {\n       private static Charset PLAIN_TEXT_ENCODING = Charset.forName(\"UTF-8\");\n       private static String CIPHER_TRANSFORMATION = \"AES/CTR/NoPadding\";\n       private static String KEY_TYPE = \"AES\";\n       private static int KEY_SIZE_BITS = 128;\n\n       private SecretKey key;\n       private Cipher cipher = Cipher.getInstance(CIPHER_TRANSFORMATION);\n       private byte[] ivBytes = new byte[KEY_SIZE_BITS/8];\n\n   public AES() throws NoSuchAlgorithmException, NoSuchPaddingException, NoSuchProviderException, InvalidParameterSpecException, InvalidKeyException, InvalidAlgorithmParameterException{\n       KeyGenerator kgen = KeyGenerator.getInstance(KEY_TYPE);\n       kgen.init(KEY_SIZE_BITS); \n       key = kgen.generateKey();\n       cipher.init(Cipher.ENCRYPT_MODE, key);\n       ivBytes = cipher.getParameters().getParameterSpec(IvParameterSpec.class).getIV();\n   }\n\n   public String getIVAsHex(){\n       return byteArrayToHexString(ivBytes);\n   }\n\n   public String getKeyAsHex(){\n       return byteArrayToHexString(key.getEncoded());\n   }\n\n   public void setStringToKey(String keyText){\n       setKey(keyText.getBytes());\n   }\n\n   public void setHexToKey(String hexKey){\n       setKey(hexStringToByteArray(hexKey));\n   }\n\n   private void setKey(byte[] bArray){\n       byte[] bText = new byte[KEY_SIZE_BITS/8];\n       int end = Math.min(KEY_SIZE_BITS/8, bArray.length);\n       System.arraycopy(bArray, 0, bText, 0, end);\n       key = new SecretKeySpec(bText, KEY_TYPE);\n   }\n\n   public void setStringToIV(String ivText){\n       setIV(ivText.getBytes());\n   }\n\n   public void setHexToIV(String hexIV){\n       setIV(hexStringToByteArray(hexIV));\n   }\n\n   private void setIV(byte[] bArray){\n       byte[] bText = new byte[KEY_SIZE_BITS/8];\n       int end = Math.min(KEY_SIZE_BITS/8, bArray.length);\n       System.arraycopy(bArray, 0, bText, 0, end);\n       ivBytes = bText;\n   }\n\n    public String encrypt(String message) throws InvalidKeyException,\n            IllegalBlockSizeException, BadPaddingException,\n            InvalidAlgorithmParameterException {\n        cipher.init(Cipher.ENCRYPT_MODE, key, new IvParameterSpec(ivBytes));\n        byte[] encrypted = cipher.doFinal(message.getBytes(PLAIN_TEXT_ENCODING));\n        return byteArrayToHexString(encrypted);\n    }\n\n    public String decrypt(String hexCiphertext)\n            throws IllegalBlockSizeException, BadPaddingException,\n            InvalidKeyException, InvalidAlgorithmParameterException,\n            UnsupportedEncodingException {\n        cipher.init(Cipher.DECRYPT_MODE, key, new IvParameterSpec(ivBytes));\n        byte[] dec = hexStringToByteArray(hexCiphertext);\n        byte[] decrypted = cipher.doFinal(dec);\n        return new String(decrypted, PLAIN_TEXT_ENCODING);\n    }\n\n    private static String byteArrayToHexString(byte[] raw) {\n        StringBuilder sb = new StringBuilder(2 + raw.length * 2);\n        sb.append(\"0x\");\n        for (int i = 0; i < raw.length; i++) {\n            sb.append(String.format(\"%02X\", Integer.valueOf(raw[i] & 0xFF)));\n        }\n        return sb.toString();\n    }\n\n   private static byte[] hexStringToByteArray(String hex) {\n        Pattern replace = Pattern.compile(\"^0x\");\n        String s = replace.matcher(hex).replaceAll(\"\");\n\n        byte[] b = new byte[s.length() / 2];\n        for (int i = 0; i < b.length; i++){\n          int index = i * 2;\n          int v = Integer.parseInt(s.substring(index, index + 2), 16);\n          b[i] = (byte)v;\n        }\n        return b;\n   }\n", "idx": 2161}
{"project": "cipher", "commit_id": "Snippet21982389_4407.java", "target": 0, "func": "    import java.security.spec.KeySpec;\n    import javax.crypto.Cipher;\n    import javax.crypto.SecretKey;\n    import javax.crypto.SecretKeyFactory;\n    import javax.crypto.spec.DESedeKeySpec;\n\n\n    public class SecretKeyEncryptionExample\n    {\n      private static final String FORMAT = \"ISO-8859-1\";\n      public static final String DESEDE_ENCRYPTION_SCHEME = \"DESede\";\n      private KeySpec ks;\n      private SecretKeyFactory skf;\n      private Cipher cipher;\n      SecretKey key;\n\n      public SecretKeyEncryptionExample()\n        throws Exception\n      {\n        String myEncryptionKey = \"<48 chars long string>\";\n\n        this.ks = new DESedeKeySpec(myEncryptionKey.getBytes(\"ISO-8859-1\"));\n        this.skf = SecretKeyFactory.getInstance(\"DESede\");\n        this.cipher = Cipher.getInstance(\"DESede\");\n        this.key = this.skf.generateSecret(this.ks);\n      }\n", "idx": 1792}
{"project": "cipher", "commit_id": "Snippet13969530_37397.java", "target": 1, "func": "public static byte[] encrypt(byte[] data, byte[] key, byte[] ivs) {\n        try {\n            Cipher cipher = Cipher.getInstance(\"AES/CBC/PKCS5Padding\");\n\n            SecretKeySpec secretKeySpec = new SecretKeySpec(key, \"AES\");\n            byte[] finalIvs = new byte[16];\n            int len = ivs.length > 16 ? 16 : ivs.length;\n            System.arraycopy(ivs, 0, finalIvs, 0, len);\n            IvParameterSpec ivps = new IvParameterSpec(finalIvs);\n            cipher.init(Cipher.ENCRYPT_MODE, secretKeySpec, ivps);\n            return cipher.doFinal(data);\n        } catch (Exception e) {\n            e.printStackTrace();\n        }\n\n        return null;\n    }\n\n    public static byte[] decrypt(byte[] data, byte[] key, byte[] ivs) {\n        try {\n            Cipher cipher = Cipher.getInstance(\"AES/CBC/PKCS5Padding\");\n            SecretKeySpec secretKeySpec = new SecretKeySpec(key, \"AES\");\n            byte[] finalIvs = new byte[16];\n            int len = ivs.length > 16 ? 16 : ivs.length;\n            System.arraycopy(ivs, 0, finalIvs, 0, len);\n            IvParameterSpec ivps = new IvParameterSpec(finalIvs);\n            cipher.init(Cipher.DECRYPT_MODE, secretKeySpec, ivps);\n            return cipher.doFinal(data);\n        } catch (Exception e) {\n            e.printStackTrace();\n        }\n\n        return null;\n    }\n", "idx": 2052}
{"project": "cipher", "commit_id": "Snippet11683946_35698.java", "target": 0, "func": "import java.security.*;\nimport javax.crypto.*;\nimport javax.crypto.spec.*;\nimport java.io.*;\n\npublic class AESEncrypt {\n\n    /**\n     * Turns array of bytes into string\n     * \n     * @param buf\n     *            Array of bytes to convert to hex string\n     * @return Generated hex string\n     */\n    public static String asHex(byte buf[]) {\n        StringBuffer strbuf = new StringBuffer(buf.length * 2);\n        int i;\n\n        for (i = 0; i < buf.length; i++) {\n            if (((int) buf[i] & 0xff) < 0x10)\n                strbuf.append(\"0\");\n\n            strbuf.append(Long.toString((int) buf[i] & 0xff, 16));\n        }\n\n        return strbuf.toString();\n    }\n\n    public static byte[] hexStringToByteArray(String s) {\n        int len = s.length();\n        byte[] data = new byte[len / 2];\n        for (int i = 0; i < len; i += 2) {\n            data[i / 2] = (byte) ((Character.digit(s.charAt(i), 16) << 4) + Character\n                    .digit(s.charAt(i + 1), 16));\n        }\n        return data;\n    }\n\n    public static void main(String[] args) throws Exception {\n\n        String message = \"Test text!\";\n\n        // Get the KeyGenerator\n        KeyGenerator kgen = KeyGenerator.getInstance(\"AES\");\n        kgen.init(128); // 192 and 256 bits may not be available\n\n        // Generate the secret key specs.\n        SecretKey skey = kgen.generateKey();\n        byte[] raw = skey.getEncoded();\n\n        SecretKeySpec skeySpec = new SecretKeySpec(raw, \"AES\");\n        System.out.println(\"Key: \" + asHex(raw));\n\n        // Instantiate the cipher\n\n        Cipher cipher = Cipher.getInstance(\"AES\");\n\n        cipher.init(Cipher.ENCRYPT_MODE, skeySpec);\n\n        byte[] encrypted = cipher.doFinal((args.length == 0 ? message : args[0]).getBytes());\n        System.out.println(\"encrypted string: \" + asHex(encrypted));\n\n    }\n}\n", "idx": 1695}
{"project": "cipher", "commit_id": "Snippet24593429_6946.java", "target": 1, "func": "private static void decryptFile(String file, String password, byte[] Salt, byte[] IV, String attachmentunecryptedhash, String attachmentoriginalsizeString, String attachmentcreated)\n{\n        long attachmentSize = 0;\n        String attachmentCreated = null;\n        String attachmentModified = null;\n        String attachmentHash = null;\n        byte[] buffers = new byte[16];\n        byte[] endOfFile = new byte[16];\n        int counterForFile = 0;\n        int attachmentoriginalsize = 0;\n        int noBytes = 0;\n\n        try\n        {\n            if(Paths.get(file.trim()).toFile().exists() == true) //If the File Exists\n            {\n                //Creates Secret Key For Decryption -- Passes Password, Salt, Iterations, and Key Length\n                PBEKeySpec keySpec = new PBEKeySpec(password.toCharArray(), Salt, 65536, 256);\n                SecretKeyFactory factory = SecretKeyFactory.getInstance(\"PBKDF2WithHmacSHA1\");\n                SecretKey secretKey = factory.generateSecret(keySpec);\n                SecretKeySpec secret = new SecretKeySpec(secretKey.getEncoded(), \"AES\");\n\n                //Initalizes Cipher For Decrypt Mode -- Passes Password and Salt\n                Cipher cipher = Cipher.getInstance(\"AES/CBC/PKCS5Padding\");\n                cipher.init(Cipher.DECRYPT_MODE, secret, new IvParameterSpec(IV));\n\n                //Prepares To Write New Buffer Containing Decrypted Information to Output File\n                String unencryptedFile = file.trim().replaceAll(\".aes\", \"\");\n                FileInputStream fileInputStream = new FileInputStream(file.trim());\n                FileOutputStream fileOutputStream = new FileOutputStream(unencryptedFile);\n                attachmentoriginalsize = Integer.parseInt(attachmentoriginalsizeString);\n\n\n\n                //Writes Encrypted File to Disk Using Secure Cipher Output Stream\n                while((noBytes = fileInputStream.read(buffers)) != -1)\n                {\n\n                    //Writes 1 encrypted byte at a time\n                    fileOutputStream.write(cipher.update(buffers,0,noBytes));\n                    //counterForFile += 16;\n                }\n\n                buffers = cipher.doFinal();  //Line 1437 Where the Error Exists\n\n                fileOutputStream.write(buffers);\n                fileOutputStream.flush();\n\n\n                //Close Files, Cleanup\n                fileInputStream.close();\n                fileOutputStream.close();\n\n                System.exit(1);\n\n}\n", "idx": 2236}
{"project": "cipher", "commit_id": "Snippet34121787_16147.java", "target": 1, "func": "import java.io.File;\nimport java.io.FileInputStream;\nimport java.io.FileOutputStream;\nimport java.io.InputStream;\nimport java.security.KeyStore;\nimport java.security.MessageDigest;\nimport java.security.PrivateKey;\nimport java.security.PublicKey;\nimport java.security.cert.CertificateFactory;\nimport java.security.cert.X509Certificate;\nimport javax.crypto.Cipher;\nimport javax.crypto.spec.IvParameterSpec;\nimport javax.crypto.spec.SecretKeySpec;\nimport org.apache.commons.codec.binary.Base64;\n\nclass Sender{\n\npublic static void main(String[] args) {\n        //infile.txt\n        File inFile = new File(args[0]);\n        //outfile.txt\n        File outFile = new File(args[1]);\n        //mykeystore.jks\n        File keyStoreFile = new File(args[2]);\n        //mykeystore info\n        String alias = args[3];\n        String password = args[4];\n        String storepass = args[5];\n        //receptor certificate\n        String receptorCert = args[6];\n\n        try {\n            //Read plain text\n            FileInputStream rawDataFromFile = new FileInputStream(inFile);\n            byte[] plainText = new byte[(int) inFile.length()];\n            rawDataFromFile.read(plainText);\n\n            //Create simmetric key\n            String key = \"Bar12345Bar12345\"; // 128 bit key\n            String initVector = \"RandomInitVector\"; // 16 bytes IV\n            IvParameterSpec iv = new IvParameterSpec(initVector.getBytes(\"UTF-8\"));\n            SecretKeySpec skeySpec = new SecretKeySpec(key.getBytes(\"UTF-8\"), \"AES\");\n            Cipher cipher = Cipher.getInstance(\"AES/CBC/PKCS5PADDING\");\n            cipher.init(Cipher.ENCRYPT_MODE, skeySpec, iv);\n\n            //Encrypt plaintext\n            byte[] ciphertext = cipher.doFinal(plainText);\n\n            //Hash plaintext\n            MessageDigest md = MessageDigest.getInstance(\"SHA\");\n            md.update(plainText);\n            byte[] digest = md.digest();\n\n            //Encrypt simmetric key with receiver's public key          \n            Cipher rsaCipher = Cipher.getInstance(\"RSA/ECB/PKCS1Padding\");\n            PublicKey receptorPublicKey = getPublicKeyFromCert(receptorCert);\n            rsaCipher.init(Cipher.ENCRYPT_MODE, receptorPublicKey);\n            byte[] simmetricKey = rsaCipher.doFinal(skeySpec.getEncoded());\n\n            //Encrypt hash with my private key\n            KeyStore myKeyStore = KeyStore.getInstance(\"JKS\");\n            FileInputStream inStream = new FileInputStream(keyStoreFile);\n            myKeyStore.load(inStream, storepass.toCharArray());\n            PrivateKey privatekey = (PrivateKey) myKeyStore.getKey(alias, password.toCharArray());\n            rsaCipher.init(Cipher.ENCRYPT_MODE, privatekey);            \n            byte[] encodedHash = rsaCipher.doFinal(digest);\n\n            //Write to outputfile\n            FileOutputStream outToFile = new FileOutputStream(outFile);\n\n            outToFile.write(simmetricKey);\n            outToFile.write(encodedHash);\n            outToFile.write(ciphertext);\n\n            outToFile.close();\n            rawDataFromFile.close();\n        } catch (Exception e) {\n            e.printStackTrace();\n            e.getMessage();\n        }\n    }\n    public static PublicKey getPublicKeyFromCert(String certLocation) {\n        PublicKey pub = null;\n        try {\n            InputStream inStream = new FileInputStream(certLocation);\n            CertificateFactory cf = CertificateFactory.getInstance(\"X.509\");\n            X509Certificate cert = (X509Certificate) cf.generateCertificate(inStream);\n            inStream.close();\n            pub = (PublicKey) cert.getPublicKey();\n\n        } catch (Exception e) {\n            e.printStackTrace();\n        }\n        return pub;\n    }\n}\n", "idx": 2043}
{"project": "cipher", "commit_id": "Snippet21043028_3627.java", "target": 1, "func": "try {\n        cipher = Cipher.getInstance(\"AES/CBC/PKCS5Padding\", \"BC\");\n        byte[] key = { 107, -39, 87, -65, -1, -28, -85, -94, 105, 76, -94,\n                110, 48, 116, -115, 86 };\n        byte[] vector = { -94, 112, -23, 93, -112, -58, 18, 78, 1, 69, -92,\n                102, 33, -96, -94, 59 };\n        SecretKey aesKey = new SecretKeySpec(key, \"AES\");\n        byte[] message = { 32, -26, -72, 25, 63, 114, -58, -5, 4, 90, 54,\n                88, -28, 3, -72, 25, -54, -60, 17, -53, -27, -91, 34, -101,\n                -93, -3, -47, 47, -12, -35, -118, -122, -77, -7, -9, -123,\n                7, -66, 10, -93, -29, 4, -60, -102, 16, -57, -118, 94 };\n\n        IvParameterSpec aesVector = new IvParameterSpec(vector);\n        cipher.init(Cipher.DECRYPT_MODE, aesKey, aesVector);\n        byte[] wynik = cipher.doFinal(message);\n        Log.d(\"Solution here\", \"Solution\");\n        for (byte i : wynik)\n            Log.d(\"Solution\", \"\" + i);\n    } catch (Exception e) {\n        Log.d(\"ERROR\", \"TU\");\n        e.printStackTrace();\n    }\n", "idx": 2022}
{"project": "cipher", "commit_id": "Snippet22919265_5280.java", "target": 1, "func": "public static String encrypt(String data, Key key) throws Exception {\n\n    Cipher cipher = Cipher.getInstance(\"RSA\");\n    cipher.init(Cipher.ENCRYPT_MODE, key);\n    byte[] encryptedBytes = cipher.doFinal(data.getBytes());\n    byte[] base64Bytes = Base64.encodeBase64(encryptedBytes);\n    String base64EncodedString = new String(base64Bytes);\n    return base64EncodedString;\n}\n\npublic static String decrypt(String encrypted, Key key) throws Exception {\n\n    Cipher cipher = Cipher.getInstance(\"RSA\");\n    cipher.init(Cipher.DECRYPT_MODE, key);\n    byte[] decoded = Base64.decodeBase64(encrypted.getBytes());\n    byte[] decrypted = cipher.doFinal(decoded);\n    return new String(decrypted);\n}\n", "idx": 2286}
{"project": "cipher", "commit_id": "Snippet24405731_6719.java", "target": 1, "func": "SecretKeyFactory factory = SecretKeyFactory.getInstance(\"PBKDF2WithHmacSHA1\");\nPBEKeySpec keyspec = new PBEKeySpec(password, salt, 1000, 256);\nKey key = factory.generateSecret(keyspec);\nSecretKeySpec secret = new SecretKeySpec(key.getEncoded(), \"AES\");\nbyte[] iv = \"how_to_generate_in_java_as_in_c\".getBytes();\nAlgorithmParameterSpec ivSpec = new IvParameterSpec(iv);\nCipher cipher = Cipher.getInstance(\"AES/CBC/PKCS5Padding\");\ncipher.init(Cipher.ENCRYPT_MODE, secret, ivSpec);\nbyte[] result = cipher.doFinal(\"asdfasdf\".getBytes(\"UTF-8\"));\n", "idx": 2184}
{"project": "cipher", "commit_id": "Snippet18979978_1878.java", "target": 0, "func": "        // Sensitive information - message to be encrypted\n        byte[] date_of_exp = \"032019\".getBytes(); // Date of Expiration in form MMYYYY\n\n        //System.out.println(\"Card Number : \" + card_number); // Print original message\n\n        // Encrypt the text\n       byte[] date_of_expEncrypted = desCipher.doFinal(date_of_exp);\n\n        System.out.println(\"\");\n        System.out.println(\"Date of Expiration Encrypted : \" + date_of_expEncrypted); // Print the encrypted message\n        System.out.println(\"\");\n\n        // Initialize the same cipher for decryption\n        desCipher.init(Cipher.DECRYPT_MODE, myDesKey_2);\n\n        String date_of_expEncrypted_;\n        date_of_expEncrypted_ = DatatypeConverter.printBase64Binary(date_of_expEncrypted); \n        // SecretKey card_numberEncrypted_key;\n        // card_numberEncrypted_key = stringToSecretKey (card_numberEncrypted_, \"DES\");\n        SecretKey date_of_expEncrypted_key;\n        date_of_expEncrypted_key = new SecretKeySpec(date_of_expEncrypted, 0, 8, \"DES\");\n        System.out.println(\"\");\n        System.out.println(\"Date of expiration as secret key :\" + date_of_expEncrypted_key);\n        System.out.println(\"\");\n\n        // Decrypt the text\n        byte[] date_of_expDecrypted = desCipher.doFinal(date_of_expEncrypted);\n\n        System.out.println(\"Original Date of Expiration (decrypted) : \" + new String(date_of_expDecrypted)); // Print the decrypted Text\n        System.out.println(\"\");\n        System.out.println(\"\");\n        System.out.println(\"-----------------------------------------------------------------------------------\");\n        System.out.println(\"Further to Step 3\"); // Print the decrypted Text\n        System.out.println(\"-----------------------------------------------------------------------------------\"); // Print the decrypted Text\n        System.out.println(\"\");\n        System.out.println(\"\");\n\n\n\n\n    SecretKey myDesKey_3 = date_of_expEncrypted_key;\n\n    //Cipher desCipher_2; // New Cipher for iteration 2\n\n        // Create the cipher \n        //desCipher_2 = Cipher.getInstance(\"DES/ECB/PKCS5Padding\");\n\n        // Initialize the cipher for encryption\n        desCipher.init(Cipher.ENCRYPT_MODE, myDesKey_3);\n\n        // Sensitive information - message to be encrypted\n        byte[] service_code = \"318\".getBytes(); \n\n       // Encrypt the text\n       byte[] service_codeEncrypted = desCipher.doFinal(service_code);\n        System.out.println(\"\");\n        System.out.println(\"Service Code Encrypted : \" + service_codeEncrypted); // Print the encrypted message\n        System.out.println(\"\");\n        // Initialize the same cipher for decryption\n        desCipher.init(Cipher.DECRYPT_MODE, myDesKey_3);\n\n        // Decrypt the text\n        byte[] service_codeDecrypted = desCipher.doFinal(service_codeEncrypted);\n\n        System.out.println(\"Service Code decrypted : \" + new String(service_codeDecrypted)); // Print the decrypted Text\n        System.out.println(\"\");\n        System.out.println(\"\");\n        System.out.println(\"-----------------------------------------------------------------------------------\");\n        System.out.println(\"Finish!!!\"); // Print the decrypted Text\n        System.out.println(\"-----------------------------------------------------------------------------------\"); // Print the decrypted Text\n        System.out.println(\"\");\n        System.out.println(\"\");\n\n\n        //Integer bigInt = new Integer(\"Bwwhw34\".getBytes());\n        // int service_codeEncrypted_hashed = service_codeEncrypted.hashCode();\n        // System.out.println(\"hash code for Service Code Encrypted : \" + service_codeEncrypted_hashed);\n        // int service_codeEncrypted_hashed_2 = service_codeEncrypted_hashed.hashCode();\n\n        // byte[] service_code__ = service_codeEncrypted.getBytes(); \n        //  System.out.println(\"hash code for Service Code Encrypted and baseD  : \" + service_code__);\n\n\n\n    }catch(NoSuchAlgorithmException e){\n        e.printStackTrace();\n    }catch(NoSuchPaddingException e){\n        e.printStackTrace();\n    }catch(InvalidKeyException e){\n        e.printStackTrace();\n    }catch(IllegalBlockSizeException e){\n        e.printStackTrace();\n    }catch(BadPaddingException e){\n        e.printStackTrace();\n    } \n\n}\n", "idx": 1874}
{"project": "cipher", "commit_id": "Snippet37030469_18982.java", "target": 1, "func": "   AESCipher = Cipher.getInstance(\"AES/CBC/PKCS5Padding\");\n", "idx": 2001}
{"project": "cipher", "commit_id": "Snippet12803298_36471.java", "target": 0, "func": "package main;\n\nimport java.security.InvalidKeyException;\nimport java.security.NoSuchAlgorithmException;\n\nimport javax.crypto.BadPaddingException;\nimport javax.crypto.Cipher;\nimport javax.crypto.IllegalBlockSizeException;\nimport javax.crypto.NoSuchPaddingException;\nimport javax.crypto.spec.SecretKeySpec;\n\n\npublic class Prueba {\n\n    private static final String keyValue = \"fd<[;.7e/OC0W!d|\";\n    private static final String ALG = \"Blowfish\";\n\n    public static void main(String[] args) {\n        String text = \"some random text\";\n\n        try {\n            SecretKeySpec key = new SecretKeySpec(keyValue.getBytes(), ALG);\n            Cipher cipher = Cipher.getInstance(ALG);\n            cipher.init(Cipher.ENCRYPT_MODE, key);\n            byte[] encryptedBytes = cipher.doFinal(text.getBytes());\n            String encrypted = new String(encryptedBytes);\n\n            cipher.init(Cipher.DECRYPT_MODE, key);\n            byte[] recoveredBytes = cipher.doFinal(encrypted.getBytes());\n            String recovered = new String(recoveredBytes);\n\n        } catch (NoSuchAlgorithmException nsa) {\n            nsa.printStackTrace();\n        } catch (NoSuchPaddingException nspe) {\n            nspe.printStackTrace();\n        } catch (InvalidKeyException ike) {\n            ike.printStackTrace();\n        } catch (BadPaddingException bpe) {\n            bpe.printStackTrace();\n        } catch (IllegalBlockSizeException ibse) {\n            ibse.printStackTrace();\n        } \n    }\n\n\n}\n", "idx": 1884}
{"project": "cipher", "commit_id": "Snippet11418336_35571.java", "target": 0, "func": "import java.security.SecureRandom;\n\nimport javax.crypto.Cipher;\nimport javax.crypto.KeyGenerator;\nimport javax.crypto.SecretKey;\nimport javax.crypto.spec.SecretKeySpec;\n\n/**\n * Usage:\n * <pre>\n * String crypto = SimpleCrypto.encrypt(masterpassword, cleartext)\n * ...\n * String cleartext = SimpleCrypto.decrypt(masterpassword, crypto)\n * </pre>\n * @author ferenc.hechler\n */\n\npublic class SimpleCrypto {\n\n    public static String encrypt(String seed, String cleartext) throws Exception {\n            byte[] rawKey = getRawKey(seed.getBytes());\n            byte[] result = encrypt(rawKey, cleartext.getBytes());\n            return toHex(result);\n    }\n\n    public static String decrypt(String seed, String encrypted) throws Exception {\n            byte[] rawKey = getRawKey(seed.getBytes());\n            byte[] enc = toByte(encrypted);\n            byte[] result = decrypt(rawKey, enc);\n            return new String(result);\n    }\n\n    private static byte[] getRawKey(byte[] seed) throws Exception {\n            KeyGenerator kgen = KeyGenerator.getInstance(\"AES\");\n            SecureRandom sr = SecureRandom.getInstance(\"SHA1PRNG\");\n            sr.setSeed(seed);\n        kgen.init(128, sr); // 192 and 256 bits may not be available\n        SecretKey skey = kgen.generateKey();\n        byte[] raw = skey.getEncoded();\n        return raw;\n    }\n\n\n    private static byte[] encrypt(byte[] raw, byte[] clear) throws Exception {\n        SecretKeySpec skeySpec = new SecretKeySpec(raw, \"AES\");\n            Cipher cipher = Cipher.getInstance(\"AES\");\n        cipher.init(Cipher.ENCRYPT_MODE, skeySpec);\n        byte[] encrypted = cipher.doFinal(clear);\n            return encrypted;\n    }\n\n    private static byte[] decrypt(byte[] raw, byte[] encrypted) throws Exception {\n        SecretKeySpec skeySpec = new SecretKeySpec(raw, \"AES\");\n            Cipher cipher = Cipher.getInstance(\"AES\");\n        cipher.init(Cipher.DECRYPT_MODE, skeySpec);\n        byte[] decrypted = cipher.doFinal(encrypted);\n            return decrypted;\n    }\n\n    public static String toHex(String txt) {\n            return toHex(txt.getBytes());\n    }\n    public static String fromHex(String hex) {\n            return new String(toByte(hex));\n    }\n\n    public static byte[] toByte(String hexString) {\n            int len = hexString.length()/2;\n            byte[] result = new byte[len];\n            for (int i = 0; i < len; i++)\n                    result[i] = Integer.valueOf(hexString.substring(2*i, 2*i+2), 16).byteValue();\n            return result;\n    }\n\n    public static String toHex(byte[] buf) {\n            if (buf == null)\n                    return \"\";\n            StringBuffer result = new StringBuffer(2*buf.length);\n            for (int i = 0; i < buf.length; i++) {\n                    appendHex(result, buf[i]);\n            }\n            return result.toString();\n    }\n    private final static String HEX = \"0123456789ABCDEF\";\n    private static void appendHex(StringBuffer sb, byte b) {\n            sb.append(HEX.charAt((b>>4)&0x0f)).append(HEX.charAt(b&0x0f));\n    }\n\n}\n", "idx": 1619}
{"project": "cipher", "commit_id": "Snippet41099999_23037.java", "target": 0, "func": "    @Test\npublic void testGet() {\n    Cipher cipher = null;\n    try {\n        SecretKey sks= getKeySpec(pass, salt);\n        cipher = Cipher.getInstance(\"AES\");\n        cipher.init(Cipher.DECRYPT_MODE, sks);\n    } catch (NoSuchAlgorithmException e) {\n        e.printStackTrace();\n    } catch (NoSuchPaddingException e) {\n        e.printStackTrace();\n    } catch (InvalidKeySpecException e) {\n        e.printStackTrace();\n    } catch (InvalidKeyException e) {\n        e.printStackTrace();\n    }\n}\n\npublic SecretKey getKeySpec(char[] pass, byte[] salt) throws NoSuchAlgorithmException, InvalidKeySpecException {\n\n    //generate key spec...\n    return secretKeyFactory.generateSecret(keySpec);\n}\n", "idx": 1721}
{"project": "cipher", "commit_id": "Snippet26270290_8466.java", "target": 1, "func": "public static String encrypt() throws Exception {\n    try {\n        String data = \"secretdata\";\n        String key = \"secret0000000000\";\n        String iv = \"0000000000000000\";\n\n        Cipher cipher = Cipher.getInstance(\"AES/CBC/NoPadding\");\n        int blockSize = cipher.getBlockSize();\n\n        byte[] dataBytes = data.getBytes();\n        int plaintextLength = dataBytes.length;\n        if (plaintextLength % blockSize != 0) {\n            plaintextLength = plaintextLength + (blockSize - (plaintextLength % blockSize));\n        }\n\n        byte[] plaintext = new byte[plaintextLength];\n        System.arraycopy(dataBytes, 0, plaintext, 0, dataBytes.length);\n\n        SecretKeySpec keyspec = new SecretKeySpec(key.getBytes(), \"AES\");\n        IvParameterSpec ivspec = new IvParameterSpec(iv.getBytes());\n\n        cipher.init(Cipher.ENCRYPT_MODE, keyspec, ivspec);\n        byte[] encrypted = cipher.doFinal(plaintext);\n\n        return new sun.misc.BASE64Encoder().encode(encrypted);\n\n    } catch (Exception e) {\n        e.printStackTrace();\n        return null;\n    }\n}\n", "idx": 2070}
{"project": "cipher", "commit_id": "Snippet9415469_33891.java", "target": 0, "func": "import java.awt.image.*;\nimport java.io.*;\nimport java.security.*;\nimport java.security.spec.InvalidKeySpecException;\nimport javax.crypto.Cipher;\nimport javax.crypto.spec.SecretKeySpec;\nimport sun.misc.*;\nimport javax.swing.*;\n\n/**\n*\n* @author Lance Gerday\n*/\npublic class Encrypt {\n\n\u00a0\u00a0\u00a0private static final String ALGORITHM = \"AES\";\n\u00a0\u00a0\u00a0public static byte[] keyValue;\n\u00a0\u00a0\u00a0// 500 KB max\n\u00a0\u00a0\u00a0public static byte[] valuesRead = new byte[512000];\n\n\u00a0\u00a0\u00a0public static void encrypt(File f) throws Exception {\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0FileInputStream in = null;\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0FileOutputStream out = null;\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0in = new FileInputStream(f);\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0Key key = generateKey();\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0Cipher c = Cipher.getInstance(ALGORITHM);\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0c.init(Cipher.ENCRYPT_MODE, key);//my code seems to fail here\n\n\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0String name = f.getName();\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0String newFileName = name.substring(0, name.lastIndexOf(\".\"))\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0+ \".enc\" + name.substring(name.lastIndexOf(\".\"), name.length());\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0File newFile = new File(f.getParentFile(), newFileName);\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0out = new FileOutputStream(newFile);\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0//reads the file into valueToEnc and returns the number of bytes read\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0valuesRead = new byte[Integer.MAX_VALUE];\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0int numberRead = in.read(valuesRead);\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0keyValue = new byte[numberRead];\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0for (int i = 0; i < numberRead; i++) {\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0keyValue[i] = valuesRead[i];\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0}\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0byte[] encValue = c.doFinal(keyValue);\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0String encryptedValue = new BASE64Encoder().encode(encValue);\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0out.write(encryptedValue.getBytes());\n\u00a0\u00a0\u00a0}\n\n\u00a0\u00a0\u00a0public static void decrypt(File f) throws Exception {\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0Key key = generateKey();\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0Cipher c = Cipher.getInstance(ALGORITHM);\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0c.init(Cipher.DECRYPT_MODE, key);\n\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0FileInputStream in = null;\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0FileOutputStream out = null;\n\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0if (f.canRead()) {\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0in = new FileInputStream(f);\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0}\n\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0String name = f.getName();\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0String newFileName = name.substring(0, name.lastIndexOf(\".enc\"));\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0File newFile = new File(f.getParentFile(), newFileName);\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0out = new FileOutputStream(newFile);\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0//reads the file into valueToEnc and returns the number of bytes read\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0valuesRead = new byte[Integer.MAX_VALUE];\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0int numberRead = in.read(valuesRead);\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0keyValue = new byte[numberRead];\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0for (int i = 0; i < numberRead; i++) {\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0keyValue[i] = valuesRead[i];\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0}\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0String encryptedValue = new String(keyValue);\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0byte[] decordedValue = new BASE64Decoder().decodeBuffer(encryptedValue);\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0byte[] decValue = c.doFinal(decordedValue);\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0out.write(decValue);\n\u00a0\u00a0\u00a0}\n\n\u00a0\u00a0\u00a0private static Key generateKey() throws Exception {\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0Key key = new SecretKeySpec(keyValue, ALGORITHM);\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0return key;\n\u00a0\u00a0\u00a0}\n\n\u00a0\u00a0\u00a0public static void setKeyValue(File f) {\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0BufferedImage img = null;\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0try {\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0img = javax.imageio.ImageIO.read(f);\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0} catch (Exception e) {\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0JOptionPane.showMessageDialog(null, \"Fail error at line 92\");\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0}\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0Raster r = img.getData();\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0int[] data = r.getPixels(r.getMinX(), r.getMinY(), r.getWidth(), r.getHeight(), (int[]) null);\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0for (int a : data) {\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0}\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0int dataLength = data.length;\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0keyValue = new byte[dataLength << 2];\n\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0for (int i = 0; i < dataLength; i++) {\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0int x = data[i];\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0int k = i << 2;\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0keyValue[k++] = (byte) ((x >>> 0) & 0xff);\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0keyValue[k++] = (byte) ((x >>> 8) & 0xff);\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0keyValue[k++] = (byte) ((x >>> 16) & 0xff);\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0keyValue[k++] = (byte) ((x >>> 24) & 0xff);\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0}\n\u00a0\u00a0\u00a0}\n}\n", "idx": 1871}
{"project": "cipher", "commit_id": "Snippet34488397_16478.java", "target": 1, "func": "@Test\npublic void test_cipher() {\n    private static final String PROVIDER_NAME = \"BC\";\n    final Provider provider = Security.getProvider(PROVIDER_NAME);\n\n    Cipher cipher = Cipher.getInstance(\"RSA/ECB/PKCS1Padding\", provider);\n}\n", "idx": 2298}
{"project": "cipher", "commit_id": "Snippet9422145_33867.java", "target": 1, "func": "private static void testCode() {\n    try {\n        String stringDec = \"Hi there\";\n        SecretKey aesKey = new SecretKeySpec(new byte[16], \"AES\");\n\n        Cipher cipher = Cipher.getInstance(\"AES/CBC/PKCS5Padding\");\n        cipher.init(Cipher.ENCRYPT_MODE, aesKey);\n\n        // no encoding given, don't use getBytes() without a Charset.forName(\"UTF-8\")\n        byte[] data = cipher.doFinal(stringDec.getBytes());\n        byte[] iv = cipher.getIV();\n\n        // doesn't do anything\n        AlgorithmParameters.getInstance(\"AES\");\n\n        cipher.init(Cipher.DECRYPT_MODE, aesKey, new IvParameterSpec(iv));\n        byte[] decrypted = cipher.doFinal(data);\n        System.out.println(new String(decrypted));\n    } catch (GeneralSecurityException e) {\n        throw new IllegalStateException(e);\n    }\n}\n", "idx": 2051}
{"project": "cipher", "commit_id": "Snippet5408396_31619.java", "target": 1, "func": "Cipher cipher2 = Cipher.getInstance(\"RSA\");\ncipher2.init(Cipher.DECRYPT_MODE, priKey);\nbyte[] cipherData = cipher2.doFinal(data);\n", "idx": 1974}
{"project": "cipher", "commit_id": "Snippet20976375_3570.java", "target": 1, "func": "            LOGGER.info(\"Confirming write\");\n        String data = new String(buf.array());\n\n        LOGGER.info(\"Data packet found as {}\", data);\n\n        /*******************************************************/\n        byte[] iv = { 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0 };\n        IvParameterSpec ivspec = new IvParameterSpec(iv);\n        String key1 = \"1234567812345678\";\n        byte[] key2 = key1.getBytes();\n        SecretKeySpec secret = new SecretKeySpec(key2, \"AES\");\n        Cipher cipher = Cipher.getInstance(\"AES/CBC/PKCS5Padding\");\n\n        cipher.init(Cipher.DECRYPT_MODE, secret, ivspec);\n\n        byte[] encrypted = DatatypeConverter.parseBase64Binary(data);\n        byte[] decrypted = cipher.doFinal(encrypted);\n\n        System.out.println(\"Decrypted Info: \" + new String(decrypted, StandardCharsets.UTF_8));\n", "idx": 2173}
{"project": "cipher", "commit_id": "Snippet9094323_33672.java", "target": 1, "func": "static final String HEXES = \"0123456789ABCDEF\"; \nbyte[] buf = new byte[1024];      \n\npublic void saveToFile(String fileName, BigInteger mod, BigInteger exp) throws IOException {\n    ObjectOutputStream oout = new ObjectOutputStream(new BufferedOutputStream(new FileOutputStream(fileName)));\n      try {\n            oout.writeObject(mod);\n            oout.writeObject(exp);\n      } catch (Exception e) {\n      throw new IOException(\"Unexpected error\", e);\n      } finally {\n        oout.close();\n      }\n}\n\npublic static void main(String[] args) throws Exception {       \n            MyEncrypt myEncrypt = new MyEncrypt();\n    KeyPairGenerator kpg = KeyPairGenerator.getInstance(\"RSA\");\n    kpg.initialize(2048);\n    KeyPair kp = kpg.genKeyPair();\n    RSAPublicKey publicKey = (RSAPublicKey) kp.getPublic();\n    RSAPrivateKey privateKey = (RSAPrivateKey) kp.getPrivate();\n    KeyFactory fact = KeyFactory.getInstance(\"RSA\");        \n    RSAPublicKeySpec pub = fact.getKeySpec(kp.getPublic(), RSAPublicKeySpec.class);\n    RSAPrivateKeySpec priv = fact.getKeySpec(kp.getPrivate(), RSAPrivateKeySpec.class);\n\n    myEncrypt.saveToFile(\"public.key\", pub.getModulus(), pub.getPublicExponent());\n    myEncrypt.saveToFile(\"private.key\", priv.getModulus(), priv.getPrivateExponent());\n    String encString = myEncrypt.rsaEncrypt(\"pritesh\");\n    System.out.println(\"encrypted : \" + encString);\n    String decString = myEncrypt.rsaDecrypt(encString);\n    System.out.println(\"decrypted : \" + decString);\n\n    String main_file_path = \"resume.doc\";                \n    String main_encrypt_file_path = \"encrypt.doc\";\n    String main_decrypt_file_path = \"decrypt.doc\";\n\n    myEncrypt.rsaEncrypt(new FileInputStream(main_file_path),new FileOutputStream(main_encrypt_file_path));\n            // Decrypt\n    myEncrypt.rsaDecrypt(new FileInputStream(main_encrypt_file_path),new FileOutputStream(main_decrypt_file_path));\n}   \n\nPublicKey readKeyFromFile(String keyFileName) throws Exception {\n  InputStream in = new FileInputStream(keyFileName);\n  ObjectInputStream oin = new ObjectInputStream(new BufferedInputStream(in));\n  try {\n    BigInteger m = (BigInteger) oin.readObject();\n    BigInteger e = (BigInteger) oin.readObject();\n    RSAPublicKeySpec keySpec = new RSAPublicKeySpec(m, e);\n    KeyFactory fact = KeyFactory.getInstance(\"RSA\");\n    PublicKey pubKey = fact.generatePublic(keySpec);\n    return pubKey;\n  } catch (Exception e) {\n    throw new RuntimeException(\"Spurious serialisation error\", e);\n  } finally {\n    oin.close();\n  }\n}\n\nPrivateKey readPrivateKeyFromFile(String keyFileName) throws Exception {\n  InputStream in = new FileInputStream(keyFileName);\n  ObjectInputStream oin = new ObjectInputStream(new BufferedInputStream(in));\n  try {\n    BigInteger m = (BigInteger) oin.readObject();\n    BigInteger e = (BigInteger) oin.readObject();\n    RSAPrivateKeySpec keySpec = new RSAPrivateKeySpec(m, e);\n    KeyFactory fact = KeyFactory.getInstance(\"RSA\");\n    PrivateKey pubKey = fact.generatePrivate(keySpec);\n    return pubKey;\n  } catch (Exception e) {\n    throw new RuntimeException(\"Spurious serialisation error\", e);\n  } finally {\n    oin.close();\n  }\n}\n\npublic String rsaEncrypt(String plaintext) throws Exception {      \n  PublicKey pubKey = this.readKeyFromFile(\"public.key\");\n  Cipher cipher = Cipher.getInstance(\"RSA\");\n  cipher.init(Cipher.ENCRYPT_MODE, pubKey);\n  byte[] ciphertext = cipher.doFinal(plaintext.getBytes(\"UTF-8\"));\n  return this.byteToHex(ciphertext);\n}\n\npublic void rsaEncrypt(InputStream in, OutputStream out) throws Exception {\n    try {                    \n        PublicKey pubKey = this.readKeyFromFile(\"public.key\");\n        Cipher cipher = Cipher.getInstance(\"RSA\");\n        cipher.init(Cipher.ENCRYPT_MODE, pubKey); \n        // Bytes written to out will be encrypted\n        out = new CipherOutputStream(out, cipher);\n\n        // Read in the cleartext bytes and write to out to encrypt\n        int numRead = 0;\n        while ((numRead = in.read(buf)) >= 0){\n            out.write(buf, 0, numRead);\n        }\n        out.close();\n    }\n    catch (java.io.IOException e){\n        e.printStackTrace();\n    }\n}\n\npublic void rsaDecrypt(InputStream in, OutputStream out) throws Exception {\n    try {                 \n        PrivateKey pubKey = this.readPrivateKeyFromFile(\"private.key\");\n        Cipher dcipher = Cipher.getInstance(\"RSA\");\n        dcipher.init(Cipher.DECRYPT_MODE, pubKey);\n        // Bytes read from in will be decrypted\n        in = new CipherInputStream(in, dcipher);\n\n        // Read in the decrypted bytes and write the cleartext to out\n        int numRead = 0;\n        while ((numRead = in.read(buf)) >= 0) {\n            out.write(buf, 0, numRead);\n        }\n        out.close();\n    } catch (java.io.IOException e) {\n         e.printStackTrace();\n    }\n}\n\npublic String rsaDecrypt(String hexCipherText) throws Exception {      \n  PrivateKey pubKey = this.readPrivateKeyFromFile(\"private.key\");\n  Cipher cipher = Cipher.getInstance(\"RSA\");\n  cipher.init(Cipher.DECRYPT_MODE, pubKey);      \n  String plaintext = new String(cipher.doFinal(this.hexToByte(hexCipherText)), \"UTF-8\");\n  return plaintext;\n}\n\npublic static String byteToHex( byte [] raw ) {\n    if ( raw == null ) {\n      return null;\n    }\n    final StringBuilder hex = new StringBuilder( 2 * raw.length );\n    for ( final byte b : raw ) {\n      hex.append(HEXES.charAt((b & 0xF0) >> 4))\n         .append(HEXES.charAt((b & 0x0F)));\n    }\n    return hex.toString();\n}\n\npublic static byte[] hexToByte( String hexString){\n    int len = hexString.length();\n    byte[] ba = new byte[len / 2];\n    for (int i = 0; i < len; i += 2) {\n        ba[i/2] = (byte) ((Character.digit(hexString.charAt(i), 16) << 4) + Character.digit(hexString.charAt(i+1), 16));\n    }\n    return ba;\n}\n", "idx": 2059}
{"project": "cipher", "commit_id": "Snippet4419168_31115.java", "target": 1, "func": "      DocumentBuilderFactory dbf = DocumentBuilderFactory.newInstance();    \n  DocumentBuilder builder = dbf.newDocumentBuilder();  \n  Document doc = builder.parse(new File(inputFilePath));\n  NodeList nl = doc.getElementsByTagName(\"ds:SignatureValue\");\n  if (nl.getLength() == 0) {\n     throw new Exception(\"Cannot find SignatureValue element\");\n   }\n  String signature = \"OZg96GMrGh0cEwbpHwv3KDhFtFcnzPxbwp9Xv0pgw8Mr9+NIjRlg/G1OyIZ3SdcOYqqzF4/TVLDi5VclwnjBAFl3SEdkyUbbjXVAGkSsxPQcC4un9UYcecESETlAgV8UrHV3zTrjAWQvDg/YBKveoH90FIhfAthslqeFu3h9U20=\";\n  X509Certificate cert = X509Certificate.getInstance(new FileInputStream(<a file path>));\n  PublicKey pubkey = cert.getPublicKey();\n  Cipher cipher = Cipher.getInstance(\"RSA\",\"SunJCE\");\n  cipher.init(Cipher.DECRYPT_MODE, pubkey);\n  byte[] decodedSignature = Base64Coder.decode(signature);\n  cipher.update(decodedSignature);\n  byte[] sha1 = cipher.doFinal();\n\n\n  System.out.println(Base64Coder.encode(sha1));\n", "idx": 2105}
{"project": "cipher", "commit_id": "Snippet45911193_27984.java", "target": 0, "func": "    Uri targURI = Uri.parse(\"content://xxxx/yyy.txt\");\n    try {\n        InputStream content = getContentResolver().openInputStream(targURI);\n        BufferedReader reader1 = new BufferedReader(new InputStreamReader(content));\n        String line1;\n        String text = \"\";\n        while ((line1 = reader1.readLine()) != null) {\n            text+=line1;\n        }\n        Log.i(\"FILE ENCRYPTED\", text);\n        String DECRYPTED = \"\";\n        DECRYPTED = decrypt(text);\n        Log.i(\"FILE DECRYPTED:\", DECRYPTED);\n\n    } catch (FileNotFoundException e) {\n        e.printStackTrace();\n    } catch (IOException e) {\n        e.printStackTrace();\n    } catch (Exception e) {\n        e.printStackTrace();\n    }\n}\npublic String decrypt(String paramString) throws Exception {\n        String md5_pin1 = \"\";\n        String md5_pin = MD5(md5_pin1);\n        SecretKeySpec keySpec = new SecretKeySpec(md5_pin.getBytes(), \"AES\");\n        Cipher cipher = Cipher.getInstance(\"AES\");\n        cipher.init(Cipher.DECRYPT_MODE, keySpec);\n        byte[] paramString1 = Base64.decode(paramString.getBytes(), 0);\n        byte[] paramstring2 = cipher.doFinal(paramString1);\n        String decoded = new String(paramstring2, \"UTF-8\");\n        return decoded;\n    }\n\n@NonNull\npublic static String MD5(String paramString) throws Exception {\n    MessageDigest digest = java.security.MessageDigest.getInstance(\"MD5\");\n    digest.update(paramString.getBytes());\n    byte messageDigest[] = digest.digest();\n    StringBuffer hexString = new StringBuffer();\n    int i=0;\n    while( i < messageDigest.length) {\n        String str = Integer.toHexString( messageDigest[i] & 0xFF );\n        if (str.length() == 1) {\n            hexString.append(\"0\");\n        }\n\n        hexString.append(str);\n        i += 1;\n    }\n    return hexString.toString();\n}\n", "idx": 1649}
{"project": "cipher", "commit_id": "Snippet30478025_12634.java", "target": 0, "func": "package des;\n\nimport javax.crypto.Cipher;\nimport javax.crypto.SecretKey;\nimport javax.crypto.SecretKeyFactory;\nimport javax.crypto.spec.DESKeySpec;\nimport javax.crypto.spec.IvParameterSpec;\nimport javax.xml.bind.DatatypeConverter;\n\npublic final class Des\n{\n    private static final byte[] IV = {(byte) 0xA6, (byte) 0x8A, 0x11, 0x63, (byte) 0x94, 0x4D, (byte) 0x8E, (byte) 0xA3};\n    private static final byte[] DES_KEY = {(byte) 0x81, 0x33, 0x66, (byte) 0xD8, 0x5F, (byte) 0xD3, 0x17, 0x21, 0x5C, 0x7F};\n\n    public static byte [] encrypt(String data)\n    {\n        byte result[] = null;\n        try\n        {\n            Cipher cipher = Cipher.getInstance(\"DES/CBC/PKCS5Padding\");\n            DESKeySpec desKeySpec = new DESKeySpec(DES_KEY);\n            SecretKeyFactory keyFactory = SecretKeyFactory.getInstance(\"DES\");\n            SecretKey secretKey = keyFactory.generateSecret(desKeySpec);\n            IvParameterSpec iv = new IvParameterSpec(IV);\n            cipher.init(Cipher.ENCRYPT_MODE, secretKey, iv);\n            result = cipher.doFinal(data.getBytes(CHARSET));\n        }\n        catch(Exception e)\n        {\n            e.printStackTrace();\n        }\n        return result;\n    }  \n}\n", "idx": 1654}
{"project": "cipher", "commit_id": "Snippet26215279_8426.java", "target": 1, "func": "import java.io.UnsupportedEncodingException;\nimport java.security.GeneralSecurityException;\nimport java.security.Provider;\nimport java.security.Provider.Service;\nimport java.security.SecureRandom;\nimport java.security.Security;\nimport java.security.spec.KeySpec;\nimport java.util.ArrayList;\nimport java.util.Arrays;\nimport java.util.Collections;\nimport java.util.List;\nimport java.util.Set;\n\nimport javax.crypto.Cipher;\nimport javax.crypto.KeyGenerator;\nimport javax.crypto.SecretKey;\nimport javax.crypto.SecretKeyFactory;\nimport javax.crypto.spec.IvParameterSpec;\nimport javax.crypto.spec.PBEKeySpec;\nimport javax.crypto.spec.PBEParameterSpec;\nimport javax.crypto.spec.SecretKeySpec;\n\nimport android.util.Base64;\nimport android.util.Log;\n\npublic class Crypto {\n\n    private static final String TAG = Crypto.class.getSimpleName();\n\n    public static final String PKCS12_DERIVATION_ALGORITHM = \"PBEWITHSHA256AND256BITAES-CBC-BC\";\n    public static final String PBKDF2_DERIVATION_ALGORITHM = \"PBKDF2WithHmacSHA1\";\n    private static final String CIPHER_ALGORITHM = \"AES/CBC/PKCS5Padding\";\n\n    private static String DELIMITER = \"]\";\n\n    private static int KEY_LENGTH = 256;\n    // minimum values recommended by PKCS#5, increase as necessary\n    private static int ITERATION_COUNT = 1000;\n    private static final int PKCS5_SALT_LENGTH = 8;\n\n    private static SecureRandom random = new SecureRandom();\n\n    private Crypto() {\n    }\n\n    public static void listAlgorithms(String algFilter) {\n        Provider[] providers = Security.getProviders();\n        for (Provider p : providers) {\n            String providerStr = String.format(\"%s/%s/%f\\n\", p.getName(),\n                    p.getInfo(), p.getVersion());\n            Log.d(TAG, providerStr);\n            Set<Service> services = p.getServices();\n            List<String> algs = new ArrayList<String>();\n            for (Service s : services) {\n                boolean match = true;\n                if (algFilter != null) {\n                    match = s.getAlgorithm().toLowerCase()\n                            .contains(algFilter.toLowerCase());\n                }\n\n                if (match) {\n                    String algStr = String.format(\"\\t%s/%s/%s\", s.getType(),\n                            s.getAlgorithm(), s.getClassName());\n                    algs.add(algStr);\n                }\n            }\n\n            Collections.sort(algs);\n            for (String alg : algs) {\n                Log.d(TAG, \"\\t\" + alg);\n            }\n            Log.d(TAG, \"\");\n        }\n    }\n\n    // Illustration code only: don't use in production!\n    public static SecretKey deriveKeyPad(String password) {\n        try {\n            long start = System.currentTimeMillis();\n            byte[] keyBytes = new byte[KEY_LENGTH / 8];\n            // explicitly fill with zeros\n            Arrays.fill(keyBytes, (byte) 0x0);\n\n            // if password is shorter then key length, it will be zero-padded\n            // to key length\n            byte[] passwordBytes = password.getBytes(\"UTF-8\");\n            int length = passwordBytes.length < keyBytes.length ? PasswordBytes.length\n                    : keyBytes.length;\n            System.arraycopy(passwordBytes, 0, keyBytes, 0, length);\n\n            SecretKey result = new SecretKeySpec(keyBytes, \"AES\");\n            long elapsed = System.currentTimeMillis() - start;\n            Log.d(TAG, String.format(\"Padding key derivation took %d [ms].\",\n                    elapsed));\n\n            return result;\n        } catch (UnsupportedEncodingException e) {\n            throw new RuntimeException(e);\n        }\n    }\n\n    // Illustration code only: don't use in production!\n    public static SecretKey deriveKeySha1prng(String password) {\n        try {\n            long start = System.currentTimeMillis();\n            KeyGenerator kgen = KeyGenerator.getInstance(\"AES\");\n            SecureRandom sr = SecureRandom.getInstance(\"SHA1PRNG\");\n            byte[] seed = password.getBytes(\"UTF-8\");\n            sr.setSeed(seed);\n            kgen.init(KEY_LENGTH, sr);\n\n            SecretKey result = kgen.generateKey();\n            long elapsed = System.currentTimeMillis() - start;\n            Log.d(TAG, String.format(\"SHA1PRNG key derivation took %d [ms].\",\n                    elapsed));\n\n            return result;\n        } catch (GeneralSecurityException e) {\n            throw new RuntimeException(e);\n        } catch (UnsupportedEncodingException e) {\n            throw new RuntimeException(e);\n        }\n    }\n\n    public static SecretKey deriveKeyPkcs12(byte[] salt, String password) {\n        try {\n            long start = System.currentTimeMillis();\n            KeySpec keySpec = new PBEKeySpec(password.toCharArray(), salt,\n                    ITERATION_COUNT, KEY_LENGTH);\n            SecretKeyFactory keyFactory = SecretKeyFactory\n                    .getInstance(PKCS12_DERIVATION_ALGORITHM);\n            SecretKey result = keyFactory.generateSecret(keySpec);\n            long elapsed = System.currentTimeMillis() - start;\n            Log.d(TAG, String.format(\"PKCS#12 key derivation took %d [ms].\",\n                    elapsed));\n\n            return result;\n        } catch (GeneralSecurityException e) {\n            throw new RuntimeException(e);\n        }\n    }\n\n    public static SecretKey deriveKeyPbkdf2(byte[] salt, String password) {\n        try {\n            long start = System.currentTimeMillis();\n            KeySpec keySpec = new PBEKeySpec(password.toCharArray(), salt,\n                    ITERATION_COUNT, KEY_LENGTH);\n            SecretKeyFactory keyFactory = SecretKeyFactory\n                    .getInstance(PBKDF2_DERIVATION_ALGORITHM);\n            byte[] keyBytes = keyFactory.generateSecret(keySpec).getEncoded();\n            Log.d(TAG, \"key bytes: \" + toHex(keyBytes));\n\n            SecretKey result = new SecretKeySpec(keyBytes, \"AES\");\n            long elapsed = System.currentTimeMillis() - start;\n            Log.d(TAG, String.format(\"PBKDF2 key derivation took %d [ms].\",\n                    elapsed));\n\n            return result;\n        } catch (GeneralSecurityException e) {\n            throw new RuntimeException(e);\n        }\n    }\n\n    public static byte[] generateIv(int length) {\n        byte[] b = new byte[length];\n        random.nextBytes(b);\n\n        return b;\n    }\n\n    public static byte[] generateSalt() {\n        byte[] b = new byte[PKCS5_SALT_LENGTH];\n        random.nextBytes(b);\n\n        return b;\n    }\n\n    public static String encryptPkcs12(String plaintext, SecretKey key,\n            byte[] salt) {\n        try {\n            Cipher cipher = Cipher.getInstance(CIPHER_ALGORITHM);\n\n            PBEParameterSpec pbeSpec = new PBEParameterSpec(salt,\n                    ITERATION_COUNT);\n            cipher.init(Cipher.ENCRYPT_MODE, key, pbeSpec);\n            Log.d(TAG, \"Cipher IV: \" + toHex(cipher.getIV()));\n            byte[] cipherText = cipher.doFinal(plaintext.getBytes(\"UTF-8\"));\n\n            return String.format(\"%s%s%s\", toBase64(salt), DELIMITER,\n                    toBase64(cipherText));\n        } catch (GeneralSecurityException e) {\n            throw new RuntimeException(e);\n        } catch (UnsupportedEncodingException e) {\n            throw new RuntimeException(e);\n        }\n    }\n\n    public static String encrypt(String plaintext, SecretKey key, byte[] salt) {\n        try {\n            Cipher cipher = Cipher.getInstance(CIPHER_ALGORITHM);\n\n            byte[] iv = generateIv(cipher.getBlockSize());\n            Log.d(TAG, \"IV: \" + toHex(iv));\n            IvParameterSpec ivParams = new IvParameterSpec(iv);\n            cipher.init(Cipher.ENCRYPT_MODE, key, ivParams);\n            Log.d(TAG, \"Cipher IV: \"\n                    + (cipher.getIV() == null ? Null : toHex(cipher.getIV())));\n            byte[] cipherText = cipher.doFinal(plaintext.getBytes(\"UTF-8\"));\n\n            if (salt != null) {\n                return String.format(\"%s%s%s%s%s\", toBase64(salt), DELIMITER,\n                        toBase64(iv), DELIMITER, toBase64(cipherText));\n            }\n\n            return String.format(\"%s%s%s\", toBase64(iv), DELIMITER,\n                    toBase64(cipherText));\n        } catch (GeneralSecurityException e) {\n            throw new RuntimeException(e);\n        } catch (UnsupportedEncodingException e) {\n            throw new RuntimeException(e);\n        }\n    }\n\n    public static String toHex(byte[] bytes) {\n        StringBuffer buff = new StringBuffer();\n        for (byte b : bytes) {\n            buff.append(String.format(\"%02X\", b));\n        }\n\n        return buff.toString();\n    }\n\n    public static String toBase64(byte[] bytes) {\n        return Base64.encodeToString(bytes, Base64.NO_WRAP);\n    }\n\n    public static byte[] fromBase64(String base64) {\n        return Base64.decode(base64, Base64.NO_WRAP);\n    }\n\n    public static String decryptPkcs12(byte[] cipherBytes, SecretKey key,\n            byte[] salt) {\n        try {\n            Cipher cipher = Cipher.getInstance(CIPHER_ALGORITHM);\n            PBEParameterSpec pbeSpec = new PBEParameterSpec(salt,\n                    ITERATION_COUNT);\n            cipher.init(Cipher.DECRYPT_MODE, key, pbeSpec);\n            Log.d(TAG, \"Cipher IV: \" + toHex(cipher.getIV()));\n            byte[] plainBytes = cipher.doFinal(cipherBytes);\n            String plainrStr = new String(plainBytes, \"UTF-8\");\n\n            return plainrStr;\n        } catch (GeneralSecurityException e) {\n            throw new RuntimeException(e);\n        } catch (UnsupportedEncodingException e) {\n            throw new RuntimeException(e);\n        }\n    }\n\n    public static String decrypt(byte[] cipherBytes, SecretKey key, byte[] iv) {\n        try {\n            Cipher cipher = Cipher.getInstance(CIPHER_ALGORITHM);\n            IvParameterSpec ivParams = new IvParameterSpec(iv);\n            cipher.init(Cipher.DECRYPT_MODE, key, ivParams);\n            Log.d(TAG, \"Cipher IV: \" + toHex(cipher.getIV()));\n            byte[] plaintext = cipher.doFinal(cipherBytes);\n            String plainrStr = new String(plaintext, \"UTF-8\");\n\n            return plainrStr;\n        } catch (GeneralSecurityException e) {\n            throw new RuntimeException(e);\n        } catch (UnsupportedEncodingException e) {\n            throw new RuntimeException(e);\n        }\n    }\n\n    public static String decryptPkcs12(String ciphertext, String password) {\n        String[] fields = ciphertext.split(DELIMITER);\n        if (fields.length != 2) {\n            throw new IllegalArgumentException(\"Invalid encypted text format\");\n        }\n\n        byte[] salt = fromBase64(fields[0]);\n        byte[] cipherBytes = fromBase64(fields[1]);\n        SecretKey key = deriveKeyPkcs12(salt, password);\n\n        return decryptPkcs12(cipherBytes, key, salt);\n    }\n\n    public static String decryptPbkdf2(String ciphertext, String password) {\n        String[] fields = ciphertext.split(DELIMITER);\n        if (fields.length != 3) {\n            throw new IllegalArgumentException(\"Invalid encypted text format\");\n        }\n\n        byte[] salt = fromBase64(fields[0]);\n        byte[] iv = fromBase64(fields[1]);\n        byte[] cipherBytes = fromBase64(fields[2]);\n        SecretKey key = deriveKeyPbkdf2(salt, password);\n\n        return decrypt(cipherBytes, key, iv);\n    }\n\n    public static String decryptNoSalt(String ciphertext, SecretKey key) {\n        String[] fields = ciphertext.split(DELIMITER);\n        if (fields.length != 2) {\n            throw new IllegalArgumentException(\"Invalid encypted text format\");\n        }\n        byte[] iv = fromBase64(fields[0]);\n        byte[] cipherBytes = fromBase64(fields[1]);\n\n        return decrypt(cipherBytes, key, iv);\n    }\n\n}\n", "idx": 2310}
{"project": "cipher", "commit_id": "Snippet29671427_11688.java", "target": 0, "func": " public String DesDecryptPin(String pin, String encryptKey) throws NoSuchPaddingException, NoSuchAlgorithmException, InvalidKeyException, BadPaddingException, IllegalBlockSizeException, UnsupportedEncodingException {\n\n    String UNICODE_FORMAT = \"UTF8\";\n    String decryptedPinText = null;\n\n    byte[] hexConvert = hexStringtoByteArray(encryptKey);\n\n    SecretKey desKey = null;\n    KeySpec desKeySpec = new DESedeKeySpec(hexConvert); // Exception HERE\n    Cipher desCipher;\n    SecretKeyFactory skf = SecretKeyFactory.getInstance(\"DESede\");\n    desCipher = Cipher.getInstance(\"DES/ECB/NoPadding\");\n    try {\n        desKey = skf.generateSecret(desKeySpec);\n    } catch (InvalidKeySpecException e) {\n        e.printStackTrace();\n    }\n\n    desCipher.init(Cipher.DECRYPT_MODE, desKey);\n    byte[] decryptPin = desCipher.doFinal(pin.getBytes());\n    decryptedPinText = new String(decryptPin, \"UTF-8\");\n\n    return decryptedPinText;\n}\n", "idx": 1701}
{"project": "cipher", "commit_id": "Snippet4655649_31248.java", "target": 0, "func": "public String encrypt(String data) throws Exception{\n    try {\n        Cipher cipher = Cipher.getInstance(\"AES/ECB/PKCS5Padding\");\n        Key k = new SecretKeySpec(key.getBytes(), 0, key.length(), \"AES\");\n\n        // Calculate ciphertext size.\n        int blocksize = 16;\n        int ciphertextLength = 0;\n        int remainder = data.getBytes().length % blocksize;\n        if (remainder == 0) {\n            ciphertextLength = data.getBytes().length + blocksize;\n        } else {\n            ciphertextLength = data.getBytes().length - remainder + blocksize;\n        }\n\n\n        cipher.init(Cipher.ENCRYPT_MODE, k);\n        byte[] buf = new byte[ciphertextLength];\n        cipher.doFinal(data.getBytes(), 0, data.length(), buf, 0);\n\n        StringBuffer strbuf = new StringBuffer(buf.length * 2);\n        int i;\n\n        for (i = 0; i < buf.length; i++) {\n            if (((int) buf[i] & 0xff) < 0x10) {\n                strbuf.append(\"0\");\n            }\n\n            strbuf.append(Long.toString((int) buf[i] & 0xff, 16));\n        }\n        return strbuf.toString();\n    } catch (Exception e) {\n        Logger.logException(e);\n    }\n    return null;\n}\n", "idx": 1633}
{"project": "cipher", "commit_id": "Snippet23441208_5793.java", "target": 1, "func": "public static String decrypt(String strToDecrypt)\n    {\n\n        try\n        {\n            Cipher cipher = Cipher.getInstance(\"AES/CBC/PKCS7Padding\");\n            final SecretKeySpec secretKey = new SecretKeySpec(AppConstants.AESEncryptionKey.getBytes(\"UTF8\"), \"AES\");\n            cipher.init(Cipher.DECRYPT_MODE, secretKey,new IvParameterSpec(new byte[16])); //new IvParameterSpec(new byte[16])\n            byte base64Data[] = Base64.encode(strToDecrypt.getBytes(), Base64.DEFAULT);\n            @SuppressWarnings(\"unused\")\n            String s = base64Data.toString();\n            byte decBytes[] = cipher.doFinal(base64Data);\n            String decStr = new String(decBytes);\n            return decStr;\n        }\n        catch (Exception e)\n        {\n            e.printStackTrace();\n        }\n        return null;\n    }\n", "idx": 2205}
{"project": "cipher", "commit_id": "Snippet39682186_21573.java", "target": 1, "func": "FileInputStream fis = new FileInputStream(PATH_BKP);\n\nFileOutputStream fos = new FileOutputStream(PATH_DB);\n\nbyte[] s = Arrays.copyOf(KEY_DATABASE.getBytes(),16);\nSecretKeySpec sks = new SecretKeySpec(s, \"AES\");\n\nCipher cipher = Cipher.getInstance(\"AES/CBC/PKCS5PADDING\");\ncipher.init(Cipher.DECRYPT_MODE, sks);\n\nCipherInputStream cis = new CipherInputStream (fis, cipher);\n\nbyte[] buffer = new byte[1024];\nint length;\nwhile ((length = cis.read(buffer)) != -1) {\n    fos.write(buffer, 0, length);\n}\n\nfos.flush();\nfos.close();\ncis.close();\n", "idx": 2226}
{"project": "cipher", "commit_id": "Snippet4004886_30980.java", "target": 0, "func": "import javax.crypto.BadPaddingException;\nimport javax.crypto.Cipher;\nimport javax.crypto.IllegalBlockSizeException;\nimport javax.crypto.NoSuchPaddingException;\nimport javax.crypto.spec.SecretKeySpec;\nimport java.security.*;\n\npublic class DecryptionTest {\n    public static void main(String[] args) throws NoSuchAlgorithmException, NoSuchPaddingException, InvalidKeyException, InvalidAlgorithmParameterException, IllegalBlockSizeException, BadPaddingException, NoSuchProviderException {\n        String password = \"12345678901234567890\";\n        Security.addProvider(new org.bouncycastle.jce.provider.BouncyCastleProvider());\n        SecretKeySpec key = new SecretKeySpec(password.getBytes(), \"ECB\");\n        Cipher m_decrypter = Cipher.getInstance(\"DESede/ECB/ZeroBytePadding\");\n        m_decrypter.init(Cipher.DECRYPT_MODE, key);\n        byte[] decryptedText = m_decrypter.doFinal(\"bdf0baf948bff7e7\".getBytes());\n        System.out.println(new String(decryptedText));\n    }\n}\n", "idx": 1723}
{"project": "cipher", "commit_id": "Snippet4896232_31379.java", "target": 0, "func": "dcipher = Cipher.getInstance(\"PBEWithMD5AndDES/CBC/PKCS5Padding\");\n", "idx": 1880}
